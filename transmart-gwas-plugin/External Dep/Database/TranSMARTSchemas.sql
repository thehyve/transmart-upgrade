--------------------------------------------------------
--  File created - Tuesday-May-20-2014   
--------------------------------------------------------
--------------------------------------------------------
--  DDL for Type CONCEPT_CD_TAB
--------------------------------------------------------

  CREATE OR REPLACE TYPE "BIOMART_USER"."CONCEPT_CD_TAB" IS TABLE OF VARCHAR2(50)

/
--------------------------------------------------------
--  DDL for Type PATIENTS_TAB
--------------------------------------------------------

  CREATE OR REPLACE TYPE "BIOMART_USER"."PATIENTS_TAB" IS TABLE OF NUMBER(10,0)

/
--------------------------------------------------------
--  DDL for Sequence SEQ_FM_ID
--------------------------------------------------------

   CREATE SEQUENCE  "FMAPP"."SEQ_FM_ID"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 964 CACHE 20 NOORDER  NOCYCLE ;
--------------------------------------------------------
--  DDL for Table MLOG$_SEARCH_GENE_SIGNATUR
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."MLOG$_SEARCH_GENE_SIGNATUR" 
   (	"DELETED_FLAG" NUMBER(1,0), 
	"PUBLIC_FLAG" NUMBER(1,0), 
	"M_ROW$$" VARCHAR2(255 BYTE), 
	"SEQUENCE$$" NUMBER, 
	"SNAPTIME$$" DATE, 
	"DMLTYPE$$" VARCHAR2(1 BYTE), 
	"OLD_NEW$$" VARCHAR2(1 BYTE), 
	"CHANGE_VECTOR$$" RAW(255)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 30 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
 

   COMMENT ON TABLE "SEARCHAPP"."MLOG$_SEARCH_GENE_SIGNATUR"  IS 'snapshot log for master table SEARCHAPP.SEARCH_GENE_SIGNATURE';
--------------------------------------------------------
--  DDL for Table PLUGIN
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."PLUGIN" 
   (	"PLUGIN_SEQ" NUMBER, 
	"NAME" VARCHAR2(200 BYTE), 
	"PLUGIN_NAME" VARCHAR2(90 BYTE), 
	"HAS_MODULES" CHAR(1 BYTE) DEFAULT 'N', 
	"HAS_FORM" CHAR(1 BYTE) DEFAULT 'N', 
	"DEFAULT_LINK" VARCHAR2(70 BYTE), 
	"FORM_LINK" VARCHAR2(70 BYTE), 
	"FORM_PAGE" VARCHAR2(100 BYTE), 
	"ACTIVE" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table PLUGIN_MODULE
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."PLUGIN_MODULE" 
   (	"MODULE_SEQ" NUMBER, 
	"PLUGIN_SEQ" NUMBER, 
	"NAME" VARCHAR2(70 BYTE), 
	"PARAMS" CLOB, 
	"VERSION" VARCHAR2(10 BYTE) DEFAULT 0.1, 
	"ACTIVE" CHAR(1 BYTE) DEFAULT 'Y', 
	"HAS_FORM" CHAR(1 BYTE) DEFAULT 'N', 
	"FORM_LINK" VARCHAR2(90 BYTE), 
	"FORM_PAGE" VARCHAR2(90 BYTE), 
	"MODULE_NAME" VARCHAR2(50 BYTE), 
	"CATEGORY" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" 
 LOB ("PARAMS") STORE AS BASICFILE (
  TABLESPACE "BIOMART" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table REPORT
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."REPORT" 
   (	"REPORT_ID" NUMBER, 
	"NAME" VARCHAR2(200 BYTE), 
	"DESCRIPTION" VARCHAR2(1000 BYTE), 
	"CREATINGUSER" VARCHAR2(200 BYTE), 
	"PUBLIC_FLAG" CHAR(1 BYTE), 
	"CREATE_DATE" TIMESTAMP (1), 
	"STUDY" VARCHAR2(200 BYTE), 
	"MODULE_NAME" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table REPORT_ITEM
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."REPORT_ITEM" 
   (	"REPORT_ITEM_ID" NUMBER, 
	"REPORT_ID" NUMBER, 
	"CODE" VARCHAR2(4000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_APP_ACCESS_LOG
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_APP_ACCESS_LOG" 
   (	"ID" NUMBER(19,0), 
	"ACCESS_TIME" TIMESTAMP (6), 
	"EVENT" VARCHAR2(255 CHAR), 
	"REQUEST_URL" VARCHAR2(255 CHAR), 
	"USER_NAME" VARCHAR2(255 CHAR), 
	"EVENT_MESSAGE" CLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 917504 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" 
 LOB ("EVENT_MESSAGE") STORE AS BASICFILE "SYS_LOB0000140259C00006$$"(
  TABLESPACE "BIOMART" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table SEARCH_AUTH_GROUP
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_AUTH_GROUP" 
   (	"ID" NUMBER(19,0), 
	"GROUP_CATEGORY" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_AUTH_GROUP_MEMBER
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_AUTH_GROUP_MEMBER" 
   (	"AUTH_USER_ID" NUMBER(19,0), 
	"AUTH_GROUP_ID" NUMBER(19,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_AUTH_PRINCIPAL
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL" 
   (	"ID" NUMBER(19,0), 
	"PRINCIPAL_TYPE" VARCHAR2(255 BYTE), 
	"DATE_CREATED" DATE, 
	"DESCRIPTION" VARCHAR2(255 BYTE), 
	"LAST_UPDATED" DATE, 
	"NAME" VARCHAR2(255 BYTE), 
	"UNIQUE_ID" VARCHAR2(255 BYTE), 
	"ENABLED" NUMBER(1,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_AUTH_SEC_OBJECT_ACCESS
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_AUTH_SEC_OBJECT_ACCESS" 
   (	"AUTH_SEC_OBJ_ACCESS_ID" NUMBER(18,0), 
	"AUTH_PRINCIPAL_ID" NUMBER(18,0), 
	"SECURE_OBJECT_ID" NUMBER(18,0), 
	"SECURE_ACCESS_LEVEL_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_AUTH_USER
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_AUTH_USER" 
   (	"ID" NUMBER(19,0), 
	"EMAIL" VARCHAR2(255 CHAR), 
	"EMAIL_SHOW" NUMBER(1,0), 
	"PASSWD" VARCHAR2(255 CHAR), 
	"USER_REAL_NAME" VARCHAR2(255 CHAR), 
	"USERNAME" VARCHAR2(255 CHAR)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_AUTH_USER_SEC_ACCESS
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_AUTH_USER_SEC_ACCESS" 
   (	"SEARCH_AUTH_USER_SEC_ACCESS_ID" NUMBER(18,0), 
	"SEARCH_AUTH_USER_ID" NUMBER(18,0), 
	"SEARCH_SECURE_OBJECT_ID" NUMBER(18,0), 
	"SEARCH_SEC_ACCESS_LEVEL_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_CUSTOM_FILTER
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER" 
   (	"SEARCH_CUSTOM_FILTER_ID" NUMBER(18,0), 
	"SEARCH_USER_ID" NUMBER(18,0), 
	"NAME" NVARCHAR2(200), 
	"DESCRIPTION" NVARCHAR2(2000), 
	"PRIVATE" CHAR(1 BYTE) DEFAULT 'N'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_CUSTOM_FILTER_ITEM
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER_ITEM" 
   (	"SEARCH_CUSTOM_FILTER_ITEM_ID" NUMBER(18,0), 
	"SEARCH_CUSTOM_FILTER_ID" NUMBER(18,0), 
	"UNIQUE_ID" VARCHAR2(200 CHAR), 
	"BIO_DATA_TYPE" VARCHAR2(100 CHAR)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_GENE_SIGNATURE
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" 
   (	"SEARCH_GENE_SIGNATURE_ID" NUMBER, 
	"NAME" VARCHAR2(100 BYTE), 
	"DESCRIPTION" VARCHAR2(1000 BYTE), 
	"UNIQUE_ID" VARCHAR2(50 BYTE), 
	"CREATE_DATE" TIMESTAMP (6), 
	"CREATED_BY_AUTH_USER_ID" NUMBER, 
	"LAST_MODIFIED_DATE" TIMESTAMP (6), 
	"MODIFIED_BY_AUTH_USER_ID" NUMBER, 
	"VERSION_NUMBER" VARCHAR2(50 BYTE), 
	"PUBLIC_FLAG" NUMBER(1,0) DEFAULT 0, 
	"DELETED_FLAG" NUMBER(1,0) DEFAULT 0, 
	"PARENT_GENE_SIGNATURE_ID" NUMBER, 
	"SOURCE_CONCEPT_ID" NUMBER, 
	"SOURCE_OTHER" VARCHAR2(255 BYTE), 
	"OWNER_CONCEPT_ID" NUMBER, 
	"STIMULUS_DESCRIPTION" VARCHAR2(1000 BYTE), 
	"STIMULUS_DOSING" VARCHAR2(255 BYTE), 
	"TREATMENT_DESCRIPTION" VARCHAR2(1000 BYTE), 
	"TREATMENT_DOSING" VARCHAR2(255 BYTE), 
	"TREATMENT_BIO_COMPOUND_ID" NUMBER, 
	"TREATMENT_PROTOCOL_NUMBER" VARCHAR2(50 BYTE), 
	"PMID_LIST" VARCHAR2(255 BYTE), 
	"SPECIES_CONCEPT_ID" NUMBER, 
	"SPECIES_MOUSE_SRC_CONCEPT_ID" NUMBER, 
	"SPECIES_MOUSE_DETAIL" VARCHAR2(255 BYTE), 
	"TISSUE_TYPE_CONCEPT_ID" NUMBER, 
	"EXPERIMENT_TYPE_CONCEPT_ID" NUMBER, 
	"EXPERIMENT_TYPE_IN_VIVO_DESCR" VARCHAR2(255 BYTE), 
	"EXPERIMENT_TYPE_ATCC_REF" VARCHAR2(255 BYTE), 
	"ANALYTIC_CAT_CONCEPT_ID" NUMBER, 
	"ANALYTIC_CAT_OTHER" VARCHAR2(255 BYTE), 
	"BIO_ASSAY_PLATFORM_ID" NUMBER, 
	"ANALYST_NAME" VARCHAR2(100 BYTE), 
	"NORM_METHOD_CONCEPT_ID" NUMBER, 
	"NORM_METHOD_OTHER" VARCHAR2(255 BYTE), 
	"ANALYSIS_METHOD_CONCEPT_ID" NUMBER, 
	"ANALYSIS_METHOD_OTHER" VARCHAR2(255 BYTE), 
	"MULTIPLE_TESTING_CORRECTION" NUMBER(1,0), 
	"P_VALUE_CUTOFF_CONCEPT_ID" NUMBER, 
	"UPLOAD_FILE" VARCHAR2(255 BYTE), 
	"SEARCH_GENE_SIG_FILE_SCHEMA_ID" NUMBER DEFAULT 1, 
	"FOLD_CHG_METRIC_CONCEPT_ID" NUMBER DEFAULT NULL, 
	"EXPERIMENT_TYPE_CELL_LINE_ID" NUMBER, 
	"FLANKING_REGION" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
 

   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."NAME" IS 'name of the gene signature for identification purposes';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."DESCRIPTION" IS 'expanded description ';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."UNIQUE_ID" IS 'a unique code assigned to the object by a naming convention';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."CREATE_DATE" IS 'date object was created';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."CREATED_BY_AUTH_USER_ID" IS 'auth user that created the object';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."LAST_MODIFIED_DATE" IS 'date of the last modification';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."MODIFIED_BY_AUTH_USER_ID" IS 'auth user that last modified the object';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."VERSION_NUMBER" IS 'for version tracking for modifications';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."PUBLIC_FLAG" IS 'binary flag indicates if object is accessible to other users besides the creator';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."DELETED_FLAG" IS 'binary flag indicates if object is deleted so that it will not appear on the UI';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."PARENT_GENE_SIGNATURE_ID" IS 'tracks the parent gene signature this object was derived from';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."SOURCE_CONCEPT_ID" IS 'source meta data defined in bio_concept_code';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."SOURCE_OTHER" IS 'source of the object when selection is not defined in bio_concept_code (other selection)';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."OWNER_CONCEPT_ID" IS 'owner of the data defined in bio_concept_code';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."STIMULUS_DESCRIPTION" IS 'a description for the stimulus ';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."STIMULUS_DOSING" IS 'the dosing used for the stimulus';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."TREATMENT_DESCRIPTION" IS 'description of the treamtent involved';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."TREATMENT_DOSING" IS 'descipriont of any treatment dosing used';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."TREATMENT_BIO_COMPOUND_ID" IS 'reference to the bio_compound_id if relevant';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."TREATMENT_PROTOCOL_NUMBER" IS 'the protocol number associated with the treatment';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."PMID_LIST" IS 'list of associated pmids (comma separated)';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."SPECIES_CONCEPT_ID" IS 'species meta data defined in bio_concept_code';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."SPECIES_MOUSE_SRC_CONCEPT_ID" IS 'for species of mouse type, specifies the source of the mouse in bio_concept_code';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."SPECIES_MOUSE_DETAIL" IS 'extra detail for knockout/transgenic, or other mouse strain ';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."TISSUE_TYPE_CONCEPT_ID" IS 'tissue type meta data defined in bio_concept_code';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."EXPERIMENT_TYPE_CONCEPT_ID" IS 'experiment type meta data defined in bio_concept_code';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."EXPERIMENT_TYPE_IN_VIVO_DESCR" IS 'describes the model for in vivo experiment types';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."EXPERIMENT_TYPE_ATCC_REF" IS 'experiment type atcc designation';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."ANALYTIC_CAT_CONCEPT_ID" IS 'analytic category meta deta from bio_concept_code';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."ANALYTIC_CAT_OTHER" IS 'analytic category atcc designation';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."BIO_ASSAY_PLATFORM_ID" IS 'technology platform meta deta from bio_concept_code';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."ANALYST_NAME" IS 'name of the analyst performing analysis (analysis meta data)';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."NORM_METHOD_CONCEPT_ID" IS 'normalization method from bio_concept_code (analysis meta data)';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."NORM_METHOD_OTHER" IS 'normalization method for other selection (analysis meta data)';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."ANALYSIS_METHOD_CONCEPT_ID" IS 'analysis method from bio_concept_code (analysis meta data)';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."ANALYSIS_METHOD_OTHER" IS 'analysis method for other selection (analysis meta data)';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."MULTIPLE_TESTING_CORRECTION" IS 'binary flag indicates if multiple testing correction was employed (analysis meta data) ';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."P_VALUE_CUTOFF_CONCEPT_ID" IS 'p-value cutoff from bio_concept_code (analysis meta data)';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."UPLOAD_FILE" IS 'upload file name from user containing gene items';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."SEARCH_GENE_SIG_FILE_SCHEMA_ID" IS 'file schema for the upload gene signature file';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."FOLD_CHG_METRIC_CONCEPT_ID" IS 'fold change metric type in bio_concept_code';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE"."EXPERIMENT_TYPE_CELL_LINE_ID" IS 'for established cell line experiment, specifies the specific cell line from bio_cell_line';
--------------------------------------------------------
--  DDL for Table SEARCH_GENE_SIGNATURE_ITEM
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM" 
   (	"SEARCH_GENE_SIGNATURE_ID" NUMBER, 
	"BIO_MARKER_ID" NUMBER, 
	"FOLD_CHG_METRIC" NUMBER, 
	"BIO_DATA_UNIQUE_ID" NVARCHAR2(200), 
	"ID" NUMBER, 
	"BIO_ASSAY_FEATURE_GROUP_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
 

   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM"."SEARCH_GENE_SIGNATURE_ID" IS 'associated gene signature';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM"."BIO_MARKER_ID" IS 'link to bio_marker table ';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM"."FOLD_CHG_METRIC" IS 'the corresponding fold change value metric (actual number or -1,0,1 for composite gene signatures). If null, it''s assumed to be a gene list in which case all genes are assumed to be up regulated';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM"."BIO_DATA_UNIQUE_ID" IS 'link to unique_id from bio_data_uid table (context sensitive)';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM"."ID" IS 'hibernate primary key';
--------------------------------------------------------
--  DDL for Table SEARCH_GENE_SIGNATURE_ITEM_SAV
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM_SAV" 
   (	"SEARCH_GENE_SIGNATURE_ID" NUMBER, 
	"BIO_MARKER_ID" NUMBER, 
	"FOLD_CHG_METRIC" NUMBER, 
	"BIO_DATA_UNIQUE_ID" NVARCHAR2(200), 
	"ID" NUMBER, 
	"BIO_ASSAY_FEATURE_GROUP_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_GENE_SIG_FILE_SCHEMA
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA" 
   (	"SEARCH_GENE_SIG_FILE_SCHEMA_ID" NUMBER, 
	"NAME" VARCHAR2(100 BYTE), 
	"DESCRIPTION" VARCHAR2(255 BYTE), 
	"NUMBER_COLUMNS" NUMBER DEFAULT 2, 
	"SUPPORTED" NUMBER(1,0) DEFAULT 0
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
 

   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA"."SEARCH_GENE_SIG_FILE_SCHEMA_ID" IS 'primary key';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA"."NAME" IS 'name of the file schema';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA"."NUMBER_COLUMNS" IS 'number of columns in tab delimited file';
 
   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA"."SUPPORTED" IS 'a binary flag indicates if schema is supported by the application';
 
   COMMENT ON TABLE "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA"  IS 'Represents file schemas used to represent a gene signature upload. Normally this table would be populated only by seed data';
--------------------------------------------------------
--  DDL for Table SEARCH_KEYWORD
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_KEYWORD" 
   (	"KEYWORD" NVARCHAR2(200), 
	"BIO_DATA_ID" NUMBER(18,0), 
	"UNIQUE_ID" NVARCHAR2(500), 
	"SEARCH_KEYWORD_ID" NUMBER(18,0), 
	"DATA_CATEGORY" NVARCHAR2(200), 
	"SOURCE_CODE" NVARCHAR2(100), 
	"DISPLAY_DATA_CATEGORY" NVARCHAR2(200), 
	"OWNER_AUTH_USER_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" 
  PARALLEL 4 ;
 

   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_KEYWORD"."OWNER_AUTH_USER_ID" IS 'the owner of the object, this can be used to control access permissions in search';
--------------------------------------------------------
--  DDL for Table SEARCH_KEYWORD1
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_KEYWORD1" 
   (	"KEYWORD" NVARCHAR2(200), 
	"BIO_DATA_ID" NUMBER(18,0), 
	"UNIQUE_ID" NVARCHAR2(500), 
	"SEARCH_KEYWORD_ID" NUMBER(18,0), 
	"DATA_CATEGORY" NVARCHAR2(200), 
	"SOURCE_CODE" NVARCHAR2(100), 
	"DISPLAY_DATA_CATEGORY" NVARCHAR2(200), 
	"OWNER_AUTH_USER_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_KEYWORD_TERM
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_KEYWORD_TERM" 
   (	"KEYWORD_TERM" VARCHAR2(200 BYTE), 
	"SEARCH_KEYWORD_ID" NUMBER(18,0), 
	"RANK" NUMBER(18,0), 
	"SEARCH_KEYWORD_TERM_ID" NUMBER(18,0), 
	"TERM_LENGTH" NUMBER(18,0), 
	"OWNER_AUTH_USER_ID" NUMBER, 
	"DATA_CATEGORY" NVARCHAR2(200)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255 COMPRESS BASIC LOGGING
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" 
  PARALLEL 4 ;
 

   COMMENT ON COLUMN "SEARCHAPP"."SEARCH_KEYWORD_TERM"."OWNER_AUTH_USER_ID" IS 'owner of the object, this can be used to control access in search';
--------------------------------------------------------
--  DDL for Table SEARCH_KEYWORD_TERM1
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_KEYWORD_TERM1" 
   (	"KEYWORD_TERM" VARCHAR2(200 BYTE), 
	"SEARCH_KEYWORD_ID" NUMBER(18,0), 
	"RANK" NUMBER(18,0), 
	"SEARCH_KEYWORD_TERM_ID" NUMBER(18,0), 
	"TERM_LENGTH" NUMBER(18,0), 
	"OWNER_AUTH_USER_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_REQUEST_MAP
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_REQUEST_MAP" 
   (	"ID" NUMBER(19,0), 
	"VERSION" NUMBER(19,0), 
	"CONFIG_ATTRIBUTE" VARCHAR2(255 CHAR), 
	"URL" VARCHAR2(255 CHAR)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_ROLE
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_ROLE" 
   (	"ID" NUMBER(19,0), 
	"VERSION" NUMBER(19,0), 
	"AUTHORITY" VARCHAR2(255 CHAR), 
	"DESCRIPTION" VARCHAR2(255 CHAR)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_ROLE_AUTH_USER
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_ROLE_AUTH_USER" 
   (	"PEOPLE_ID" NUMBER(19,0), 
	"AUTHORITIES_ID" NUMBER(19,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_SECURE_OBJECT
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_SECURE_OBJECT" 
   (	"SEARCH_SECURE_OBJECT_ID" NUMBER(18,0), 
	"BIO_DATA_ID" NUMBER(18,0), 
	"DISPLAY_NAME" NVARCHAR2(100), 
	"DATA_TYPE" NVARCHAR2(200), 
	"BIO_DATA_UNIQUE_ID" NVARCHAR2(200)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_SECURE_OBJECT_PATH
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_SECURE_OBJECT_PATH" 
   (	"SEARCH_SECURE_OBJECT_ID" NUMBER(18,0), 
	"I2B2_CONCEPT_PATH" NVARCHAR2(2000), 
	"SEARCH_SECURE_OBJ_PATH_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_SEC_ACCESS_LEVEL
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_SEC_ACCESS_LEVEL" 
   (	"SEARCH_SEC_ACCESS_LEVEL_ID" NUMBER(18,0), 
	"ACCESS_LEVEL_NAME" NVARCHAR2(200), 
	"ACCESS_LEVEL_VALUE" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_TAXONOMY
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_TAXONOMY" 
   (	"TERM_ID" NUMBER(22,0), 
	"TERM_NAME" VARCHAR2(900 BYTE), 
	"SOURCE_CD" VARCHAR2(900 BYTE), 
	"IMPORT_DATE" TIMESTAMP (1) DEFAULT Sysdate, 
	"SEARCH_KEYWORD_ID" NUMBER(38,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_TAXONOMY_RELS
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_TAXONOMY_RELS" 
   (	"SEARCH_TAXONOMY_RELS_ID" NUMBER(22,0), 
	"CHILD_ID" NUMBER(22,0), 
	"PARENT_ID" NUMBER(22,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_USER_FEEDBACK
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SEARCH_USER_FEEDBACK" 
   (	"SEARCH_USER_FEEDBACK_ID" NUMBER(18,0), 
	"SEARCH_USER_ID" NUMBER(18,0), 
	"CREATE_DATE" DATE, 
	"FEEDBACK_TEXT" NVARCHAR2(2000), 
	"APP_VERSION" NVARCHAR2(100)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table SUBSET
--------------------------------------------------------

  CREATE TABLE "SEARCHAPP"."SUBSET" 
   (	"SUBSET_ID" NUMBER, 
	"DESCRIPTION" VARCHAR2(1000 BYTE), 
	"CREATE_DATE" TIMESTAMP (6), 
	"CREATING_USER" VARCHAR2(200 BYTE), 
	"PUBLIC_FLAG" NUMBER(1,0) DEFAULT 0, 
	"DELETED_FLAG" NUMBER(1,0) DEFAULT 0, 
	"QUERY_MASTER_ID_1" NUMBER, 
	"QUERY_MASTER_ID_2" NUMBER, 
	"STUDY" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table DEAPP_ANNOTATION
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DEAPP_ANNOTATION" 
   (	"ANNOTATION_TYPE" VARCHAR2(50 BYTE), 
	"ANNOTATION_VALUE" VARCHAR2(100 BYTE), 
	"GENE_ID" NUMBER, 
	"GENE_SYMBOL" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_CONCEPT_CONTEXT
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_CONCEPT_CONTEXT" 
   (	"DE_CONTEXT_ID" NUMBER, 
	"CONCEPT_CD" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_CONTEXT
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_CONTEXT" 
   (	"DE_CONTEXT_ID" NUMBER, 
	"DE_CONTEXT_NAME" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_GENE_INFO
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_GENE_INFO" 
   (	"GENE_INFO_ID" NUMBER(22,0), 
	"GENE_SOURCE_ID" NUMBER(5,0), 
	"ENTREZ_ID" NUMBER(10,0), 
	"GENE_SYMBOL" VARCHAR2(255 BYTE), 
	"GENE_NAME" VARCHAR2(255 BYTE), 
	"CHROM" VARCHAR2(16 BYTE), 
	"CHROM_START" NUMBER, 
	"CHROM_STOP" NUMBER, 
	"STRAND" NUMBER(2,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_GENE_SOURCE
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_GENE_SOURCE" 
   (	"GENE_SOURCE_ID" NUMBER(5,0), 
	"GENE_SOURCE_NAME" VARCHAR2(255 BYTE), 
	"VERSION" VARCHAR2(32 BYTE), 
	"RELEASE_DATE" DATE, 
	"URL" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_GPL_INFO
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_GPL_INFO" 
   (	"PLATFORM" VARCHAR2(50 BYTE), 
	"TITLE" VARCHAR2(500 BYTE), 
	"ORGANISM" VARCHAR2(100 BYTE), 
	"ANNOTATION_DATE" TIMESTAMP (6), 
	"MARKER_TYPE" VARCHAR2(100 BYTE), 
	"RELEASE_NBR" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_MRNA_ANNOTATION
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_MRNA_ANNOTATION" 
   (	"GPL_ID" VARCHAR2(100 BYTE), 
	"PROBE_ID" VARCHAR2(100 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"PROBESET_ID" NUMBER(38,0), 
	"GENE_ID" NUMBER(18,0), 
	"ORGANISM" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 5242880 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_PATHWAY
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_PATHWAY" 
   (	"NAME" NVARCHAR2(300), 
	"DESCRIPTION" NVARCHAR2(510), 
	"ID" NUMBER(18,0), 
	"TYPE" NVARCHAR2(100), 
	"SOURCE" NVARCHAR2(100), 
	"EXTERNALID" NVARCHAR2(100), 
	"PATHWAY_UID" VARCHAR2(200 BYTE), 
	"USER_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_PATHWAY_GENE
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_PATHWAY_GENE" 
   (	"ID" NUMBER(18,0), 
	"PATHWAY_ID" NUMBER(18,0), 
	"GENE_SYMBOL" NVARCHAR2(200), 
	"GENE_ID" NVARCHAR2(200)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 917504 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_RC_SNP_INFO
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_RC_SNP_INFO" 
   (	"SNP_INFO_ID" NUMBER(22,0), 
	"RS_ID" NVARCHAR2(50), 
	"CHROM" VARCHAR2(4 BYTE), 
	"POS" NUMBER(10,0), 
	"HG_VERSION" VARCHAR2(10 BYTE), 
	"EXON_INTRON" VARCHAR2(10 BYTE), 
	"RECOMBINATION_RATE" NUMBER(18,6), 
	"RECOMBINATION_MAP" NUMBER(18,6), 
	"REGULOME_SCORE" VARCHAR2(10 BYTE), 
	"GENE_NAME" VARCHAR2(50 BYTE), 
	"ENTREZ_ID" VARCHAR2(50 BYTE)
   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" 
  PARTITION BY LIST ("HG_VERSION") 
 (PARTITION "HG18"  VALUES ('18') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" NOCOMPRESS , 
 PARTITION "HG19"  VALUES ('19') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" NOCOMPRESS , 
 PARTITION "HGXX"  VALUES (default) 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" NOCOMPRESS ) 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Table DE_RC_SNP_INFO_ALL
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_RC_SNP_INFO_ALL" 
   (	"SNP_INFO_ID" NUMBER(22,0), 
	"RS_ID" VARCHAR2(100 BYTE), 
	"CHROM" VARCHAR2(4 BYTE), 
	"POS" NUMBER(10,0), 
	"REF" VARCHAR2(3000 BYTE), 
	"ALT" VARCHAR2(3000 BYTE), 
	"GENE_INFO" VARCHAR2(1000 BYTE), 
	"VARIATION_CLASS" VARCHAR2(10 BYTE), 
	"STRAND" VARCHAR2(1 BYTE), 
	"CLINSIG" VARCHAR2(100 BYTE), 
	"DISEASE" VARCHAR2(500 BYTE), 
	"GMAF" NUMBER(10,0), 
	"GENE_BIOTYPE" VARCHAR2(100 BYTE), 
	"IMPACT" VARCHAR2(50 BYTE), 
	"TRANSCRIPT_ID" VARCHAR2(100 BYTE), 
	"FUNCTIONAL_CLASS" VARCHAR2(100 BYTE), 
	"EFFECT" VARCHAR2(100 BYTE), 
	"EXON_ID" VARCHAR2(100 BYTE), 
	"AMINO_ACID_CHANGE" VARCHAR2(50 BYTE), 
	"CODON_CHANGE" VARCHAR2(100 BYTE), 
	"HG_VERSION" VARCHAR2(10 BYTE)
   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" 
  PARTITION BY LIST ("HG_VERSION") 
  SUBPARTITION BY LIST ("CHROM") 
  SUBPARTITION TEMPLATE ( 
    SUBPARTITION "CHR1" VALUES ( '1' ), 
    SUBPARTITION "CHR2" VALUES ( '2' ), 
    SUBPARTITION "CHR3" VALUES ( '3' ), 
    SUBPARTITION "CHR4" VALUES ( '4' ), 
    SUBPARTITION "CHR5" VALUES ( '5' ), 
    SUBPARTITION "CHR6" VALUES ( '6' ), 
    SUBPARTITION "CHR7" VALUES ( '7' ), 
    SUBPARTITION "CHR8" VALUES ( '8' ), 
    SUBPARTITION "CHR9" VALUES ( '9' ), 
    SUBPARTITION "CHR10" VALUES ( '10' ), 
    SUBPARTITION "CHR11" VALUES ( '11' ), 
    SUBPARTITION "CHR12" VALUES ( '12' ), 
    SUBPARTITION "CHR13" VALUES ( '13' ), 
    SUBPARTITION "CHR14" VALUES ( '14' ), 
    SUBPARTITION "CHR15" VALUES ( '15' ), 
    SUBPARTITION "CHR16" VALUES ( '16' ), 
    SUBPARTITION "CHR17" VALUES ( '17' ), 
    SUBPARTITION "CHR18" VALUES ( '18' ), 
    SUBPARTITION "CHR19" VALUES ( '19' ), 
    SUBPARTITION "CHR20" VALUES ( '20' ), 
    SUBPARTITION "CHR21" VALUES ( '21' ), 
    SUBPARTITION "CHR22" VALUES ( '22' ), 
    SUBPARTITION "CHRX" VALUES ( 'X' ), 
    SUBPARTITION "CHRY" VALUES ( 'Y' ), 
    SUBPARTITION "CHRM" VALUES ( 'M' ), 
    SUBPARTITION "CHRO" VALUES ( default ) ) 
 (PARTITION "HG18"  VALUES ('18') 
PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HG19"  VALUES ('19') 
PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HGXX"  VALUES (default) 
PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" )  ENABLE ROW MOVEMENT ;
--------------------------------------------------------
--  DDL for Table DE_RC_SNP_INFO_OLD
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_RC_SNP_INFO_OLD" 
   (	"SNP_INFO_ID" NUMBER(22,0), 
	"RS_ID" NVARCHAR2(50), 
	"CHROM" VARCHAR2(4 BYTE), 
	"POS" NUMBER(10,0), 
	"HG_VERSION" VARCHAR2(10 BYTE)
   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" 
  PARTITION BY LIST ("HG_VERSION") 
 (PARTITION "HG18"  VALUES ('18') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" NOCOMPRESS , 
 PARTITION "HG19"  VALUES ('19') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" NOCOMPRESS , 
 PARTITION "HGXX"  VALUES (default) 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" NOCOMPRESS ) 
  PARALLEL 4 ;
--------------------------------------------------------
--  DDL for Table DE_SAVED_COMPARISON
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SAVED_COMPARISON" 
   (	"COMPARISON_ID" NUMBER, 
	"QUERY_ID1" NUMBER, 
	"QUERY_ID2" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_CALLS_BY_GSM
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_CALLS_BY_GSM" 
   (	"GSM_NUM" VARCHAR2(20 BYTE), 
	"PATIENT_NUM" NUMBER(20,0), 
	"SNP_NAME" VARCHAR2(100 BYTE), 
	"SNP_CALLS" VARCHAR2(4 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_COPY_NUMBER
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_COPY_NUMBER" 
   (	"PATIENT_NUM" NUMBER(20,0), 
	"SNP_NAME" VARCHAR2(50 BYTE), 
	"CHROM" VARCHAR2(2 BYTE), 
	"CHROM_POS" NUMBER(20,0), 
	"COPY_NUMBER" NUMBER(2,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_DATA_BY_PATIENT
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_DATA_BY_PATIENT" 
   (	"SNP_DATA_BY_PATIENT_ID" NUMBER(22,0), 
	"SNP_DATASET_ID" NUMBER(22,0), 
	"TRIAL_NAME" VARCHAR2(255 BYTE), 
	"PATIENT_NUM" NUMBER, 
	"CHROM" VARCHAR2(16 BYTE), 
	"DATA_BY_PATIENT_CHR" CLOB, 
	"PED_BY_PATIENT_CHR" CLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" 
 LOB ("DATA_BY_PATIENT_CHR") STORE AS BASICFILE (
  TABLESPACE "DEAPP" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("PED_BY_PATIENT_CHR") STORE AS BASICFILE (
  TABLESPACE "DEAPP" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table DE_SNP_DATA_BY_PROBE
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_DATA_BY_PROBE" 
   (	"SNP_DATA_BY_PROBE_ID" NUMBER(22,0), 
	"PROBE_ID" NUMBER(22,0), 
	"PROBE_NAME" VARCHAR2(255 BYTE), 
	"SNP_ID" NUMBER(22,0), 
	"SNP_NAME" VARCHAR2(255 BYTE), 
	"TRIAL_NAME" VARCHAR2(255 BYTE), 
	"DATA_BY_PROBE" CLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 83886080 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" 
 LOB ("DATA_BY_PROBE") STORE AS BASICFILE (
  TABLESPACE "DEAPP" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table DE_SNP_DATA_DATASET_LOC
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_DATA_DATASET_LOC" 
   (	"SNP_DATA_DATASET_LOC_ID" NUMBER(22,0), 
	"TRIAL_NAME" VARCHAR2(255 BYTE), 
	"SNP_DATASET_ID" NUMBER(22,0), 
	"LOCATION" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_GENE_MAP
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_GENE_MAP" 
   (	"SNP_ID" NUMBER(22,0), 
	"SNP_NAME" NVARCHAR2(50), 
	"ENTREZ_GENE_ID" NUMBER, 
	"GENE_NAME" NVARCHAR2(200)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" 
  PARALLEL 4 ;
--------------------------------------------------------
--  DDL for Table DE_SNP_INFO
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_INFO" 
   (	"SNP_INFO_ID" NUMBER(22,0), 
	"NAME" VARCHAR2(255 BYTE), 
	"CHROM" VARCHAR2(16 BYTE), 
	"CHROM_POS" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 75497472 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE ROW MOVEMENT ;
--------------------------------------------------------
--  DDL for Table DE_SNP_INFO_HG19_MV_0
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_INFO_HG19_MV_0" 
   (	"RS_ID" NVARCHAR2(50), 
	"CHROM" VARCHAR2(4 BYTE), 
	"POS" NUMBER(10,0), 
	"RSGENE" NVARCHAR2(200)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
  CACHE PARALLEL 10 ;
 

   COMMENT ON TABLE "DEAPP"."DE_SNP_INFO_HG19_MV_0"  IS 'snapshot table for snapshot DEAPP.DE_SNP_INFO_HG19_MV';
--------------------------------------------------------
--  DDL for Table DE_SNP_INFO_HG19_MV_T
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_INFO_HG19_MV_T" 
   (	"RS_ID" NVARCHAR2(50), 
	"CHROM" VARCHAR2(4 BYTE), 
	"POS" NUMBER(10,0), 
	"RSGENE" VARCHAR2(50 BYTE), 
	"EXON_INTRON" VARCHAR2(10 BYTE), 
	"RECOMBINATION_RATE" NUMBER(18,6), 
	"REGULOME_SCORE" VARCHAR2(10 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 2537553920 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_PROBE
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_PROBE" 
   (	"SNP_PROBE_ID" NUMBER(22,0), 
	"PROBE_NAME" VARCHAR2(255 BYTE), 
	"SNP_ID" NUMBER(22,0), 
	"SNP_NAME" VARCHAR2(255 BYTE), 
	"VENDOR_NAME" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 83886080 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_PROBE_SORTED_DEF
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_PROBE_SORTED_DEF" 
   (	"SNP_PROBE_SORTED_DEF_ID" NUMBER(22,0), 
	"PLATFORM_NAME" VARCHAR2(255 BYTE), 
	"NUM_PROBE" NUMBER, 
	"CHROM" VARCHAR2(16 BYTE), 
	"PROBE_DEF" CLOB, 
	"SNP_ID_DEF" CLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" 
 LOB ("PROBE_DEF") STORE AS BASICFILE (
  TABLESPACE "DEAPP" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("SNP_ID_DEF") STORE AS BASICFILE (
  TABLESPACE "DEAPP" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table DE_SNP_SUBJECT_SORTED_DEF
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SNP_SUBJECT_SORTED_DEF" 
   (	"SNP_SUBJECT_SORTED_DEF_ID" NUMBER(22,0), 
	"TRIAL_NAME" VARCHAR2(255 BYTE), 
	"PATIENT_POSITION" NUMBER(5,0), 
	"PATIENT_NUM" NUMBER, 
	"SUBJECT_ID" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SUBJECT_MICROARRAY_DATA
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SUBJECT_MICROARRAY_DATA" 
   (	"TRIAL_SOURCE" VARCHAR2(200 BYTE), 
	"TRIAL_NAME" VARCHAR2(50 BYTE), 
	"PROBESET_ID" NUMBER(22,0), 
	"ASSAY_ID" NUMBER(18,0), 
	"PATIENT_ID" NUMBER(18,0), 
	"RAW_INTENSITY" NUMBER(18,4), 
	"LOG_INTENSITY" NUMBER(18,4), 
	"ZSCORE" NUMBER(18,4)
   ) PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255 COMPRESS BASIC  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" 
  PARTITION BY LIST ("TRIAL_SOURCE") 
 (PARTITION "A:A"  VALUES ('A:A') 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" COMPRESS BASIC , 
 PARTITION "GSE4382:STD"  VALUES ('GSE4382:STD') 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" COMPRESS BASIC , 
 PARTITION "A90000001:STD"  VALUES ('A90000001:STD') 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" COMPRESS BASIC , 
 PARTITION "A90000001:MIRNA"  VALUES ('A90000001:MIRNA') 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" COMPRESS BASIC , 
 PARTITION "B0151006:PFIZER"  VALUES ('B0151006:PFIZER') 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" COMPRESS BASIC , 
 PARTITION "BOLD:STDD"  VALUES ('BOLD:STDD') 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" COMPRESS BASIC , 
 PARTITION "BOLD:STDC"  VALUES ('BOLD:STDC') 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" COMPRESS BASIC ) ;
--------------------------------------------------------
--  DDL for Table DE_SUBJECT_MICROARRAY_DATA_OLD
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SUBJECT_MICROARRAY_DATA_OLD" 
   (	"TRIAL_NAME" VARCHAR2(50 BYTE), 
	"PROBESET_ID" NUMBER(22,0), 
	"ASSAY_ID" NUMBER(18,0), 
	"PATIENT_ID" NUMBER(18,0), 
	"RAW_INTENSITY" NUMBER(18,4), 
	"LOG_INTENSITY" NUMBER(18,4), 
	"ZSCORE" NUMBER(18,4), 
	"RAW_INTENSITY_4" NUMBER(18,4)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SUBJECT_MICROARRAY_LOGS
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SUBJECT_MICROARRAY_LOGS" 
   (	"PROBESET" VARCHAR2(50 BYTE), 
	"RAW_INTENSITY" NUMBER, 
	"PVALUE" FLOAT(126), 
	"REFSEQ" VARCHAR2(50 BYTE), 
	"GENE_SYMBOL" VARCHAR2(50 BYTE), 
	"ASSAY_ID" NUMBER(18,0), 
	"PATIENT_ID" NUMBER(18,0), 
	"SUBJECT_ID" VARCHAR2(20 BYTE), 
	"TRIAL_NAME" VARCHAR2(15 BYTE), 
	"TIMEPOINT" VARCHAR2(30 BYTE), 
	"LOG_INTENSITY" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SUBJECT_MICROARRAY_MED
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SUBJECT_MICROARRAY_MED" 
   (	"PROBESET" VARCHAR2(50 BYTE), 
	"RAW_INTENSITY" NUMBER, 
	"LOG_INTENSITY" NUMBER, 
	"GENE_SYMBOL" VARCHAR2(50 BYTE), 
	"ASSAY_ID" NUMBER(18,0), 
	"PATIENT_ID" NUMBER(18,0), 
	"SUBJECT_ID" VARCHAR2(20 BYTE), 
	"TRIAL_NAME" VARCHAR2(15 BYTE), 
	"TIMEPOINT" VARCHAR2(30 BYTE), 
	"PVALUE" FLOAT(126), 
	"REFSEQ" VARCHAR2(50 BYTE), 
	"MEAN_INTENSITY" NUMBER, 
	"STDDEV_INTENSITY" NUMBER, 
	"MEDIAN_INTENSITY" NUMBER, 
	"ZSCORE" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SUBJECT_PROTEIN_DATA
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SUBJECT_PROTEIN_DATA" 
   (	"TRIAL_NAME" VARCHAR2(15 BYTE), 
	"COMPONENT" VARCHAR2(15 BYTE), 
	"INTENSITY" NUMBER, 
	"PATIENT_ID" NUMBER(38,0), 
	"SUBJECT_ID" VARCHAR2(10 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" NUMBER(10,0), 
	"ASSAY_ID" NUMBER, 
	"TIMEPOINT" VARCHAR2(20 BYTE), 
	"N_VALUE" NUMBER, 
	"MEAN_INTENSITY" NUMBER, 
	"STDDEV_INTENSITY" NUMBER, 
	"MEDIAN_INTENSITY" NUMBER, 
	"ZSCORE" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SUBJECT_RBM_DATA
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SUBJECT_RBM_DATA" 
   (	"TRIAL_NAME" VARCHAR2(15 BYTE), 
	"ANTIGEN_NAME" VARCHAR2(100 BYTE), 
	"N_VALUE" NUMBER, 
	"PATIENT_ID" NUMBER(38,0), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" NUMBER(10,0), 
	"ASSAY_ID" NUMBER, 
	"NORMALIZED_VALUE" NUMBER(18,5), 
	"CONCEPT_CD" NVARCHAR2(100), 
	"TIMEPOINT" VARCHAR2(100 BYTE), 
	"DATA_UID" VARCHAR2(100 BYTE), 
	"VALUE" NUMBER, 
	"LOG_INTENSITY" NUMBER, 
	"MEAN_INTENSITY" NUMBER, 
	"STDDEV_INTENSITY" NUMBER, 
	"MEDIAN_INTENSITY" NUMBER, 
	"ZSCORE" NUMBER, 
	"RBM_PANEL" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SUBJECT_SAMPLE_MAPPING
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SUBJECT_SAMPLE_MAPPING" 
   (	"PATIENT_ID" NUMBER(18,0), 
	"SITE_ID" NVARCHAR2(100), 
	"SUBJECT_ID" NVARCHAR2(100), 
	"SUBJECT_TYPE" NVARCHAR2(100), 
	"CONCEPT_CODE" VARCHAR2(1000 CHAR), 
	"ASSAY_ID" NUMBER(18,0), 
	"PATIENT_UID" VARCHAR2(50 BYTE), 
	"SAMPLE_TYPE" VARCHAR2(100 BYTE), 
	"ASSAY_UID" NVARCHAR2(100), 
	"TRIAL_NAME" VARCHAR2(30 BYTE), 
	"TIMEPOINT" VARCHAR2(100 BYTE), 
	"TIMEPOINT_CD" VARCHAR2(50 BYTE), 
	"SAMPLE_TYPE_CD" VARCHAR2(50 BYTE), 
	"TISSUE_TYPE_CD" VARCHAR2(50 BYTE), 
	"PLATFORM" VARCHAR2(50 BYTE), 
	"PLATFORM_CD" VARCHAR2(50 BYTE), 
	"TISSUE_TYPE" VARCHAR2(100 BYTE), 
	"DATA_UID" VARCHAR2(100 BYTE), 
	"GPL_ID" VARCHAR2(20 BYTE), 
	"RBM_PANEL" VARCHAR2(50 BYTE), 
	"SAMPLE_ID" NUMBER(22,0), 
	"SAMPLE_CD" VARCHAR2(200 BYTE), 
	"CATEGORY_CD" VARCHAR2(1000 BYTE), 
	"SOURCE_CD" VARCHAR2(50 BYTE), 
	"OMIC_SOURCE_STUDY" VARCHAR2(200 BYTE), 
	"OMIC_PATIENT_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 524288 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_SUBJECT_SNP_DATASET
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_SUBJECT_SNP_DATASET" 
   (	"SUBJECT_SNP_DATASET_ID" NUMBER(22,0), 
	"DATASET_NAME" VARCHAR2(255 BYTE), 
	"CONCEPT_CD" VARCHAR2(255 BYTE), 
	"PLATFORM_NAME" VARCHAR2(255 BYTE), 
	"TRIAL_NAME" VARCHAR2(255 BYTE), 
	"PATIENT_NUM" NUMBER, 
	"TIMEPOINT" VARCHAR2(255 BYTE), 
	"SUBJECT_ID" VARCHAR2(255 BYTE), 
	"SAMPLE_TYPE" VARCHAR2(255 BYTE), 
	"PAIRED_DATASET_ID" NUMBER(22,0), 
	"PATIENT_GENDER" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_XTRIAL_CHILD_MAP
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_XTRIAL_CHILD_MAP" 
   (	"CONCEPT_CD" VARCHAR2(50 BYTE), 
	"PARENT_CD" NUMBER, 
	"MANUALLY_MAPPED" NUMBER, 
	"STUDY_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table DE_XTRIAL_PARENT_NAMES
--------------------------------------------------------

  CREATE TABLE "DEAPP"."DE_XTRIAL_PARENT_NAMES" 
   (	"PARENT_CD" NUMBER, 
	"ACROSS_PATH" VARCHAR2(500 BYTE), 
	"MANUALLY_CREATED" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table HAPLOVIEW_DATA
--------------------------------------------------------

  CREATE TABLE "DEAPP"."HAPLOVIEW_DATA" 
   (	"I2B2_ID" NUMBER(20,0), 
	"JNJ_ID" VARCHAR2(30 BYTE), 
	"FATHER_ID" NUMBER(5,0), 
	"MOTHER_ID" NUMBER(5,0), 
	"SEX" NUMBER(1,0), 
	"AFFECTION_STATUS" NUMBER(1,0), 
	"CHROMOSOME" VARCHAR2(10 BYTE), 
	"GENE" VARCHAR2(50 BYTE), 
	"RELEASE" NUMBER(4,0), 
	"RELEASE_DATE" DATE, 
	"TRIAL_NAME" VARCHAR2(50 BYTE), 
	"SNP_DATA" CLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" 
 LOB ("SNP_DATA") STORE AS BASICFILE (
  TABLESPACE "DEAPP" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table TEST_SNP_INFO
--------------------------------------------------------

  CREATE TABLE "DEAPP"."TEST_SNP_INFO" 
   (	"SNP_INFO_ID" NUMBER(22,0), 
	"RS_ID" NVARCHAR2(50), 
	"CHROM" VARCHAR2(4 BYTE), 
	"POS" NUMBER(10,0), 
	"HG_VERSION" VARCHAR2(10 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Table FM_DATA_UID
--------------------------------------------------------

  CREATE TABLE "FMAPP"."FM_DATA_UID" 
   (	"FM_DATA_ID" NUMBER(18,0), 
	"UNIQUE_ID" NVARCHAR2(300), 
	"FM_DATA_TYPE" NVARCHAR2(100)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FM_FILE
--------------------------------------------------------

  CREATE TABLE "FMAPP"."FM_FILE" 
   (	"FILE_ID" NUMBER(18,0), 
	"DISPLAY_NAME" NVARCHAR2(1000), 
	"ORIGINAL_NAME" NVARCHAR2(1000), 
	"FILE_VERSION" NUMBER(18,0), 
	"FILE_TYPE" NVARCHAR2(100), 
	"FILE_SIZE" NUMBER(18,0), 
	"FILESTORE_LOCATION" NVARCHAR2(1000), 
	"FILESTORE_NAME" NVARCHAR2(1000), 
	"LINK_URL" NVARCHAR2(1000), 
	"ACTIVE_IND" CHAR(1 BYTE), 
	"CREATE_DATE" DATE, 
	"UPDATE_DATE" DATE, 
	"DESCRIPTION" NVARCHAR2(2000)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FM_FOLDER
--------------------------------------------------------

  CREATE TABLE "FMAPP"."FM_FOLDER" 
   (	"FOLDER_ID" NUMBER(18,0), 
	"FOLDER_NAME" NVARCHAR2(500), 
	"FOLDER_FULL_NAME" NVARCHAR2(500), 
	"FOLDER_LEVEL" NUMBER, 
	"FOLDER_TYPE" NVARCHAR2(50), 
	"FOLDER_TAG" NVARCHAR2(50), 
	"ACTIVE_IND" CHAR(1 BYTE), 
	"OLD_FOLDER_ID" NUMBER(18,0), 
	"PARENT_ID" NUMBER(18,0), 
	"DESCRIPTION" NVARCHAR2(2000)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FM_FOLDER_ASSOCIATION
--------------------------------------------------------

  CREATE TABLE "FMAPP"."FM_FOLDER_ASSOCIATION" 
   (	"FOLDER_ID" NUMBER(18,0), 
	"OBJECT_UID" NVARCHAR2(300), 
	"OBJECT_TYPE" NVARCHAR2(100)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table FM_FOLDER_FILE_ASSOCIATION
--------------------------------------------------------

  CREATE TABLE "FMAPP"."FM_FOLDER_FILE_ASSOCIATION" 
   (	"FOLDER_ID" NUMBER(18,0), 
	"FILE_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ANNOTATION_DEAPP
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."ANNOTATION_DEAPP" 
   (	"GPL_ID" VARCHAR2(100 BYTE), 
	"PROBE_ID" VARCHAR2(100 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" VARCHAR2(100 BYTE), 
	"PROBESET_ID" NUMBER(38,0), 
	"ORGANISM" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 11534336 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table ANNOTATION_DEAPP_20120206
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."ANNOTATION_DEAPP_20120206" 
   (	"GPL_ID" VARCHAR2(100 BYTE), 
	"PROBE_ID" VARCHAR2(100 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" VARCHAR2(100 BYTE), 
	"PROBESET_ID" NUMBER(38,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table BIO_CLINICAL_TRIAL_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."BIO_CLINICAL_TRIAL_RELEASE" 
   (	"TRIAL_NUMBER" NVARCHAR2(510), 
	"STUDY_OWNER" NVARCHAR2(510), 
	"STUDY_PHASE" VARCHAR2(100 BYTE), 
	"BLINDING_PROCEDURE" NVARCHAR2(1000), 
	"STUDYTYPE" NVARCHAR2(510), 
	"DURATION_OF_STUDY_WEEKS" NUMBER(10,0), 
	"NUMBER_OF_PATIENTS" NUMBER(10,0), 
	"NUMBER_OF_SITES" NUMBER(10,0), 
	"ROUTE_OF_ADMINISTRATION" NVARCHAR2(510), 
	"DOSING_REGIMEN" VARCHAR2(3500 BYTE), 
	"GROUP_ASSIGNMENT" NVARCHAR2(510), 
	"TYPE_OF_CONTROL" NVARCHAR2(510), 
	"COMPLETION_DATE" DATE, 
	"PRIMARY_END_POINTS" VARCHAR2(2000 BYTE), 
	"SECONDARY_END_POINTS" VARCHAR2(3500 BYTE), 
	"INCLUSION_CRITERIA" NCLOB, 
	"EXCLUSION_CRITERIA" NCLOB, 
	"SUBJECTS" VARCHAR2(2000 BYTE), 
	"GENDER_RESTRICTION_MFB" NVARCHAR2(510), 
	"MIN_AGE" NUMBER(10,0), 
	"MAX_AGE" NUMBER(10,0), 
	"SECONDARY_IDS" NVARCHAR2(510), 
	"BIO_EXPERIMENT_ID" NUMBER(18,0), 
	"DEVELOPMENT_PARTNER" VARCHAR2(100 BYTE), 
	"GEO_PLATFORM" VARCHAR2(30 BYTE), 
	"MAIN_FINDINGS" VARCHAR2(2000 BYTE), 
	"PLATFORM_NAME" VARCHAR2(200 BYTE), 
	"SEARCH_AREA" VARCHAR2(100 BYTE), 
	"RELEASE_STUDY" NVARCHAR2(510)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("INCLUSION_CRITERIA") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("EXCLUSION_CRITERIA") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table BIO_DATA_COMPOUND_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."BIO_DATA_COMPOUND_RELEASE" 
   (	"BIO_DATA_ID" NUMBER(18,0), 
	"BIO_COMPOUND_ID" NUMBER(18,0), 
	"ETL_SOURCE" VARCHAR2(100 BYTE), 
	"RELEASE_STUDY" NVARCHAR2(100)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table BIO_DATA_UID_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."BIO_DATA_UID_RELEASE" 
   (	"BIO_DATA_ID" NUMBER(18,0), 
	"UNIQUE_ID" NVARCHAR2(200), 
	"BIO_DATA_TYPE" NVARCHAR2(100), 
	"RELEASE_STUDY" NVARCHAR2(200)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table BIO_EXPERIMENT_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."BIO_EXPERIMENT_RELEASE" 
   (	"BIO_EXPERIMENT_ID" NUMBER(18,0), 
	"BIO_EXPERIMENT_TYPE" NVARCHAR2(200), 
	"TITLE" NVARCHAR2(1000), 
	"DESCRIPTION" NVARCHAR2(2000), 
	"DESIGN" NVARCHAR2(2000), 
	"START_DATE" DATE, 
	"COMPLETION_DATE" DATE, 
	"PRIMARY_INVESTIGATOR" NVARCHAR2(400), 
	"CONTACT_FIELD" NVARCHAR2(400), 
	"ETL_ID" NVARCHAR2(100), 
	"STATUS" VARCHAR2(100 BYTE), 
	"OVERALL_DESIGN" NVARCHAR2(2000), 
	"ACCESSION" NVARCHAR2(100), 
	"ENTRYDT" DATE, 
	"UPDATED" DATE, 
	"INSTITUTION" VARCHAR2(100 BYTE), 
	"COUNTRY" VARCHAR2(50 BYTE), 
	"BIOMARKER_TYPE" VARCHAR2(255 BYTE), 
	"TARGET" VARCHAR2(255 BYTE), 
	"ACCESS_TYPE" VARCHAR2(100 BYTE), 
	"RELEASE_STUDY" NVARCHAR2(100)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CATEGORY_PATH_EXCLUDED_WORDS
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CATEGORY_PATH_EXCLUDED_WORDS" 
   (	"EXCLUDED_TEXT" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CONCEPT_DIMENSION_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CONCEPT_DIMENSION_RELEASE" 
   (	"CONCEPT_CD" VARCHAR2(50 BYTE), 
	"CONCEPT_PATH" VARCHAR2(700 BYTE), 
	"NAME_CHAR" VARCHAR2(2000 BYTE), 
	"CONCEPT_BLOB" CLOB, 
	"UPDATE_DATE" DATE, 
	"DOWNLOAD_DATE" DATE, 
	"IMPORT_DATE" DATE, 
	"SOURCESYSTEM_CD" VARCHAR2(50 BYTE), 
	"UPLOAD_ID" NUMBER, 
	"TABLE_NAME" VARCHAR2(255 BYTE), 
	"RELEASE_STUDY" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("CONCEPT_BLOB") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table CZ_DATA_PROFILE_COLUMN_EXCLUSI
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_DATA_PROFILE_COLUMN_EXCLUSI" 
   (	"TABLE_NAME" VARCHAR2(500 BYTE), 
	"COLUMN_NAME" VARCHAR2(500 BYTE), 
	"EXCLUSION_REASON" VARCHAR2(2000 BYTE), 
	"ETL_DATE" DATE DEFAULT SYSDATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_DATA_PROFILE_COLUMN_SAMPLE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_DATA_PROFILE_COLUMN_SAMPLE" 
   (	"TABLE_NAME" VARCHAR2(500 BYTE), 
	"COLUMN_NAME" VARCHAR2(500 BYTE), 
	"VALUE" VARCHAR2(4000 BYTE), 
	"COUNT" NUMBER(19,0), 
	"ETL_DATE" DATE DEFAULT SYSDATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_DATA_PROFILE_STATS
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_DATA_PROFILE_STATS" 
   (	"TABLE_NAME" VARCHAR2(500 BYTE), 
	"COLUMN_NAME" VARCHAR2(500 BYTE), 
	"DATA_TYPE" VARCHAR2(500 BYTE), 
	"COLUMN_LENGTH" NUMBER(10,0), 
	"COLUMN_PRECISION" NUMBER(10,0), 
	"COLUMN_SCALE" NUMBER(10,0), 
	"TOTAL_COUNT" NUMBER(19,0), 
	"PERCENTAGE_NULL" NUMBER(5,2), 
	"NULL_COUNT" NUMBER(19,0), 
	"NON_NULL_COUNT" NUMBER(19,0), 
	"DISTINCT_COUNT" NUMBER(19,0), 
	"MAX_LENGTH" NUMBER(10,0), 
	"MIN_LENGTH" NUMBER(10,0), 
	"FIRST_VALUE" VARCHAR2(4000 BYTE), 
	"LAST_VALUE" VARCHAR2(4000 BYTE), 
	"MAX_LENGTH_VALUE" VARCHAR2(4000 BYTE), 
	"MIN_LENGTH_VALUE" VARCHAR2(4000 BYTE), 
	"ETL_DATE" DATE DEFAULT SYSDATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_FORM_LAYOUT
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_FORM_LAYOUT" 
   (	"FORM_LAYOUT_ID" NUMBER(22,0), 
	"FORM_KEY" NVARCHAR2(50), 
	"FORM_COLUMN" NVARCHAR2(50), 
	"DISPLAY_NAME" NVARCHAR2(50), 
	"DATA_TYPE" NVARCHAR2(50), 
	"SEQUENCE" NUMBER(22,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_JOB_AUDIT
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_JOB_AUDIT" 
   (	"SEQ_ID" NUMBER(18,0), 
	"JOB_ID" NUMBER(18,0), 
	"DATABASE_NAME" NVARCHAR2(50), 
	"PROCEDURE_NAME" NVARCHAR2(100), 
	"STEP_DESC" NVARCHAR2(1000), 
	"STEP_STATUS" NVARCHAR2(50), 
	"RECORDS_MANIPULATED" NUMBER(18,0), 
	"STEP_NUMBER" NUMBER(18,0), 
	"JOB_DATE" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"TIME_ELAPSED_SECS" NUMBER(18,4) DEFAULT 0
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 29360128 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_JOB_ERROR
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_JOB_ERROR" 
   (	"JOB_ID" NUMBER(18,0), 
	"ERROR_NUMBER" NUMBER(18,0), 
	"ERROR_MESSAGE" NVARCHAR2(1000), 
	"ERROR_STACK" NVARCHAR2(2000), 
	"SEQ_ID" NUMBER(18,0), 
	"ERROR_BACKTRACE" NVARCHAR2(2000)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_JOB_MASTER
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_JOB_MASTER" 
   (	"JOB_ID" NUMBER(18,0) DEFAULT NULL, 
	"START_DATE" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"END_DATE" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"ACTIVE" NVARCHAR2(1), 
	"TIME_ELAPSED_SECS" NUMBER(18,4) DEFAULT 0, 
	"BUILD_ID" NUMBER(18,0), 
	"SESSION_ID" NUMBER(18,0), 
	"DATABASE_NAME" NVARCHAR2(50), 
	"JOB_STATUS" NVARCHAR2(50), 
	"JOB_NAME" NVARCHAR2(500)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_JOB_MESSAGE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_JOB_MESSAGE" 
   (	"JOB_ID" NUMBER(18,0), 
	"MESSAGE_ID" NUMBER(18,0), 
	"MESSAGE_LINE" NUMBER(18,0), 
	"MESSAGE_PROCEDURE" NVARCHAR2(100), 
	"INFO_MESSAGE" NVARCHAR2(2000), 
	"SEQ_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_PERSON
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_PERSON" 
   (	"PERSON_ID" NUMBER(18,0), 
	"F_NAME" NVARCHAR2(200), 
	"L_NAME" NVARCHAR2(200), 
	"M_NAME" NVARCHAR2(200), 
	"USER_NAME" NVARCHAR2(20), 
	"ROLE_CODE" VARCHAR2(20 BYTE), 
	"EMAIL_ADDRESS" VARCHAR2(100 BYTE), 
	"MAIL_ADDRESS" VARCHAR2(200 BYTE), 
	"CELL_PHONE" VARCHAR2(20 BYTE), 
	"WORK_PHONE" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_REQUIRED_UPLOAD_FIELD
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_REQUIRED_UPLOAD_FIELD" 
   (	"REQUIRED_UPLOAD_FIELD_ID" NUMBER(22,0), 
	"TYPE" NVARCHAR2(50), 
	"FIELD" NVARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_TEST
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_TEST" 
   (	"TEST_ID" NUMBER(18,0), 
	"TEST_NAME" NVARCHAR2(200), 
	"TEST_DESC" NVARCHAR2(1000), 
	"TEST_SCHEMA" NVARCHAR2(255), 
	"TEST_TABLE" NVARCHAR2(255), 
	"TEST_COLUMN" NVARCHAR2(255), 
	"TEST_TYPE" NVARCHAR2(255), 
	"TEST_SQL" NVARCHAR2(2000), 
	"TEST_PARAM1" NVARCHAR2(2000), 
	"TEST_PARAM2" NVARCHAR2(2000), 
	"TEST_PARAM3" NVARCHAR2(2000), 
	"TEST_MIN_VALUE" NUMBER(18,4), 
	"TEST_MAX_VALUE" NUMBER(18,4), 
	"TEST_CATEGORY_ID" NUMBER, 
	"TEST_SEVERITY_CD" NVARCHAR2(20), 
	"TABLE_TYPE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_TEST_CATEGORY
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_TEST_CATEGORY" 
   (	"TEST_CATEGORY_ID" NUMBER(18,0), 
	"TEST_CATEGORY" NVARCHAR2(255), 
	"TEST_SUB_CATEGORY1" NVARCHAR2(255), 
	"TEST_SUB_CATEGORY2" NVARCHAR2(255)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_TEST_RESULT
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_TEST_RESULT" 
   (	"TEST_ID" NUMBER(18,0), 
	"TEST_RESULT_ID" NUMBER(18,0), 
	"TEST_RESULT_TEXT" VARCHAR2(2000 BYTE), 
	"TEST_RESULT_NBR" NUMBER(22,0), 
	"TEST_RUN_ID" NUMBER(18,0), 
	"EXTERNAL_LOCATION" VARCHAR2(2000 BYTE), 
	"RUN_DATE" DATE, 
	"STUDY_ID" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_XTRIAL_CTRL_VOCAB
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_XTRIAL_CTRL_VOCAB" 
   (	"CTRL_VOCAB_CODE" VARCHAR2(200 BYTE), 
	"CTRL_VOCAB_NAME" VARCHAR2(200 BYTE), 
	"CTRL_VOCAB_CATEGORY" VARCHAR2(200 BYTE), 
	"CTRL_VOCAB_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CZ_XTRIAL_EXCLUSION
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."CZ_XTRIAL_EXCLUSION" 
   (	"TRIAL_ID" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DE_GPL_INFO_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_GPL_INFO_RELEASE" 
   (	"PLATFORM" VARCHAR2(10 BYTE), 
	"TITLE" VARCHAR2(500 BYTE), 
	"ORGANISM" VARCHAR2(100 BYTE), 
	"ANNOTATION_DATE" TIMESTAMP (6)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DE_MRNA_ANNOTATION_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_MRNA_ANNOTATION_RELEASE" 
   (	"GPL_ID" VARCHAR2(100 BYTE), 
	"PROBE_ID" VARCHAR2(100 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" VARCHAR2(100 BYTE), 
	"PROBESET_ID" NUMBER(38,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_DATA_BY_PATIENT_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SNP_DATA_BY_PATIENT_RELEASE" 
   (	"SNP_DATA_BY_PATIENT_ID" NUMBER(22,0), 
	"SNP_DATASET_ID" NUMBER(22,0), 
	"TRIAL_NAME" VARCHAR2(255 BYTE), 
	"PATIENT_NUM" NUMBER, 
	"CHROM" VARCHAR2(16 BYTE), 
	"DATA_BY_PATIENT_CHR" CLOB, 
	"PED_BY_PATIENT_CHR" CLOB, 
	"RELEASE_STUDY" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("DATA_BY_PATIENT_CHR") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("PED_BY_PATIENT_CHR") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table DE_SNP_DATA_BY_PROBE_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SNP_DATA_BY_PROBE_RELEASE" 
   (	"SNP_DATA_BY_PROBE_ID" NUMBER(22,0), 
	"PROBE_ID" NUMBER(22,0), 
	"PROBE_NAME" VARCHAR2(255 BYTE), 
	"SNP_ID" NUMBER(22,0), 
	"SNP_NAME" VARCHAR2(255 BYTE), 
	"TRIAL_NAME" VARCHAR2(255 BYTE), 
	"DATA_BY_PROBE" CLOB, 
	"RELEASE_STUDY" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("DATA_BY_PROBE") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table DE_SNP_DATA_DS_LOC_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SNP_DATA_DS_LOC_RELEASE" 
   (	"SNP_DATA_DATASET_LOC_ID" NUMBER(22,0), 
	"TRIAL_NAME" VARCHAR2(255 BYTE), 
	"SNP_DATASET_ID" NUMBER(22,0), 
	"LOCATION" NUMBER, 
	"RELEASE_STUDY" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_GENE_MAP_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SNP_GENE_MAP_RELEASE" 
   (	"SNP_ID" NUMBER(22,0), 
	"SNP_NAME" VARCHAR2(255 BYTE), 
	"ENTREZ_GENE_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_INFO_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SNP_INFO_RELEASE" 
   (	"SNP_INFO_ID" NUMBER(22,0), 
	"NAME" VARCHAR2(255 BYTE), 
	"CHROM" VARCHAR2(16 BYTE), 
	"CHROM_POS" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_PROBE_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SNP_PROBE_RELEASE" 
   (	"SNP_PROBE_ID" NUMBER(22,0), 
	"PROBE_NAME" VARCHAR2(255 BYTE), 
	"SNP_ID" NUMBER(22,0), 
	"SNP_NAME" VARCHAR2(255 BYTE), 
	"VENDOR_NAME" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DE_SNP_PROBE_SORT_DEF_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SNP_PROBE_SORT_DEF_RELEASE" 
   (	"SNP_PROBE_SORTED_DEF_ID" NUMBER(22,0), 
	"PLATFORM_NAME" VARCHAR2(255 BYTE), 
	"NUM_PROBE" NUMBER, 
	"CHROM" VARCHAR2(16 BYTE), 
	"PROBE_DEF" CLOB, 
	"SNP_ID_DEF" CLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("PROBE_DEF") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("SNP_ID_DEF") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table DE_SUBJECT_MRNA_DATA_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SUBJECT_MRNA_DATA_RELEASE" 
   (	"TRIAL_NAME" VARCHAR2(50 BYTE), 
	"PROBESET_ID" NUMBER(22,0), 
	"ASSAY_ID" NUMBER(18,0), 
	"PATIENT_ID" NUMBER(18,0), 
	"TIMEPOINT" VARCHAR2(100 BYTE), 
	"PVALUE" FLOAT(126), 
	"REFSEQ" VARCHAR2(50 BYTE), 
	"SUBJECT_ID" VARCHAR2(50 BYTE), 
	"RAW_INTENSITY" NUMBER, 
	"MEAN_INTENSITY" NUMBER(18,4), 
	"STDDEV_INTENSITY" NUMBER(18,4), 
	"MEDIAN_INTENSITY" NUMBER(18,4), 
	"LOG_INTENSITY" NUMBER(18,4), 
	"ZSCORE" NUMBER(18,4), 
	"SAMPLE_ID" NUMBER(22,0), 
	"RELEASE_STUDY" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DE_SUBJECT_RBM_DATA_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SUBJECT_RBM_DATA_RELEASE" 
   (	"TRIAL_NAME" VARCHAR2(15 BYTE), 
	"ANTIGEN_NAME" VARCHAR2(100 BYTE), 
	"N_VALUE" NUMBER, 
	"PATIENT_ID" NUMBER(38,0), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" NUMBER(10,0), 
	"ASSAY_ID" NUMBER, 
	"NORMALIZED_VALUE" NUMBER(18,5), 
	"CONCEPT_CD" NVARCHAR2(100), 
	"TIMEPOINT" VARCHAR2(100 BYTE), 
	"DATA_UID" VARCHAR2(100 BYTE), 
	"VALUE" NUMBER, 
	"LOG_INTENSITY" NUMBER, 
	"MEAN_INTENSITY" NUMBER, 
	"STDDEV_INTENSITY" NUMBER, 
	"MEDIAN_INTENSITY" NUMBER, 
	"ZSCORE" NUMBER, 
	"RBM_PANEL" VARCHAR2(50 BYTE), 
	"RELEASE_STUDY" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DE_SUBJ_PROTEIN_DATA_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SUBJ_PROTEIN_DATA_RELEASE" 
   (	"TRIAL_NAME" VARCHAR2(15 BYTE), 
	"COMPONENT" VARCHAR2(15 BYTE), 
	"INTENSITY" NUMBER, 
	"PATIENT_ID" NUMBER(38,0), 
	"SUBJECT_ID" VARCHAR2(10 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" NUMBER(10,0), 
	"ASSAY_ID" NUMBER, 
	"TIMEPOINT" VARCHAR2(20 BYTE), 
	"N_VALUE" NUMBER, 
	"MEAN_INTENSITY" NUMBER, 
	"STDDEV_INTENSITY" NUMBER, 
	"MEDIAN_INTENSITY" NUMBER, 
	"ZSCORE" NUMBER, 
	"RELEASE_STUDY" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DE_SUBJ_SAMPLE_MAP_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."DE_SUBJ_SAMPLE_MAP_RELEASE" 
   (	"PATIENT_ID" NUMBER(18,0), 
	"SITE_ID" NVARCHAR2(100), 
	"SUBJECT_ID" NVARCHAR2(100), 
	"SUBJECT_TYPE" NVARCHAR2(100), 
	"CONCEPT_CODE" VARCHAR2(1000 CHAR), 
	"ASSAY_ID" NUMBER(18,0), 
	"PATIENT_UID" VARCHAR2(50 BYTE), 
	"SAMPLE_TYPE" VARCHAR2(100 BYTE), 
	"ASSAY_UID" NVARCHAR2(100), 
	"TRIAL_NAME" VARCHAR2(30 BYTE), 
	"TIMEPOINT" VARCHAR2(100 BYTE), 
	"TIMEPOINT_CD" VARCHAR2(50 BYTE), 
	"SAMPLE_TYPE_CD" VARCHAR2(50 BYTE), 
	"TISSUE_TYPE_CD" VARCHAR2(50 BYTE), 
	"PLATFORM" VARCHAR2(50 BYTE), 
	"PLATFORM_CD" VARCHAR2(50 BYTE), 
	"TISSUE_TYPE" VARCHAR2(100 BYTE), 
	"DATA_UID" VARCHAR2(100 BYTE), 
	"GPL_ID" VARCHAR2(20 BYTE), 
	"RBM_PANEL" VARCHAR2(50 BYTE), 
	"SAMPLE_ID" NUMBER(22,0), 
	"SAMPLE_CD" VARCHAR2(200 BYTE), 
	"CATEGORY_CD" VARCHAR2(1000 BYTE), 
	"RELEASE_STUDY" VARCHAR2(30 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table HAPLOVIEW_DATA_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."HAPLOVIEW_DATA_RELEASE" 
   (	"I2B2_ID" NUMBER(20,0), 
	"JNJ_ID" VARCHAR2(30 BYTE), 
	"FATHER_ID" NUMBER(5,0), 
	"MOTHER_ID" NUMBER(5,0), 
	"SEX" NUMBER(1,0), 
	"AFFECTION_STATUS" NUMBER(1,0), 
	"CHROMOSOME" VARCHAR2(10 BYTE), 
	"GENE" VARCHAR2(50 BYTE), 
	"RELEASE" NUMBER(4,0), 
	"RELEASE_DATE" DATE, 
	"TRIAL_NAME" VARCHAR2(50 BYTE), 
	"SNP_DATA" CLOB, 
	"RELEASE_STUDY" VARCHAR2(30 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("SNP_DATA") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table I2B2_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."I2B2_RELEASE" 
   (	"C_HLEVEL" NUMBER(22,0), 
	"C_FULLNAME" VARCHAR2(900 BYTE), 
	"C_NAME" VARCHAR2(2000 BYTE), 
	"C_SYNONYM_CD" CHAR(1 BYTE), 
	"C_VISUALATTRIBUTES" CHAR(3 BYTE), 
	"C_TOTALNUM" NUMBER(22,0), 
	"C_BASECODE" VARCHAR2(450 BYTE), 
	"C_METADATAXML" CLOB, 
	"C_FACTTABLECOLUMN" VARCHAR2(50 BYTE), 
	"C_TABLENAME" VARCHAR2(50 BYTE), 
	"C_COLUMNNAME" VARCHAR2(50 BYTE), 
	"C_COLUMNDATATYPE" VARCHAR2(50 BYTE), 
	"C_OPERATOR" VARCHAR2(10 BYTE), 
	"C_DIMCODE" VARCHAR2(900 BYTE), 
	"C_COMMENT" CLOB, 
	"C_TOOLTIP" VARCHAR2(900 BYTE), 
	"UPDATE_DATE" DATE, 
	"DOWNLOAD_DATE" DATE, 
	"IMPORT_DATE" DATE, 
	"SOURCESYSTEM_CD" VARCHAR2(50 BYTE), 
	"VALUETYPE_CD" VARCHAR2(50 BYTE), 
	"I2B2_ID" NUMBER(22,0), 
	"RELEASE_STUDY" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("C_METADATAXML") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("C_COMMENT") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table I2B2_TAGS_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."I2B2_TAGS_RELEASE" 
   (	"TAG_ID" NUMBER(18,0), 
	"PATH" NVARCHAR2(200), 
	"TAG" NVARCHAR2(200), 
	"TAG_TYPE" NVARCHAR2(200), 
	"RELEASE_STUDY" NVARCHAR2(200)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table NODE_CURATION
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."NODE_CURATION" 
   (	"NODE_TYPE" VARCHAR2(25 BYTE), 
	"NODE_NAME" VARCHAR2(250 BYTE), 
	"DISPLAY_NAME" VARCHAR2(250 BYTE), 
	"DISPLAY_IN_UI" CHAR(1 BYTE), 
	"DATA_TYPE" CHAR(1 BYTE), 
	"GLOBAL_FLAG" CHAR(1 BYTE), 
	"STUDY_ID" VARCHAR2(30 BYTE), 
	"CURATOR_NAME" VARCHAR2(250 BYTE), 
	"CURATION_DATE" DATE, 
	"ACTIVE_FLAG" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table OBSERVATION_FACT_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."OBSERVATION_FACT_RELEASE" 
   (	"ENCOUNTER_NUM" NUMBER(38,0), 
	"PATIENT_NUM" NUMBER(38,0), 
	"CONCEPT_CD" VARCHAR2(50 BYTE), 
	"PROVIDER_ID" VARCHAR2(50 BYTE), 
	"START_DATE" DATE, 
	"MODIFIER_CD" VARCHAR2(100 BYTE), 
	"VALTYPE_CD" VARCHAR2(50 BYTE), 
	"TVAL_CHAR" VARCHAR2(255 BYTE), 
	"NVAL_NUM" NUMBER(18,5), 
	"VALUEFLAG_CD" VARCHAR2(50 BYTE), 
	"QUANTITY_NUM" NUMBER(18,5), 
	"UNITS_CD" VARCHAR2(50 BYTE), 
	"END_DATE" DATE, 
	"LOCATION_CD" VARCHAR2(50 BYTE), 
	"CONFIDENCE_NUM" NUMBER(18,0), 
	"UPDATE_DATE" DATE, 
	"DOWNLOAD_DATE" DATE, 
	"IMPORT_DATE" DATE, 
	"SOURCESYSTEM_CD" VARCHAR2(50 BYTE), 
	"UPLOAD_ID" NUMBER(38,0), 
	"OBSERVATION_BLOB" CLOB, 
	"RELEASE_STUDY" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("OBSERVATION_BLOB") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table PATIENT_DIMENSION_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."PATIENT_DIMENSION_RELEASE" 
   (	"PATIENT_NUM" NUMBER(38,0), 
	"VITAL_STATUS_CD" VARCHAR2(50 BYTE), 
	"BIRTH_DATE" DATE, 
	"DEATH_DATE" DATE, 
	"SEX_CD" VARCHAR2(50 BYTE), 
	"AGE_IN_YEARS_NUM" NUMBER(38,0), 
	"LANGUAGE_CD" VARCHAR2(50 BYTE), 
	"RACE_CD" VARCHAR2(50 BYTE), 
	"MARITAL_STATUS_CD" VARCHAR2(50 BYTE), 
	"RELIGION_CD" VARCHAR2(50 BYTE), 
	"ZIP_CD" VARCHAR2(50 BYTE), 
	"STATECITYZIP_PATH" VARCHAR2(700 BYTE), 
	"UPDATE_DATE" DATE, 
	"DOWNLOAD_DATE" DATE, 
	"IMPORT_DATE" DATE, 
	"SOURCESYSTEM_CD" VARCHAR2(50 BYTE), 
	"UPLOAD_ID" NUMBER(38,0), 
	"PATIENT_BLOB" CLOB, 
	"RELEASE_STUDY" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("PATIENT_BLOB") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 PCTVERSION 10
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table PROBESET_DEAPP
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."PROBESET_DEAPP" 
   (	"PROBESET_ID" NUMBER(38,0), 
	"PROBESET" VARCHAR2(100 BYTE), 
	"PLATFORM" VARCHAR2(100 BYTE), 
	"ORGANISM" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 9437184 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table PROBESET_DEAPP_20120206
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."PROBESET_DEAPP_20120206" 
   (	"PROBESET_ID" NUMBER(38,0), 
	"PROBESET" VARCHAR2(100 BYTE), 
	"PLATFORM" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table SAMPLE_CATEGORIES_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."SAMPLE_CATEGORIES_RELEASE" 
   (	"TRIAL_CD" VARCHAR2(200 BYTE), 
	"SITE_CD" VARCHAR2(200 BYTE), 
	"SUBJECT_CD" VARCHAR2(200 BYTE), 
	"SAMPLE_CD" VARCHAR2(200 BYTE), 
	"CATEGORY_CD" VARCHAR2(200 BYTE), 
	"CATEGORY_VALUE" VARCHAR2(200 BYTE), 
	"RELEASE_STUDY" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table SEARCH_SECURE_OBJECT_RELEASE
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."SEARCH_SECURE_OBJECT_RELEASE" 
   (	"SEARCH_SECURE_OBJECT_ID" NUMBER(18,0), 
	"BIO_DATA_ID" NUMBER(18,0), 
	"DISPLAY_NAME" NVARCHAR2(100), 
	"DATA_TYPE" NVARCHAR2(200), 
	"BIO_DATA_UNIQUE_ID" NVARCHAR2(200), 
	"RELEASE_STUDY" NVARCHAR2(100)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table TEMP
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."TEMP" 
   (	"BIO_ASSAY_ANALYSIS_ID" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table TJEA_JUNK
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."TJEA_JUNK" 
   (	"ANALYSIS_NAME" VARCHAR2(500 BYTE), 
	"MODEL_DESC" VARCHAR2(4000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table TMP_NUM_DATA_TYPES
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."TMP_NUM_DATA_TYPES" 
   (	"CATEGORY_CD" VARCHAR2(200 BYTE), 
	"DATA_LABEL" VARCHAR2(500 BYTE), 
	"PERIOD" VARCHAR2(100 BYTE), 
	"SAMPLE_TYPE" VARCHAR2(100 BYTE), 
	"VISIT_NAME" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table TMP_SUBJECT_INFO
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."TMP_SUBJECT_INFO" 
   (	"USUBJID" VARCHAR2(100 BYTE), 
	"AGE_IN_YEARS_NUM" NUMBER(3,0), 
	"SEX_CD" VARCHAR2(50 BYTE), 
	"RACE_CD" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table TMP_TRIAL_DATA
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."TMP_TRIAL_DATA" 
   (	"USUBJID" VARCHAR2(50 BYTE), 
	"STUDY_ID" VARCHAR2(25 BYTE), 
	"DATA_TYPE" CHAR(1 BYTE), 
	"VISIT_NAME" VARCHAR2(100 BYTE), 
	"DATA_LABEL" VARCHAR2(500 BYTE), 
	"DATA_VALUE" VARCHAR2(500 BYTE), 
	"UNIT_CD" VARCHAR2(50 BYTE), 
	"CATEGORY_PATH" VARCHAR2(250 BYTE), 
	"SUB_CATEGORY_PATH_1" VARCHAR2(250 BYTE), 
	"SUB_CATEGORY_PATH_2" VARCHAR2(250 BYTE), 
	"PATIENT_NUM" NUMBER(38,0), 
	"SOURCESYSTEM_CD" VARCHAR2(50 BYTE), 
	"BASE_PATH" VARCHAR2(1250 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table TMP_TRIAL_NODES
--------------------------------------------------------

  CREATE TABLE "TM_CZ"."TMP_TRIAL_NODES" 
   (	"LEAF_NODE" VARCHAR2(4000 BYTE), 
	"CATEGORY_CD" VARCHAR2(200 BYTE), 
	"VISIT_NAME" VARCHAR2(100 BYTE), 
	"SAMPLE_TYPE" VARCHAR2(100 BYTE), 
	"PERIOD" VARCHAR2(100 BYTE), 
	"DATA_LABEL" VARCHAR2(500 BYTE), 
	"NODE_NAME" VARCHAR2(500 BYTE), 
	"DATA_VALUE" VARCHAR2(500 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CARDS_ANP_INFO
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."CARDS_ANP_INFO" 
   (	"SNP_ID" NUMBER(10,0), 
	"DBSNP_RSID" NUMBER(10,0), 
	"DBSNP_SSID" NUMBER(10,0), 
	"SNP_INFO_ID" NUMBER(22,0), 
	"NAME" VARCHAR2(255 BYTE), 
	"CHROM" VARCHAR2(16 BYTE), 
	"CHROM_POS" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CARDS_GENOTYPE
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."CARDS_GENOTYPE" 
   (	"SNP_ID" NUMBER(10,0), 
	"GENOTYPE" CLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("GENOTYPE") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table CARDS_MAP
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."CARDS_MAP" 
   (	"CHROM" VARCHAR2(16 BYTE), 
	"NAME" VARCHAR2(255 BYTE), 
	"CHROM_POS" NUMBER, 
	"SNP_ID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table CARDS_SNP
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."CARDS_SNP" 
   (	"SNP_ID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DBSNP_135_TO_PERLEGEN_600K
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."DBSNP_135_TO_PERLEGEN_600K" 
   (	"SUBSNP_ID" NUMBER(10,0), 
	"SNP_ID" NUMBER(10,0), 
	"CHR" VARCHAR2(10 BYTE), 
	"POS" NUMBER(10,0), 
	"P_SNP_ID" NUMBER(10,0), 
	"P_RSID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table DUP_RSID
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."DUP_RSID" 
   (	"SNP_PROBE_ID" NUMBER(22,0), 
	"PROBE_NAME" VARCHAR2(255 BYTE), 
	"SNP_ID" NUMBER(22,0), 
	"SNP_NAME" VARCHAR2(255 BYTE), 
	"VENDOR_NAME" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LT_SRC_CLINICAL_DATA
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LT_SRC_CLINICAL_DATA" 
   (	"STUDY_ID" VARCHAR2(25 BYTE), 
	"SITE_ID" VARCHAR2(50 BYTE), 
	"SUBJECT_ID" VARCHAR2(20 BYTE), 
	"VISIT_NAME" VARCHAR2(100 BYTE), 
	"DATA_LABEL" VARCHAR2(500 BYTE), 
	"DATA_VALUE" VARCHAR2(500 BYTE), 
	"CATEGORY_CD" VARCHAR2(250 BYTE), 
	"CTRL_VOCAB_CODE" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 327680 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
  CACHE ;
--------------------------------------------------------
--  DDL for Table LT_SRC_DEAPP_ANNOT
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LT_SRC_DEAPP_ANNOT" 
   (	"GPL_ID" VARCHAR2(100 BYTE), 
	"PROBE_ID" VARCHAR2(100 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" VARCHAR2(250 BYTE), 
	"ORGANISM" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LT_SRC_MRNA_DATA
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LT_SRC_MRNA_DATA" 
   (	"TRIAL_NAME" VARCHAR2(25 BYTE), 
	"PROBESET" VARCHAR2(100 BYTE), 
	"EXPR_ID" VARCHAR2(100 BYTE), 
	"INTENSITY_VALUE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 243269632 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LT_SRC_MRNA_SUBJ_SAMP_MAP
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LT_SRC_MRNA_SUBJ_SAMP_MAP" 
   (	"TRIAL_NAME" VARCHAR2(100 BYTE), 
	"SITE_ID" VARCHAR2(100 BYTE), 
	"SUBJECT_ID" VARCHAR2(100 BYTE), 
	"SAMPLE_CD" VARCHAR2(100 BYTE), 
	"PLATFORM" VARCHAR2(100 BYTE), 
	"TISSUE_TYPE" VARCHAR2(100 BYTE), 
	"ATTRIBUTE_1" VARCHAR2(256 BYTE), 
	"ATTRIBUTE_2" VARCHAR2(200 BYTE), 
	"CATEGORY_CD" VARCHAR2(200 BYTE), 
	"SOURCE_CD" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LT_SRC_SAMPLE_CATEGORIES
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LT_SRC_SAMPLE_CATEGORIES" 
   (	"TRIAL_CD" VARCHAR2(200 BYTE), 
	"SITE_CD" VARCHAR2(200 BYTE), 
	"SUBJECT_CD" VARCHAR2(200 BYTE), 
	"SAMPLE_CD" VARCHAR2(200 BYTE), 
	"CATEGORY_CD" VARCHAR2(200 BYTE), 
	"CATEGORY_VALUE" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LT_SRC_STUDY_METADATA
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LT_SRC_STUDY_METADATA" 
   (	"STUDY_ID" VARCHAR2(100 BYTE), 
	"TITLE" VARCHAR2(1000 BYTE), 
	"DESCRIPTION" VARCHAR2(2000 BYTE), 
	"DESIGN" VARCHAR2(2000 BYTE), 
	"START_DATE" VARCHAR2(50 BYTE), 
	"COMPLETION_DATE" VARCHAR2(50 BYTE), 
	"PRIMARY_INVESTIGATOR" VARCHAR2(400 BYTE), 
	"CONTACT_FIELD" VARCHAR2(400 BYTE), 
	"STATUS" VARCHAR2(100 BYTE), 
	"OVERALL_DESIGN" VARCHAR2(2000 BYTE), 
	"INSTITUTION" VARCHAR2(100 BYTE), 
	"COUNTRY" VARCHAR2(50 BYTE), 
	"BIOMARKER_TYPE" VARCHAR2(255 BYTE), 
	"TARGET" VARCHAR2(255 BYTE), 
	"ACCESS_TYPE" VARCHAR2(100 BYTE), 
	"STUDY_OWNER" VARCHAR2(510 BYTE), 
	"STUDY_PHASE" VARCHAR2(100 BYTE), 
	"BLINDING_PROCEDURE" VARCHAR2(1000 BYTE), 
	"STUDYTYPE" VARCHAR2(510 BYTE), 
	"DURATION_OF_STUDY_WEEKS" VARCHAR2(200 BYTE), 
	"NUMBER_OF_PATIENTS" VARCHAR2(200 BYTE), 
	"NUMBER_OF_SITES" VARCHAR2(200 BYTE), 
	"ROUTE_OF_ADMINISTRATION" VARCHAR2(510 BYTE), 
	"DOSING_REGIMEN" VARCHAR2(3500 BYTE), 
	"GROUP_ASSIGNMENT" VARCHAR2(510 BYTE), 
	"TYPE_OF_CONTROL" VARCHAR2(510 BYTE), 
	"PRIMARY_END_POINTS" VARCHAR2(2000 BYTE), 
	"SECONDARY_END_POINTS" VARCHAR2(3500 BYTE), 
	"INCLUSION_CRITERIA" VARCHAR2(4000 BYTE), 
	"EXCLUSION_CRITERIA" VARCHAR2(4000 BYTE), 
	"SUBJECTS" VARCHAR2(2000 BYTE), 
	"GENDER_RESTRICTION_MFB" VARCHAR2(510 BYTE), 
	"MIN_AGE" VARCHAR2(100 BYTE), 
	"MAX_AGE" VARCHAR2(100 BYTE), 
	"SECONDARY_IDS" VARCHAR2(510 BYTE), 
	"DEVELOPMENT_PARTNER" VARCHAR2(100 BYTE), 
	"GEO_PLATFORM" VARCHAR2(100 BYTE), 
	"MAIN_FINDINGS" VARCHAR2(2000 BYTE), 
	"SEARCH_AREA" VARCHAR2(100 BYTE), 
	"COMPOUND" VARCHAR2(1000 BYTE), 
	"DISEASE" VARCHAR2(1000 BYTE), 
	"PUBMED_IDS" VARCHAR2(1000 BYTE), 
	"ORGANISM" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LT_SRC_STUDY_METADATA_AD_HOC
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LT_SRC_STUDY_METADATA_AD_HOC" 
   (	"STUDY_ID" VARCHAR2(100 BYTE), 
	"AD_HOC_PROPERTY_KEY" VARCHAR2(500 BYTE), 
	"AD_HOC_PROPERTY_VALUE" VARCHAR2(4000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LZ_SRC_ANALYSIS_METADATA
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LZ_SRC_ANALYSIS_METADATA" 
   (	"STUDY_ID" VARCHAR2(50 BYTE), 
	"DATA_TYPE" VARCHAR2(50 BYTE), 
	"ANALYSIS_NAME" VARCHAR2(500 BYTE), 
	"DESCRIPTION" VARCHAR2(4000 BYTE), 
	"PHENOTYPE_IDS" VARCHAR2(250 BYTE), 
	"POPULATION" VARCHAR2(500 BYTE), 
	"TISSUE" VARCHAR2(500 BYTE), 
	"GENOME_VERSION" VARCHAR2(50 BYTE), 
	"GENOTYPE_PLATFORM_IDS" VARCHAR2(500 BYTE), 
	"EXPRESSION_PLATFORM_IDS" VARCHAR2(500 BYTE), 
	"STATISTICAL_TEST" VARCHAR2(500 BYTE), 
	"RESEARCH_UNIT" VARCHAR2(500 BYTE), 
	"SAMPLE_SIZE" VARCHAR2(500 BYTE), 
	"CELL_TYPE" VARCHAR2(500 BYTE), 
	"PVALUE_CUTOFF" VARCHAR2(50 BYTE), 
	"ETL_DATE" TIMESTAMP (6), 
	"FILENAME" VARCHAR2(500 BYTE), 
	"STATUS" VARCHAR2(50 BYTE), 
	"PROCESS_DATE" TIMESTAMP (6), 
	"ETL_ID" NUMBER(38,0), 
	"ANALYSIS_NAME_ARCHIVED" VARCHAR2(500 BYTE), 
	"MODEL_NAME" VARCHAR2(500 BYTE), 
	"MODEL_DESC" VARCHAR2(4000 BYTE), 
	"SENSITIVE_FLAG" NUMBER(38,0), 
	"SENSITIVE_DESC" VARCHAR2(500 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LZ_SRC_CLINICAL_DATA
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LZ_SRC_CLINICAL_DATA" 
   (	"STUDY_ID" VARCHAR2(25 BYTE), 
	"SITE_ID" VARCHAR2(50 BYTE), 
	"SUBJECT_ID" VARCHAR2(20 BYTE), 
	"VISIT_NAME" VARCHAR2(100 BYTE), 
	"DATA_LABEL" VARCHAR2(500 BYTE), 
	"DATA_VALUE" VARCHAR2(500 BYTE), 
	"CATEGORY_CD" VARCHAR2(250 BYTE), 
	"ETL_JOB_ID" NUMBER(22,0), 
	"ETL_DATE" DATE, 
	"CTRL_VOCAB_CODE" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 83886080 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LZ_SRC_MRNA_DATA
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LZ_SRC_MRNA_DATA" 
   (	"TRIAL_NAME" VARCHAR2(25 BYTE), 
	"PROBESET" VARCHAR2(100 BYTE), 
	"EXPR_ID" VARCHAR2(100 BYTE), 
	"INTENSITY_VALUE" VARCHAR2(50 BYTE), 
	"SOURCE_CD" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LZ_SRC_MRNA_SUBJ_SAMP_MAP
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LZ_SRC_MRNA_SUBJ_SAMP_MAP" 
   (	"TRIAL_NAME" VARCHAR2(100 BYTE), 
	"SITE_ID" VARCHAR2(100 BYTE), 
	"SUBJECT_ID" VARCHAR2(100 BYTE), 
	"SAMPLE_CD" VARCHAR2(100 BYTE), 
	"PLATFORM" VARCHAR2(100 BYTE), 
	"TISSUE_TYPE" VARCHAR2(100 BYTE), 
	"ATTRIBUTE_1" VARCHAR2(256 BYTE), 
	"ATTRIBUTE_2" VARCHAR2(200 BYTE), 
	"CATEGORY_CD" VARCHAR2(200 BYTE), 
	"SOURCE_CD" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LZ_SRC_SAMPLE_CATEGORIES
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LZ_SRC_SAMPLE_CATEGORIES" 
   (	"TRIAL_CD" VARCHAR2(200 BYTE), 
	"SITE_CD" VARCHAR2(200 BYTE), 
	"SUBJECT_CD" VARCHAR2(200 BYTE), 
	"SAMPLE_CD" VARCHAR2(200 BYTE), 
	"CATEGORY_CD" VARCHAR2(200 BYTE), 
	"CATEGORY_VALUE" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LZ_SRC_SAMPLE_CATEGORIES_BKUP
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LZ_SRC_SAMPLE_CATEGORIES_BKUP" 
   (	"TRIAL_CD" VARCHAR2(200 BYTE), 
	"SITE_CD" VARCHAR2(200 BYTE), 
	"SUBJECT_CD" VARCHAR2(200 BYTE), 
	"SAMPLE_CD" VARCHAR2(200 BYTE), 
	"CATEGORY_CD" VARCHAR2(200 BYTE), 
	"CATEGORY_VALUE" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LZ_SRC_STUDY_METADATA
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LZ_SRC_STUDY_METADATA" 
   (	"STUDY_ID" VARCHAR2(100 BYTE), 
	"TITLE" VARCHAR2(1000 BYTE), 
	"DESCRIPTION" VARCHAR2(2000 BYTE), 
	"DESIGN" VARCHAR2(2000 BYTE), 
	"START_DATE" VARCHAR2(50 BYTE), 
	"COMPLETION_DATE" VARCHAR2(50 BYTE), 
	"PRIMARY_INVESTIGATOR" VARCHAR2(400 BYTE), 
	"CONTACT_FIELD" VARCHAR2(400 BYTE), 
	"STATUS" VARCHAR2(100 BYTE), 
	"OVERALL_DESIGN" VARCHAR2(2000 BYTE), 
	"INSTITUTION" VARCHAR2(100 BYTE), 
	"COUNTRY" VARCHAR2(50 BYTE), 
	"BIOMARKER_TYPE" VARCHAR2(255 BYTE), 
	"TARGET" VARCHAR2(255 BYTE), 
	"ACCESS_TYPE" VARCHAR2(100 BYTE), 
	"STUDY_OWNER" VARCHAR2(510 BYTE), 
	"STUDY_PHASE" VARCHAR2(100 BYTE), 
	"BLINDING_PROCEDURE" VARCHAR2(1000 BYTE), 
	"STUDYTYPE" VARCHAR2(510 BYTE), 
	"DURATION_OF_STUDY_WEEKS" VARCHAR2(200 BYTE), 
	"NUMBER_OF_PATIENTS" VARCHAR2(200 BYTE), 
	"NUMBER_OF_SITES" VARCHAR2(200 BYTE), 
	"ROUTE_OF_ADMINISTRATION" VARCHAR2(510 BYTE), 
	"DOSING_REGIMEN" VARCHAR2(3500 BYTE), 
	"GROUP_ASSIGNMENT" VARCHAR2(510 BYTE), 
	"TYPE_OF_CONTROL" VARCHAR2(510 BYTE), 
	"PRIMARY_END_POINTS" VARCHAR2(2000 BYTE), 
	"SECONDARY_END_POINTS" VARCHAR2(3500 BYTE), 
	"INCLUSION_CRITERIA" VARCHAR2(4000 BYTE), 
	"EXCLUSION_CRITERIA" VARCHAR2(4000 BYTE), 
	"SUBJECTS" VARCHAR2(2000 BYTE), 
	"GENDER_RESTRICTION_MFB" VARCHAR2(510 BYTE), 
	"MIN_AGE" VARCHAR2(100 BYTE), 
	"MAX_AGE" VARCHAR2(100 BYTE), 
	"SECONDARY_IDS" VARCHAR2(510 BYTE), 
	"DEVELOPMENT_PARTNER" VARCHAR2(100 BYTE), 
	"GEO_PLATFORM" VARCHAR2(100 BYTE), 
	"MAIN_FINDINGS" VARCHAR2(2000 BYTE), 
	"SEARCH_AREA" VARCHAR2(100 BYTE), 
	"COMPOUND" VARCHAR2(1000 BYTE), 
	"DISEASE" VARCHAR2(1000 BYTE), 
	"PUBMED_IDS" VARCHAR2(1000 BYTE), 
	"ORGANISM" VARCHAR2(200 BYTE), 
	"UPLOAD_DATE" TIMESTAMP (6)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table LZ_SRC_STUDY_METADATA_AD_HOC
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."LZ_SRC_STUDY_METADATA_AD_HOC" 
   (	"STUDY_ID" VARCHAR2(100 BYTE), 
	"AD_HOC_PROPERTY_KEY" VARCHAR2(500 BYTE), 
	"AD_HOC_PROPERTY_VALUE" VARCHAR2(4000 BYTE), 
	"UPLOAD_DATE" TIMESTAMP (6)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table MERGED_SNP
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."MERGED_SNP" 
   (	"OLD_RSID" NUMBER(10,0), 
	"NEW_RSID" NUMBER(10,0), 
	"BUILD" NUMBER(4,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table NEW_DBSNP_INFO
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."NEW_DBSNP_INFO" 
   (	"SNP_ID" NUMBER(10,0), 
	"CHR" VARCHAR2(32 BYTE), 
	"POS" NUMBER(10,0), 
	"ORIEN" NUMBER(10,0), 
	"NEIGHBOR_SNP_LIST" NUMBER(10,0), 
	"ISPAR" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table NOT_IN_VCF
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."NOT_IN_VCF" 
   (	"RSID" VARCHAR2(20 BYTE), 
	"RS" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table PERLEGEN_600K
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."PERLEGEN_600K" 
   (	"SNP_ID" NUMBER(10,0), 
	"DBSNP_RSID" NUMBER(10,0), 
	"DBSNP_SSID" NUMBER(10,0), 
	"ALLELE_1" VARCHAR2(1 BYTE), 
	"ALLELE_2" VARCHAR2(1 BYTE), 
	"CHR" VARCHAR2(4 BYTE), 
	"SEX_LINKED" VARCHAR2(4 BYTE), 
	"ACCESSION_ID" VARCHAR2(20 BYTE), 
	"CONTIG_POSITION" NUMBER(10,0), 
	"ISTRAND" VARCHAR2(1 BYTE), 
	"ASSAYED_SEQUENCE" VARCHAR2(100 BYTE), 
	"NEARBY_GENES" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table PFIZER_SNP
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."PFIZER_SNP" 
   (	"SNP_ID" NUMBER(10,0), 
	"DBSNP_RSID" NUMBER(10,0), 
	"DBSNP_SSID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table PFIZER_SNP1
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."PFIZER_SNP1" 
   (	"SNP_ID" NUMBER(10,0), 
	"DBSNP_RSID" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table RENAMED_SNP
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."RENAMED_SNP" 
   (	"DBSNP_RSID" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table RENAMED_SNP1
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."RENAMED_SNP1" 
   (	"RSID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table RENAMED_SNP_INFO
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."RENAMED_SNP_INFO" 
   (	"OLD_RSID" NUMBER(10,0), 
	"NEW_RSID" NUMBER(10,0), 
	"CHR" VARCHAR2(32 BYTE), 
	"POS" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table RSMERGEARCH_135
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."RSMERGEARCH_135" 
   (	"OLD_RSID" NUMBER(10,0), 
	"NEW_RSID" NUMBER(10,0), 
	"BUILD" NUMBER(4,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table SNP1
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."SNP1" 
   (	"RSID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table SNP2
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."SNP2" 
   (	"RSID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table SNPCHRPOSONREF_135
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."SNPCHRPOSONREF_135" 
   (	"SNP_ID" NUMBER(10,0), 
	"CHR" VARCHAR2(32 BYTE), 
	"POS" NUMBER(10,0), 
	"ORIEN" NUMBER(10,0), 
	"NEIGHBOR_SNP_LIST" NUMBER(10,0), 
	"ISPAR" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table SNPSUBSNPLINK_135
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."SNPSUBSNPLINK_135" 
   (	"SUBSNP_ID" NUMBER(10,0), 
	"SNP_ID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table T
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."T" 
   (	"P_SNP_ID" NUMBER(10,0), 
	"SNP_INFO_ID" NUMBER(22,0), 
	"NAME" VARCHAR2(255 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table T1
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."T1" 
   (	"SNP_ID" NUMBER(10,0), 
	"GENOTYPE" CLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
 LOB ("GENOTYPE") STORE AS BASICFILE (
  TABLESPACE "TRANSMART" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;
--------------------------------------------------------
--  DDL for Table VCF18
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."VCF18" 
   (	"CHROM" VARCHAR2(2 BYTE), 
	"POS" NUMBER(10,0), 
	"RS_ID" VARCHAR2(200 BYTE), 
	"REF" VARCHAR2(4000 BYTE), 
	"ALT" VARCHAR2(4000 BYTE), 
	"VARIATION_CLASS" VARCHAR2(10 BYTE), 
	"AF" VARCHAR2(1000 BYTE), 
	"GMAF" VARCHAR2(1000 BYTE), 
	"GENE_INFO" VARCHAR2(1000 BYTE)
   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
  PARTITION BY LIST ("CHROM") 
 (PARTITION "PART_CHR1"  VALUES ('1') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR2"  VALUES ('2') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR3"  VALUES ('3') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR4"  VALUES ('4') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR5"  VALUES ('5') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR6"  VALUES ('6') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR7"  VALUES ('7') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR8"  VALUES ('8') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR9"  VALUES ('9') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR10"  VALUES ('10') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR11"  VALUES ('11') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR12"  VALUES ('12') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR13"  VALUES ('13') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR14"  VALUES ('14') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR15"  VALUES ('15') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR16"  VALUES ('16') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR17"  VALUES ('17') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR18"  VALUES ('18') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR19"  VALUES ('19') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR20"  VALUES ('20') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR21"  VALUES ('21') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR22"  VALUES ('22') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHRX"  VALUES ('X') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHRY"  VALUES ('Y') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHRM"  VALUES ('M') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_OTHER"  VALUES (default) 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS ) ;
--------------------------------------------------------
--  DDL for Table VCF18_GENE
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."VCF18_GENE" 
   (	"CHR" VARCHAR2(10 BYTE), 
	"POS" NUMBER(10,0), 
	"RS_ID" VARCHAR2(200 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table VCF19
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."VCF19" 
   (	"CHROM" VARCHAR2(2 BYTE), 
	"POS" NUMBER(10,0), 
	"RS_ID" VARCHAR2(200 BYTE), 
	"REF" VARCHAR2(4000 BYTE), 
	"ALT" VARCHAR2(4000 BYTE), 
	"VARIATION_CLASS" VARCHAR2(10 BYTE), 
	"AF" VARCHAR2(1000 BYTE), 
	"GMAF" VARCHAR2(1000 BYTE), 
	"GENE_INFO" VARCHAR2(1000 BYTE)
   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" 
  PARTITION BY LIST ("CHROM") 
 (PARTITION "PART_CHR1"  VALUES ('1') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR2"  VALUES ('2') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR3"  VALUES ('3') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR4"  VALUES ('4') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR5"  VALUES ('5') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR6"  VALUES ('6') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR7"  VALUES ('7') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR8"  VALUES ('8') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR9"  VALUES ('9') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR10"  VALUES ('10') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR11"  VALUES ('11') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR12"  VALUES ('12') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR13"  VALUES ('13') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR14"  VALUES ('14') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR15"  VALUES ('15') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR16"  VALUES ('16') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR17"  VALUES ('17') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR18"  VALUES ('18') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR19"  VALUES ('19') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR20"  VALUES ('20') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR21"  VALUES ('21') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHR22"  VALUES ('22') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHRX"  VALUES ('X') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHRY"  VALUES ('Y') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_CHRM"  VALUES ('M') 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS , 
 PARTITION "PART_OTHER"  VALUES (default) 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" NOCOMPRESS ) ;
--------------------------------------------------------
--  DDL for Table VCF19_GENE
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."VCF19_GENE" 
   (	"CHR" VARCHAR2(10 BYTE), 
	"POS" NUMBER(10,0), 
	"RS_ID" VARCHAR2(200 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table WT_SNP_NODES
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."WT_SNP_NODES" 
   (	"LEAF_NODE" VARCHAR2(2000 BYTE), 
	"CATEGORY_CD" VARCHAR2(500 BYTE), 
	"PLATFORM" VARCHAR2(500 BYTE), 
	"SAMPLE_TYPE" VARCHAR2(200 BYTE), 
	"TIMEPOINT" VARCHAR2(200 BYTE), 
	"NODE_TYPE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table WT_SNP_NODE_VALUES
--------------------------------------------------------

  CREATE TABLE "TM_LZ"."WT_SNP_NODE_VALUES" 
   (	"CATEGORY_CD" VARCHAR2(500 BYTE), 
	"SAMPLE_TYPE" VARCHAR2(200 BYTE), 
	"TIMEPOINT" VARCHAR2(200 BYTE), 
	"TITLE" VARCHAR2(500 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Table BIO_ASSAY_ANALYSIS_EQTL
--------------------------------------------------------

  CREATE TABLE "BIOMART_STAGE"."BIO_ASSAY_ANALYSIS_EQTL" 
   (	"BIO_ASY_ANALYSIS_EQTL_ID" NUMBER(22,0), 
	"BIO_ASSAY_ANALYSIS_ID" NUMBER(22,0), 
	"RS_ID" NVARCHAR2(50), 
	"GENE" VARCHAR2(50 BYTE), 
	"P_VALUE_CHAR" VARCHAR2(100 BYTE), 
	"CIS_TRANS" VARCHAR2(10 BYTE), 
	"DISTANCE_FROM_GENE" VARCHAR2(10 BYTE), 
	"ETL_ID" NUMBER(18,0), 
	"EXT_DATA" VARCHAR2(4000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table BIO_ASSAY_ANALYSIS_GWAS
--------------------------------------------------------

  CREATE TABLE "BIOMART_STAGE"."BIO_ASSAY_ANALYSIS_GWAS" 
   (	"BIO_ASY_ANALYSIS_GWAS_ID" NUMBER(18,0), 
	"BIO_ASSAY_ANALYSIS_ID" NUMBER(18,0), 
	"RS_ID" NVARCHAR2(50), 
	"P_VALUE_CHAR" VARCHAR2(100 BYTE), 
	"ETL_ID" NUMBER(18,0), 
	"EXT_DATA" VARCHAR2(4000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Table BIO_MARKER_EXP_ANALYSIS_MV
--------------------------------------------------------

  CREATE TABLE "BIOMART_USER"."BIO_MARKER_EXP_ANALYSIS_MV" 
   (	"BIO_MARKER_ID" NUMBER(18,0), 
	"BIO_EXPERIMENT_ID" NUMBER(18,0), 
	"BIO_ASSAY_ANALYSIS_ID" NUMBER(18,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index FM_DATA_UID_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FMAPP"."FM_DATA_UID_PK" ON "FMAPP"."FM_DATA_UID" ("FM_DATA_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 589824 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index FM_DATA_UID_UK
--------------------------------------------------------

  CREATE UNIQUE INDEX "FMAPP"."FM_DATA_UID_UK" ON "FMAPP"."FM_DATA_UID" ("UNIQUE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index PK_FOLDER_FILE_ASSOC
--------------------------------------------------------

  CREATE UNIQUE INDEX "FMAPP"."PK_FOLDER_FILE_ASSOC" ON "FMAPP"."FM_FOLDER_FILE_ASSOCIATION" ("FOLDER_ID", "FILE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C0011773
--------------------------------------------------------

  CREATE UNIQUE INDEX "FMAPP"."SYS_C0011773" ON "FMAPP"."FM_FOLDER" ("FOLDER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C0013129
--------------------------------------------------------

  CREATE UNIQUE INDEX "FMAPP"."SYS_C0013129" ON "FMAPP"."FM_FILE" ("FILE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PLUGIN_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."PLUGIN_PK" ON "SEARCHAPP"."PLUGIN" ("PLUGIN_SEQ") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index PLUGIN_MODULE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."PLUGIN_MODULE_PK" ON "SEARCHAPP"."PLUGIN_MODULE" ("MODULE_SEQ") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index PK_AUTH_USR_GROUP
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."PK_AUTH_USR_GROUP" ON "SEARCHAPP"."SEARCH_AUTH_GROUP" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index PK_SEARCH_PRINCIPAL
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."PK_SEARCH_PRINCIPAL" ON "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SCH_SEC_A_A_S_A_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SCH_SEC_A_A_S_A_PK" ON "SEARCHAPP"."SEARCH_AUTH_SEC_OBJECT_ACCESS" ("AUTH_SEC_OBJ_ACCESS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SYS_C0021173
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SYS_C0021173" ON "SEARCHAPP"."SEARCH_AUTH_USER" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_SEC_A_U_S_A_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_SEC_A_U_S_A_PK" ON "SEARCHAPP"."SEARCH_AUTH_USER_SEC_ACCESS" ("SEARCH_AUTH_USER_SEC_ACCESS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_CUSTOM_FILTER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_CUSTOM_FILTER_PK" ON "SEARCHAPP"."SEARCH_CUSTOM_FILTER" ("SEARCH_CUSTOM_FILTER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_CUST_FIL_ITEM_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_CUST_FIL_ITEM_PK" ON "SEARCHAPP"."SEARCH_CUSTOM_FILTER_ITEM" ("SEARCH_CUSTOM_FILTER_ITEM_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_GENE_SIG_DESCR_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_GENE_SIG_DESCR_PK" ON "SEARCHAPP"."SEARCH_GENE_SIGNATURE" ("SEARCH_GENE_SIGNATURE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_GENE_SIGNATURE_ITE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITE_PK" ON "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_GENE_SIG_FILE_SCHE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHE_PK" ON "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA" ("SEARCH_GENE_SIG_FILE_SCHEMA_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_KEYWORD_UK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_KEYWORD_UK" ON "SEARCHAPP"."SEARCH_KEYWORD" ("UNIQUE_ID", "DATA_CATEGORY") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index IDX_SK_KEYWORD
--------------------------------------------------------

  CREATE INDEX "SEARCHAPP"."IDX_SK_KEYWORD" ON "SEARCHAPP"."SEARCH_KEYWORD" ("KEYWORD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_SK_DATA_ID
--------------------------------------------------------

  CREATE INDEX "SEARCHAPP"."IDX_SK_DATA_ID" ON "SEARCHAPP"."SEARCH_KEYWORD" ("BIO_DATA_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS COMPRESS 1 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index SEARCH_KW_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_KW_PK" ON "SEARCHAPP"."SEARCH_KEYWORD" ("SEARCH_KEYWORD_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 917504 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SCH_KWD_DT_CAT_IDX
--------------------------------------------------------

  CREATE INDEX "SEARCHAPP"."SCH_KWD_DT_CAT_IDX" ON "SEARCHAPP"."SEARCH_KEYWORD" ("DATA_CATEGORY") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index IDX_SK_DISPLAY_CATEGORY1
--------------------------------------------------------

  CREATE BITMAP INDEX "SEARCHAPP"."IDX_SK_DISPLAY_CATEGORY1" ON "SEARCHAPP"."SEARCH_KEYWORD" ("DATA_CATEGORY", "DISPLAY_DATA_CATEGORY") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index SEARCH_KW_TERM_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_KW_TERM_PK" ON "SEARCHAPP"."SEARCH_KEYWORD_TERM" ("SEARCH_KEYWORD_TERM_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index IDX_SKT_TERM
--------------------------------------------------------

  CREATE INDEX "SEARCHAPP"."IDX_SKT_TERM" ON "SEARCHAPP"."SEARCH_KEYWORD_TERM" ("KEYWORD_TERM") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_SKT_KEYWORD_ID
--------------------------------------------------------

  CREATE INDEX "SEARCHAPP"."IDX_SKT_KEYWORD_ID" ON "SEARCHAPP"."SEARCH_KEYWORD_TERM" ("SEARCH_KEYWORD_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index SYS_C0021181
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SYS_C0021181" ON "SEARCHAPP"."SEARCH_ROLE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_SEC_OBJ_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_SEC_OBJ_PK" ON "SEARCHAPP"."SEARCH_SECURE_OBJECT" ("SEARCH_SECURE_OBJECT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_SEC_OBJ__PATH_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_SEC_OBJ__PATH_PK" ON "SEARCHAPP"."SEARCH_SECURE_OBJECT_PATH" ("SEARCH_SECURE_OBJ_PATH_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_SEC_AC_LEVEL_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_SEC_AC_LEVEL_PK" ON "SEARCHAPP"."SEARCH_SEC_ACCESS_LEVEL" ("SEARCH_SEC_ACCESS_LEVEL_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SEARCH_TAXONOMY_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SEARCH_TAXONOMY_PK" ON "SEARCHAPP"."SEARCH_TAXONOMY" ("TERM_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SYS_C0056419
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SYS_C0056419" ON "SEARCHAPP"."SEARCH_TAXONOMY_RELS" ("SEARCH_TAXONOMY_RELS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index U_CHILD_ID_PARENT_ID
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."U_CHILD_ID_PARENT_ID" ON "SEARCHAPP"."SEARCH_TAXONOMY_RELS" ("CHILD_ID", "PARENT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index RDT_SEARCH_USER_FDBK_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."RDT_SEARCH_USER_FDBK_PK" ON "SEARCHAPP"."SEARCH_USER_FEEDBACK" ("SEARCH_USER_FEEDBACK_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SUBSET_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "SEARCHAPP"."SUBSET_PK" ON "SEARCHAPP"."SUBSET" ("SUBSET_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" ;
--------------------------------------------------------
--  DDL for Index SYS_C0029255
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0029255" ON "DEAPP"."DE_GENE_INFO" ("GENE_SOURCE_ID", "GENE_SYMBOL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index SYS_C0029257
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0029257" ON "DEAPP"."DE_GENE_INFO" ("GENE_INFO_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index SYS_C0029254
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0029254" ON "DEAPP"."DE_GENE_SOURCE" ("GENE_SOURCE_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index SYS_C0029256
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0029256" ON "DEAPP"."DE_GENE_SOURCE" ("GENE_SOURCE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index DE_MRNA_ANNOTATION_INDEX1
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_MRNA_ANNOTATION_INDEX1" ON "DEAPP"."DE_MRNA_ANNOTATION" ("PROBESET_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index DE_PATHWAY_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."DE_PATHWAY_PK" ON "DEAPP"."DE_PATHWAY" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index DE_PATHWAY_GENE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."DE_PATHWAY_GENE_PK" ON "DEAPP"."DE_PATHWAY_GENE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index DE_RSNP_CHROMPOS_IDX
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_RSNP_CHROMPOS_IDX" ON "DEAPP"."DE_RC_SNP_INFO" ("CHROM", "POS") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) LOCAL
 (PARTITION "HG18" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HG19" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HGXX" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ) 
  PARALLEL 4 ;
--------------------------------------------------------
--  DDL for Index DE_RSNP_CHROM_IDX
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_RSNP_CHROM_IDX" ON "DEAPP"."DE_RC_SNP_INFO" ("CHROM") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) LOCAL
 (PARTITION "HG18" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HG19" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HGXX" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ) 
  PARALLEL 4 ;
--------------------------------------------------------
--  DDL for Index DE_R_S_I_IDX4
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_R_S_I_IDX4" ON "DEAPP"."DE_RC_SNP_INFO" ("SNP_INFO_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  LOCAL
 (PARTITION "HG18" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "HG19" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "HGXX" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ) 
  PARALLEL 8 ;
--------------------------------------------------------
--  DDL for Index IDX_VCF_POS
--------------------------------------------------------

  CREATE INDEX "DEAPP"."IDX_VCF_POS" ON "DEAPP"."DE_RC_SNP_INFO" ("POS") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) LOCAL
 (PARTITION "HG18" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HG19" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HGXX" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ) 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_VCF_RSID
--------------------------------------------------------

  CREATE INDEX "DEAPP"."IDX_VCF_RSID" ON "DEAPP"."DE_RC_SNP_INFO" ("RS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  LOCAL
 (PARTITION "HG18" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "HG19" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "HGXX" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ) 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_DE_RC_SNP_INFO_RSID
--------------------------------------------------------

  CREATE INDEX "DEAPP"."IDX_DE_RC_SNP_INFO_RSID" ON "DEAPP"."DE_RC_SNP_INFO_ALL" ("RS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_RC_SNP_INFO_POS
--------------------------------------------------------

  CREATE INDEX "DEAPP"."IDX_RC_SNP_INFO_POS" ON "DEAPP"."DE_RC_SNP_INFO_ALL" ("POS") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  LOCAL
 (PARTITION "HG18" 
PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
 ( SUBPARTITION "HG18_CHR1" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR2" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR3" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR4" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR5" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR6" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR7" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR8" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR9" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR10" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR11" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR12" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR13" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR14" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR15" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR16" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR17" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR18" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR19" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR20" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR21" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHR22" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHRX" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHRY" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHRM" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG18_CHRO" 
   TABLESPACE "INDX" ) , 
 PARTITION "HG19" 
PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
 ( SUBPARTITION "HG19_CHR1" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR2" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR3" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR4" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR5" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR6" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR7" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR8" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR9" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR10" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR11" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR12" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR13" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR14" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR15" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR16" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR17" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR18" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR19" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR20" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR21" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHR22" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHRX" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHRY" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHRM" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HG19_CHRO" 
   TABLESPACE "INDX" ) , 
 PARTITION "HGXX" 
PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
 ( SUBPARTITION "HGXX_CHR1" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR2" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR3" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR4" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR5" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR6" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR7" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR8" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR9" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR10" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR11" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR12" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR13" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR14" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR15" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR16" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR17" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR18" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR19" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR20" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR21" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHR22" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHRX" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHRY" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHRM" 
   TABLESPACE "INDX" , 
  SUBPARTITION "HGXX_CHRO" 
   TABLESPACE "INDX" ) ) ;
--------------------------------------------------------
--  DDL for Index DE_RSNP_CHROMPOS_IDX_O
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_RSNP_CHROMPOS_IDX_O" ON "DEAPP"."DE_RC_SNP_INFO_OLD" ("CHROM", "POS") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) LOCAL
 (PARTITION "HG18" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HG19" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HGXX" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ) ;
--------------------------------------------------------
--  DDL for Index DE_RSNP_CHROM_IDX_O
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_RSNP_CHROM_IDX_O" ON "DEAPP"."DE_RC_SNP_INFO_OLD" ("CHROM") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) LOCAL
 (PARTITION "HG18" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HG19" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HGXX" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ) ;
--------------------------------------------------------
--  DDL for Index IDX_VCF_RSID_O
--------------------------------------------------------

  CREATE INDEX "DEAPP"."IDX_VCF_RSID_O" ON "DEAPP"."DE_RC_SNP_INFO_OLD" ("RS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  LOCAL
 (PARTITION "HG18" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "HG19" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "HGXX" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ) 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_VCF_SNPID_O
--------------------------------------------------------

  CREATE INDEX "DEAPP"."IDX_VCF_SNPID_O" ON "DEAPP"."DE_RC_SNP_INFO_OLD" ("SNP_INFO_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  LOCAL
 (PARTITION "HG18" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "HG19" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "HGXX" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ) 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_VCF_POS_O
--------------------------------------------------------

  CREATE INDEX "DEAPP"."IDX_VCF_POS_O" ON "DEAPP"."DE_RC_SNP_INFO_OLD" ("POS") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) LOCAL
 (PARTITION "HG18" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HG19" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" , 
 PARTITION "HGXX" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ) 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_SNP_CALLS_1
--------------------------------------------------------

  CREATE BITMAP INDEX "DEAPP"."IDX_SNP_CALLS_1" ON "DEAPP"."DE_SNP_CALLS_BY_GSM" ("PATIENT_NUM", "GSM_NUM") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_SNP_CALLS_2
--------------------------------------------------------

  CREATE INDEX "DEAPP"."IDX_SNP_CALLS_2" ON "DEAPP"."DE_SNP_CALLS_BY_GSM" ("PATIENT_NUM", "SNP_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index SYS_C0021222
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0021222" ON "DEAPP"."DE_SNP_DATA_BY_PATIENT" ("SNP_DATA_BY_PATIENT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index SYS_C0021223
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0021223" ON "DEAPP"."DE_SNP_DATA_BY_PROBE" ("SNP_DATA_BY_PROBE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index SYS_C0021110
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0021110" ON "DEAPP"."DE_SNP_DATA_DATASET_LOC" ("SNP_DATA_DATASET_LOC_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index ENTREZ_IDX1
--------------------------------------------------------

  CREATE INDEX "DEAPP"."ENTREZ_IDX1" ON "DEAPP"."DE_SNP_GENE_MAP" ("ENTREZ_GENE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index SNP_NAME_IDX1
--------------------------------------------------------

  CREATE INDEX "DEAPP"."SNP_NAME_IDX1" ON "DEAPP"."DE_SNP_GENE_MAP" ("SNP_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index DE_SNP_GM_SNP_G_IDX
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_SNP_GM_SNP_G_IDX" ON "DEAPP"."DE_SNP_GENE_MAP" ("SNP_NAME", "GENE_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index DE_GENE_NAME_IDX
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_GENE_NAME_IDX" ON "DEAPP"."DE_SNP_GENE_MAP" ("GENE_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index U_SNP_INFO_NAME
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."U_SNP_INFO_NAME" ON "DEAPP"."DE_SNP_INFO" ("NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 100663296 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index SYS_C0021112
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0021112" ON "DEAPP"."DE_SNP_INFO" ("SNP_INFO_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 22020096 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index DE_SNP_INFO_HG19_MV_INDEX1O
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_SNP_INFO_HG19_MV_INDEX1O" ON "DEAPP"."DE_SNP_INFO_HG19_MV_0" ("RS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL 8 ;
--------------------------------------------------------
--  DDL for Index SNP_HG19_MV_IDX2O
--------------------------------------------------------

  CREATE INDEX "DEAPP"."SNP_HG19_MV_IDX2O" ON "DEAPP"."DE_SNP_INFO_HG19_MV_0" ("CHROM", "POS") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL 10 ;
--------------------------------------------------------
--  DDL for Index SNP_HG19_MV_IDX2
--------------------------------------------------------

  CREATE INDEX "DEAPP"."SNP_HG19_MV_IDX2" ON "DEAPP"."DE_SNP_INFO_HG19_MV_T" ("CHROM", "POS") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL 10 ;
--------------------------------------------------------
--  DDL for Index DE_SNP_INFO_HG19_MV_INDEX1
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_SNP_INFO_HG19_MV_INDEX1" ON "DEAPP"."DE_SNP_INFO_HG19_MV_T" ("RS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL 8 ;
--------------------------------------------------------
--  DDL for Index U_SNP_PROBE_NAME
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."U_SNP_PROBE_NAME" ON "DEAPP"."DE_SNP_PROBE" ("PROBE_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 83886080 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index SYS_C0021114
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0021114" ON "DEAPP"."DE_SNP_PROBE" ("SNP_PROBE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 22020096 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index SYS_C0021224
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0021224" ON "DEAPP"."DE_SNP_PROBE_SORTED_DEF" ("SNP_PROBE_SORTED_DEF_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index SYS_C0021115
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0021115" ON "DEAPP"."DE_SNP_SUBJECT_SORTED_DEF" ("SNP_SUBJECT_SORTED_DEF_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index DE_MICROARRAY_DATA_IDX1
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_MICROARRAY_DATA_IDX1" ON "DEAPP"."DE_SUBJECT_MICROARRAY_DATA" ("TRIAL_NAME", "ASSAY_ID", "PROBESET_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  LOCAL
 (PARTITION "A:A" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "GSE4382:STD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "A90000001:STD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "A90000001:MIRNA" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "B0151006:PFIZER" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "BOLD:STDD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "BOLD:STDC" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ) COMPRESS 3 ;
--------------------------------------------------------
--  DDL for Index DE_MICROARRAY_DATA_IDX2
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_MICROARRAY_DATA_IDX2" ON "DEAPP"."DE_SUBJECT_MICROARRAY_DATA" ("ASSAY_ID", "PROBESET_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  LOCAL
 (PARTITION "A:A" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "GSE4382:STD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "A90000001:STD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "A90000001:MIRNA" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "B0151006:PFIZER" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "BOLD:STDD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "BOLD:STDC" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ) COMPRESS 2 ;
--------------------------------------------------------
--  DDL for Index DE_MICROARRAY_DATA_IDX3
--------------------------------------------------------

  CREATE BITMAP INDEX "DEAPP"."DE_MICROARRAY_DATA_IDX3" ON "DEAPP"."DE_SUBJECT_MICROARRAY_DATA" ("ASSAY_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  LOCAL
 (PARTITION "A:A" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "GSE4382:STD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "A90000001:STD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "A90000001:MIRNA" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "B0151006:PFIZER" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "BOLD:STDD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "BOLD:STDC" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ) ;
--------------------------------------------------------
--  DDL for Index DE_MICROARRAY_DATA_IDX4
--------------------------------------------------------

  CREATE BITMAP INDEX "DEAPP"."DE_MICROARRAY_DATA_IDX4" ON "DEAPP"."DE_SUBJECT_MICROARRAY_DATA" ("PROBESET_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  LOCAL
 (PARTITION "A:A" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "GSE4382:STD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "A90000001:STD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "A90000001:MIRNA" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "B0151006:PFIZER" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "BOLD:STDD" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" , 
 PARTITION "BOLD:STDC" 
  PCTFREE 10 INITRANS 2 MAXTRANS 255  NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ) ;
--------------------------------------------------------
--  DDL for Index DE_SUBJECT_SMPL_MPNG_IDX2
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_SUBJECT_SMPL_MPNG_IDX2" ON "DEAPP"."DE_SUBJECT_SAMPLE_MAPPING" ("PATIENT_ID", "TIMEPOINT_CD", "PLATFORM_CD", "ASSAY_ID", "TRIAL_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index DE_SUBJECT_SMPL_MPNG_IDX1
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_SUBJECT_SMPL_MPNG_IDX1" ON "DEAPP"."DE_SUBJECT_SAMPLE_MAPPING" ("TIMEPOINT", "PATIENT_ID", "TRIAL_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index DE_SUBJECT_SMPL_MPNG_IDX3
--------------------------------------------------------

  CREATE INDEX "DEAPP"."DE_SUBJECT_SMPL_MPNG_IDX3" ON "DEAPP"."DE_SUBJECT_SAMPLE_MAPPING" ("ASSAY_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index SYS_C0021116
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0021116" ON "DEAPP"."DE_SUBJECT_SNP_DATASET" ("SUBJECT_SNP_DATASET_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index SYS_C0021117
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0021117" ON "DEAPP"."DE_XTRIAL_CHILD_MAP" ("CONCEPT_CD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index DEXTPN_PARENT_NODE_U
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."DEXTPN_PARENT_NODE_U" ON "DEAPP"."DE_XTRIAL_PARENT_NAMES" ("ACROSS_PATH") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index SYS_C0021119
--------------------------------------------------------

  CREATE UNIQUE INDEX "DEAPP"."SYS_C0021119" ON "DEAPP"."DE_XTRIAL_PARENT_NAMES" ("PARENT_CD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index T_S_I_RS_IDX
--------------------------------------------------------

  CREATE INDEX "DEAPP"."T_S_I_RS_IDX" ON "DEAPP"."TEST_SNP_INFO" ("RS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP" ;
--------------------------------------------------------
--  DDL for Index CZ_FORM_LAYOUT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "TM_CZ"."CZ_FORM_LAYOUT_PK" ON "TM_CZ"."CZ_FORM_LAYOUT" ("FORM_LAYOUT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index CZ_JOB_AUDIT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "TM_CZ"."CZ_JOB_AUDIT_PK" ON "TM_CZ"."CZ_JOB_AUDIT" ("SEQ_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IX_CZ_JOB_AUDIT_DATE
--------------------------------------------------------

  CREATE INDEX "TM_CZ"."IX_CZ_JOB_AUDIT_DATE" ON "TM_CZ"."CZ_JOB_AUDIT" ("JOB_DATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index CZ_JOB_MASTER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "TM_CZ"."CZ_JOB_MASTER_PK" ON "TM_CZ"."CZ_JOB_MASTER" ("JOB_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index CZ_PERSON_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "TM_CZ"."CZ_PERSON_PK" ON "TM_CZ"."CZ_PERSON" ("PERSON_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index CZ_REQUIRED_UPLOAD_FIELD_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "TM_CZ"."CZ_REQUIRED_UPLOAD_FIELD_PK" ON "TM_CZ"."CZ_REQUIRED_UPLOAD_FIELD" ("REQUIRED_UPLOAD_FIELD_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index CZ_TEST_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "TM_CZ"."CZ_TEST_PK" ON "TM_CZ"."CZ_TEST" ("TEST_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index CZ_TEST_CATEGORY_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "TM_CZ"."CZ_TEST_CATEGORY_PK" ON "TM_CZ"."CZ_TEST_CATEGORY" ("TEST_CATEGORY_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index NODE_CURATION_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "TM_CZ"."NODE_CURATION_PK" ON "TM_CZ"."NODE_CURATION" ("NODE_TYPE", "NODE_NAME", "STUDY_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index PROBESET_DEAPP_I1
--------------------------------------------------------

  CREATE INDEX "TM_CZ"."PROBESET_DEAPP_I1" ON "TM_CZ"."PROBESET_DEAPP" ("PROBESET_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 4194304 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index PROBESET_DEAPP_I2
--------------------------------------------------------

  CREATE INDEX "TM_CZ"."PROBESET_DEAPP_I2" ON "TM_CZ"."PROBESET_DEAPP" ("PROBESET", "PLATFORM") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 10485760 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index TEMP_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "TM_CZ"."TEMP_PK" ON "TM_CZ"."TEMP" ("BIO_ASSAY_ANALYSIS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_CARDS_GENOTYPE
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_CARDS_GENOTYPE" ON "TM_LZ"."CARDS_GENOTYPE" ("SNP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index DBSNP_135_TO_PERLEGEN_600K_1
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."DBSNP_135_TO_PERLEGEN_600K_1" ON "TM_LZ"."DBSNP_135_TO_PERLEGEN_600K" ("SUBSNP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index DBSNP_135_TO_PERLEGEN_600K_2
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."DBSNP_135_TO_PERLEGEN_600K_2" ON "TM_LZ"."DBSNP_135_TO_PERLEGEN_600K" ("SNP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index DBSNP_135_TO_PERLEGEN_600K_3
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."DBSNP_135_TO_PERLEGEN_600K_3" ON "TM_LZ"."DBSNP_135_TO_PERLEGEN_600K" ("P_SNP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index DBSNP_135_TO_PERLEGEN_600K_4
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."DBSNP_135_TO_PERLEGEN_600K_4" ON "TM_LZ"."DBSNP_135_TO_PERLEGEN_600K" ("P_RSID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index LZ_SRC_MRNA_SUBJ_SAMP_IDX1
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."LZ_SRC_MRNA_SUBJ_SAMP_IDX1" ON "TM_LZ"."LZ_SRC_MRNA_SUBJ_SAMP_MAP" ("TRIAL_NAME", "SOURCE_CD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" ;
--------------------------------------------------------
--  DDL for Index IDX_MERGED_SNP1
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_MERGED_SNP1" ON "TM_LZ"."MERGED_SNP" ("OLD_RSID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_MERGED_SNP2
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_MERGED_SNP2" ON "TM_LZ"."MERGED_SNP" ("NEW_RSID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_CPERLEGEN_600K_1
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_CPERLEGEN_600K_1" ON "TM_LZ"."PERLEGEN_600K" ("SNP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_CPERLEGEN_600K_2
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_CPERLEGEN_600K_2" ON "TM_LZ"."PERLEGEN_600K" ("DBSNP_RSID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_PFIZER_SNP1_RSID
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_PFIZER_SNP1_RSID" ON "TM_LZ"."PFIZER_SNP1" ("DBSNP_RSID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_PFIZER_SNP1_SNP
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_PFIZER_SNP1_SNP" ON "TM_LZ"."PFIZER_SNP1" ("SNP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_RSMERGEARCH_135_1
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_RSMERGEARCH_135_1" ON "TM_LZ"."RSMERGEARCH_135" ("OLD_RSID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_RSMERGEARCH_135_2
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_RSMERGEARCH_135_2" ON "TM_LZ"."RSMERGEARCH_135" ("NEW_RSID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_SNPCHRPOSONREF_135
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_SNPCHRPOSONREF_135" ON "TM_LZ"."SNPCHRPOSONREF_135" ("SNP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_SNPSUBSNPLINK_135_1
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_SNPSUBSNPLINK_135_1" ON "TM_LZ"."SNPSUBSNPLINK_135" ("SUBSNP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_SNPSUBSNPLINK_135_2
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_SNPSUBSNPLINK_135_2" ON "TM_LZ"."SNPSUBSNPLINK_135" ("SNP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART" ;
--------------------------------------------------------
--  DDL for Index IDX_VCF18
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_VCF18" ON "TM_LZ"."VCF18" ("RS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_VCF18_GENE
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_VCF18_GENE" ON "TM_LZ"."VCF18_GENE" ("RS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_VCF19
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_VCF19" ON "TM_LZ"."VCF19" ("RS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_VCF19_GENE
--------------------------------------------------------

  CREATE INDEX "TM_LZ"."IDX_VCF19_GENE" ON "TM_LZ"."VCF19_GENE" ("RS_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX" 
  PARALLEL ;
--------------------------------------------------------
--  DDL for Index IDX_BIO_MARKER_EXP_ANALYSIS_MV
--------------------------------------------------------

  CREATE INDEX "BIOMART_USER"."IDX_BIO_MARKER_EXP_ANALYSIS_MV" ON "BIOMART_USER"."BIO_MARKER_EXP_ANALYSIS_MV" ("BIO_MARKER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART" 
  PARALLEL ;
--------------------------------------------------------
--  Constraints for Table PLUGIN
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."PLUGIN" ADD CONSTRAINT "PLUGIN_PK" PRIMARY KEY ("PLUGIN_SEQ")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."PLUGIN" MODIFY ("PLUGIN_SEQ" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN" MODIFY ("NAME" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN" MODIFY ("PLUGIN_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN" MODIFY ("HAS_MODULES" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN" MODIFY ("HAS_FORM" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN" MODIFY ("DEFAULT_LINK" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table PLUGIN_MODULE
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."PLUGIN_MODULE" ADD CONSTRAINT "PLUGIN_MODULE_PK" PRIMARY KEY ("MODULE_SEQ")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."PLUGIN_MODULE" MODIFY ("MODULE_SEQ" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN_MODULE" MODIFY ("PLUGIN_SEQ" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN_MODULE" MODIFY ("NAME" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN_MODULE" MODIFY ("PARAMS" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN_MODULE" MODIFY ("VERSION" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN_MODULE" MODIFY ("ACTIVE" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN_MODULE" MODIFY ("HAS_FORM" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."PLUGIN_MODULE" MODIFY ("MODULE_NAME" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table REPORT
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."REPORT" MODIFY ("REPORT_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table REPORT_ITEM
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."REPORT_ITEM" MODIFY ("REPORT_ITEM_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."REPORT_ITEM" MODIFY ("REPORT_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_AUTH_GROUP
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_GROUP" ADD CONSTRAINT "PK_AUTH_USR_GROUP" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_GROUP" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_AUTH_PRINCIPAL
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL" ADD CONSTRAINT "PK_SEARCH_PRINCIPAL" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL" MODIFY ("ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL" MODIFY ("DATE_CREATED" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL" MODIFY ("LAST_UPDATED" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_AUTH_SEC_OBJECT_ACCESS
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_SEC_OBJECT_ACCESS" ADD CONSTRAINT "SCH_SEC_A_A_S_A_PK" PRIMARY KEY ("AUTH_SEC_OBJ_ACCESS_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SEARCH_AUTH_USER
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_USER" ADD PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SEARCH_AUTH_USER_SEC_ACCESS
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_USER_SEC_ACCESS" ADD CONSTRAINT "SEARCH_SEC_A_U_S_A_PK" PRIMARY KEY ("SEARCH_AUTH_USER_SEC_ACCESS_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SEARCH_CUSTOM_FILTER
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER" ADD CONSTRAINT "SEARCH_CUSTOM_FILTER_PK" PRIMARY KEY ("SEARCH_CUSTOM_FILTER_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER" MODIFY ("SEARCH_CUSTOM_FILTER_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER" MODIFY ("SEARCH_USER_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER" MODIFY ("NAME" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER" MODIFY ("PRIVATE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_CUSTOM_FILTER_ITEM
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER_ITEM" ADD CONSTRAINT "SEARCH_CUST_FIL_ITEM_PK" PRIMARY KEY ("SEARCH_CUSTOM_FILTER_ITEM_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER_ITEM" MODIFY ("SEARCH_CUSTOM_FILTER_ITEM_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER_ITEM" MODIFY ("SEARCH_CUSTOM_FILTER_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER_ITEM" MODIFY ("UNIQUE_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_CUSTOM_FILTER_ITEM" MODIFY ("BIO_DATA_TYPE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_GENE_SIGNATURE
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" ADD CONSTRAINT "SEARCH_GENE_SIG_DESCR_PK" PRIMARY KEY ("SEARCH_GENE_SIGNATURE_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("SEARCH_GENE_SIGNATURE_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("NAME" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("CREATE_DATE" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("CREATED_BY_AUTH_USER_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("PUBLIC_FLAG" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("DELETED_FLAG" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("SPECIES_CONCEPT_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("BIO_ASSAY_PLATFORM_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("P_VALUE_CUTOFF_CONCEPT_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("UPLOAD_FILE" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("SEARCH_GENE_SIG_FILE_SCHEMA_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" MODIFY ("FOLD_CHG_METRIC_CONCEPT_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_GENE_SIGNATURE_ITEM
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM" ADD CONSTRAINT "SEARCH_GENE_SIGNATURE_ITE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM" MODIFY ("SEARCH_GENE_SIGNATURE_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_GENE_SIGNATURE_ITEM_SAV
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM_SAV" MODIFY ("SEARCH_GENE_SIGNATURE_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM_SAV" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_GENE_SIG_FILE_SCHEMA
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA" ADD CONSTRAINT "SEARCH_GENE_SIG_FILE_SCHE_PK" PRIMARY KEY ("SEARCH_GENE_SIG_FILE_SCHEMA_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA" MODIFY ("SEARCH_GENE_SIG_FILE_SCHEMA_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA" MODIFY ("NAME" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA" MODIFY ("NUMBER_COLUMNS" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA" MODIFY ("SUPPORTED" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_KEYWORD
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_KEYWORD" ADD CONSTRAINT "SEARCH_KEYWORD_UK" UNIQUE ("UNIQUE_ID", "DATA_CATEGORY") DISABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_KEYWORD" ADD CONSTRAINT "SEARCH_KW_PK" PRIMARY KEY ("SEARCH_KEYWORD_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 917504 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_KEYWORD" MODIFY ("UNIQUE_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_KEYWORD" MODIFY ("DATA_CATEGORY" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_KEYWORD1
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_KEYWORD1" MODIFY ("UNIQUE_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_KEYWORD1" MODIFY ("DATA_CATEGORY" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_KEYWORD_TERM
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_KEYWORD_TERM" ADD CONSTRAINT "SEARCH_KW_TERM_PK" PRIMARY KEY ("SEARCH_KEYWORD_TERM_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SEARCH_ROLE
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_ROLE" ADD PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SEARCH_SECURE_OBJECT
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_SECURE_OBJECT" ADD CONSTRAINT "SEARCH_SEC_OBJ_PK" PRIMARY KEY ("SEARCH_SECURE_OBJECT_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SEARCH_SECURE_OBJECT_PATH
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_SECURE_OBJECT_PATH" ADD CONSTRAINT "SEARCH_SEC_OBJ__PATH_PK" PRIMARY KEY ("SEARCH_SECURE_OBJ_PATH_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_SECURE_OBJECT_PATH" MODIFY ("SEARCH_SECURE_OBJ_PATH_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_SEC_ACCESS_LEVEL
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_SEC_ACCESS_LEVEL" ADD CONSTRAINT "SEARCH_SEC_AC_LEVEL_PK" PRIMARY KEY ("SEARCH_SEC_ACCESS_LEVEL_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SEARCH_TAXONOMY
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_TAXONOMY" ADD CONSTRAINT "SEARCH_TAXONOMY_PK" PRIMARY KEY ("TERM_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_TAXONOMY" MODIFY ("TERM_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_TAXONOMY" MODIFY ("TERM_NAME" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SEARCH_TAXONOMY_RELS
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_TAXONOMY_RELS" MODIFY ("CHILD_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SEARCH_TAXONOMY_RELS" ADD PRIMARY KEY ("SEARCH_TAXONOMY_RELS_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_TAXONOMY_RELS" ADD CONSTRAINT "U_CHILD_ID_PARENT_ID" UNIQUE ("CHILD_ID", "PARENT_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SEARCH_USER_FEEDBACK
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_USER_FEEDBACK" ADD CONSTRAINT "RDT_SEARCH_USER_FDBK_PK" PRIMARY KEY ("SEARCH_USER_FEEDBACK_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SUBSET
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SUBSET" ADD CONSTRAINT "SUBSET_PK" PRIMARY KEY ("SUBSET_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "BIOMART"  ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SUBSET" MODIFY ("SUBSET_ID" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SUBSET" MODIFY ("DESCRIPTION" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SUBSET" MODIFY ("CREATE_DATE" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SUBSET" MODIFY ("CREATING_USER" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SUBSET" MODIFY ("PUBLIC_FLAG" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SUBSET" MODIFY ("DELETED_FLAG" NOT NULL ENABLE);
 
  ALTER TABLE "SEARCHAPP"."SUBSET" MODIFY ("QUERY_MASTER_ID_1" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DE_CONTEXT
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_CONTEXT" MODIFY ("DE_CONTEXT_NAME" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DE_GENE_INFO
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_GENE_INFO" MODIFY ("GENE_SOURCE_ID" NOT NULL ENABLE);
 
  ALTER TABLE "DEAPP"."DE_GENE_INFO" MODIFY ("GENE_SYMBOL" NOT NULL ENABLE);
 
  ALTER TABLE "DEAPP"."DE_GENE_INFO" MODIFY ("CHROM" NOT NULL ENABLE);
 
  ALTER TABLE "DEAPP"."DE_GENE_INFO" ADD UNIQUE ("GENE_SOURCE_ID", "GENE_SYMBOL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
 
  ALTER TABLE "DEAPP"."DE_GENE_INFO" ADD PRIMARY KEY ("GENE_INFO_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_GENE_SOURCE
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_GENE_SOURCE" MODIFY ("GENE_SOURCE_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "DEAPP"."DE_GENE_SOURCE" ADD UNIQUE ("GENE_SOURCE_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
 
  ALTER TABLE "DEAPP"."DE_GENE_SOURCE" ADD PRIMARY KEY ("GENE_SOURCE_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_PATHWAY
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_PATHWAY" ADD CONSTRAINT "DE_PATHWAY_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
 
  ALTER TABLE "DEAPP"."DE_PATHWAY" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DE_PATHWAY_GENE
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_PATHWAY_GENE" ADD CONSTRAINT "DE_PATHWAY_GENE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
 
  ALTER TABLE "DEAPP"."DE_PATHWAY_GENE" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DE_SAVED_COMPARISON
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SAVED_COMPARISON" MODIFY ("COMPARISON_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DE_SNP_DATA_BY_PATIENT
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_DATA_BY_PATIENT" ADD PRIMARY KEY ("SNP_DATA_BY_PATIENT_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_SNP_DATA_BY_PROBE
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_DATA_BY_PROBE" ADD PRIMARY KEY ("SNP_DATA_BY_PROBE_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_SNP_DATA_DATASET_LOC
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_DATA_DATASET_LOC" ADD PRIMARY KEY ("SNP_DATA_DATASET_LOC_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_SNP_INFO
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_INFO" ADD PRIMARY KEY ("SNP_INFO_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 22020096 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
 
  ALTER TABLE "DEAPP"."DE_SNP_INFO" ADD CONSTRAINT "U_SNP_INFO_NAME" UNIQUE ("NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 100663296 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_SNP_PROBE
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_PROBE" ADD PRIMARY KEY ("SNP_PROBE_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 22020096 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART"  ENABLE;
 
  ALTER TABLE "DEAPP"."DE_SNP_PROBE" ADD CONSTRAINT "U_SNP_PROBE_NAME" UNIQUE ("PROBE_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 83886080 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_SNP_PROBE_SORTED_DEF
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_PROBE_SORTED_DEF" ADD PRIMARY KEY ("SNP_PROBE_SORTED_DEF_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_SNP_SUBJECT_SORTED_DEF
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_SUBJECT_SORTED_DEF" ADD PRIMARY KEY ("SNP_SUBJECT_SORTED_DEF_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_SUBJECT_SNP_DATASET
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SUBJECT_SNP_DATASET" ADD PRIMARY KEY ("SUBJECT_SNP_DATASET_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_XTRIAL_CHILD_MAP
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_XTRIAL_CHILD_MAP" MODIFY ("CONCEPT_CD" NOT NULL ENABLE);
 
  ALTER TABLE "DEAPP"."DE_XTRIAL_CHILD_MAP" MODIFY ("PARENT_CD" NOT NULL ENABLE);
 
  ALTER TABLE "DEAPP"."DE_XTRIAL_CHILD_MAP" ADD PRIMARY KEY ("CONCEPT_CD")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DE_XTRIAL_PARENT_NAMES
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_XTRIAL_PARENT_NAMES" ADD CONSTRAINT "DEXTPN_PARENT_NODE_U" UNIQUE ("ACROSS_PATH")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
 
  ALTER TABLE "DEAPP"."DE_XTRIAL_PARENT_NAMES" MODIFY ("PARENT_CD" NOT NULL ENABLE);
 
  ALTER TABLE "DEAPP"."DE_XTRIAL_PARENT_NAMES" ADD PRIMARY KEY ("PARENT_CD")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "DEAPP"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FM_DATA_UID
--------------------------------------------------------

  ALTER TABLE "FMAPP"."FM_DATA_UID" ADD CONSTRAINT "FM_DATA_UID_PK" PRIMARY KEY ("FM_DATA_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 589824 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  ENABLE;
 
  ALTER TABLE "FMAPP"."FM_DATA_UID" ADD CONSTRAINT "FM_DATA_UID_UK" UNIQUE ("UNIQUE_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  ENABLE;
 
  ALTER TABLE "FMAPP"."FM_DATA_UID" MODIFY ("FM_DATA_ID" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_DATA_UID" MODIFY ("UNIQUE_ID" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_DATA_UID" MODIFY ("FM_DATA_TYPE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table FM_FILE
--------------------------------------------------------

  ALTER TABLE "FMAPP"."FM_FILE" MODIFY ("FILE_ID" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FILE" MODIFY ("DISPLAY_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FILE" MODIFY ("ORIGINAL_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FILE" MODIFY ("ACTIVE_IND" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FILE" MODIFY ("CREATE_DATE" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FILE" MODIFY ("UPDATE_DATE" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FILE" ADD PRIMARY KEY ("FILE_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FM_FOLDER
--------------------------------------------------------

  ALTER TABLE "FMAPP"."FM_FOLDER" MODIFY ("FOLDER_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FOLDER" MODIFY ("FOLDER_FULL_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FOLDER" MODIFY ("FOLDER_LEVEL" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FOLDER" MODIFY ("FOLDER_TYPE" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FOLDER" ADD PRIMARY KEY ("FOLDER_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
 
  ALTER TABLE "FMAPP"."FM_FOLDER" MODIFY ("ACTIVE_IND" NOT NULL DISABLE);
--------------------------------------------------------
--  Constraints for Table FM_FOLDER_ASSOCIATION
--------------------------------------------------------

  ALTER TABLE "FMAPP"."FM_FOLDER_ASSOCIATION" ADD CONSTRAINT "PK_FOLDER_ASSOC" PRIMARY KEY ("FOLDER_ID", "OBJECT_UID") DISABLE;
 
  ALTER TABLE "FMAPP"."FM_FOLDER_ASSOCIATION" MODIFY ("FOLDER_ID" NOT NULL DISABLE);
 
  ALTER TABLE "FMAPP"."FM_FOLDER_ASSOCIATION" MODIFY ("OBJECT_UID" NOT NULL DISABLE);
 
  ALTER TABLE "FMAPP"."FM_FOLDER_ASSOCIATION" MODIFY ("OBJECT_TYPE" NOT NULL DISABLE);
--------------------------------------------------------
--  Constraints for Table FM_FOLDER_FILE_ASSOCIATION
--------------------------------------------------------

  ALTER TABLE "FMAPP"."FM_FOLDER_FILE_ASSOCIATION" ADD CONSTRAINT "PK_FOLDER_FILE_ASSOC" PRIMARY KEY ("FOLDER_ID", "FILE_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
 
  ALTER TABLE "FMAPP"."FM_FOLDER_FILE_ASSOCIATION" MODIFY ("FOLDER_ID" NOT NULL ENABLE);
 
  ALTER TABLE "FMAPP"."FM_FOLDER_FILE_ASSOCIATION" MODIFY ("FILE_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BIO_DATA_COMPOUND_RELEASE
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."BIO_DATA_COMPOUND_RELEASE" MODIFY ("BIO_DATA_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."BIO_DATA_COMPOUND_RELEASE" MODIFY ("BIO_COMPOUND_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BIO_DATA_UID_RELEASE
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."BIO_DATA_UID_RELEASE" MODIFY ("BIO_DATA_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."BIO_DATA_UID_RELEASE" MODIFY ("UNIQUE_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."BIO_DATA_UID_RELEASE" MODIFY ("BIO_DATA_TYPE" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."BIO_DATA_UID_RELEASE" MODIFY ("RELEASE_STUDY" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CONCEPT_DIMENSION_RELEASE
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CONCEPT_DIMENSION_RELEASE" MODIFY ("CONCEPT_CD" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CONCEPT_DIMENSION_RELEASE" MODIFY ("CONCEPT_PATH" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_DATA_PROFILE_COLUMN_EXCLUSI
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_DATA_PROFILE_COLUMN_EXCLUSI" MODIFY ("TABLE_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_DATA_PROFILE_COLUMN_EXCLUSI" MODIFY ("COLUMN_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_DATA_PROFILE_COLUMN_EXCLUSI" MODIFY ("ETL_DATE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_DATA_PROFILE_COLUMN_SAMPLE
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_DATA_PROFILE_COLUMN_SAMPLE" MODIFY ("ETL_DATE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_DATA_PROFILE_STATS
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_DATA_PROFILE_STATS" MODIFY ("TABLE_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_DATA_PROFILE_STATS" MODIFY ("COLUMN_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_DATA_PROFILE_STATS" MODIFY ("COLUMN_SCALE" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_DATA_PROFILE_STATS" MODIFY ("ETL_DATE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_FORM_LAYOUT
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_FORM_LAYOUT" ADD CONSTRAINT "CZ_FORM_LAYOUT_PK" PRIMARY KEY ("FORM_LAYOUT_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  ENABLE;
 
  ALTER TABLE "TM_CZ"."CZ_FORM_LAYOUT" MODIFY ("FORM_LAYOUT_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_JOB_AUDIT
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_JOB_AUDIT" ADD CONSTRAINT "CZ_JOB_AUDIT_PK" PRIMARY KEY ("SEQ_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART"  ENABLE;
 
  ALTER TABLE "TM_CZ"."CZ_JOB_AUDIT" MODIFY ("SEQ_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_JOB_AUDIT" MODIFY ("JOB_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_JOB_ERROR
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_JOB_ERROR" MODIFY ("JOB_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_JOB_ERROR" MODIFY ("SEQ_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_JOB_MASTER
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_JOB_MASTER" ADD CONSTRAINT "CZ_JOB_MASTER_PK" PRIMARY KEY ("JOB_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART"  ENABLE;
 
  ALTER TABLE "TM_CZ"."CZ_JOB_MASTER" MODIFY ("JOB_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_JOB_MESSAGE
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_JOB_MESSAGE" MODIFY ("JOB_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_JOB_MESSAGE" MODIFY ("SEQ_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_PERSON
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_PERSON" ADD CONSTRAINT "CZ_PERSON_PK" PRIMARY KEY ("PERSON_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART"  ENABLE;
 
  ALTER TABLE "TM_CZ"."CZ_PERSON" MODIFY ("PERSON_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_REQUIRED_UPLOAD_FIELD
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_REQUIRED_UPLOAD_FIELD" ADD CONSTRAINT "CZ_REQUIRED_UPLOAD_FIELD_PK" PRIMARY KEY ("REQUIRED_UPLOAD_FIELD_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "INDX"  ENABLE;
 
  ALTER TABLE "TM_CZ"."CZ_REQUIRED_UPLOAD_FIELD" MODIFY ("REQUIRED_UPLOAD_FIELD_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_TEST
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_TEST" ADD CONSTRAINT "CZ_TEST_PK" PRIMARY KEY ("TEST_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART"  ENABLE;
 
  ALTER TABLE "TM_CZ"."CZ_TEST" MODIFY ("TEST_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_TEST_CATEGORY
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_TEST_CATEGORY" ADD CONSTRAINT "CZ_TEST_CATEGORY_PK" PRIMARY KEY ("TEST_CATEGORY_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART"  ENABLE;
 
  ALTER TABLE "TM_CZ"."CZ_TEST_CATEGORY" MODIFY ("TEST_CATEGORY_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_TEST_RESULT
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_TEST_RESULT" MODIFY ("TEST_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_TEST_RESULT" MODIFY ("TEST_RESULT_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table CZ_XTRIAL_CTRL_VOCAB
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_XTRIAL_CTRL_VOCAB" MODIFY ("CTRL_VOCAB_CODE" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_XTRIAL_CTRL_VOCAB" MODIFY ("CTRL_VOCAB_NAME" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."CZ_XTRIAL_CTRL_VOCAB" MODIFY ("CTRL_VOCAB_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table I2B2_RELEASE
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."I2B2_RELEASE" MODIFY ("C_FULLNAME" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table I2B2_TAGS_RELEASE
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."I2B2_TAGS_RELEASE" MODIFY ("TAG_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table OBSERVATION_FACT_RELEASE
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."OBSERVATION_FACT_RELEASE" MODIFY ("CONCEPT_CD" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."OBSERVATION_FACT_RELEASE" MODIFY ("PROVIDER_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."OBSERVATION_FACT_RELEASE" MODIFY ("LOCATION_CD" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table PROBESET_DEAPP
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."PROBESET_DEAPP" MODIFY ("PROBESET_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."PROBESET_DEAPP" MODIFY ("PROBESET" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."PROBESET_DEAPP" MODIFY ("PLATFORM" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table PROBESET_DEAPP_20120206
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."PROBESET_DEAPP_20120206" MODIFY ("PROBESET_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."PROBESET_DEAPP_20120206" MODIFY ("PROBESET" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."PROBESET_DEAPP_20120206" MODIFY ("PLATFORM" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table TEMP
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."TEMP" MODIFY ("BIO_ASSAY_ANALYSIS_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_CZ"."TEMP" ADD CONSTRAINT "TEMP_PK" PRIMARY KEY ("BIO_ASSAY_ANALYSIS_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 NOLOGGING COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TRANSMART"  ENABLE;
--------------------------------------------------------
--  Constraints for Table NEW_DBSNP_INFO
--------------------------------------------------------

  ALTER TABLE "TM_LZ"."NEW_DBSNP_INFO" MODIFY ("SNP_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_LZ"."NEW_DBSNP_INFO" MODIFY ("CHR" NOT NULL ENABLE);
 
  ALTER TABLE "TM_LZ"."NEW_DBSNP_INFO" MODIFY ("ISPAR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table RENAMED_SNP_INFO
--------------------------------------------------------

  ALTER TABLE "TM_LZ"."RENAMED_SNP_INFO" MODIFY ("CHR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SNPCHRPOSONREF_135
--------------------------------------------------------

  ALTER TABLE "TM_LZ"."SNPCHRPOSONREF_135" MODIFY ("SNP_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_LZ"."SNPCHRPOSONREF_135" MODIFY ("CHR" NOT NULL ENABLE);
 
  ALTER TABLE "TM_LZ"."SNPCHRPOSONREF_135" MODIFY ("ISPAR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SNPSUBSNPLINK_135
--------------------------------------------------------

  ALTER TABLE "TM_LZ"."SNPSUBSNPLINK_135" MODIFY ("SUBSNP_ID" NOT NULL ENABLE);
 
  ALTER TABLE "TM_LZ"."SNPSUBSNPLINK_135" MODIFY ("SNP_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BIO_ASSAY_ANALYSIS_EQTL
--------------------------------------------------------

  ALTER TABLE "BIOMART_STAGE"."BIO_ASSAY_ANALYSIS_EQTL" MODIFY ("BIO_ASY_ANALYSIS_EQTL_ID" NOT NULL ENABLE);
 
  ALTER TABLE "BIOMART_STAGE"."BIO_ASSAY_ANALYSIS_EQTL" MODIFY ("BIO_ASSAY_ANALYSIS_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BIO_ASSAY_ANALYSIS_GWAS
--------------------------------------------------------

  ALTER TABLE "BIOMART_STAGE"."BIO_ASSAY_ANALYSIS_GWAS" MODIFY ("BIO_ASY_ANALYSIS_GWAS_ID" NOT NULL ENABLE);
 
  ALTER TABLE "BIOMART_STAGE"."BIO_ASSAY_ANALYSIS_GWAS" MODIFY ("BIO_ASSAY_ANALYSIS_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BIO_MARKER_EXP_ANALYSIS_MV
--------------------------------------------------------

  ALTER TABLE "BIOMART_USER"."BIO_MARKER_EXP_ANALYSIS_MV" MODIFY ("BIO_MARKER_ID" NOT NULL ENABLE);
 
  ALTER TABLE "BIOMART_USER"."BIO_MARKER_EXP_ANALYSIS_MV" MODIFY ("BIO_ASSAY_ANALYSIS_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Ref Constraints for Table PLUGIN_MODULE
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."PLUGIN_MODULE" ADD CONSTRAINT "PLUGIN_MODULE_PLUGIN_FK1" FOREIGN KEY ("PLUGIN_SEQ")
	  REFERENCES "SEARCHAPP"."PLUGIN" ("PLUGIN_SEQ") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEARCH_AUTH_GROUP
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_GROUP" ADD CONSTRAINT "SH_AUTH_GP_ID_FK" FOREIGN KEY ("ID")
	  REFERENCES "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEARCH_AUTH_GROUP_MEMBER
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_GROUP_MEMBER" ADD CONSTRAINT "SCH_USER_GP_M_GRP_FK" FOREIGN KEY ("AUTH_GROUP_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_AUTH_GROUP" ("ID") ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_GROUP_MEMBER" ADD CONSTRAINT "SCH_USER_GP_M_USR_FK" FOREIGN KEY ("AUTH_USER_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEARCH_AUTH_SEC_OBJECT_ACCESS
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_SEC_OBJECT_ACCESS" ADD CONSTRAINT "SCH_SEC_A_U_FK" FOREIGN KEY ("AUTH_PRINCIPAL_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL" ("ID") ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_SEC_OBJECT_ACCESS" ADD CONSTRAINT "SCH_SEC_S_A_L_FK" FOREIGN KEY ("SECURE_ACCESS_LEVEL_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_SEC_ACCESS_LEVEL" ("SEARCH_SEC_ACCESS_LEVEL_ID") ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_SEC_OBJECT_ACCESS" ADD CONSTRAINT "SCH_SEC_S_O_FK" FOREIGN KEY ("SECURE_OBJECT_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_SECURE_OBJECT" ("SEARCH_SECURE_OBJECT_ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEARCH_AUTH_USER
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_USER" ADD CONSTRAINT "SH_AUTH_USER_ID_FK" FOREIGN KEY ("ID")
	  REFERENCES "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEARCH_AUTH_USER_SEC_ACCESS
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_USER_SEC_ACCESS" ADD CONSTRAINT "SEARCH_SEC_A_U_FK" FOREIGN KEY ("SEARCH_AUTH_USER_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_AUTH_USER" ("ID") ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_USER_SEC_ACCESS" ADD CONSTRAINT "SEARCH_SEC_S_A_L_FK" FOREIGN KEY ("SEARCH_SEC_ACCESS_LEVEL_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_SEC_ACCESS_LEVEL" ("SEARCH_SEC_ACCESS_LEVEL_ID") ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_AUTH_USER_SEC_ACCESS" ADD CONSTRAINT "SEARCH_SEC_S_O_FK" FOREIGN KEY ("SEARCH_SECURE_OBJECT_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_SECURE_OBJECT" ("SEARCH_SECURE_OBJECT_ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEARCH_GENE_SIGNATURE
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" ADD CONSTRAINT "GENE_SIG_CREATE_AUTH_USER_FK1" FOREIGN KEY ("CREATED_BY_AUTH_USER_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_AUTH_USER" ("ID") ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" ADD CONSTRAINT "GENE_SIG_FILE_SCHEMA_FK1" FOREIGN KEY ("SEARCH_GENE_SIG_FILE_SCHEMA_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA" ("SEARCH_GENE_SIG_FILE_SCHEMA_ID") ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" ADD CONSTRAINT "GENE_SIG_MOD_AUTH_USER_FK1" FOREIGN KEY ("MODIFIED_BY_AUTH_USER_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_AUTH_USER" ("ID") ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_GENE_SIGNATURE" ADD CONSTRAINT "GENE_SIG_PARENT_FK1" FOREIGN KEY ("PARENT_GENE_SIGNATURE_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_GENE_SIGNATURE" ("SEARCH_GENE_SIGNATURE_ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEARCH_KEYWORD_TERM
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_KEYWORD_TERM" ADD CONSTRAINT "SEARCH_KW_FK" FOREIGN KEY ("SEARCH_KEYWORD_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_KEYWORD" ("SEARCH_KEYWORD_ID") DISABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEARCH_ROLE_AUTH_USER
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_ROLE_AUTH_USER" ADD CONSTRAINT "FKFB14EF79287E0CAC" FOREIGN KEY ("AUTHORITIES_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_AUTH_USER" ("ID") ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_ROLE_AUTH_USER" ADD CONSTRAINT "FKFB14EF798F01F561" FOREIGN KEY ("PEOPLE_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_ROLE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEARCH_TAXONOMY
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_TAXONOMY" ADD CONSTRAINT "FK_SEARCH_TAX_SEARCH_KEYWORD" FOREIGN KEY ("SEARCH_KEYWORD_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_KEYWORD" ("SEARCH_KEYWORD_ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table SEARCH_TAXONOMY_RELS
--------------------------------------------------------

  ALTER TABLE "SEARCHAPP"."SEARCH_TAXONOMY_RELS" ADD CONSTRAINT "FK_SEARCH_TAX_RELS_CHILD" FOREIGN KEY ("CHILD_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_TAXONOMY" ("TERM_ID") ENABLE;
 
  ALTER TABLE "SEARCHAPP"."SEARCH_TAXONOMY_RELS" ADD CONSTRAINT "FK_SEARCH_TAX_RELS_PARENT" FOREIGN KEY ("PARENT_ID")
	  REFERENCES "SEARCHAPP"."SEARCH_TAXONOMY" ("TERM_ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table DE_GENE_INFO
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_GENE_INFO" ADD FOREIGN KEY ("GENE_SOURCE_ID")
	  REFERENCES "DEAPP"."DE_GENE_SOURCE" ("GENE_SOURCE_ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table DE_SNP_DATA_BY_PATIENT
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_DATA_BY_PATIENT" ADD CONSTRAINT "FK_SNP_DATASET_ID" FOREIGN KEY ("SNP_DATASET_ID")
	  REFERENCES "DEAPP"."DE_SUBJECT_SNP_DATASET" ("SUBJECT_SNP_DATASET_ID") DISABLE;
--------------------------------------------------------
--  Ref Constraints for Table DE_SNP_DATA_BY_PROBE
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_DATA_BY_PROBE" ADD CONSTRAINT "FK_SNP_BY_PROBE_SNP_ID" FOREIGN KEY ("SNP_ID")
	  REFERENCES "DEAPP"."DE_SNP_INFO" ("SNP_INFO_ID") DISABLE;
--------------------------------------------------------
--  Ref Constraints for Table DE_SNP_DATA_DATASET_LOC
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_DATA_DATASET_LOC" ADD CONSTRAINT "FK_SNP_LOC_DATASET_ID" FOREIGN KEY ("SNP_DATASET_ID")
	  REFERENCES "DEAPP"."DE_SUBJECT_SNP_DATASET" ("SUBJECT_SNP_DATASET_ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table DE_SNP_PROBE
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_SNP_PROBE" ADD CONSTRAINT "FK_SNP_PROBE_SNP_ID" FOREIGN KEY ("SNP_ID")
	  REFERENCES "DEAPP"."DE_SNP_INFO" ("SNP_INFO_ID") DISABLE;
--------------------------------------------------------
--  Ref Constraints for Table DE_XTRIAL_CHILD_MAP
--------------------------------------------------------

  ALTER TABLE "DEAPP"."DE_XTRIAL_CHILD_MAP" ADD CONSTRAINT "DEXCM_PARENT_CD_FK" FOREIGN KEY ("PARENT_CD")
	  REFERENCES "DEAPP"."DE_XTRIAL_PARENT_NAMES" ("PARENT_CD") DISABLE;
--------------------------------------------------------
--  Ref Constraints for Table FM_FOLDER_ASSOCIATION
--------------------------------------------------------

  ALTER TABLE "FMAPP"."FM_FOLDER_ASSOCIATION" ADD CONSTRAINT "FK_FM_FOLDER_ASSOC_FM_FOLDER" FOREIGN KEY ("FOLDER_ID")
	  REFERENCES "FMAPP"."FM_FOLDER" ("FOLDER_ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table FM_FOLDER_FILE_ASSOCIATION
--------------------------------------------------------

  ALTER TABLE "FMAPP"."FM_FOLDER_FILE_ASSOCIATION" ADD CONSTRAINT "FK_FM_FOLDER_FM_FOLDER" FOREIGN KEY ("FOLDER_ID")
	  REFERENCES "FMAPP"."FM_FOLDER" ("FOLDER_ID") ENABLE;
 
  ALTER TABLE "FMAPP"."FM_FOLDER_FILE_ASSOCIATION" ADD CONSTRAINT "FK_FOLDER_FILE_ASSOC_FILE" FOREIGN KEY ("FILE_ID")
	  REFERENCES "FMAPP"."FM_FILE" ("FILE_ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table CZ_TEST
--------------------------------------------------------

  ALTER TABLE "TM_CZ"."CZ_TEST" ADD CONSTRAINT "CZ_TEST_CZ_TEST_CATEGORY_FK1" FOREIGN KEY ("TEST_CATEGORY_ID")
	  REFERENCES "TM_CZ"."CZ_TEST_CATEGORY" ("TEST_CATEGORY_ID") ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_FM_FILE_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "FMAPP"."TRG_FM_FILE_ID" before insert on "FM_FILE"
for each row begin
if inserting then
  if :NEW."FILE_ID" is null then
    select SEQ_FM_ID.nextval into :NEW."FILE_ID" from dual;
  end if;
end if;
end;
/
ALTER TRIGGER "FMAPP"."TRG_FM_FILE_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_FM_FILE_UID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "FMAPP"."TRG_FM_FILE_UID" after insert on "FM_FILE"
for each row
DECLARE
  rec_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO rec_count
  FROM fm_data_uid
  WHERE fm_data_id = :new.FILE_ID;

  if rec_count = 0 then
    insert into fmapp.fm_data_uid (fm_data_id, unique_id, fm_data_type)
    values (:NEW."FILE_ID", FM_FILE_UID(:NEW."FILE_ID"), 'FM_FILE');
  end if;
end;
/
ALTER TRIGGER "FMAPP"."TRG_FM_FILE_UID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_FM_FOLDER_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "FMAPP"."TRG_FM_FOLDER_ID" before insert on FM_FOLDER
for each row begin
if inserting then
  if :NEW.FOLDER_ID is null then
    select SEQ_FM_ID.nextval into :NEW.FOLDER_ID from dual;
  end if;
  if :new.FOLDER_FULL_NAME is null then
    if :new.PARENT_ID is null then
      select '\' || fm_folder_uid(:new.folder_id) || '\' into :new.folder_full_name
      from dual;
    else
      select folder_full_name || fm_folder_uid(:new.folder_id) || '\' into :new.folder_full_name
      from fm_folder
      where folder_id = :new.parent_id;
    end if;
  end if;
end if;
end;
/
ALTER TRIGGER "FMAPP"."TRG_FM_FOLDER_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_FM_FOLDER_UID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "FMAPP"."TRG_FM_FOLDER_UID" after insert on "FM_FOLDER"
for each row
DECLARE
  rec_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO rec_count
  FROM fm_data_uid
  WHERE fm_data_id = :new.FOLDER_ID;

  if rec_count = 0 then
    insert into fmapp.fm_data_uid (fm_data_id, unique_id, fm_data_type)
    values (:NEW."FOLDER_ID", FM_FOLDER_UID(:NEW."FOLDER_ID"), 'FM_FOLDER');
  end if;
end;
/
ALTER TRIGGER "FMAPP"."TRG_FM_FOLDER_UID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SEARCH_AU_PRCPL_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TRG_SEARCH_AU_PRCPL_ID" 
 before insert on SEARCH_AUTH_PRINCIPAL   
 for each row begin     
 if inserting then      
 if(:NEW.ID is null or :NEW.ID = -2000) then       
 select SEQ_SEARCH_DATA_ID.nextval into :NEW.ID from dual;      
 end if;    end if; end;








/
ALTER TRIGGER "SEARCHAPP"."TRG_SEARCH_AU_PRCPL_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SEARCH_AU_OBJ_ACCESS_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TRG_SEARCH_AU_OBJ_ACCESS_ID" before insert on SEARCH_AUTH_SEC_OBJECT_ACCESS    for each row begin     if inserting then       if :NEW.AUTH_SEC_OBJ_ACCESS_ID is null then          select SEQ_SEARCH_DATA_ID.nextval into :NEW.AUTH_SEC_OBJ_ACCESS_ID from dual;       end if;    end if; end;








/
ALTER TRIGGER "SEARCHAPP"."TRG_SEARCH_AU_OBJ_ACCESS_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SEARCH_A_U_SEC_ACCESS_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TRG_SEARCH_A_U_SEC_ACCESS_ID" before insert on "SEARCH_AUTH_USER_SEC_ACCESS"    for each row begin     if inserting then       if :NEW."SEARCH_AUTH_USER_SEC_ACCESS_ID" is null then          select SEQ_SEARCH_DATA_ID.nextval into :NEW."SEARCH_AUTH_USER_SEC_ACCESS_ID" from dual;       end if;    end if; end;












/
ALTER TRIGGER "SEARCHAPP"."TRG_SEARCH_A_U_SEC_ACCESS_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SEARCH_CUSTOM_FILTER_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TRG_SEARCH_CUSTOM_FILTER_ID" 
  before insert on "SEARCH_CUSTOM_FILTER" for each row
begin 
    if inserting then if :NEW."SEARCH_CUSTOM_FILTER_ID" is null then select SEQ_SEARCH_DATA_ID.nextval into :NEW."SEARCH_CUSTOM_FILTER_ID" from dual; end if; end if;
end;












/
ALTER TRIGGER "SEARCHAPP"."TRG_SEARCH_CUSTOM_FILTER_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SEARCH_CUST_FIL_ITEM_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TRG_SEARCH_CUST_FIL_ITEM_ID" 
  before insert on "SEARCH_CUSTOM_FILTER_ITEM" for each row
begin 
    if inserting then if :NEW."SEARCH_CUSTOM_FILTER_ITEM_ID" is null then select SEQ_SEARCH_DATA_ID.nextval into :NEW."SEARCH_CUSTOM_FILTER_ITEM_ID" from dual; end if; end if;
end;












/
ALTER TRIGGER "SEARCHAPP"."TRG_SEARCH_CUST_FIL_ITEM_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SEARCH_KEYWORD_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TRG_SEARCH_KEYWORD_ID" 
before insert on "SEARCH_KEYWORD"
for each row
begin
     if inserting then
       if :NEW."SEARCH_KEYWORD_ID" is null then
          select SEQ_SEARCH_DATA_ID.nextval into :NEW."SEARCH_KEYWORD_ID" from dual;
       end if;
    end if;
 end;

/
ALTER TRIGGER "SEARCHAPP"."TRG_SEARCH_KEYWORD_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SEARCH_KEYWORD_TERM_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TRG_SEARCH_KEYWORD_TERM_ID" 
before insert on "SEARCH_KEYWORD_TERM"
for each row
begin
     if inserting then
       if :NEW."SEARCH_KEYWORD_TERM_ID" is null then
          select SEQ_SEARCH_DATA_ID.nextval into :NEW."SEARCH_KEYWORD_TERM_ID" from dual;
       end if;
    end if;
end;

/
ALTER TRIGGER "SEARCHAPP"."TRG_SEARCH_KEYWORD_TERM_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SEARCH_SEC_OBJ_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TRG_SEARCH_SEC_OBJ_ID" before insert on "SEARCH_SECURE_OBJECT"    for each row begin     if inserting then       if :NEW."SEARCH_SECURE_OBJECT_ID" is null then          select SEQ_SEARCH_DATA_ID.nextval into :NEW."SEARCH_SECURE_OBJECT_ID" from dual;       end if;    end if; end;












/
ALTER TRIGGER "SEARCHAPP"."TRG_SEARCH_SEC_OBJ_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SEARCH_SEC_OBJ_PATH_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TRG_SEARCH_SEC_OBJ_PATH_ID" before insert on "SEARCH_SECURE_OBJECT_PATH"    for each row begin     if inserting then       if :NEW."SEARCH_SECURE_OBJ_PATH_ID" is null then          select SEQ_SEARCH_DATA_ID.nextval into :NEW."SEARCH_SECURE_OBJ_PATH_ID" from dual;       end if;    end if; end;












/
ALTER TRIGGER "SEARCHAPP"."TRG_SEARCH_SEC_OBJ_PATH_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SEARCH_SEC_ACC_LEVEL_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TRG_SEARCH_SEC_ACC_LEVEL_ID" before insert on "SEARCH_SEC_ACCESS_LEVEL"    for each row begin     if inserting then       if :NEW."SEARCH_SEC_ACCESS_LEVEL_ID" is null then          select SEQ_SEARCH_DATA_ID.nextval into :NEW."SEARCH_SEC_ACCESS_LEVEL_ID" from dual;       end if;    end if; end;












/
ALTER TRIGGER "SEARCHAPP"."TRG_SEARCH_SEC_ACC_LEVEL_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TGR_SEARCH_TAXONOMY_TERM_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TGR_SEARCH_TAXONOMY_TERM_ID" 
  before insert on "SEARCHAPP"."SEARCH_TAXONOMY" for each row
begin 
    If Inserting 
      Then If :New.Term_Id Is Null 
        Then Select Seq_Search_Taxonomy_Term_Id.Nextval Into :New.Term_Id From Dual; 
      End If; 
    end if;
end;


/
ALTER TRIGGER "SEARCHAPP"."TGR_SEARCH_TAXONOMY_TERM_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TGR_SEARCH_TAXONOMY_RELS_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "SEARCHAPP"."TGR_SEARCH_TAXONOMY_RELS_ID" 
  before insert on searchapp.Search_Taxonomy_rels for each row
begin 
    If Inserting 
      Then If :New.search_taxonomy_rels_Id Is Null 
        Then Select Seq_Search_Taxonomy_rels_Id.Nextval Into :New.search_taxonomy_rels_Id From Dual; 
      End If; 
    end if;
end;


/
ALTER TRIGGER "SEARCHAPP"."TGR_SEARCH_TAXONOMY_RELS_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger DE_CONTEXT_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."DE_CONTEXT_TRIGGER" 
before
  insert on DEAPP.DE_CONTEXT for each row
begin
   select DEAPP.de_context_seq.nextval into :new.DE_CONTEXT_ID from dual;
end;


/
ALTER TRIGGER "DEAPP"."DE_CONTEXT_TRIGGER" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_DE_GENE_INFO_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_DE_GENE_INFO_ID" 
BEFORE
  INSERT ON DEAPP.DE_GENE_INFO FOR EACH ROW
BEGIN
  IF inserting THEN
    IF :NEW.GENE_INFO_ID IS NULL THEN
        SELECT DEAPP.SEQ_GENE_INFO_ID.nextval INTO :NEW.GENE_INFO_ID FROM dual;
    END IF;
  END IF;
END;

/
ALTER TRIGGER "DEAPP"."TRG_DE_GENE_INFO_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_DE_GENE_SOURCE_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_DE_GENE_SOURCE_ID" 
BEFORE
  INSERT ON DEAPP.DE_GENE_SOURCE FOR EACH ROW
BEGIN
  IF inserting THEN
    IF :NEW.GENE_SOURCE_ID IS NULL THEN
        SELECT DEAPP.SEQ_GENE_SOURCE_ID.nextval INTO :NEW.GENE_SOURCE_ID FROM dual;
    END IF;
  END IF;
END;

/
ALTER TRIGGER "DEAPP"."TRG_DE_GENE_SOURCE_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_DE_PATHWAY_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_DE_PATHWAY_ID" 
before
  insert on "DE_PATHWAY"  for each row
begin
     if inserting then
  	    if :NEW."ID" is null then
  		    select SEQ_DATA_ID.nextval into :NEW."ID" from dual;
		end if;
	end if;
end;


/
ALTER TRIGGER "DEAPP"."TRG_DE_PATHWAY_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_DE_PATHWAY_GENE_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_DE_PATHWAY_GENE_ID" 
before
	insert on "DE_PATHWAY_GENE"  for each row
begin
	if inserting then
		if :NEW."ID" is null then
			select SEQ_DATA_ID.nextval into :NEW."ID" from dual;
		end if;
	end if; end;


/
ALTER TRIGGER "DEAPP"."TRG_DE_PATHWAY_GENE_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SNP_DATA_BY_PATIENT_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_SNP_DATA_BY_PATIENT_ID" 
before insert on DE_SNP_DATA_BY_PATIENT
for each row
begin
   if inserting then
      if :NEW.SNP_DATA_BY_PATIENT_ID is null then
         select BIOMART.SEQ_BIO_DATA_ID.nextval into :NEW.SNP_DATA_BY_PATIENT_ID from dual;
      end if;
  end if;
end;

/
ALTER TRIGGER "DEAPP"."TRG_SNP_DATA_BY_PATIENT_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SNP_DATA_BY_PPROBE_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_SNP_DATA_BY_PPROBE_ID" 
before insert on DE_SNP_DATA_BY_PROBE
for each row
begin
   if inserting then
      if :NEW.SNP_DATA_BY_PROBE_ID is null then
         select BIOMART.SEQ_BIO_DATA_ID.nextval into :NEW.SNP_DATA_BY_PROBE_ID from dual;
      end if;
  end if;
end;

/
ALTER TRIGGER "DEAPP"."TRG_SNP_DATA_BY_PPROBE_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SNP_DATA_DATASET_LOC_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_SNP_DATA_DATASET_LOC_ID" 
before insert on DE_SNP_DATA_DATASET_LOC
for each row
begin
   if inserting then
      if :NEW.SNP_DATA_DATASET_LOC_ID is null then
         select BIOMART.SEQ_BIO_DATA_ID.nextval into :NEW.SNP_DATA_DATASET_LOC_ID from dual;
      end if;
  end if;
end;

/
ALTER TRIGGER "DEAPP"."TRG_SNP_DATA_DATASET_LOC_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_DE_SNP_INFO_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_DE_SNP_INFO_ID" 
BEFORE
  INSERT ON DE_SNP_INFO FOR EACH ROW
BEGIN
  IF inserting THEN
    IF :NEW.SNP_INFO_ID IS NULL THEN
        SELECT biomart.SEQ_BIO_DATA_ID.nextval INTO :NEW.SNP_INFO_ID FROM dual;
    END IF;
  END IF;
END;

/
ALTER TRIGGER "DEAPP"."TRG_DE_SNP_INFO_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_DE_SNP_PROBE_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_DE_SNP_PROBE_ID" 
BEFORE
  INSERT ON DE_SNP_PROBE FOR EACH ROW
BEGIN
  IF inserting THEN
    IF :NEW.SNP_PROBE_ID IS NULL THEN
        SELECT biomart.SEQ_BIO_DATA_ID.nextval INTO :NEW.SNP_PROBE_ID FROM dual;
    END IF;
  END IF;
END;

/
ALTER TRIGGER "DEAPP"."TRG_DE_SNP_PROBE_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_DE_SNP_PROBE_SORTED_DEF_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_DE_SNP_PROBE_SORTED_DEF_ID" 
before insert on DE_SNP_PROBE_SORTED_DEF
for each row
begin
   if inserting then
      if :NEW.SNP_PROBE_SORTED_DEF_ID is null then
         select biomart.SEQ_bio_DATA_ID.nextval into :NEW.SNP_PROBE_SORTED_DEF_ID from dual;
      end if;
  end if;
end;

/
ALTER TRIGGER "DEAPP"."TRG_DE_SNP_PROBE_SORTED_DEF_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_DE_SUBJECT_SORTED_DEF_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_DE_SUBJECT_SORTED_DEF_ID" 
before insert on DE_SNP_SUBJECT_SORTED_DEF
for each row
begin
if inserting then
if :NEW.SNP_SUBJECT_SORTED_DEF_ID is null then
select BIOMART.SEQ_BIO_DATA_ID.nextval into :NEW.SNP_SUBJECT_SORTED_DEF_ID from dual;
end if;
end if;
end;

/
ALTER TRIGGER "DEAPP"."TRG_DE_SUBJECT_SORTED_DEF_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SNP_SUBJECT_SORTED_DEF_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_SNP_SUBJECT_SORTED_DEF_ID" 
before insert on DE_SNP_SUBJECT_SORTED_DEF
for each row
begin
if inserting then
if :NEW.SNP_SUBJECT_SORTED_DEF_ID is null then
select BIOMART.SEQ_BIO_DATA_ID.nextval into :NEW.SNP_SUBJECT_SORTED_DEF_ID from dual;
end if;
end if;
end;

/
ALTER TRIGGER "DEAPP"."TRG_SNP_SUBJECT_SORTED_DEF_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_DE_SUBJECT_SNP_DATASET_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."TRG_DE_SUBJECT_SNP_DATASET_ID" 
before insert on DE_SUBJECT_SNP_DATASET
for each row
begin
   if inserting then
      if :NEW.SUBJECT_SNP_DATASET_ID is null then
         select BIOMART.SEQ_BIO_DATA_ID.nextval into :NEW.SUBJECT_SNP_DATASET_ID from dual;
      end if;
  end if;
end;

/
ALTER TRIGGER "DEAPP"."TRG_DE_SUBJECT_SNP_DATASET_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger DE_PARENT_CD_TRG
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "DEAPP"."DE_PARENT_CD_TRG" 
BEFORE INSERT ON deapp.de_xtrial_parent_names
FOR EACH ROW
      WHEN (
new.parent_cd is null
      ) BEGIN
  SELECT de_parent_cd_seq.nextval
  INTO :new.parent_cd
  FROM DUAL;
END;





/
ALTER TRIGGER "DEAPP"."DE_PARENT_CD_TRG" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_CZ_FORM_LAYOUT_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_CZ_FORM_LAYOUT_ID" before
  INSERT ON "TM_CZ"."CZ_FORM_LAYOUT" FOR EACH row BEGIN IF inserting THEN IF :NEW."FORM_LAYOUT_ID" IS NULL THEN
  SELECT SEQ_FORM_LAYOUT_ID.nextval INTO :NEW."FORM_LAYOUT_ID" FROM dual;
END IF;
END IF;
END;

/
ALTER TRIGGER "TM_CZ"."TRG_CZ_FORM_LAYOUT_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_CZ_SEQ_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_CZ_SEQ_ID" 
  before insert on CZ_JOB_AUDIT    for each row 
  begin     
    if inserting then       
      if :NEW.SEQ_ID is null then          
        select SEQ_CZ_JOB_AUDIT.nextval into :NEW.SEQ_ID from dual;       
      end if;       
    end if;   
  end;


/
ALTER TRIGGER "TM_CZ"."TRG_CZ_SEQ_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_CZ_JOB_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_CZ_JOB_ID" 
  before insert on CZ_JOB_MASTER    for each row 
  begin     
    if inserting then       
      if :NEW.JOB_ID is null then          
        select SEQ_CZ_JOB_MASTER.nextval into :NEW.JOB_ID from dual;       
      end if;       
    end if;   
  end;


/
ALTER TRIGGER "TM_CZ"."TRG_CZ_JOB_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_CZ_PERSONID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_CZ_PERSONID" 
before insert on "CZ_PERSON"    
for each row 
begin     if inserting then       
if :NEW."PERSON_ID" is null then          
select SEQ_CZ_PERSON_ID.nextval into :NEW."PERSON_ID" from dual;       end if;    end if; end;










/
ALTER TRIGGER "TM_CZ"."TRG_CZ_PERSONID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_CZ_REQ_UPLOAD_FIELD_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_CZ_REQ_UPLOAD_FIELD_ID" before
  INSERT ON "TM_CZ"."CZ_REQUIRED_UPLOAD_FIELD" FOR EACH row BEGIN IF inserting THEN IF :NEW."REQUIRED_UPLOAD_FIELD_ID" IS NULL THEN
  SELECT SEQ_REQUIRED_UPLOAD_FIELD_ID.nextval INTO :NEW."REQUIRED_UPLOAD_FIELD_ID" FROM dual;
END IF;
END IF;
END;

/
ALTER TRIGGER "TM_CZ"."TRG_CZ_REQ_UPLOAD_FIELD_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_CZ_TEST_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_CZ_TEST_ID" 
before insert on "CZ_TEST"    for each row 
begin     if inserting then       
if :NEW."TEST_ID" is null then          
select SEQ_CZ.nextval into :NEW."TEST_ID" from dual;       end if;       end if;   end;



/
ALTER TRIGGER "TM_CZ"."TRG_CZ_TEST_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_CZ_TEST_CATEGORY_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_CZ_TEST_CATEGORY_ID" 
before insert on "CZ_TEST_CATEGORY"    for each row 
begin     if inserting then       
if :NEW."TEST_CATEGORY_ID" is null then          
select SEQ_CZ.nextval into :NEW."TEST_CATEGORY_ID" from dual;       end if;       end if;   end;



/
ALTER TRIGGER "TM_CZ"."TRG_CZ_TEST_CATEGORY_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_CZ_TEST_RESULT_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_CZ_TEST_RESULT_ID" 
before insert on "CZ_TEST_RESULT"    for each row 
begin     if inserting then       
if :NEW."TEST_RESULT_ID" is null then          
select SEQ_CZ.nextval into :NEW."TEST_RESULT_ID" from dual;       end if;       end if;   end;



/
ALTER TRIGGER "TM_CZ"."TRG_CZ_TEST_RESULT_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_XTRIAL_CTRL_VOCAB_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_XTRIAL_CTRL_VOCAB_ID" 
before insert on "CZ_XTRIAL_CTRL_VOCAB"    for each row 
begin     if inserting then       
if :NEW."CTRL_VOCAB_ID" is null then          
select SEQ_CZ.nextval into :NEW."CTRL_VOCAB_ID" from dual;       end if;       end if;   end;



/
ALTER TRIGGER "TM_CZ"."TRG_XTRIAL_CTRL_VOCAB_ID" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PROBESET_DEAPP
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_PROBESET_DEAPP" 
before insert on "PROBESET_DEAPP"    
	for each row begin     
		if inserting then       
			if :NEW."PROBESET_ID" is null then
				select SEQ_PROBESET_ID.nextval into :NEW."PROBESET_ID" from dual;       
			end if;   
		end if; 
	end;



/
ALTER TRIGGER "TM_CZ"."TRG_PROBESET_DEAPP" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_ETL_ID
--------------------------------------------------------

  CREATE OR REPLACE TRIGGER "TM_LZ"."TRG_ETL_ID" 
  before INSERT ON LZ_SRC_ANALYSIS_METADATA FOR EACH row 
  BEGIN IF inserting THEN IF :NEW.ETL_ID IS NULL THEN
  SELECT SEQ_ETL_ID.nextval INTO :NEW.ETL_ID FROM dual;
END IF;
END IF;
END;

/
ALTER TRIGGER "TM_LZ"."TRG_ETL_ID" ENABLE;
--------------------------------------------------------
--  DDL for Function FM_FILE_UID
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "FMAPP"."FM_FILE_UID" (
  FILE_ID NUMBER
) RETURN VARCHAR2 AS
BEGIN
  -- $Id$
  -- Creates uid for bio_concept_code.

  RETURN 'FIL:' || FILE_ID;
END FM_FILE_UID;

/
--------------------------------------------------------
--  DDL for Function FM_FOLDER_UID
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "FMAPP"."FM_FOLDER_UID" (
  FOLDER_ID NUMBER
) RETURN VARCHAR2 AS
BEGIN
  -- $Id$
  -- Creates uid for bio_concept_code.

  RETURN 'FOL:' || FOLDER_ID;
END FM_FOLDER_UID;

/
--------------------------------------------------------
--  DDL for Function FM_GET_FOLDER_FULL_NAME
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "FMAPP"."FM_GET_FOLDER_FULL_NAME" (
  p_folder_id number
)
return nvarchar2
as
  v_parent_id number;
  v_folder_full_name nvarchar2(1000);
begin

  select parent_id into v_parent_id
  from fm_folder
  where folder_id = p_folder_id;

  v_folder_full_name := fm_folder_uid(p_folder_id) || '\';

  while v_parent_id is not null
  loop
    v_folder_full_name := fm_folder_uid(v_parent_id) || '\' || v_folder_full_name;

    select parent_id into v_parent_id
    from fm_folder
    where folder_id = v_parent_id;
  end loop;

  v_folder_full_name := '\' || v_folder_full_name;

  return v_folder_full_name;
end;

/
--------------------------------------------------------
--  DDL for Function ID_TO_TAG
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "FMAPP"."ID_TO_TAG" (p_id number)
return varchar
as
  v_id number := p_id;
  v_mod number;
  v_tag_char char;
  v_digits constant varchar2(36) := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  v_tag varchar2(50) := '';

begin

  if p_id = 0 then
    v_tag := '0';
  end if;

  while v_id != 0 loop
    v_mod := v_id mod 36;
    v_tag_char := substr(v_digits, v_mod + 1, 1);
    v_tag := v_tag_char || v_tag;
    v_id := floor(v_id / 36);
  end loop;

  return v_tag;

end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."STANDARD" AUTHID CURRENT_USER is              -- careful on this line; SED edit occurs!

  /********** Types and subtypes, do not reorder **********/
  type BOOLEAN is (FALSE, TRUE);

  type DATE is DATE_BASE;

  type NUMBER is NUMBER_BASE;
  subtype FLOAT is NUMBER; -- NUMBER(126)
  subtype REAL is FLOAT; -- FLOAT(63)
  subtype "DOUBLE PRECISION" is FLOAT;
  subtype INTEGER is NUMBER(38,0);
  subtype INT is INTEGER;
  subtype SMALLINT is NUMBER(38,0);
  subtype DECIMAL is NUMBER(38,0);
  subtype NUMERIC is DECIMAL;
  subtype DEC is DECIMAL;


  subtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;
  subtype NATURAL is BINARY_INTEGER range 0..2147483647;
  subtype NATURALN is NATURAL not null;
  subtype POSITIVE is BINARY_INTEGER range 1..2147483647;
  subtype POSITIVEN is POSITIVE not null;
  subtype SIGNTYPE is BINARY_INTEGER range '-1'..1;  -- for SIGN functions

  type VARCHAR2 is NEW CHAR_BASE;

  subtype VARCHAR is VARCHAR2;
  subtype STRING is VARCHAR2;

  subtype LONG is VARCHAR2(32760);

  subtype RAW is VARCHAR2;
  subtype "LONG RAW" is RAW(32760);

  subtype ROWID is VARCHAR2(256);

  -- Ansi fixed-length char
  -- Define synonyms for CHAR and CHARN.
  subtype CHAR is VARCHAR2;
  subtype CHARACTER is CHAR;

  type MLSLABEL is new CHAR_BASE;

  -- Large object data types.
  --  binary, character, binary file.
  type  BLOB is BLOB_BASE;
  type  CLOB is CLOB_BASE;
  type  BFILE is BFILE_BASE;

  -- Verbose and NCHAR type names
  subtype "CHARACTER VARYING" is VARCHAR;
  subtype "CHAR VARYING" is VARCHAR;
  subtype "NATIONAL CHARACTER" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHARACTER VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NVARCHAR2" is VARCHAR2 CHARACTER SET NCHAR_CS;
  subtype "CHARACTER LARGE OBJECT" is CLOB;
  subtype "CHAR LARGE OBJECT" is CLOB;
  subtype "NATIONAL CHARACTER LARGE OBJEC" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCHAR LARGE OBJECT" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCLOB" is CLOB CHARACTER SET NCHAR_CS;
  subtype "BINARY LARGE OBJECT" is BLOB;

  subtype pls_integer is binary_integer;

  type TIME is new DATE_BASE;
  type TIMESTAMP is new DATE_BASE;
  type "TIME WITH TIME ZONE" is new DATE_BASE;
  type "TIMESTAMP WITH TIME ZONE" is new DATE_BASE;
  type "INTERVAL YEAR TO MONTH" is new DATE_BASE;
  type "INTERVAL DAY TO SECOND" is new DATE_BASE;

  SUBTYPE TIME_UNCONSTRAINED IS TIME(9);
  SUBTYPE TIME_TZ_UNCONSTRAINED IS TIME(9) WITH TIME ZONE;
  SUBTYPE TIMESTAMP_UNCONSTRAINED IS TIMESTAMP(9);
  SUBTYPE TIMESTAMP_TZ_UNCONSTRAINED IS TIMESTAMP(9) WITH TIME ZONE;
  SUBTYPE YMINTERVAL_UNCONSTRAINED IS INTERVAL YEAR(9) TO MONTH;
  SUBTYPE DSINTERVAL_UNCONSTRAINED IS INTERVAL DAY(9) TO SECOND (9);

  TYPE UROWID IS NEW CHAR_BASE;

  type "TIMESTAMP WITH LOCAL TIME ZONE" is new DATE_BASE;
  subtype timestamp_ltz_unconstrained is timestamp(9) with local time zone;

  subtype BINARY_FLOAT is NUMBER;
  subtype BINARY_DOUBLE is NUMBER;

  -- The following data types are generics, used specially within package
  -- STANDARD and some other Oracle packages.  They are protected against
  -- other use; sorry.  True generic types are not yet part of the language.

  type "<ADT_1>" as object (dummy char(1));
  type "<RECORD_1>" is record (dummy char(1));
  type "<TUPLE_1>" as object (dummy char(1));
  type "<VARRAY_1>" is varray (1) of char(1);
  type "<V2_TABLE_1>" is table of char(1) index by binary_integer;
  type "<TABLE_1>" is table of char(1);
  type "<COLLECTION_1>" is table of char(1);
  type "<REF_CURSOR_1>" is ref cursor;

  -- This will actually match against a Q_TABLE
  type "<TYPED_TABLE>" is table of  "<ADT_1>";
  subtype "<ADT_WITH_OID>" is "<TYPED_TABLE>";

  -- The following generic index table data types are used by the PL/SQL
  -- compiler to materialize an array attribute at the runtime (for more
  -- details about the array attributes, please see Bulk Binds document).
  type " SYS$INT_V2TABLE" is table of pls_integer index by binary_integer;

  -- The following record type and the corresponding generic index table
  -- data types are used by the PL/SQL compiler to materialize a table
  -- at the runtime in order to record the exceptions raised during the
  -- execution of FORALL bulk bind statement (for more details, please
  -- see bulk binds extensions document in 8.2).
  type " SYS$BULK_ERROR_RECORD" is
          record (error_index pls_integer, error_code pls_integer);
  type " SYS$REC_V2TABLE" is table of " SYS$BULK_ERROR_RECORD"
                               index by binary_integer;

  /* Adding a generic weak ref cursor type */
  type sys_refcursor is ref cursor;

  /* the following data type is a generic for all opaque types */
  type "<OPAQUE_1>" as opaque FIXED(1) USING LIBRARY dummy_lib
    (static function dummy return number);

  type "<ASSOC_ARRAY_1>" is table of char(1) index by varchar2(1);

  /********** Add new types or subtypes here **********/

  -- Simple scalar types

  subtype SIMPLE_INTEGER is BINARY_INTEGER NOT NULL;
  subtype SIMPLE_FLOAT   is BINARY_FLOAT   NOT NULL;
  subtype SIMPLE_DOUBLE  is BINARY_DOUBLE  NOT NULL;

  /********** Predefined constants **********/

  BINARY_FLOAT_NAN constant BINARY_FLOAT;
  BINARY_FLOAT_INFINITY constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_SUBNORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_SUBNORMAL constant BINARY_FLOAT;
  BINARY_DOUBLE_NAN constant BINARY_DOUBLE;
  BINARY_DOUBLE_INFINITY constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_SUBNORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_SUBNORMAL constant BINARY_DOUBLE;

  /********** Add new constants here **********/

  /********** Predefined exceptions **********/

  CURSOR_ALREADY_OPEN exception;
    pragma EXCEPTION_INIT(CURSOR_ALREADY_OPEN, '-6511');

  DUP_VAL_ON_INDEX exception;
    pragma EXCEPTION_INIT(DUP_VAL_ON_INDEX, '-0001');

  TIMEOUT_ON_RESOURCE exception;
    pragma EXCEPTION_INIT(TIMEOUT_ON_RESOURCE, '-0051');

  INVALID_CURSOR exception;
    pragma EXCEPTION_INIT(INVALID_CURSOR, '-1001');

  NOT_LOGGED_ON exception;
    pragma EXCEPTION_INIT(NOT_LOGGED_ON, '-1012');

  LOGIN_DENIED exception;
    pragma EXCEPTION_INIT(LOGIN_DENIED, '-1017');

  NO_DATA_FOUND exception;
    pragma EXCEPTION_INIT(NO_DATA_FOUND, 100);

  ZERO_DIVIDE exception;
    pragma EXCEPTION_INIT(ZERO_DIVIDE, '-1476');

  INVALID_NUMBER exception;
    pragma EXCEPTION_INIT(INVALID_NUMBER, '-1722');

  TOO_MANY_ROWS exception;
    pragma EXCEPTION_INIT(TOO_MANY_ROWS, '-1422');

  STORAGE_ERROR exception;
    pragma EXCEPTION_INIT(STORAGE_ERROR, '-6500');

  PROGRAM_ERROR exception;
    pragma EXCEPTION_INIT(PROGRAM_ERROR, '-6501');

  VALUE_ERROR exception;
    pragma EXCEPTION_INIT(VALUE_ERROR, '-6502');

  ACCESS_INTO_NULL exception;
    pragma EXCEPTION_INIT(ACCESS_INTO_NULL, '-6530');

  COLLECTION_IS_NULL exception;
    pragma EXCEPTION_INIT(COLLECTION_IS_NULL , '-6531');

  SUBSCRIPT_OUTSIDE_LIMIT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_OUTSIDE_LIMIT,'-6532');

  SUBSCRIPT_BEYOND_COUNT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_BEYOND_COUNT ,'-6533');

  -- exception for ref cursors
  ROWTYPE_MISMATCH exception;
  pragma EXCEPTION_INIT(ROWTYPE_MISMATCH, '-6504');

  SYS_INVALID_ROWID  EXCEPTION;
  PRAGMA EXCEPTION_INIT(SYS_INVALID_ROWID, '-1410');

  -- The object instance i.e. SELF is null
  SELF_IS_NULL exception;
    pragma EXCEPTION_INIT(SELF_IS_NULL, '-30625');

  CASE_NOT_FOUND exception;
    pragma EXCEPTION_INIT(CASE_NOT_FOUND, '-6592');

  -- Added for USERENV enhancement, bug 1622213.
  USERENV_COMMITSCN_ERROR exception;
    pragma EXCEPTION_INIT(USERENV_COMMITSCN_ERROR, '-1725');

  -- Parallel and pipelined support
  NO_DATA_NEEDED exception;
    pragma EXCEPTION_INIT(NO_DATA_NEEDED, '-6548');
  -- End of 8.2 parallel and pipelined support

  /********** Add new exceptions here **********/

  /********** Function, operators and procedures **********/

  function "EXISTS" return BOOLEAN;
    pragma BUILTIN('EXISTS',10,240,240); -- This is special cased in PH2 -- Pj

  function GREATEST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DATE) return DATE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DATE) return DATE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr NUMBER, pat NUMBER, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER,
                   pat NUMBER,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER, pat NUMBER, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr DATE, pat DATE, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE,
                   pat DATE,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE, pat DATE, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function SQLCODE return PLS_INTEGER;
    pragma BUILTIN('SQLCODE',45, 10, 0); -- PEMS_DB, DB_SQLCODE

  function SQLERRM return varchar2;
    pragma FIPSFLAG('SQLERRM', 1452);

  function SQLERRM (code PLS_INTEGER) return varchar2;
    pragma BUILTIN('SQLERRM',46, 10, 1); -- PEMS_DB, DB_SQLERRM
    pragma FIPSFLAG('SQLERRM', 1452);

  function LEVEL return NUMBER;

  function ROWNUM return NUMBER;

  function '='  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('=',2, 3, 1); -- PEMS_INTEGER, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN; -- also <> and ~=
    pragma BUILTIN('!=',5, 3, 2); -- PEMS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<',4, 3, 3);  -- PEMS_INTEGER, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<=',6, 3, 4); -- PEMS_INTEGER, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>',1, 3, 5); -- PEMS_INTEGER, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>=',3, 3, 6); -- PEMS_INTEGER, PEMDMGE
    pragma FIPSFLAG('>=', 1450);

  --  Since SQL permits short-circuit evaluation, the 'and' and 'or'
  --  operations will always be interpreted as 'and then' and 'or else'
  --  when they occur in conditional statements.

  function XOR (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('XOR',8, 3, 9); -- PEMS_INTEGER, INT_XOR
    pragma FIPSFLAG('XOR', 1450);

  function 'NOT' (RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('NOT',9, 3, 10); -- PEMS_INTEGER, INT_NOT

  function 'IS NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);  -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50); -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 BOOLEAN, B2 BOOLEAN) return BOOLEAN;
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('=',2, 1, 14); -- PEMS_CHAR, PEMDCMEQ (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('=', 1454);
  function '!=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('!=',5, 1, 15);  -- PEMS_CHAR, PEMDCMNE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('!=', 1454);
  function '<'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<',4, 1, 16); -- PEMS_CHAR, PEMDCMLT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<', 1454);
  function '<=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<=',6, 1, 17); -- PEMS_CHAR, PEMDCMLE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<=', 1454);
  function '>'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>',1, 1, 18); -- PEMS_CHAR, PEMDCMGT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>', 1454);
  function '>=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>=',3, 1, 19); -- PEMS_CHAR, PEMDCMGE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>=', 1454);

  function '||' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN('||',25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT VARCHAR2 CHARACTER SET ANY_CS,
                  RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN(CONCAT,25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG(CONCAT, 1454);

  function LENGTH(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH', 1452);
  -- In SUBSTR, LEN defaults to remainder of string
  -- In substr and instr, a negative value of parameter POS means to
  -- count from the right end of the string.
  function SUBSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  POS PLS_INTEGER,
                  LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  -- Find nth occurrence of str1 in str2 starting at pos
  function INSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);
  function LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);
  function ASCII(ch VARCHAR2 CHARACTER SET ANY_CS)
        return PLS_INTEGER; -- should be ASCII.CHRANGE
    pragma FIPSFLAG('ASCII', 1452);
  function ASCIISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('ASCIISTR', 1452);
  function UNISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return NVARCHAR2;
    pragma FIPSFLAG('UNISTR', 1452);
  function CHR(n PLS_INTEGER) return varchar2;  -- N should be ASCII.CHRANGE
    pragma FIPSFLAG('CHR', 1452);
  function " SYS$STANDARD_CHR"(n PLS_INTEGER,csn VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET csn%CHARSET;
    pragma FIPSFLAG(' SYS$STANDARD_CHR', 1452);
  function INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('INITCAP', 1452);
  function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('SOUNDEX', 1452);

  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);
  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
  pragma FIPSFLAG('LPAD', 1452);

  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);
  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                     SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
                     DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('TRANSLATE', 1452);

  function REPLACE(SRCSTR VARCHAR2 CHARACTER SET ANY_CS,
                   OLDSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET := NULL)
        return VARCHAR2 CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);
  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);
  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'IS NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20);  -- PEMS_CHAR, PEMDNUL
  function 'IS NOT NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50); -- PEMS_CHAR, PEMDNUL

  function NVL(s1 VARCHAR2 CHARACTER SET ANY_CS,
               s2 VARCHAR2 CHARACTER SET s1%CHARSET)
        return VARCHAR2 CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);


  function '='  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 1); -- PEMS_NUMBER, PEMDCMEQ
  function '!=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 2); -- PEMS_NUMBER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 3); -- PEMS_NUMBER, PEMDCMLT
  function '<=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 4); -- PEMS_NUMBER, PEMDCMLE
  function '>'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 5); -- PEMS_NUMBER, PEMDCMGT
  function '>=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 6); -- PEMS_NUMBER, PEMDCMGE

  function 'IS NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_NUMBER, PEMDNUL

  function NVL(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 7); -- PEMS_NUMBER, NUM_NEG
  function ABS(n NUMBER) return NUMBER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 2, 8); -- PEMS_NUMBER, NUM_ADD
  function '-' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 9); -- PEMS_NUMBER, NUM_SUB
  function '*' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('*',17, 2, 10); -- PEMS_NUMBER, NUM_MUL
  function '/' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('/',18, 2, 11); -- PEMS_NUMBER, NUM_DIV

  function 'REM' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(n NUMBER) return NUMBER;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(n NUMBER) return NUMBER;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(n NUMBER) return NUMBER;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(n NUMBER) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COS', 1452);
  function SIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SIN', 1452);
  function TAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TAN', 1452);
  function COSH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COSH', 1452);
  function SINH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SINH', 1452);
  function TANH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TANH', 1452);

  function EXP(N NUMBER) return NUMBER;
  function LN(N NUMBER) return NUMBER;

  function BITAND (LEFT pls_integer, RIGHT pls_integer)
        return pls_integer;
  function BITAND (LEFT integer, RIGHT integer)
        return integer;
  function LOG (LEFT NUMBER, RIGHT NUMBER) return NUMBER;

  function TRUNC (n NUMBER, places pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT NUMBER, RIGHT pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (n NUMBER, e NUMBER) return NUMBER;
    pragma FIPSFLAG('POWER', 1452);

  function '='  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('=',2, 12, 1); -- PEMS_DATE, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT DATE, RIGHT DATE) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 12, 2); -- PEMS_DATE, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<',4, 12, 3); -- PEMS_DATE, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<=',6, 12, 4); -- PEMS_DATE, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>',1, 12, 5);  -- PEMS_DATE, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>=',3, 12, 6);  -- PEMS_DATE, PEMDCMGE
    pragma FIPSFLAG('>=', 1450);

  function '+' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('+',14, 12, 7); -- PEMS_DATE, DATE_ADD1
    pragma FIPSFLAG('+', 1450);
  function '+' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('+',14, 12, 8); -- PEMS_DATE, DATE_ADD2
    pragma FIPSFLAG('+', 1450);
  function '-' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('-',15, 12, 9); -- PEMS_DATE, DATE_SUB1
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('-',15, 12, 10); -- PEMS_DATE, DATE_SUB2
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('-',15, 12, 11); -- PEMS_DATE, DATE_SUB3
    pragma FIPSFLAG('-', 1450);

  function LAST_DAY(RIGHT DATE) return DATE;
    pragma BUILTIN('LAST_DAY',38, 12, 12); -- PEMS_DATE, DATE_LAST_DAY
    pragma FIPSFLAG('LAST_DAY', 1450);
  function ADD_MONTHS(LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 13); -- PEMS_DATE, DATE_ADD_MONTHS1
    pragma FIPSFLAG('ADD_MONTHS', 1450);
  function ADD_MONTHS(LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 14); -- PEMS_DATE, DATE_ADD_MONTHS2
    pragma FIPSFLAG('ADD_MONTHS', 1450);

  function MONTHS_BETWEEN(LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('MONTHS_BETWEEN',42, 12, 15); -- PEMS_DATE, DATE_MONTHS_BET
    pragma FIPSFLAG('MONTHS_BETWEEN', 1450);
  function NEXT_DAY(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('NEXT_DAY',43, 12, 16); -- PEMS_DATE, DATE_NEXT_DAY
    pragma FIPSFLAG('NEXT_DAY', 1450);
  function ROUND(RIGHT DATE) return DATE;
    pragma BUILTIN('ROUND',24, 12, 17); -- PEMS_DATE, DATE_ROUND
    pragma FIPSFLAG('ROUND', 1450);
  function NEW_TIME(RIGHT DATE, MIDDLE VARCHAR2, LEFT VARCHAR2) return DATE;
    pragma FIPSFLAG('NEW_TIME', 1450);

  function 'IS NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 12, 0);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 12, 50);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);
  function NVL (d1 DATE, d2 DATE) return DATE;
    pragma FIPSFLAG('NVL', 1450);

  function TRUNC(LEFT DATE) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 20); -- PEMS_DATE, DATE_TRUNC1
    pragma FIPSFLAG('TRUNC', 1450);
  function TRUNC(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 21); -- PEMS_DATE, DATE_TRUNC2
    pragma FIPSFLAG('TRUNC', 1450);
  function ROUND(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('ROUND',24, 12, 22); -- PEMS_DATE, DATE_ROUND2
    pragma FIPSFLAG('ROUND', 1450);

  function TO_DATE    (RIGHT VARCHAR2 character set any_cs)  return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 10); -- PEMS_CHAR, CHR_CNV_DAT
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT VARCHAR2 character set any_cs,
       RIGHT VARCHAR2 character set LEFT%charset) return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 8); -- PEMS_CHAR, CHR_CNV_DATE
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT NUMBER, RIGHT VARCHAR2) return DATE;
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE(left varchar2 character set any_cs,
                   format varchar2 character set LEFT%charset,
                   parms varchar2 character set LEFT%charset) return date;

  function TO_CHAR (RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',14, 0, 2);

  function TO_CHAR (LEFT DATE, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  function TO_CHAR (LEFT NUMBER, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function TO_NUMBER (RIGHT NUMBER) RETURN NUMBER;
    pragma BUILTIN('TO_NUMBER',14, 0, 1); -- PEMS_QUICK

  function TO_NUMBER (RIGHT VARCHAR2 character set any_cs)    return NUMBER;
    pragma BUILTIN('TO_NUMBER',48, 1, 9); -- PEMS_CHAR, CHR_CNV_NUM

  function TO_NUMBER(left varchar2 character set any_cs,
        format varchar2 character set LEFT%charset)
    return number;
  function TO_NUMBER(left varchar2 character set any_cs,
                     format varchar2 character set LEFT%charset,
                     parms varchar2 character set LEFT%charset)
    return number;

  -- Define SQL predicates.  These don't gen code, so no body is needed.

  -- PRIOR is WEIRD - For now, it will be treated as a function call.
  -- Does the function only take a column name?  how about its use in
  -- a predicate?
  function 'PRIOR'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname NUMBER) return NUMBER;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname DATE) return DATE;
      pragma FIPSFLAG('PRIOR', 1450);

  -- Outer Join has same problem as PRIOR
  function '(+)'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
  function '(+)'(colname NUMBER) return NUMBER;
  function '(+)'(colname DATE) return DATE;
      pragma FIPSFLAG('(+)', 1450);

  function '=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ANY', 1450);
  function '=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ANY', 1450);
  function '!=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ANY', 1450);
  function '<ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ANY', 1450);
  function '<=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ANY', 1450);
  function '>ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ANY', 1450);
  function '>=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ALL', 1450);
  function '=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ALL', 1450);
  function '!=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ALL', 1450);
  function '<ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ALL', 1450);
  function '<=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ALL', 1450);
  function '>ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ALL', 1450);
  function '>=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=SOME', 1450);
  function '=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=SOME', 1450);
  function '!=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<SOME', 1450);
  function '<SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=SOME', 1450);
  function '<=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>SOME', 1450);
  function '>SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=SOME', 1450);
  function '>=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  -- SQL Transaction routines
  procedure SET_TRANSACTION_USE(vc VARCHAR2);
  procedure COMMIT;
  procedure COMMIT_CM(vc VARCHAR2);
  procedure ROLLBACK_NR;
  procedure ROLLBACK_SV(Save_Point CHAR);
  procedure SAVEPOINT(Save_Point CHAR);

  function SYSDATE return DATE;
    pragma FIPSFLAG('SYSDATE', 1452);

  function UID return PLS_INTEGER;
    pragma FIPSFLAG('UID', 1452);

  function USER return VARCHAR2;

  function USERENV (envstr VARCHAR2) return VARCHAR2;
    pragma FIPSFLAG('USERENV', 1452);

  -- ROWID: this dreadful identifier is supposed to represent a datatype
  -- outside of SQL and and a pseudo-column (function, to us) when inside
  -- a sql statement.  ADA data model doesn't allow for any
  -- function X return X;
  -- so we must special case this.  Yuk.  There's special-case code in ph2nre
  -- which maps "rowid" to "rowid " if we're inside a SQL stmt.
  function "ROWID " return ROWID;
    pragma builtin('ROWID ', 1, 209, 240);  -- this had better never be called.

  function NULLFN (str VARCHAR2) return RAW;
    pragma builtin('NULLFN', 1, 0, 1);

  function HEXTORAW (c VARCHAR2) return RAW;
     pragma builtin('HEXTORAW', 1, 23, 1);

  function RAWTOHEX (r RAW) return VARCHAR2;
     pragma builtin('RAWTOHEX', 1, 23, 2);

  function CHARTOROWID (str VARCHAR2) return ROWID;
    pragma builtin('CHARTOROWID', 1, 0, 1);

  function ROWIDTOCHAR (str ROWID) return VARCHAR2;
    pragma builtin('ROWIDTOCHAR', 1, 0, 1);


  -- Trusted*Oracle additions
  Function ROWLABEL return MLSLABEL;                     -- pseudo column

  Function TO_CHAR(label MLSLABEL, format VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',90, 4, 19); -- PEMS_DATE, MLS_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  Function TO_LABEL(label VARCHAR2, format VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 8); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  Function TO_LABEL(label VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 2); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  -- vararg routines - icds in stdbdy
  Function LEAST_UB    (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('LEAST_UB',90, 4, 3); -- PEMS_CHAR, CHR_CNV_MLS
  Function GREATEST_LB (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('GREATEST_LB',90, 4, 4); -- PEMS_CHAR, CHR_CNV_MLS

  Function '>=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '>'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '='  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '!=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  function 'IS NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20); -- same "cod" as IS NULL(varchar2)
  function 'IS NOT NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50);

  function NVL(label1 MLSLABEL, label2 MLSLABEL) return MLSLABEL;
    pragma FIPSFLAG('NVL', 1452);

  -- group functions
  Function LUB (label MLSLABEL) return MLSLABEL;
  Function GLB (label MLSLABEL) return MLSLABEL;

  -- end of Trusted*Oracle additions


  -- beginning of NLS routines

  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS, c2 VARCHAR2) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS,
                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);

  function LENGTHB(ch VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
    pragma FIPSFLAG('LENGTHB', 1452);
  function SUBSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);
  function INSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  function TO_SINGLE_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_SINGLE_BYTE', 1452);
  function TO_MULTI_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_MULTI_BYTE', 1452);

  -- Next two added for NLS 6/3/92 JEM.
  function TO_CHAR(left date, format varchar2, parms varchar2) return varchar2;
  function TO_CHAR(left number, format varchar2, parms varchar2)
    return varchar2;
  function NLS_CHARSET_NAME(csetid PLS_INTEGER) return VARCHAR2;
  function NLS_CHARSET_ID(csetname VARCHAR2) return PLS_INTEGER;
  function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
    return PLS_INTEGER;

  -- end of NLS routines

  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2)
           return VARCHAR2 character set src%charset;
  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2,
                   srccset VARCHAR2)
          return VARCHAR2 character set src%charset;

  function " SYS$STANDARD_TRANSLATE" (src VARCHAR2 CHARACTER SET ANY_CS,
                                      csn VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET csn%CHARSET;
     pragma FIPSFLAG(' SYS$STANDARD_TRANSLATE',1452);

  function VSIZE (e number ) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e DATE) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);


  -- dump( expr [,display_format[,start_pos[,length]]]) return VARCHAR2
  function DUMP(e varchar2 character set any_cs,
                df pls_integer := null,sp pls_integer := null,
                len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e number,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e date,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  --
  -- ACOS, ASIN, ATAN, ATAN2
  --   Inverse Trigonometric functions
  --   These functions return NULL if any of the inputs are NULL
  --
  function ACOS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x NUMBER, y NUMBER) return NUMBER;
  pragma FIPSFLAG('ATAN2', 1452);

  --#### This is the end of 7.3 Standard

  -- LOB IS NULL
  function 'IS NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);
  -- end LOB IS NULL

  --****************************************************************
  -- 20 mar 96 =G=> In the following, arguments "1, 1, 1" to pragma BUILTIN
  -- e.g.,                pragma builtin('whatever', 1, 1, 1)
  -- indicate that those three numeric arguments to pragma BUILTIN are unknown,
  -- because they are not yet implemented by the backend.

  function '='  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<ADT_1>", pat "<ADT_1>", res "<ADT_1>")
        return "<ADT_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<ADT_1>", B2 "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function VALUE (item "<ADT_WITH_OID>") return "<ADT_1>";
    pragma BUILTIN('VALUE', 1, 1, 1);
    pragma FIPSFLAG('VALUE', 1450);

  function REF (item "<ADT_WITH_OID>") return REF "<ADT_1>";
    pragma BUILTIN('REF', 1, 1, 1);
    pragma FIPSFLAG('REF', 1450);

  function DEREF (r REF "<ADT_1>") return "<ADT_1>";
    pragma BUILTIN('DEREF', 1, 1, 1);
    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF ADT

  function 'IS NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function 'IS DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS DANGLING', 1450);

  function 'IS NOT DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  function NVL (B1 REF "<ADT_1>", B2 REF "<ADT_1>") return REF "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 0, 3, 1);
    pragma FIPSFLAG('=', 1450);

  function '!=' (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 0, 3, 2);
    pragma FIPSFLAG('!=', 1450);

  --  function '='  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('=', 1, 1, 1);
  --    pragma FIPSFLAG('=', 1450);
  --
  --  function '!=' (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('!=', 1, 1, 1);
  --    pragma FIPSFLAG('!=', 1450);
  --
  --  function '=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --
  --  function DECODE (expr "<COLLECTION_1>", pat "<COLLECTION_1>",
  --                                        res "<COLLECTION_1>")
  --      return "<COLLECTION_1>";
  --    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<COLLECTION_1>", B2 "<COLLECTION_1>")
        return "<COLLECTION_1>";
    pragma FIPSFLAG('NVL', 1450);

  function 'IS NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
        return "<REF_CURSOR_1>";
    pragma FIPSFLAG('NVL', 1450);

  function EMPTY_CLOB return clob;
  function EMPTY_BLOB return blob;

  function BFILENAME(directory varchar2,filename varchar2) return BFILE;

  function "SYS$LOB_REPLICATION" (x in blob) return blob;
  function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
    return clob character set x%charset;

  --#### This is the end of 8.0 Standard

  --  + overloadings

  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;

  function '+'(LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_UNCONSTRAINED;

  function '+'(LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_TZ_UNCONSTRAINED;

  function '+'(LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
                return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
                return TIME_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
                return TIME_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return DSINTERVAL_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return YMINTERVAL_UNCONSTRAINED ;

  -- begin subtract
  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return YMINTERVAL_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT" (LEFT TIME_UNCONSTRAINED,
                                      RIGHT TIME_UNCONSTRAINED)
     return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_UNCONSTRAINED ;
  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED ;
  function  " SYS$DSINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date;
  function '-' (LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date;

  function '-' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
   return DSINTERVAL_UNCONSTRAINED ;

  -- end subtract

  -- other datetime operators

  function '*' (LEFT number, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT number, RIGHT DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;

  function '*' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;

  function '/' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '/' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;


  function current_date return date;
  function current_time return TIME_TZ_UNCONSTRAINED;
  function current_timestamp return TIMESTAMP_TZ_UNCONSTRAINED;

  function TO_TIME (RIGHT varchar2 character set any_cs) return
    time_unconstrained;
    pragma BUILTIN('TO_TIME', 0, 15, 1);
    function TO_TIMESTAMP (RIGHT varchar2 character set any_cs)
                           return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 3);
  function TO_TIME_TZ (RIGHT varchar2 character set any_cs)
    return  TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 5);
  function TO_TIMESTAMP_TZ (RIGHT varchar2 character set any_cs)
    return  TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 7);
  function TO_YMINTERVAL (RIGHT varchar2 character set any_cs)
    return  YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_YMINTERVAL', 0, 15, 9);
  function TO_DSINTERVAL (RIGHT varchar2 character set any_cs)
    return  DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_DSINTERVAL', 0, 15, 11);

  -- with nls args
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset,
                   parms varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset,
                        parms varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset,
                           parms varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset,
                      parms varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_DSINTERVAL(RIGHT varchar2 character set any_cs,
                         parms varchar2 character set RIGHT%charset)
    return DSINTERVAL_UNCONSTRAINED;

  function NUMTOYMINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return YMINTERVAL_UNCONSTRAINED;
  function NUMTODSINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return DSINTERVAL_UNCONSTRAINED;

  function '='  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('=',0, 11, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',0, 11, 2);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<',0, 11, 3);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<=',0, 11, 4);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>',0, 11, 5);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>=',0, 11, 6);
    pragma FIPSFLAG('>=', 1450);

  function 'IS NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 14, 0); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 14, 50); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function "UROWID " return UROWID;
    pragma builtin('UROWID ', 1, 209, 240);  -- this had better never be called.

  -- New built-in function SYS_GUID, returns globally unique id
  function SYS_GUID return RAW;

  -- New built-in function SYS_CONTEXT
  function SYS_CONTEXT (namespace varchar2, attribute varchar2)
    return varchar2;

  function TRIM(v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  --#### This is the end of 8.1.5 Standard

  -- SYS_CONTEXT now has an additional optional parameter
  function SYS_CONTEXT(namespace varchar2, attribute varchar2,
                       newoptional varchar2)
    return varchar2;

  -- CUBE and ROLLUP are not real functions; they are variants on the GROUP
  -- BY clause (GROUP BY CUBE (...) and GROUP BY ROLLUP (...)). They have
  -- been added here as functions to avoid name capture issues.
  --
  -- Note that both CUBE and ROLLUP look like true vararg functions with
  -- *no* repeating pattern of formals - hence they are special cased in
  -- the overloading code.
  function CUBE return NUMBER;
  function ROLLUP return NUMBER;

  -- The GROUPING function must be used in conjunction with CUBE and ROLLUP
  -- in the GROUP BY clause. The type of the parameter to GROUPING can be
  -- any type that can appear in a GROUP BY list.
  function GROUPING(v VARCHAR2) return NUMBER;
  function GROUPING(a "<ADT_1>") return NUMBER;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 VARCHAR2 CHARACTER SET ANY_CS ,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   VARCHAR2 CHARACTER SET ANY_CS ,
                                 TSET   VARCHAR2 CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  --#### This is the end of the supported parts of 8.1.6 Standard

  --## Support for ANSI datetime data types is under development.
  --## The following operations, as well as the related types and
  --## operations defined above in the 8.1.5 section, are not yet
  --## available for use and are still subject to change.

  --- datetime equivalence
  function '='  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function TO_TIME (RIGHT TIME_TZ_UNCONSTRAINED)  return TIME_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME', 0, 15, 13);
  function TO_TIME_TZ (RIGHT TIME_UNCONSTRAINED)  return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 14);
  function TO_TIMESTAMP (RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 15);
  function TO_TIMESTAMP_TZ (RIGHT TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 16);

  function '-'
      (LEFT TIME_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  -- timezone functions
  function SYS_AT_TIME_ZONE(t time_tz_unconstrained,
                            i varchar2) RETURN time_tz_unconstrained;
  function SYS_AT_TIME_ZONE(t timestamp_tz_unconstrained,
                            i varchar2) RETURN timestamp_tz_unconstrained;
  FUNCTION systimestamp RETURN timestamp_tz_unconstrained;
  FUNCTION dbtimezone RETURN varchar2;
  FUNCTION sessiontimezone RETURN varchar2;
  FUNCTION localtimestamp RETURN timestamp_unconstrained;
  FUNCTION localtime RETURN time_unconstrained;

  function TO_TIMESTAMP (RIGHT DATE)  return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 17);

  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT yminterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '+'(LEFT dsinterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return yminterval_unconstrained;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;

  function '='  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;

  function SYS_LITERALTOYMINTERVAL(numerator varchar2, units varchar2)
    return YMINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTODSINTERVAL(numerator varchar2, units varchar2)
    return DSINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTOTIME(numerator varchar2)
    return TIME_UNCONSTRAINED;
  function SYS_LITERALTOTZTIME(numerator varchar2)
    return TIME_TZ_UNCONSTRAINED;
  function SYS_LITERALTOTIMESTAMP(numerator varchar2)
    return TIMESTAMP_UNCONSTRAINED;
  function SYS_LITERALTOTZTIMESTAMP(numerator varchar2)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function SYS_LITERALTODATE(numerator varchar2) return DATE;


  -- Explicit conversions between date and datetime
  function TO_TIMESTAMP(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 24);

  function TO_TIMESTAMP_TZ(ARG DATE) return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 27);

  function TO_TIMESTAMP_TZ(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 26);

  -- IS [NOT] NULL / NVL for datetime
  function 'IS NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_UNCONSTRAINED,
                b2 TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;

  function 'IS NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_TZ_UNCONSTRAINED, b2 TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_UNCONSTRAINED,
                b2 TIMESTAMP_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_TZ_UNCONSTRAINED, b2 TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_LTZ_UNCONSTRAINED,
                b2 TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;

  function 'IS NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 YMINTERVAL_UNCONSTRAINED, b2 YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;

  function 'IS NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 DSINTERVAL_UNCONSTRAINED, b2 DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  function " SYS$EXTRACT_FROM"
              (T TIME_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T DATE,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I YMINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I DSINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;

  -- ##########      8.2 LOB Built-in Functions       ######## --

  -- LENGTH --
  function LENGTH(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  function LENGTH(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  -- SUBSTR --
  function SUBSTR(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  function SUBSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);

  -- INSTR --
  function INSTR(STR1 CLOB CHARACTER SET ANY_CS,
                 STR2 CLOB CHARACTER SET STR1%CHARSET,
                 POS INTEGER := 1,
                 NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function INSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  STR2 CLOB CHARACTER SET STR1%CHARSET,
                  POS INTEGER := 1,
                  NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  -- CONCAT --
  function '||' (LEFT CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT CLOB CHARACTER SET ANY_CS,
                  RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG(CONCAT, 1454);

  -- UPPER --
  function UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);

  -- LOWER --
  function LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);

  -- LPAD --
  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  -- RPAD --
  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  -- LTRIM --
  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  -- RTRIM --
  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  -- TRIM --
  function TRIM(v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 CLOB CHARACTER SET ANY_CS ,
                               TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   CLOB CHARACTER SET ANY_CS ,
                                 TSET   CLOB CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;


  -- LIKE --
  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  -- NVL --
  function NVL(s1 CLOB CHARACTER SET ANY_CS,
               s2 CLOB CHARACTER SET s1%CHARSET)
    return CLOB CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);

  -- REPLACE --
  function REPLACE(SRCSTR CLOB CHARACTER SET ANY_CS,
                   OLDSUB CLOB CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB CLOB CHARACTER SET SRCSTR%CHARSET := NULL)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  -- LOB RELATIONAL OPERATORS --

  Function '='  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;

  /* LOB-related conversion functions */
  function TO_CLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS) return CLOB;
    pragma BUILTIN('TO_CLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  function TO_BLOB(RIGHT RAW) return BLOB;
    pragma BUILTIN('TO_BLOB', 0, 15, 30); -- OPC_CVT_RAW2BLB
  function TO_RAW(RIGHT BLOB) return RAW;
    pragma BUILTIN('TO_RAW', 0, 15, 32); -- OPC_CVT_BLB2RAW

  -- ####### end of 8.2 LOB Built-in Functions  ######## --

  function NULLIF(v1 VARCHAR2, v2 VARCHAR2) return VARCHAR2;
  function NULLIF(v1 BOOLEAN, v2 BOOLEAN) return VARCHAR2;
  function NULLIF(a1 "<ADT_1>", a2 "<ADT_1>") return VARCHAR2;

  function COALESCE return VARCHAR2;

  /* Daylight Saving Time Functions */
  FUNCTION tz_offset(region VARCHAR2)  RETURN VARCHAR2;
  FUNCTION from_tz(t TIMESTAMP_UNCONSTRAINED,timezone VARCHAR2)
    RETURN timestamp_tz_unconstrained;

  function " SYS$EXTRACT_STRING_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;

  function INSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR2', 1452);

  function INSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR4', 1452);

  function INSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRC', 1452);

  function LENGTH2(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH2', 1452);

  function LENGTH4(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH4', 1452);

  function LENGTHC(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTHC', 1452);

  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function SUBSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR2', 1452);

  function SUBSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR4', 1452);

  function SUBSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRC', 1452);

  /**** char <--> nchar conversion functions in Unicode project ********/

  function TO_NCHAR(RIGHT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',14, 0, 2);

  function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB;
  function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB;

  function TO_NCLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return NCLOB;
    pragma BUILTIN('TO_NCLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  /* convert to either CLOB or NCLOB respectively if parm is char or nchar */
  function TO_ANYLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET RIGHT%CHARSET;
    pragma BUILTIN('TO_ANYLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB

  /* Followings are the same builtin op codes as without N prefix functions,
   * implementation relys on impilcit conversion MCODEs
   */
  function TO_NCHAR (LEFT DATE, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_NCHAR', 1450);
  function TO_NCHAR (LEFT NUMBER, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function NHEXTORAW (c NVARCHAR2) return RAW;
    pragma builtin('NHEXTORAW', 1, 23, 1);
  function RAWTONHEX (r RAW) return NVARCHAR2;
    pragma builtin('RAWTONHEX', 1, 23, 2);
  function NCHARTOROWID (str NVARCHAR2) return ROWID;
    pragma builtin('NCHARTOROWID', 1, 0, 1);
  function ROWIDTONCHAR (str ROWID) return NVARCHAR2;
    pragma builtin('ROWIDTONCHAR', 1, 0, 1);

  function NCHR(n pls_integer) return NVARCHAR2;

  /* implemented by icd calls as the same as TO_CHAR */
  function TO_NCHAR(left date, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left number, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  /* implemented as a icd call, return TRUE if nchar, otherwise FALSE */
  function ISNCHAR(c VARCHAR2 character set any_cs) return boolean;

  /************ end of char <--> nchar conversion functions ************/

  /* Create overloads for all standard functions that work with <ADT_1> for
     <OPAQUE_1> */
  function '='  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<OPAQUE_1>", pat "<OPAQUE_1>", res "<OPAQUE_1>")
    return "<OPAQUE_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<OPAQUE_1>", B2 "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('NVL', 1450);

  --  REFs to opaques are not supported yet.
  --  function VALUE (item "<ADT_WITH_OID>") return "<OPAQUE_1>";
  --    pragma BUILTIN('VALUE', 1, 1, 1);
  --    pragma FIPSFLAG('VALUE', 1450);

  --  function REF (item "<ADT_WITH_OID>") return REF "<OPAQUE_1>";
  --    pragma BUILTIN('REF', 1, 1, 1);
  --    pragma FIPSFLAG('REF', 1450);

  --  function DEREF (r REF "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('DEREF', 1, 1, 1);
  --    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF OPAQUE

  --  function 'IS NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NULL', 0, 3, 0);
  --    pragma FIPSFLAG('IS NULL', 1450);

  --  function 'IS NOT NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma FIPSFLAG('IS NOT NULL', 1450);

  --  function 'IS DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS DANGLING', 1450);

  --  function 'IS NOT DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
  --    return REF "<OPAQUE_1>";
  --    pragma FIPSFLAG('NVL', 1450);

  --  function '='  (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('=', 0, 3, 1);
  --    pragma FIPSFLAG('=', 1450);

  --  function '!=' (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('!=', 0, 3, 2);
  --    pragma FIPSFLAG('!=', 1450);

  function GROUPING(a "<OPAQUE_1>") return NUMBER;
  function NULLIF(a1 "<OPAQUE_1>", a2 "<OPAQUE_1>") return VARCHAR2;

  function GREATEST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIME_TZ_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj

  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;

  -- CONVERT FOR LOB --
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2,
                   SRCCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;

  -- NLS_UPPER/NLS_LOWER FOR LOB --
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);

  function COMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS)
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('COMPOSE', 1452);
  function DECOMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS,
                     canmode in VARCHAR2 DEFAULT 'CANONICAL')
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('DECOMPOSE', 1452);
  FUNCTION SYS_EXTRACT_UTC(t timestamp_tz_unconstrained)
    return TIMESTAMP_UNCONSTRAINED;

  -- Begin REGEXP Support (10iR1) --

  -- REGEXP_LIKE --
  function REGEXP_LIKE (srcstr   VARCHAR2 CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  function REGEXP_LIKE (srcstr   CLOB CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  -- REGEXP_INSTR --
  function REGEXP_INSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        occurrence  PLS_INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);

  function REGEXP_INSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        occurrence  INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);


  -- REGEXP_SUBSTR --
  function REGEXP_SUBSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    PLS_INTEGER := 1,
                         occurrence  PLS_INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  function REGEXP_SUBSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    INTEGER := 1,
                         occurrence  INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  -- REGEXP_REPLACE --
  function REGEXP_REPLACE(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    PLS_INTEGER := 1,
                          occurrence  PLS_INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  CLOB CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  -- End REGEXP Support --

  -- binary_float and binary_double functions and operators.
  function TO_BINARY_FLOAT (RIGHT BINARY_FLOAT) RETURN BINARY_FLOAT;
    pragma BUILTIN('TO_BINARY_FLOAT',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;

  function TO_BINARY_DOUBLE (RIGHT BINARY_DOUBLE) RETURN BINARY_DOUBLE;
    pragma BUILTIN('TO_BINARY_DOUBLE',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;

  function 'IS NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;

  function TO_CHAR (left binary_float, format varchar2)
    return VARCHAR2;
  function TO_CHAR (left binary_double, format varchar2)
    return VARCHAR2;

  function TO_CHAR(left binary_float, format varchar2, parms varchar2)
    return varchar2;
  function TO_CHAR(left binary_double, format varchar2, parms varchar2)
    return varchar2;

  function TO_NCHAR(left binary_float, format nvarchar2) return NVARCHAR2;
  function TO_NCHAR(left binary_double, format nvarchar2) return NVARCHAR2;

  function TO_NCHAR(left binary_float, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left binary_double, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  function 'REMAINDER'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG(REMAINDER, 1452);

  function '='  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 15);
  function '!=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('!=',5, 2, 16);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 17);
  function '<=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 18);
  function '>'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 19);
  function '>=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 20);

  function 'IS NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 23);
  function ABS(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 2, 24);
  function '-' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 25);
  function '*' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('*',17, 2, 26);
  function '/' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('/',18, 2, 27);

  function 'REM' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(F1 BINARY_FLOAT, F2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('MOD', 1452);

  function FLOOR(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('CEIL', 1452);
  function SIGN(f BINARY_FLOAT) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);
  function SQRT(f BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('SQRT', 1452);

  function TRUNC (F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ROUND', 1452);

  function '='  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 28);
  function '!=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 29);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 30);
  function '<=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 31);
  function '>'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 32);
  function '>=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 33);

  function 'IS NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 36);
  function ABS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ABS', 1452);

  function ACOS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x BINARY_DOUBLE, y BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN2', 1452);

  function '+' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 2, 37);
  function '-' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 38);
  function '*' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('*',17, 2, 39);
  function '/' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('/',18, 2, 40);

  function 'REM' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(D1 BINARY_DOUBLE, D2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(d BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(d BINARY_DOUBLE) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function COSH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SINH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TANH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function EXP(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function LN(D BINARY_DOUBLE) return BINARY_DOUBLE;

  function LOG (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;

  function TRUNC (D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (d BINARY_DOUBLE, e BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('POWER', 1452);

  function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER;
  function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
  function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;

  function GREATEST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function GREATEST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2


  function '+' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',15, 2, 41);
  function ABS(I PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 2, 42);
  function '-' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',14, 2, 43);
  function '*' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('*',14, 2, 44);

  function '='  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 45); -- PEMS_PLS_INTEGER, PEMDCMEQ
  function '!=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 46); -- PEMS_PLS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 47); -- PEMS_PLS_INTEGER, PEMDCMLT
  function '<=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 48); -- PEMS_PLS_INTEGER, PEMDCMLE
  function '>'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 49); -- PEMS_PLS_INTEGER, PEMDCMGT
  function '>=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 51); -- PEMS_PLS_INTEGER, PEMDCMGE

  function 'IS NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_PLS_INTEGER, PEMDNUL
  function 'IS NOT NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_PLS_INTEGER, PEMDNUL

  function NVL(I1 PLS_INTEGER, I2 PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('NVL', 1452);

  function TRUNC (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('ROUND', 1452);

  function SIGN(i PLS_INTEGER) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);

  function GREATEST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2

  -- MultiSet Functions and Operators.

  -- Equality
  function '='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('=',2, 16, 1);

  function '!='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('!=',2, 16, 2);

  function CARDINALITY (collection IN "<TABLE_1>") return PLS_INTEGER;

  function SET (collection IN "<TABLE_1>") return "<TABLE_1>";
    pragma BUILTIN('SET',18, 2, 40);-- Dummy

  function 'IS A SET' (collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS A SET',18, 2, 40);-- Dummy
  function 'IS NOT A SET'(collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT A SET',18, 2, 40);-- Dummy

  function 'IS EMPTY' (collection IN  "<TABLE_1>") return BOOLEAN;
  function 'IS NOT EMPTY'(collection IN  "<TABLE_1>") return BOOLEAN;

  -- IS A SUBMULTISET OF
  function 'SUBMULTISET' (collection IN  "<TABLE_1>",
                          collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('SUBMULTISET',18, 2, 40);

  function 'MULTISET_UNION_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
      pragma BUILTIN('MULTISET_UNION_ALL',18, 2, 40);

  function 'MULTISET_UNION_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_UNION_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_DISTINCT',18, 2, 40);-- Dummy

  -- These are dummy procedures for correct management of new control
  -- statements added to PL/SQL. They ensure local procedures which have the
  -- same names as newly introduced keywords are not masked by those keywords.

  procedure continue;

  -- REGEXP_COUNT --
  function REGEXP_COUNT(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  function REGEXP_COUNT(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  --#### All user-visible declarations should preceed this point.  The
  --#### following are implementation-oriented pragmas that may need
  --#### editing in the future; we would prefer to be able to edit them
  --#### without affecting the rft numbering of user-visible items.

  --#### interface pragmas

  --#### Note that for any ICD which maps directly to a PVM
  --#### Opcode MUST be mapped to pes_dummy.
  --#### An ICD which invokes another ICD by flipping operands is
  --#### mapped to pes_flip, and an ICD whose result is the inverse of
  --#### another ICD is mapped to pes_invert
  --#### New ICDs should be placed at the end of this list, and a
  --#### corresponding entry must be made in the ICD table in pdz7

  PRAGMA interface(c,length,"pes_dummy",1);
  PRAGMA interface(c,substr,"pes_dummy",1);
  PRAGMA interface(c,instr,"pesist",1);
  PRAGMA interface(c,UPPER,"pesupp",1);
  PRAGMA interface(c,LOWER,"peslow",1);
  PRAGMA interface(c,ASCII,"pesasc");
  PRAGMA interface(c,ASCIISTR,"pesastr");
  PRAGMA interface(c,UNISTR,"pesustr");
  PRAGMA interface(c,CHR,"peschr");
  PRAGMA interface(c," SYS$STANDARD_CHR","peschr");
  PRAGMA interface(c,INITCAP,"pesicp");
  PRAGMA interface(c,LPAD,"peslpd",1);
  PRAGMA interface(c,LPAD,"peslpd",2);
  PRAGMA interface(c,RPAD,"pesrpd",1);
  PRAGMA interface(c,RPAD,"pesrpd",2);
  PRAGMA interface(c,REPLACE,"pesrep",1);
  PRAGMA interface(c,LTRIM,"pesltr",1);
  PRAGMA interface(c,LTRIM,"pesltr",2);
  PRAGMA interface(c,RTRIM,"pesrtr",1);
  PRAGMA interface(c,RTRIM,"pesrtr",2);
  PRAGMA interface(c,'LIKE',"peslik",1);
  PRAGMA interface(c,'LIKE',"pesli2",2);
  PRAGMA interface(c,ABS,"pes_dummy",1);
  PRAGMA interface(c,'MOD',"pesmod", 1);
  PRAGMA interface(c,floor,"pesflo", 1);
  PRAGMA interface(c,CEIL,"pescei", 1);
  PRAGMA interface (c, SQRT, "pessqt", 1);
  PRAGMA interface(c,SIGN,"pessgn", 1);
  PRAGMA interface(c,cos,"pescos", 1);
  PRAGMA interface(c,sin,"pessin",1);
  PRAGMA interface(c,TAN,"pestan",1);
  PRAGMA interface(c,COSH,"pescsh",1);
  PRAGMA interface(c,SINH,"pessnh",1);
  PRAGMA interface(c,TANH,"pestnh",1);
  PRAGMA interface(c,EXP,"pesexp",1);
  PRAGMA interface(c,LN,"pesln",1);
  PRAGMA interface(c,BITAND,"pesbtd",1);
  PRAGMA interface(c,BITAND,"pesbtdn",2);
  PRAGMA interface(c,LOG,"peslog",1);
  PRAGMA interface(c,TRUNC,"pestru",1);
  PRAGMA interface(c,ROUND,"pesrnd",1);
  PRAGMA interface(c,POWER,"pespow",1);
  PRAGMA interface(c,NEW_TIME,"pesnwt");
  PRAGMA interface(c,TO_DATE,"pesc2d",4);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",3);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",4);
  PRAGMA interface(c,'>=',"pes_flip",5);
  PRAGMA interface(c,'>',"pes_flip",5);
  PRAGMA interface(c,'<=',"peszle",5);
  PRAGMA interface(c,'<',"peszlt",5);        -- ICD #50
  PRAGMA interface(c,'=',"peszeq",5);
  PRAGMA interface(c,'!=',"pes_invert",5);
  PRAGMA interface(c,nlssort,"pesxco",2);
  PRAGMA interface(c,NLS_UPPER,"pesxup",1);
  PRAGMA interface(c,NLS_UPPER,"peslcnup",3); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_UPPER,"peslcnup",4); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_LOWER,"pesxlo",1);
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",3); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",4); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_INITCAP,"pesxcp",1);
  PRAGMA interface(c,lengthb,"pes_dummy",1);
  PRAGMA interface(c,substrb,"pes_dummy",1);
  PRAGMA interface(c,instrb,"pesxis",1);
  PRAGMA interface(c,TO_SINGLE_BYTE, "pesxsi");
  PRAGMA interface(c,TO_MULTI_BYTE,"pesxmu");
  PRAGMA interface(c,TO_CHAR,"pesd2c",5);
  PRAGMA interface(c,TO_CHAR,"pesn2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesd2c",4);
  PRAGMA interface(c,TO_NCHAR,"pesn2c",5);
  PRAGMA interface(c," SYS$STANDARD_TRANSLATE","pesxcs");
  PRAGMA interface(c,ATAN,"pesatan",1);
  PRAGMA interface(c,EMPTY_CLOB,"peslcem");
  PRAGMA interface(c,EMPTY_BLOB,"peslbem");
  PRAGMA interface(c,BFILENAME,"pesfnm");
  PRAGMA interface(c,TO_TIME,"pes3tm",2);
  PRAGMA interface(c,TO_TIME,"pes3tm",3);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",2);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",3);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",2);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",3);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",2);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",3);
  PRAGMA interface(c,TO_DSINTERVAL,"pes2dsi",2);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",1);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",2);
  PRAGMA interface(c,SESSIONTIMEZONE,"pesstz",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",2);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",3);
  PRAGMA interface(c,TRIM,"pestrim",1);
  -- Datetime addition
  PRAGMA interface(c,'+',"pesati",5);    --  +(tsp, iym) return tsp
  PRAGMA interface(c,'+',"pesati",6);    --  +(tsp, ids) return tsp
  PRAGMA interface(c,'+',"pesati",7);    --  +(tsz, iym) return tsz
  PRAGMA interface(c,'+',"pesati",8);    --  +(tsz, ids) return tsz
  PRAGMA interface(c,'+',"pesati",9);    --  +(tim, ids) return tim
  PRAGMA interface(c,'+',"pesati",10);   --  +(tmz, ids) return tmz
  PRAGMA interface(c,'+',"pesadi",11);   --  +(dat, iym) return dat
  PRAGMA interface(c,'+',"pesadi",12);   --  +(dat, ids) return dat
  PRAGMA interface(c,'+',"pes_flip",13); --  +(iym, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",14); --  +(iym, tsz) return tsz -- ICD #100
  PRAGMA interface(c,'+',"pes_flip",15); --  +(iym, dat) return dat
  PRAGMA interface(c,'+',"pes_flip",16); --  +(ids, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",17); --  +(ids, tsz) return tsz
  PRAGMA interface(c,'+',"pes_flip",18); --  +(ids, tim) return tim
  PRAGMA interface(c,'+',"pes_flip",19); --  +(ids, tmz) return tmz
  PRAGMA interface(c,'+',"pes_flip",20); --  +(ids, dat) return dat
  PRAGMA interface(c,'+',"pesaii",21);   --  +(ids, ids) return ids
  PRAGMA interface(c,'+',"pesaii",22);   --  +(iym, iym) return iym
  PRAGMA interface(c,'+',"pesati",23);   --  +(ltz, iym) return ltz
  PRAGMA interface(c,'+',"pesati",24);   --  +(ltz, ids) return ltz
  PRAGMA interface(c,'+',"pes_flip",25);--  +(iym, ltz) return ltz
  PRAGMA interface(c,'+',"pes_flip",26);--  +(ids, ltz) return ltz
  -- Datetime subtraction
  PRAGMA interface(c,'-',"pessti",6);    --  -(tsp, iym) return tsp
  PRAGMA interface(c,'-',"pessti",7);    --  -(tsp, ids) return tsp
  PRAGMA interface(c,'-',"pessti",8);    --  -(tsz, iym) return tsz
  PRAGMA interface(c,'-',"pessti",9);    --  -(tsz, ids) return tsz
  PRAGMA interface(c,'-',"pessti",10);   --  -(tim, ids) return tim
  PRAGMA interface(c,'-',"pessti",11);   --  -(tmz, ids) return tmz
  PRAGMA interface(c,'-',"pessdi",12);   --  -(dat, iym) return dat
  PRAGMA interface(c,'-',"pessdi",13);   --  -(dat, ids) return dat
  PRAGMA interface(c,'-',"pessii",14);   --  -(iym, iym) return iym
  PRAGMA interface(c,'-',"pessii",15);   --  -(ids, ids) return ids
  PRAGMA interface(c,'-',"pessttds",16); --  -(tim, tim) return ids
  PRAGMA interface(c,'-',"pessttds",17); --  -(tsp, tsp) return ids
  PRAGMA interface(c,'-',"pessttds",18); --  -(tmz, tmz) return ids
  PRAGMA interface(c,'-',"pessttds",19); --  -(tsz, tsz) return ids
  PRAGMA interface(c,'-',"pessti",20);   --  -(ltz, iym) return iym
  PRAGMA interface(c,'-',"pessti",21);   --  -(ltz, ids) return ids
  PRAGMA interface(c,'-',"pessttds",22); --  -(ltz, ltz) return ids
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",1);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",2);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",3);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",4);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessddds",5);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",6);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",1);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",2);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessddym",3);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",4);
  -- Datetime multiplication
  PRAGMA interface(c,'*',"pesmni",2);    --  *(num, iym) return iym
  PRAGMA interface(c,'*',"pesmni",3);    --  *(num, ids) return ids
  PRAGMA interface(c,'*',"pes_flip",4);  --  *(iym, num) return iym
  PRAGMA interface(c,'*',"pes_flip",5);  --  *(ids, num) return ids
  -- Datetime division
  PRAGMA interface(c,'/',"pesdvin",2);   --  /(iym, num) return iym
  PRAGMA interface(c,'/',"pesdvin",3);   --  /(ids, num) return ids
  -- TIME
  PRAGMA interface(c,'=',"pes_dummy",9);
  PRAGMA interface(c,'!=',"pes_invert",9);
  PRAGMA interface(c,'>',"pes_flip",8);
  PRAGMA interface(c,'<',"pes_dummy",8);
  PRAGMA interface(c,'>=',"pes_flip",8);   -- ICD #150
  PRAGMA interface(c,'<=',"pes_dummy",8);
  -- TIME WITH TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",10);
  PRAGMA interface(c,'!=',"pes_invert",10);
  PRAGMA interface(c,'>',"pes_flip",9);
  PRAGMA interface(c,'<',"pes_dummy",9);
  PRAGMA interface(c,'>=',"pes_flip",9);
  PRAGMA interface(c,'<=',"pes_dummy",9);
  -- TIMESTAMP
  PRAGMA interface(c,'=',"pes_dummy",11);
  PRAGMA interface(c,'!=',"pes_invert",11);
  PRAGMA interface(c,'>',"pes_flip",10);
  PRAGMA interface(c,'<',"pes_dummy",10);
  PRAGMA interface(c,'>=',"pes_flip",10);
  PRAGMA interface(c,'<=',"pes_dummy",10);
  -- INTERVAL YEAR TO MONTH
  PRAGMA interface(c,'=',"pes_dummy",12);
  PRAGMA interface(c,'!=',"pes_invert",12);
  PRAGMA interface(c,'>',"pes_flip",11);
  PRAGMA interface(c,'<',"pes_dummy",11);
  PRAGMA interface(c,'>=',"pes_flip",11);
  PRAGMA interface(c,'<=',"pes_dummy",11);
  -- INTERVAL DAY TO SECOND
  PRAGMA interface(c,'=',"pes_dummy",13);
  PRAGMA interface(c,'!=',"pes_invert",13);
  PRAGMA interface(c,'>',"pes_flip",12);
  PRAGMA interface(c,'<',"pes_dummy",12);
  PRAGMA interface(c,'>=',"pes_flip",12);
  PRAGMA interface(c,'<=',"pes_dummy",12);
  -- TIMESTAMP_TZ_UNCONSTRAINED
  PRAGMA interface(c,'=',"pes_dummy",14);
  PRAGMA interface(c,'!=',"pes_invert",14);
  PRAGMA interface(c,'>',"pes_flip",13);
  PRAGMA interface(c,'<',"pes_dummy",13);
  PRAGMA interface(c,'>=',"pes_flip",13);
  PRAGMA interface(c,'<=',"pes_dummy",13);
  -- TIMESTAMP WITH LOCAL TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",15);
  PRAGMA interface(c,'!=',"pes_invert",15);
  PRAGMA interface(c,'>',"pes_flip",14);
  PRAGMA interface(c,'<',"pes_dummy",14);
  PRAGMA interface(c,'>=',"pes_flip",14);
  PRAGMA interface(c,'<=',"pes_dummy",14);
  -- Other datetime functions
  PRAGMA interface(c,'CURRENT_DATE',"pescdt",1);
  PRAGMA interface(c,'CURRENT_TIME',"pesctm",1);
  PRAGMA interface(c,'CURRENT_TIMESTAMP',"pescts",1);
  --  Internal calls to evaluate datetime/interval literals without NLS parms.
  PRAGMA interface(c,SYS_LITERALTOYMINTERVAL,"pesc2ymi",1);
  PRAGMA interface(c,SYS_LITERALTODSINTERVAL,"pesc2dsi",1);
  PRAGMA interface(c,SYS_LITERALTOTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTODATE,"pesc2date",1);
  -- extract(field from expr)
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",1);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",2);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",3);   -- ICD #200
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",4);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",5);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefdt",6);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",7);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",8);
  -- datetime is null
  PRAGMA interface(c,"IS NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NULL","pes_dummy",20); -- interval ds

  -- 8.2 LOB Built-in Functions
  PRAGMA interface(c,length, "peslcln",2);    -- LOB LENGTH
  PRAGMA interface(c,lengthb,"peslclb",2);    -- LOB LENGTHB
  PRAGMA interface(c,substr, "peslcst",2);    -- LOB SUBSTR
  PRAGMA interface(c,substrb,"peslcsb",2);    -- LOB SUBSTRB
  PRAGMA interface(c,instr,  "peslcin",2);    -- LOB INSTR
  PRAGMA interface(c,instrb, "peslcib",2);    -- LOB INSTRB
  PRAGMA interface(c,'||',   "peslcct",2);    -- LOB '||'
  PRAGMA interface(c,concat, "peslcct",2);    -- LOB CONCAT
  PRAGMA interface(c,lpad,   "peslclp",3);    -- LOB LPAD
  PRAGMA interface(c,lpad,   "peslclp",4);    -- LOB LPAD
  PRAGMA interface(c,rpad,   "peslcrp",3);    -- LOB RPAD
  PRAGMA interface(c,rpad,   "peslcrp",4);    -- LOB RPAD
  PRAGMA interface(c,lower,  "peslclr",2);    -- LOB LOWER
  PRAGMA interface(c,upper,  "peslcup",2);    -- LOB UPPER
  PRAGMA interface(c,ltrim,  "peslclm",3);    -- LOB LTRIM
  PRAGMA interface(c,ltrim,  "peslclm",4);    -- LOB LTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",3);    -- LOB RTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",4);    -- LOB RTRIM
  PRAGMA interface(c,trim,   "peslctr",2);    -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",4); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",5); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",6); -- LOB TRIM
  PRAGMA interface(c,'LIKE', "peslclk",3);    -- LOB LIKE
  PRAGMA interface(c,'LIKE', "peslcl2",4);    -- LOB LIKE
  PRAGMA interface(c,nvl,"peslcnl",17);       -- LOB NVL
  PRAGMA interface(c,replace, "peslcrl",2);   -- LOB REPLACE

     -- LOB Relational Operators
     -- LHS: CLOB,    RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_dummy",16);     -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",16);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",15);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pes_dummy",15);     -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",15);      -- LOB '>='
  PRAGMA interface(c,'<=',"pes_dummy",15);       -- LOB '<='
     -- LHS: CLOB,     RHS:VARCHAR2
  PRAGMA interface(c,'=' ,"pesleq2",17);       -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",17);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",16);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt2",16);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",16);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle2",16);       -- LOB '<='  -- ICD #250
     -- LHS: VARCHAR2, RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_flip",18);      -- LOB '='
  PRAGMA interface(c,'!=',"pes_flip",18);      -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",17);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt3",17);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",17);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle3",17);       -- LOB '<='

  PRAGMA interface(c,length, "peslbln",3);    -- BLOB LENGTH
  PRAGMA interface(c,lengthb,"peslblb",3);    -- BLOB LENGTHB
  -- End of 8.2 LOB Built-in Functions


  PRAGMA interface(c,tz_offset,"pestzo",1);
  PRAGMA interface(c,from_tz,"pesftz",1);

  PRAGMA interface(c,ISNCHAR,"pesinc", 1);

  PRAGMA interface(c,CONVERT,"pescnv", 1);
  PRAGMA interface(c,CONVERT,"pescnv", 2);
  PRAGMA interface(c,CONVERT,"peslccnv", 3);  -- LOB CONVERT
  PRAGMA interface(c,CONVERT,"peslccnv", 4);  -- LOB CONVERT

  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",1);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",2);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",3);

  PRAGMA interface(c,TO_CHAR,"pesdtm2c",7); -- datetime
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",8);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",9);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",10);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",11);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",12);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",13);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",14);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",15);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",16);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",17); -- interval
  PRAGMA interface(c,TO_CHAR,"pesitv2c",18);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",19);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",20);

  --#### new_names pragmas

  -- This is an internal pragma that restricts the use
  -- of particular new entries in package standard.
  -- It is only valid in package standard.
  -- Note that left out of the 8.1.5 set are non datetime
  -- entries urowid, "UROWID ", self_is_null and trim.

  pragma new_names('8.1.5',
                   time,"TIME WITH TIME ZONE",
                   timestamp,"TIMESTAMP WITH TIME ZONE",
                   "INTERVAL DAY TO SECOND",
                   "INTERVAL YEAR TO MONTH",
                   to_time, to_timestamp,
                   to_time_tz, to_timestamp_tz,
                   " SYS$DSINTERVALSUBTRACT",
                   " SYS$YMINTERVALSUBTRACT",
                   to_yminterval,to_dsinterval,
                   NUMTOYMINTERVAL, NUMTODSINTERVAL,
                   current_date,
                   current_time,current_timestamp);

  pragma new_names('8.1.6',
                   dbtimezone, sessiontimezone, localtimestamp,
                   localtime,
                   cube, rollup, grouping, "TIMESTAMP WITH LOCAL TIME ZONE");

  -- Should there be a 8.2 new names pragma ?

  -- 8.2 UCS2/UCS4/Complete Built-in Functions

  PRAGMA interface(c,INSTR2,"pesist2",1);
  PRAGMA interface(c,INSTR4,"pesist4",1);
  PRAGMA interface(c,INSTRC,"pesistc",1);

  PRAGMA interface(c,LENGTH2,"peslen2",1);
  PRAGMA interface(c,LENGTH4,"peslen4",1);
  PRAGMA interface(c,LENGTHC,"peslenc",1);

  PRAGMA interface(c,LIKE2,"peslik2",1);
  PRAGMA interface(c,LIKE2,"pesli22",2);
  PRAGMA interface(c,LIKE4,"peslik4",1);
  PRAGMA interface(c,LIKE4,"pesli42",2);
  PRAGMA interface(c,LIKEC,"peslikc",1);
  PRAGMA interface(c,LIKEC,"peslic2",2);

  PRAGMA interface(c,SUBSTR2,"pes_dummy",1);
  PRAGMA interface(c,SUBSTR4,"pes_dummy",1);
  PRAGMA interface(c,SUBSTRC,"pes_dummy",1);
  PRAGMA interface(c,SYS_EXTRACT_UTC,"pessexu");
  PRAGMA interface(c,COMPOSE,"pescomp");
  PRAGMA interface(c,DECOMPOSE,"pesdcmp");



  -- End of 8.2 UCS2/UCS4/Complete Built-in Functions

  -- Begin REGEXP support (10iR1) --
  PRAGMA interface(c,regexp_like,    "pes_dummy",1);
  PRAGMA interface(c,regexp_instr,   "pes_dummy",1);    -- ICD #300
  PRAGMA interface(c,regexp_substr,  "pes_dummy",1);
  PRAGMA interface(c,regexp_replace, "pes_dummy",1);
  PRAGMA interface(c,regexp_count,   "pes_dummy",1);
  PRAGMA interface(c,regexp_like,    "pes_dummy",2);    -- LOB REGEXP_LIKE
  PRAGMA interface(c,regexp_instr,   "pes_dummy",2);    -- LOB REGEXP_INSTR
  PRAGMA interface(c,regexp_substr,  "pes_dummy",2);    -- LOB REGEXP_SUBSTR
  PRAGMA interface(c,regexp_replace, "pes_dummy",2);    -- LOB REGEXP_REPLACE
  PRAGMA interface(c,regexp_count,   "pes_dummy",2);    -- LOB REGEXP_COUNT
  PRAGMA interface(c,regexp_replace, "pes_dummy",3);    -- LOB REGEXP_REPLACE

  -- End of REGEXP Built-in Functions --


  -- 10i Binary Floating-point Built-in Functions

  PRAGMA interface(c,"IS NAN","pesnanf",2);
  PRAGMA interface(c,"IS NAN","pesnand",3);
  PRAGMA interface(c,"IS INFINITE","pesinf",1);
  PRAGMA interface(c,"IS INFINITE","pesinff",2);
  PRAGMA interface(c,"IS INFINITE","pesinfd",3);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",2);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",3);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",2);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",3);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",21);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",22);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",23);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",24);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",7);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",8);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",9);
  PRAGMA interface(c,'REMAINDER',"pesrem", 1);
  PRAGMA interface(c,REMAINDER,"pesrem", 2);
  PRAGMA interface(c,'REMAINDER',"pesremf", 3);
  PRAGMA interface(c,REMAINDER,"pesremf", 4);
  PRAGMA interface(c,'REMAINDER',"pesremd", 5);
  PRAGMA interface(c,REMAINDER,"pesremd", 6);
  PRAGMA interface(c,ABS,"pes_dummy",2);
  PRAGMA interface(c,ABS,"pes_dummy",3);
  PRAGMA interface(c,ABS,"pes_dummy",4);
  PRAGMA interface(c,ATAN,"pesatand",2);
  PRAGMA interface(c,'MOD',"pesmodf", 2);
  PRAGMA interface(c,'MOD',"pesmodd", 3);
  PRAGMA interface(c,floor,"pesflof", 2);
  PRAGMA interface(c,floor,"pesflod", 3);
  PRAGMA interface(c,CEIL,"pesceif", 2);
  PRAGMA interface(c,CEIL,"pesceid", 3);
  PRAGMA interface (c, SQRT, "pessqtf", 2);
  PRAGMA interface (c, SQRT, "pessqtd", 3);
  PRAGMA interface(c,SIGN,"pessgnf", 2);
  PRAGMA interface(c,SIGN,"pessgnd", 3);
  PRAGMA interface(c,SIGN,"pessgni", 4);
  PRAGMA interface(c,cos,"pescosd", 2);
  PRAGMA interface(c,sin,"pessind",2);
  PRAGMA interface(c,TAN,"pestand",2);
  PRAGMA interface(c,COSH,"pescshd",2);
  PRAGMA interface(c,SINH,"pessnhd",2);   -- ICD #350
  PRAGMA interface(c,TANH,"pestnhd",2);
  PRAGMA interface(c,EXP,"pesexpd",2);
  PRAGMA interface(c,LN,"peslnd",2);
  PRAGMA interface(c,LOG,"peslogd",2);
  PRAGMA interface(c,TRUNC,"pestruf",4);
  PRAGMA interface(c,TRUNC,"pestrud",5);
  PRAGMA interface(c,TRUNC,"pestrui",6);
  PRAGMA interface(c,ROUND,"pesrndf",4);
  PRAGMA interface(c,ROUND,"pesrndd",5);
  PRAGMA interface(c,ROUND,"pesrndi",6);
  PRAGMA interface(c,POWER,"pespowd",2);

  -- End of 10i Binary Floating-point Built-in Functions

  -- ICDs for MULTISET

  PRAGMA interface(c,CARDINALITY,"pesmcnt");
  PRAGMA interface(c,"IS EMPTY","pesmie");
  PRAGMA interface(c,"IS NOT EMPTY","pes_invert",1);
  -- ICDs which used to be in the body of standard, but which new COG can
  -- handle directly

  -- NOT (some ICD)
  PRAGMA interface(c,NOT_LIKE,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",3);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",4);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",3);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",1);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",2);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",3);

  -- datetime is not null
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",20); -- interval ds

  -- Misc
  PRAGMA interface(c,"**",   "pespow",1);    -- number
  PRAGMA interface(c,"**",   "pespowd",2);   -- binary double
  PRAGMA interface(c,"ACOS", "pesacosd",2);  -- binary double
  PRAGMA interface(c,"ASIN", "pesasind",2);  -- binary double
  PRAGMA interface(c,"ATAN2","pesatn2d",2);  -- binary double

  -- All the flavors of NVL
  PRAGMA interface(c,nvl,"pes_dummy",1);       -- Boolean -- ICD #400
  PRAGMA interface(c,nvl,"pes_dummy",2);       -- Varchar2
  PRAGMA interface(c,nvl,"pes_dummy",3);       -- Number
  PRAGMA interface(c,nvl,"pes_dummy",4);       -- Date
  PRAGMA interface(c,nvl,"pes_dummy",5);       -- MLSLabel
  PRAGMA interface(c,nvl,"pes_dummy",6);       -- ADT
  PRAGMA interface(c,nvl,"pes_dummy",7);       -- Ref ADT
  PRAGMA interface(c,nvl,"pes_dummy",8);       -- Collection

--  Ref Cursor has problems. The MOVCR instruction needs more information than
--  the other MOV* instructions, including the PVM register of the destination
--  This cannot be easily supplied through the generic NVL instruction, so
--  for now, this flavor will continue to have a real body
--  PRAGMA interface(c,nvl,"pes_dummy",9);       -- Ref Cursor

  PRAGMA interface(c,nvl,"pes_dummy",10);       -- Time
  PRAGMA interface(c,nvl,"pes_dummy",11);       -- Time-tz
  PRAGMA interface(c,nvl,"pes_dummy",12);       -- Timestamp
  PRAGMA interface(c,nvl,"pes_dummy",13);       -- Timestamp-tz
  PRAGMA interface(c,nvl,"pes_dummy",14);       -- Timestamp-ltz
  PRAGMA interface(c,nvl,"pes_dummy",15);       -- Intervalym
  PRAGMA interface(c,nvl,"pes_dummy",16);       -- Intervalds
--  PRAGMA interface(c,nvl,"pes_dummy",17);       -- Clob (Handled above, ICD)
  PRAGMA interface(c,nvl,"pes_dummy",18);       -- Opaque
  PRAGMA interface(c,nvl,"pes_dummy",19);       -- Binaryfloat
  PRAGMA interface(c,nvl,"pes_dummy",20);       -- Binarydouble
  PRAGMA interface(c,nvl,"pes_dummy",21);       -- PLSInteger

  -- The following pragma overrides any other setting of the timestamp,
  -- and is used so that we recognize the client-side and server-side instances
  -- of package STANDARD as being the same.  Package STANDARD is special in
  -- that it is really the root of the PL/SQL dependencies graph; as such it
  -- itself doesn't ever need recompiling due to changes to things below it.
  -- The pragma mechanism used here is currently ignored except for
  -- package STANDARD, but in future may not be.  Do NOT add similar pragmas
  -- to your own code as it may in future interfere with the package
  -- consistency maintenance mechanisms and could have dire results.

  --#### timestamp pragma (please keep this last)
  pragma TIMESTAMP('2006-04-18:00:00:00');
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."STANDARD" AUTHID CURRENT_USER is              -- careful on this line; SED edit occurs!

  /********** Types and subtypes, do not reorder **********/
  type BOOLEAN is (FALSE, TRUE);

  type DATE is DATE_BASE;

  type NUMBER is NUMBER_BASE;
  subtype FLOAT is NUMBER; -- NUMBER(126)
  subtype REAL is FLOAT; -- FLOAT(63)
  subtype "DOUBLE PRECISION" is FLOAT;
  subtype INTEGER is NUMBER(38,0);
  subtype INT is INTEGER;
  subtype SMALLINT is NUMBER(38,0);
  subtype DECIMAL is NUMBER(38,0);
  subtype NUMERIC is DECIMAL;
  subtype DEC is DECIMAL;


  subtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;
  subtype NATURAL is BINARY_INTEGER range 0..2147483647;
  subtype NATURALN is NATURAL not null;
  subtype POSITIVE is BINARY_INTEGER range 1..2147483647;
  subtype POSITIVEN is POSITIVE not null;
  subtype SIGNTYPE is BINARY_INTEGER range '-1'..1;  -- for SIGN functions

  type VARCHAR2 is NEW CHAR_BASE;

  subtype VARCHAR is VARCHAR2;
  subtype STRING is VARCHAR2;

  subtype LONG is VARCHAR2(32760);

  subtype RAW is VARCHAR2;
  subtype "LONG RAW" is RAW(32760);

  subtype ROWID is VARCHAR2(256);

  -- Ansi fixed-length char
  -- Define synonyms for CHAR and CHARN.
  subtype CHAR is VARCHAR2;
  subtype CHARACTER is CHAR;

  type MLSLABEL is new CHAR_BASE;

  -- Large object data types.
  --  binary, character, binary file.
  type  BLOB is BLOB_BASE;
  type  CLOB is CLOB_BASE;
  type  BFILE is BFILE_BASE;

  -- Verbose and NCHAR type names
  subtype "CHARACTER VARYING" is VARCHAR;
  subtype "CHAR VARYING" is VARCHAR;
  subtype "NATIONAL CHARACTER" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHARACTER VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NVARCHAR2" is VARCHAR2 CHARACTER SET NCHAR_CS;
  subtype "CHARACTER LARGE OBJECT" is CLOB;
  subtype "CHAR LARGE OBJECT" is CLOB;
  subtype "NATIONAL CHARACTER LARGE OBJEC" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCHAR LARGE OBJECT" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCLOB" is CLOB CHARACTER SET NCHAR_CS;
  subtype "BINARY LARGE OBJECT" is BLOB;

  subtype pls_integer is binary_integer;

  type TIME is new DATE_BASE;
  type TIMESTAMP is new DATE_BASE;
  type "TIME WITH TIME ZONE" is new DATE_BASE;
  type "TIMESTAMP WITH TIME ZONE" is new DATE_BASE;
  type "INTERVAL YEAR TO MONTH" is new DATE_BASE;
  type "INTERVAL DAY TO SECOND" is new DATE_BASE;

  SUBTYPE TIME_UNCONSTRAINED IS TIME(9);
  SUBTYPE TIME_TZ_UNCONSTRAINED IS TIME(9) WITH TIME ZONE;
  SUBTYPE TIMESTAMP_UNCONSTRAINED IS TIMESTAMP(9);
  SUBTYPE TIMESTAMP_TZ_UNCONSTRAINED IS TIMESTAMP(9) WITH TIME ZONE;
  SUBTYPE YMINTERVAL_UNCONSTRAINED IS INTERVAL YEAR(9) TO MONTH;
  SUBTYPE DSINTERVAL_UNCONSTRAINED IS INTERVAL DAY(9) TO SECOND (9);

  TYPE UROWID IS NEW CHAR_BASE;

  type "TIMESTAMP WITH LOCAL TIME ZONE" is new DATE_BASE;
  subtype timestamp_ltz_unconstrained is timestamp(9) with local time zone;

  subtype BINARY_FLOAT is NUMBER;
  subtype BINARY_DOUBLE is NUMBER;

  -- The following data types are generics, used specially within package
  -- STANDARD and some other Oracle packages.  They are protected against
  -- other use; sorry.  True generic types are not yet part of the language.

  type "<ADT_1>" as object (dummy char(1));
  type "<RECORD_1>" is record (dummy char(1));
  type "<TUPLE_1>" as object (dummy char(1));
  type "<VARRAY_1>" is varray (1) of char(1);
  type "<V2_TABLE_1>" is table of char(1) index by binary_integer;
  type "<TABLE_1>" is table of char(1);
  type "<COLLECTION_1>" is table of char(1);
  type "<REF_CURSOR_1>" is ref cursor;

  -- This will actually match against a Q_TABLE
  type "<TYPED_TABLE>" is table of  "<ADT_1>";
  subtype "<ADT_WITH_OID>" is "<TYPED_TABLE>";

  -- The following generic index table data types are used by the PL/SQL
  -- compiler to materialize an array attribute at the runtime (for more
  -- details about the array attributes, please see Bulk Binds document).
  type " SYS$INT_V2TABLE" is table of pls_integer index by binary_integer;

  -- The following record type and the corresponding generic index table
  -- data types are used by the PL/SQL compiler to materialize a table
  -- at the runtime in order to record the exceptions raised during the
  -- execution of FORALL bulk bind statement (for more details, please
  -- see bulk binds extensions document in 8.2).
  type " SYS$BULK_ERROR_RECORD" is
          record (error_index pls_integer, error_code pls_integer);
  type " SYS$REC_V2TABLE" is table of " SYS$BULK_ERROR_RECORD"
                               index by binary_integer;

  /* Adding a generic weak ref cursor type */
  type sys_refcursor is ref cursor;

  /* the following data type is a generic for all opaque types */
  type "<OPAQUE_1>" as opaque FIXED(1) USING LIBRARY dummy_lib
    (static function dummy return number);

  type "<ASSOC_ARRAY_1>" is table of char(1) index by varchar2(1);

  /********** Add new types or subtypes here **********/

  -- Simple scalar types

  subtype SIMPLE_INTEGER is BINARY_INTEGER NOT NULL;
  subtype SIMPLE_FLOAT   is BINARY_FLOAT   NOT NULL;
  subtype SIMPLE_DOUBLE  is BINARY_DOUBLE  NOT NULL;

  /********** Predefined constants **********/

  BINARY_FLOAT_NAN constant BINARY_FLOAT;
  BINARY_FLOAT_INFINITY constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_SUBNORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_SUBNORMAL constant BINARY_FLOAT;
  BINARY_DOUBLE_NAN constant BINARY_DOUBLE;
  BINARY_DOUBLE_INFINITY constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_SUBNORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_SUBNORMAL constant BINARY_DOUBLE;

  /********** Add new constants here **********/

  /********** Predefined exceptions **********/

  CURSOR_ALREADY_OPEN exception;
    pragma EXCEPTION_INIT(CURSOR_ALREADY_OPEN, '-6511');

  DUP_VAL_ON_INDEX exception;
    pragma EXCEPTION_INIT(DUP_VAL_ON_INDEX, '-0001');

  TIMEOUT_ON_RESOURCE exception;
    pragma EXCEPTION_INIT(TIMEOUT_ON_RESOURCE, '-0051');

  INVALID_CURSOR exception;
    pragma EXCEPTION_INIT(INVALID_CURSOR, '-1001');

  NOT_LOGGED_ON exception;
    pragma EXCEPTION_INIT(NOT_LOGGED_ON, '-1012');

  LOGIN_DENIED exception;
    pragma EXCEPTION_INIT(LOGIN_DENIED, '-1017');

  NO_DATA_FOUND exception;
    pragma EXCEPTION_INIT(NO_DATA_FOUND, 100);

  ZERO_DIVIDE exception;
    pragma EXCEPTION_INIT(ZERO_DIVIDE, '-1476');

  INVALID_NUMBER exception;
    pragma EXCEPTION_INIT(INVALID_NUMBER, '-1722');

  TOO_MANY_ROWS exception;
    pragma EXCEPTION_INIT(TOO_MANY_ROWS, '-1422');

  STORAGE_ERROR exception;
    pragma EXCEPTION_INIT(STORAGE_ERROR, '-6500');

  PROGRAM_ERROR exception;
    pragma EXCEPTION_INIT(PROGRAM_ERROR, '-6501');

  VALUE_ERROR exception;
    pragma EXCEPTION_INIT(VALUE_ERROR, '-6502');

  ACCESS_INTO_NULL exception;
    pragma EXCEPTION_INIT(ACCESS_INTO_NULL, '-6530');

  COLLECTION_IS_NULL exception;
    pragma EXCEPTION_INIT(COLLECTION_IS_NULL , '-6531');

  SUBSCRIPT_OUTSIDE_LIMIT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_OUTSIDE_LIMIT,'-6532');

  SUBSCRIPT_BEYOND_COUNT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_BEYOND_COUNT ,'-6533');

  -- exception for ref cursors
  ROWTYPE_MISMATCH exception;
  pragma EXCEPTION_INIT(ROWTYPE_MISMATCH, '-6504');

  SYS_INVALID_ROWID  EXCEPTION;
  PRAGMA EXCEPTION_INIT(SYS_INVALID_ROWID, '-1410');

  -- The object instance i.e. SELF is null
  SELF_IS_NULL exception;
    pragma EXCEPTION_INIT(SELF_IS_NULL, '-30625');

  CASE_NOT_FOUND exception;
    pragma EXCEPTION_INIT(CASE_NOT_FOUND, '-6592');

  -- Added for USERENV enhancement, bug 1622213.
  USERENV_COMMITSCN_ERROR exception;
    pragma EXCEPTION_INIT(USERENV_COMMITSCN_ERROR, '-1725');

  -- Parallel and pipelined support
  NO_DATA_NEEDED exception;
    pragma EXCEPTION_INIT(NO_DATA_NEEDED, '-6548');
  -- End of 8.2 parallel and pipelined support

  /********** Add new exceptions here **********/

  /********** Function, operators and procedures **********/

  function "EXISTS" return BOOLEAN;
    pragma BUILTIN('EXISTS',10,240,240); -- This is special cased in PH2 -- Pj

  function GREATEST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DATE) return DATE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DATE) return DATE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr NUMBER, pat NUMBER, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER,
                   pat NUMBER,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER, pat NUMBER, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr DATE, pat DATE, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE,
                   pat DATE,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE, pat DATE, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function SQLCODE return PLS_INTEGER;
    pragma BUILTIN('SQLCODE',45, 10, 0); -- PEMS_DB, DB_SQLCODE

  function SQLERRM return varchar2;
    pragma FIPSFLAG('SQLERRM', 1452);

  function SQLERRM (code PLS_INTEGER) return varchar2;
    pragma BUILTIN('SQLERRM',46, 10, 1); -- PEMS_DB, DB_SQLERRM
    pragma FIPSFLAG('SQLERRM', 1452);

  function LEVEL return NUMBER;

  function ROWNUM return NUMBER;

  function '='  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('=',2, 3, 1); -- PEMS_INTEGER, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN; -- also <> and ~=
    pragma BUILTIN('!=',5, 3, 2); -- PEMS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<',4, 3, 3);  -- PEMS_INTEGER, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<=',6, 3, 4); -- PEMS_INTEGER, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>',1, 3, 5); -- PEMS_INTEGER, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>=',3, 3, 6); -- PEMS_INTEGER, PEMDMGE
    pragma FIPSFLAG('>=', 1450);

  --  Since SQL permits short-circuit evaluation, the 'and' and 'or'
  --  operations will always be interpreted as 'and then' and 'or else'
  --  when they occur in conditional statements.

  function XOR (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('XOR',8, 3, 9); -- PEMS_INTEGER, INT_XOR
    pragma FIPSFLAG('XOR', 1450);

  function 'NOT' (RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('NOT',9, 3, 10); -- PEMS_INTEGER, INT_NOT

  function 'IS NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);  -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50); -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 BOOLEAN, B2 BOOLEAN) return BOOLEAN;
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('=',2, 1, 14); -- PEMS_CHAR, PEMDCMEQ (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('=', 1454);
  function '!=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('!=',5, 1, 15);  -- PEMS_CHAR, PEMDCMNE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('!=', 1454);
  function '<'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<',4, 1, 16); -- PEMS_CHAR, PEMDCMLT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<', 1454);
  function '<=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<=',6, 1, 17); -- PEMS_CHAR, PEMDCMLE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<=', 1454);
  function '>'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>',1, 1, 18); -- PEMS_CHAR, PEMDCMGT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>', 1454);
  function '>=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>=',3, 1, 19); -- PEMS_CHAR, PEMDCMGE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>=', 1454);

  function '||' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN('||',25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT VARCHAR2 CHARACTER SET ANY_CS,
                  RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN(CONCAT,25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG(CONCAT, 1454);

  function LENGTH(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH', 1452);
  -- In SUBSTR, LEN defaults to remainder of string
  -- In substr and instr, a negative value of parameter POS means to
  -- count from the right end of the string.
  function SUBSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  POS PLS_INTEGER,
                  LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  -- Find nth occurrence of str1 in str2 starting at pos
  function INSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);
  function LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);
  function ASCII(ch VARCHAR2 CHARACTER SET ANY_CS)
        return PLS_INTEGER; -- should be ASCII.CHRANGE
    pragma FIPSFLAG('ASCII', 1452);
  function ASCIISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('ASCIISTR', 1452);
  function UNISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return NVARCHAR2;
    pragma FIPSFLAG('UNISTR', 1452);
  function CHR(n PLS_INTEGER) return varchar2;  -- N should be ASCII.CHRANGE
    pragma FIPSFLAG('CHR', 1452);
  function " SYS$STANDARD_CHR"(n PLS_INTEGER,csn VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET csn%CHARSET;
    pragma FIPSFLAG(' SYS$STANDARD_CHR', 1452);
  function INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('INITCAP', 1452);
  function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('SOUNDEX', 1452);

  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);
  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
  pragma FIPSFLAG('LPAD', 1452);

  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);
  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                     SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
                     DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('TRANSLATE', 1452);

  function REPLACE(SRCSTR VARCHAR2 CHARACTER SET ANY_CS,
                   OLDSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET := NULL)
        return VARCHAR2 CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);
  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);
  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'IS NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20);  -- PEMS_CHAR, PEMDNUL
  function 'IS NOT NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50); -- PEMS_CHAR, PEMDNUL

  function NVL(s1 VARCHAR2 CHARACTER SET ANY_CS,
               s2 VARCHAR2 CHARACTER SET s1%CHARSET)
        return VARCHAR2 CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);


  function '='  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 1); -- PEMS_NUMBER, PEMDCMEQ
  function '!=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 2); -- PEMS_NUMBER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 3); -- PEMS_NUMBER, PEMDCMLT
  function '<=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 4); -- PEMS_NUMBER, PEMDCMLE
  function '>'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 5); -- PEMS_NUMBER, PEMDCMGT
  function '>=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 6); -- PEMS_NUMBER, PEMDCMGE

  function 'IS NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_NUMBER, PEMDNUL

  function NVL(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 7); -- PEMS_NUMBER, NUM_NEG
  function ABS(n NUMBER) return NUMBER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 2, 8); -- PEMS_NUMBER, NUM_ADD
  function '-' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 9); -- PEMS_NUMBER, NUM_SUB
  function '*' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('*',17, 2, 10); -- PEMS_NUMBER, NUM_MUL
  function '/' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('/',18, 2, 11); -- PEMS_NUMBER, NUM_DIV

  function 'REM' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(n NUMBER) return NUMBER;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(n NUMBER) return NUMBER;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(n NUMBER) return NUMBER;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(n NUMBER) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COS', 1452);
  function SIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SIN', 1452);
  function TAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TAN', 1452);
  function COSH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COSH', 1452);
  function SINH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SINH', 1452);
  function TANH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TANH', 1452);

  function EXP(N NUMBER) return NUMBER;
  function LN(N NUMBER) return NUMBER;

  function BITAND (LEFT pls_integer, RIGHT pls_integer)
        return pls_integer;
  function BITAND (LEFT integer, RIGHT integer)
        return integer;
  function LOG (LEFT NUMBER, RIGHT NUMBER) return NUMBER;

  function TRUNC (n NUMBER, places pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT NUMBER, RIGHT pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (n NUMBER, e NUMBER) return NUMBER;
    pragma FIPSFLAG('POWER', 1452);

  function '='  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('=',2, 12, 1); -- PEMS_DATE, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT DATE, RIGHT DATE) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 12, 2); -- PEMS_DATE, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<',4, 12, 3); -- PEMS_DATE, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<=',6, 12, 4); -- PEMS_DATE, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>',1, 12, 5);  -- PEMS_DATE, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>=',3, 12, 6);  -- PEMS_DATE, PEMDCMGE
    pragma FIPSFLAG('>=', 1450);

  function '+' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('+',14, 12, 7); -- PEMS_DATE, DATE_ADD1
    pragma FIPSFLAG('+', 1450);
  function '+' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('+',14, 12, 8); -- PEMS_DATE, DATE_ADD2
    pragma FIPSFLAG('+', 1450);
  function '-' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('-',15, 12, 9); -- PEMS_DATE, DATE_SUB1
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('-',15, 12, 10); -- PEMS_DATE, DATE_SUB2
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('-',15, 12, 11); -- PEMS_DATE, DATE_SUB3
    pragma FIPSFLAG('-', 1450);

  function LAST_DAY(RIGHT DATE) return DATE;
    pragma BUILTIN('LAST_DAY',38, 12, 12); -- PEMS_DATE, DATE_LAST_DAY
    pragma FIPSFLAG('LAST_DAY', 1450);
  function ADD_MONTHS(LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 13); -- PEMS_DATE, DATE_ADD_MONTHS1
    pragma FIPSFLAG('ADD_MONTHS', 1450);
  function ADD_MONTHS(LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 14); -- PEMS_DATE, DATE_ADD_MONTHS2
    pragma FIPSFLAG('ADD_MONTHS', 1450);

  function MONTHS_BETWEEN(LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('MONTHS_BETWEEN',42, 12, 15); -- PEMS_DATE, DATE_MONTHS_BET
    pragma FIPSFLAG('MONTHS_BETWEEN', 1450);
  function NEXT_DAY(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('NEXT_DAY',43, 12, 16); -- PEMS_DATE, DATE_NEXT_DAY
    pragma FIPSFLAG('NEXT_DAY', 1450);
  function ROUND(RIGHT DATE) return DATE;
    pragma BUILTIN('ROUND',24, 12, 17); -- PEMS_DATE, DATE_ROUND
    pragma FIPSFLAG('ROUND', 1450);
  function NEW_TIME(RIGHT DATE, MIDDLE VARCHAR2, LEFT VARCHAR2) return DATE;
    pragma FIPSFLAG('NEW_TIME', 1450);

  function 'IS NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 12, 0);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 12, 50);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);
  function NVL (d1 DATE, d2 DATE) return DATE;
    pragma FIPSFLAG('NVL', 1450);

  function TRUNC(LEFT DATE) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 20); -- PEMS_DATE, DATE_TRUNC1
    pragma FIPSFLAG('TRUNC', 1450);
  function TRUNC(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 21); -- PEMS_DATE, DATE_TRUNC2
    pragma FIPSFLAG('TRUNC', 1450);
  function ROUND(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('ROUND',24, 12, 22); -- PEMS_DATE, DATE_ROUND2
    pragma FIPSFLAG('ROUND', 1450);

  function TO_DATE    (RIGHT VARCHAR2 character set any_cs)  return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 10); -- PEMS_CHAR, CHR_CNV_DAT
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT VARCHAR2 character set any_cs,
       RIGHT VARCHAR2 character set LEFT%charset) return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 8); -- PEMS_CHAR, CHR_CNV_DATE
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT NUMBER, RIGHT VARCHAR2) return DATE;
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE(left varchar2 character set any_cs,
                   format varchar2 character set LEFT%charset,
                   parms varchar2 character set LEFT%charset) return date;

  function TO_CHAR (RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',14, 0, 2);

  function TO_CHAR (LEFT DATE, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  function TO_CHAR (LEFT NUMBER, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function TO_NUMBER (RIGHT NUMBER) RETURN NUMBER;
    pragma BUILTIN('TO_NUMBER',14, 0, 1); -- PEMS_QUICK

  function TO_NUMBER (RIGHT VARCHAR2 character set any_cs)    return NUMBER;
    pragma BUILTIN('TO_NUMBER',48, 1, 9); -- PEMS_CHAR, CHR_CNV_NUM

  function TO_NUMBER(left varchar2 character set any_cs,
        format varchar2 character set LEFT%charset)
    return number;
  function TO_NUMBER(left varchar2 character set any_cs,
                     format varchar2 character set LEFT%charset,
                     parms varchar2 character set LEFT%charset)
    return number;

  -- Define SQL predicates.  These don't gen code, so no body is needed.

  -- PRIOR is WEIRD - For now, it will be treated as a function call.
  -- Does the function only take a column name?  how about its use in
  -- a predicate?
  function 'PRIOR'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname NUMBER) return NUMBER;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname DATE) return DATE;
      pragma FIPSFLAG('PRIOR', 1450);

  -- Outer Join has same problem as PRIOR
  function '(+)'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
  function '(+)'(colname NUMBER) return NUMBER;
  function '(+)'(colname DATE) return DATE;
      pragma FIPSFLAG('(+)', 1450);

  function '=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ANY', 1450);
  function '=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ANY', 1450);
  function '!=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ANY', 1450);
  function '<ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ANY', 1450);
  function '<=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ANY', 1450);
  function '>ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ANY', 1450);
  function '>=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ALL', 1450);
  function '=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ALL', 1450);
  function '!=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ALL', 1450);
  function '<ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ALL', 1450);
  function '<=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ALL', 1450);
  function '>ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ALL', 1450);
  function '>=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=SOME', 1450);
  function '=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=SOME', 1450);
  function '!=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<SOME', 1450);
  function '<SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=SOME', 1450);
  function '<=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>SOME', 1450);
  function '>SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=SOME', 1450);
  function '>=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  -- SQL Transaction routines
  procedure SET_TRANSACTION_USE(vc VARCHAR2);
  procedure COMMIT;
  procedure COMMIT_CM(vc VARCHAR2);
  procedure ROLLBACK_NR;
  procedure ROLLBACK_SV(Save_Point CHAR);
  procedure SAVEPOINT(Save_Point CHAR);

  function SYSDATE return DATE;
    pragma FIPSFLAG('SYSDATE', 1452);

  function UID return PLS_INTEGER;
    pragma FIPSFLAG('UID', 1452);

  function USER return VARCHAR2;

  function USERENV (envstr VARCHAR2) return VARCHAR2;
    pragma FIPSFLAG('USERENV', 1452);

  -- ROWID: this dreadful identifier is supposed to represent a datatype
  -- outside of SQL and and a pseudo-column (function, to us) when inside
  -- a sql statement.  ADA data model doesn't allow for any
  -- function X return X;
  -- so we must special case this.  Yuk.  There's special-case code in ph2nre
  -- which maps "rowid" to "rowid " if we're inside a SQL stmt.
  function "ROWID " return ROWID;
    pragma builtin('ROWID ', 1, 209, 240);  -- this had better never be called.

  function NULLFN (str VARCHAR2) return RAW;
    pragma builtin('NULLFN', 1, 0, 1);

  function HEXTORAW (c VARCHAR2) return RAW;
     pragma builtin('HEXTORAW', 1, 23, 1);

  function RAWTOHEX (r RAW) return VARCHAR2;
     pragma builtin('RAWTOHEX', 1, 23, 2);

  function CHARTOROWID (str VARCHAR2) return ROWID;
    pragma builtin('CHARTOROWID', 1, 0, 1);

  function ROWIDTOCHAR (str ROWID) return VARCHAR2;
    pragma builtin('ROWIDTOCHAR', 1, 0, 1);


  -- Trusted*Oracle additions
  Function ROWLABEL return MLSLABEL;                     -- pseudo column

  Function TO_CHAR(label MLSLABEL, format VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',90, 4, 19); -- PEMS_DATE, MLS_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  Function TO_LABEL(label VARCHAR2, format VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 8); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  Function TO_LABEL(label VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 2); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  -- vararg routines - icds in stdbdy
  Function LEAST_UB    (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('LEAST_UB',90, 4, 3); -- PEMS_CHAR, CHR_CNV_MLS
  Function GREATEST_LB (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('GREATEST_LB',90, 4, 4); -- PEMS_CHAR, CHR_CNV_MLS

  Function '>=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '>'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '='  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '!=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  function 'IS NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20); -- same "cod" as IS NULL(varchar2)
  function 'IS NOT NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50);

  function NVL(label1 MLSLABEL, label2 MLSLABEL) return MLSLABEL;
    pragma FIPSFLAG('NVL', 1452);

  -- group functions
  Function LUB (label MLSLABEL) return MLSLABEL;
  Function GLB (label MLSLABEL) return MLSLABEL;

  -- end of Trusted*Oracle additions


  -- beginning of NLS routines

  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS, c2 VARCHAR2) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS,
                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);

  function LENGTHB(ch VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
    pragma FIPSFLAG('LENGTHB', 1452);
  function SUBSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);
  function INSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  function TO_SINGLE_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_SINGLE_BYTE', 1452);
  function TO_MULTI_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_MULTI_BYTE', 1452);

  -- Next two added for NLS 6/3/92 JEM.
  function TO_CHAR(left date, format varchar2, parms varchar2) return varchar2;
  function TO_CHAR(left number, format varchar2, parms varchar2)
    return varchar2;
  function NLS_CHARSET_NAME(csetid PLS_INTEGER) return VARCHAR2;
  function NLS_CHARSET_ID(csetname VARCHAR2) return PLS_INTEGER;
  function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
    return PLS_INTEGER;

  -- end of NLS routines

  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2)
           return VARCHAR2 character set src%charset;
  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2,
                   srccset VARCHAR2)
          return VARCHAR2 character set src%charset;

  function " SYS$STANDARD_TRANSLATE" (src VARCHAR2 CHARACTER SET ANY_CS,
                                      csn VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET csn%CHARSET;
     pragma FIPSFLAG(' SYS$STANDARD_TRANSLATE',1452);

  function VSIZE (e number ) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e DATE) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);


  -- dump( expr [,display_format[,start_pos[,length]]]) return VARCHAR2
  function DUMP(e varchar2 character set any_cs,
                df pls_integer := null,sp pls_integer := null,
                len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e number,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e date,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  --
  -- ACOS, ASIN, ATAN, ATAN2
  --   Inverse Trigonometric functions
  --   These functions return NULL if any of the inputs are NULL
  --
  function ACOS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x NUMBER, y NUMBER) return NUMBER;
  pragma FIPSFLAG('ATAN2', 1452);

  --#### This is the end of 7.3 Standard

  -- LOB IS NULL
  function 'IS NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);
  -- end LOB IS NULL

  --****************************************************************
  -- 20 mar 96 =G=> In the following, arguments "1, 1, 1" to pragma BUILTIN
  -- e.g.,                pragma builtin('whatever', 1, 1, 1)
  -- indicate that those three numeric arguments to pragma BUILTIN are unknown,
  -- because they are not yet implemented by the backend.

  function '='  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<ADT_1>", pat "<ADT_1>", res "<ADT_1>")
        return "<ADT_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<ADT_1>", B2 "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function VALUE (item "<ADT_WITH_OID>") return "<ADT_1>";
    pragma BUILTIN('VALUE', 1, 1, 1);
    pragma FIPSFLAG('VALUE', 1450);

  function REF (item "<ADT_WITH_OID>") return REF "<ADT_1>";
    pragma BUILTIN('REF', 1, 1, 1);
    pragma FIPSFLAG('REF', 1450);

  function DEREF (r REF "<ADT_1>") return "<ADT_1>";
    pragma BUILTIN('DEREF', 1, 1, 1);
    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF ADT

  function 'IS NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function 'IS DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS DANGLING', 1450);

  function 'IS NOT DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  function NVL (B1 REF "<ADT_1>", B2 REF "<ADT_1>") return REF "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 0, 3, 1);
    pragma FIPSFLAG('=', 1450);

  function '!=' (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 0, 3, 2);
    pragma FIPSFLAG('!=', 1450);

  --  function '='  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('=', 1, 1, 1);
  --    pragma FIPSFLAG('=', 1450);
  --
  --  function '!=' (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('!=', 1, 1, 1);
  --    pragma FIPSFLAG('!=', 1450);
  --
  --  function '=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --
  --  function DECODE (expr "<COLLECTION_1>", pat "<COLLECTION_1>",
  --                                        res "<COLLECTION_1>")
  --      return "<COLLECTION_1>";
  --    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<COLLECTION_1>", B2 "<COLLECTION_1>")
        return "<COLLECTION_1>";
    pragma FIPSFLAG('NVL', 1450);

  function 'IS NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
        return "<REF_CURSOR_1>";
    pragma FIPSFLAG('NVL', 1450);

  function EMPTY_CLOB return clob;
  function EMPTY_BLOB return blob;

  function BFILENAME(directory varchar2,filename varchar2) return BFILE;

  function "SYS$LOB_REPLICATION" (x in blob) return blob;
  function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
    return clob character set x%charset;

  --#### This is the end of 8.0 Standard

  --  + overloadings

  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;

  function '+'(LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_UNCONSTRAINED;

  function '+'(LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_TZ_UNCONSTRAINED;

  function '+'(LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
                return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
                return TIME_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
                return TIME_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return DSINTERVAL_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return YMINTERVAL_UNCONSTRAINED ;

  -- begin subtract
  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return YMINTERVAL_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT" (LEFT TIME_UNCONSTRAINED,
                                      RIGHT TIME_UNCONSTRAINED)
     return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_UNCONSTRAINED ;
  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED ;
  function  " SYS$DSINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date;
  function '-' (LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date;

  function '-' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
   return DSINTERVAL_UNCONSTRAINED ;

  -- end subtract

  -- other datetime operators

  function '*' (LEFT number, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT number, RIGHT DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;

  function '*' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;

  function '/' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '/' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;


  function current_date return date;
  function current_time return TIME_TZ_UNCONSTRAINED;
  function current_timestamp return TIMESTAMP_TZ_UNCONSTRAINED;

  function TO_TIME (RIGHT varchar2 character set any_cs) return
    time_unconstrained;
    pragma BUILTIN('TO_TIME', 0, 15, 1);
    function TO_TIMESTAMP (RIGHT varchar2 character set any_cs)
                           return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 3);
  function TO_TIME_TZ (RIGHT varchar2 character set any_cs)
    return  TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 5);
  function TO_TIMESTAMP_TZ (RIGHT varchar2 character set any_cs)
    return  TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 7);
  function TO_YMINTERVAL (RIGHT varchar2 character set any_cs)
    return  YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_YMINTERVAL', 0, 15, 9);
  function TO_DSINTERVAL (RIGHT varchar2 character set any_cs)
    return  DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_DSINTERVAL', 0, 15, 11);

  -- with nls args
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset,
                   parms varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset,
                        parms varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset,
                           parms varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset,
                      parms varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_DSINTERVAL(RIGHT varchar2 character set any_cs,
                         parms varchar2 character set RIGHT%charset)
    return DSINTERVAL_UNCONSTRAINED;

  function NUMTOYMINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return YMINTERVAL_UNCONSTRAINED;
  function NUMTODSINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return DSINTERVAL_UNCONSTRAINED;

  function '='  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('=',0, 11, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',0, 11, 2);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<',0, 11, 3);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<=',0, 11, 4);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>',0, 11, 5);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>=',0, 11, 6);
    pragma FIPSFLAG('>=', 1450);

  function 'IS NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 14, 0); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 14, 50); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function "UROWID " return UROWID;
    pragma builtin('UROWID ', 1, 209, 240);  -- this had better never be called.

  -- New built-in function SYS_GUID, returns globally unique id
  function SYS_GUID return RAW;

  -- New built-in function SYS_CONTEXT
  function SYS_CONTEXT (namespace varchar2, attribute varchar2)
    return varchar2;

  function TRIM(v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  --#### This is the end of 8.1.5 Standard

  -- SYS_CONTEXT now has an additional optional parameter
  function SYS_CONTEXT(namespace varchar2, attribute varchar2,
                       newoptional varchar2)
    return varchar2;

  -- CUBE and ROLLUP are not real functions; they are variants on the GROUP
  -- BY clause (GROUP BY CUBE (...) and GROUP BY ROLLUP (...)). They have
  -- been added here as functions to avoid name capture issues.
  --
  -- Note that both CUBE and ROLLUP look like true vararg functions with
  -- *no* repeating pattern of formals - hence they are special cased in
  -- the overloading code.
  function CUBE return NUMBER;
  function ROLLUP return NUMBER;

  -- The GROUPING function must be used in conjunction with CUBE and ROLLUP
  -- in the GROUP BY clause. The type of the parameter to GROUPING can be
  -- any type that can appear in a GROUP BY list.
  function GROUPING(v VARCHAR2) return NUMBER;
  function GROUPING(a "<ADT_1>") return NUMBER;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 VARCHAR2 CHARACTER SET ANY_CS ,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   VARCHAR2 CHARACTER SET ANY_CS ,
                                 TSET   VARCHAR2 CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  --#### This is the end of the supported parts of 8.1.6 Standard

  --## Support for ANSI datetime data types is under development.
  --## The following operations, as well as the related types and
  --## operations defined above in the 8.1.5 section, are not yet
  --## available for use and are still subject to change.

  --- datetime equivalence
  function '='  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function TO_TIME (RIGHT TIME_TZ_UNCONSTRAINED)  return TIME_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME', 0, 15, 13);
  function TO_TIME_TZ (RIGHT TIME_UNCONSTRAINED)  return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 14);
  function TO_TIMESTAMP (RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 15);
  function TO_TIMESTAMP_TZ (RIGHT TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 16);

  function '-'
      (LEFT TIME_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  -- timezone functions
  function SYS_AT_TIME_ZONE(t time_tz_unconstrained,
                            i varchar2) RETURN time_tz_unconstrained;
  function SYS_AT_TIME_ZONE(t timestamp_tz_unconstrained,
                            i varchar2) RETURN timestamp_tz_unconstrained;
  FUNCTION systimestamp RETURN timestamp_tz_unconstrained;
  FUNCTION dbtimezone RETURN varchar2;
  FUNCTION sessiontimezone RETURN varchar2;
  FUNCTION localtimestamp RETURN timestamp_unconstrained;
  FUNCTION localtime RETURN time_unconstrained;

  function TO_TIMESTAMP (RIGHT DATE)  return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 17);

  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT yminterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '+'(LEFT dsinterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return yminterval_unconstrained;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;

  function '='  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;

  function SYS_LITERALTOYMINTERVAL(numerator varchar2, units varchar2)
    return YMINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTODSINTERVAL(numerator varchar2, units varchar2)
    return DSINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTOTIME(numerator varchar2)
    return TIME_UNCONSTRAINED;
  function SYS_LITERALTOTZTIME(numerator varchar2)
    return TIME_TZ_UNCONSTRAINED;
  function SYS_LITERALTOTIMESTAMP(numerator varchar2)
    return TIMESTAMP_UNCONSTRAINED;
  function SYS_LITERALTOTZTIMESTAMP(numerator varchar2)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function SYS_LITERALTODATE(numerator varchar2) return DATE;


  -- Explicit conversions between date and datetime
  function TO_TIMESTAMP(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 24);

  function TO_TIMESTAMP_TZ(ARG DATE) return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 27);

  function TO_TIMESTAMP_TZ(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 26);

  -- IS [NOT] NULL / NVL for datetime
  function 'IS NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_UNCONSTRAINED,
                b2 TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;

  function 'IS NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_TZ_UNCONSTRAINED, b2 TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_UNCONSTRAINED,
                b2 TIMESTAMP_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_TZ_UNCONSTRAINED, b2 TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_LTZ_UNCONSTRAINED,
                b2 TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;

  function 'IS NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 YMINTERVAL_UNCONSTRAINED, b2 YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;

  function 'IS NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 DSINTERVAL_UNCONSTRAINED, b2 DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  function " SYS$EXTRACT_FROM"
              (T TIME_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T DATE,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I YMINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I DSINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;

  -- ##########      8.2 LOB Built-in Functions       ######## --

  -- LENGTH --
  function LENGTH(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  function LENGTH(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  -- SUBSTR --
  function SUBSTR(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  function SUBSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);

  -- INSTR --
  function INSTR(STR1 CLOB CHARACTER SET ANY_CS,
                 STR2 CLOB CHARACTER SET STR1%CHARSET,
                 POS INTEGER := 1,
                 NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function INSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  STR2 CLOB CHARACTER SET STR1%CHARSET,
                  POS INTEGER := 1,
                  NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  -- CONCAT --
  function '||' (LEFT CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT CLOB CHARACTER SET ANY_CS,
                  RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG(CONCAT, 1454);

  -- UPPER --
  function UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);

  -- LOWER --
  function LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);

  -- LPAD --
  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  -- RPAD --
  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  -- LTRIM --
  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  -- RTRIM --
  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  -- TRIM --
  function TRIM(v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 CLOB CHARACTER SET ANY_CS ,
                               TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   CLOB CHARACTER SET ANY_CS ,
                                 TSET   CLOB CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;


  -- LIKE --
  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  -- NVL --
  function NVL(s1 CLOB CHARACTER SET ANY_CS,
               s2 CLOB CHARACTER SET s1%CHARSET)
    return CLOB CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);

  -- REPLACE --
  function REPLACE(SRCSTR CLOB CHARACTER SET ANY_CS,
                   OLDSUB CLOB CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB CLOB CHARACTER SET SRCSTR%CHARSET := NULL)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  -- LOB RELATIONAL OPERATORS --

  Function '='  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;

  /* LOB-related conversion functions */
  function TO_CLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS) return CLOB;
    pragma BUILTIN('TO_CLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  function TO_BLOB(RIGHT RAW) return BLOB;
    pragma BUILTIN('TO_BLOB', 0, 15, 30); -- OPC_CVT_RAW2BLB
  function TO_RAW(RIGHT BLOB) return RAW;
    pragma BUILTIN('TO_RAW', 0, 15, 32); -- OPC_CVT_BLB2RAW

  -- ####### end of 8.2 LOB Built-in Functions  ######## --

  function NULLIF(v1 VARCHAR2, v2 VARCHAR2) return VARCHAR2;
  function NULLIF(v1 BOOLEAN, v2 BOOLEAN) return VARCHAR2;
  function NULLIF(a1 "<ADT_1>", a2 "<ADT_1>") return VARCHAR2;

  function COALESCE return VARCHAR2;

  /* Daylight Saving Time Functions */
  FUNCTION tz_offset(region VARCHAR2)  RETURN VARCHAR2;
  FUNCTION from_tz(t TIMESTAMP_UNCONSTRAINED,timezone VARCHAR2)
    RETURN timestamp_tz_unconstrained;

  function " SYS$EXTRACT_STRING_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;

  function INSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR2', 1452);

  function INSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR4', 1452);

  function INSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRC', 1452);

  function LENGTH2(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH2', 1452);

  function LENGTH4(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH4', 1452);

  function LENGTHC(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTHC', 1452);

  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function SUBSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR2', 1452);

  function SUBSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR4', 1452);

  function SUBSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRC', 1452);

  /**** char <--> nchar conversion functions in Unicode project ********/

  function TO_NCHAR(RIGHT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',14, 0, 2);

  function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB;
  function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB;

  function TO_NCLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return NCLOB;
    pragma BUILTIN('TO_NCLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  /* convert to either CLOB or NCLOB respectively if parm is char or nchar */
  function TO_ANYLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET RIGHT%CHARSET;
    pragma BUILTIN('TO_ANYLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB

  /* Followings are the same builtin op codes as without N prefix functions,
   * implementation relys on impilcit conversion MCODEs
   */
  function TO_NCHAR (LEFT DATE, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_NCHAR', 1450);
  function TO_NCHAR (LEFT NUMBER, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function NHEXTORAW (c NVARCHAR2) return RAW;
    pragma builtin('NHEXTORAW', 1, 23, 1);
  function RAWTONHEX (r RAW) return NVARCHAR2;
    pragma builtin('RAWTONHEX', 1, 23, 2);
  function NCHARTOROWID (str NVARCHAR2) return ROWID;
    pragma builtin('NCHARTOROWID', 1, 0, 1);
  function ROWIDTONCHAR (str ROWID) return NVARCHAR2;
    pragma builtin('ROWIDTONCHAR', 1, 0, 1);

  function NCHR(n pls_integer) return NVARCHAR2;

  /* implemented by icd calls as the same as TO_CHAR */
  function TO_NCHAR(left date, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left number, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  /* implemented as a icd call, return TRUE if nchar, otherwise FALSE */
  function ISNCHAR(c VARCHAR2 character set any_cs) return boolean;

  /************ end of char <--> nchar conversion functions ************/

  /* Create overloads for all standard functions that work with <ADT_1> for
     <OPAQUE_1> */
  function '='  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<OPAQUE_1>", pat "<OPAQUE_1>", res "<OPAQUE_1>")
    return "<OPAQUE_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<OPAQUE_1>", B2 "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('NVL', 1450);

  --  REFs to opaques are not supported yet.
  --  function VALUE (item "<ADT_WITH_OID>") return "<OPAQUE_1>";
  --    pragma BUILTIN('VALUE', 1, 1, 1);
  --    pragma FIPSFLAG('VALUE', 1450);

  --  function REF (item "<ADT_WITH_OID>") return REF "<OPAQUE_1>";
  --    pragma BUILTIN('REF', 1, 1, 1);
  --    pragma FIPSFLAG('REF', 1450);

  --  function DEREF (r REF "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('DEREF', 1, 1, 1);
  --    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF OPAQUE

  --  function 'IS NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NULL', 0, 3, 0);
  --    pragma FIPSFLAG('IS NULL', 1450);

  --  function 'IS NOT NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma FIPSFLAG('IS NOT NULL', 1450);

  --  function 'IS DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS DANGLING', 1450);

  --  function 'IS NOT DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
  --    return REF "<OPAQUE_1>";
  --    pragma FIPSFLAG('NVL', 1450);

  --  function '='  (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('=', 0, 3, 1);
  --    pragma FIPSFLAG('=', 1450);

  --  function '!=' (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('!=', 0, 3, 2);
  --    pragma FIPSFLAG('!=', 1450);

  function GROUPING(a "<OPAQUE_1>") return NUMBER;
  function NULLIF(a1 "<OPAQUE_1>", a2 "<OPAQUE_1>") return VARCHAR2;

  function GREATEST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIME_TZ_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj

  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;

  -- CONVERT FOR LOB --
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2,
                   SRCCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;

  -- NLS_UPPER/NLS_LOWER FOR LOB --
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);

  function COMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS)
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('COMPOSE', 1452);
  function DECOMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS,
                     canmode in VARCHAR2 DEFAULT 'CANONICAL')
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('DECOMPOSE', 1452);
  FUNCTION SYS_EXTRACT_UTC(t timestamp_tz_unconstrained)
    return TIMESTAMP_UNCONSTRAINED;

  -- Begin REGEXP Support (10iR1) --

  -- REGEXP_LIKE --
  function REGEXP_LIKE (srcstr   VARCHAR2 CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  function REGEXP_LIKE (srcstr   CLOB CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  -- REGEXP_INSTR --
  function REGEXP_INSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        occurrence  PLS_INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);

  function REGEXP_INSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        occurrence  INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);


  -- REGEXP_SUBSTR --
  function REGEXP_SUBSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    PLS_INTEGER := 1,
                         occurrence  PLS_INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  function REGEXP_SUBSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    INTEGER := 1,
                         occurrence  INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  -- REGEXP_REPLACE --
  function REGEXP_REPLACE(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    PLS_INTEGER := 1,
                          occurrence  PLS_INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  CLOB CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  -- End REGEXP Support --

  -- binary_float and binary_double functions and operators.
  function TO_BINARY_FLOAT (RIGHT BINARY_FLOAT) RETURN BINARY_FLOAT;
    pragma BUILTIN('TO_BINARY_FLOAT',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;

  function TO_BINARY_DOUBLE (RIGHT BINARY_DOUBLE) RETURN BINARY_DOUBLE;
    pragma BUILTIN('TO_BINARY_DOUBLE',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;

  function 'IS NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;

  function TO_CHAR (left binary_float, format varchar2)
    return VARCHAR2;
  function TO_CHAR (left binary_double, format varchar2)
    return VARCHAR2;

  function TO_CHAR(left binary_float, format varchar2, parms varchar2)
    return varchar2;
  function TO_CHAR(left binary_double, format varchar2, parms varchar2)
    return varchar2;

  function TO_NCHAR(left binary_float, format nvarchar2) return NVARCHAR2;
  function TO_NCHAR(left binary_double, format nvarchar2) return NVARCHAR2;

  function TO_NCHAR(left binary_float, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left binary_double, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  function 'REMAINDER'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG(REMAINDER, 1452);

  function '='  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 15);
  function '!=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('!=',5, 2, 16);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 17);
  function '<=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 18);
  function '>'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 19);
  function '>=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 20);

  function 'IS NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 23);
  function ABS(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 2, 24);
  function '-' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 25);
  function '*' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('*',17, 2, 26);
  function '/' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('/',18, 2, 27);

  function 'REM' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(F1 BINARY_FLOAT, F2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('MOD', 1452);

  function FLOOR(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('CEIL', 1452);
  function SIGN(f BINARY_FLOAT) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);
  function SQRT(f BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('SQRT', 1452);

  function TRUNC (F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ROUND', 1452);

  function '='  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 28);
  function '!=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 29);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 30);
  function '<=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 31);
  function '>'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 32);
  function '>=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 33);

  function 'IS NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 36);
  function ABS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ABS', 1452);

  function ACOS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x BINARY_DOUBLE, y BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN2', 1452);

  function '+' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 2, 37);
  function '-' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 38);
  function '*' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('*',17, 2, 39);
  function '/' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('/',18, 2, 40);

  function 'REM' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(D1 BINARY_DOUBLE, D2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(d BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(d BINARY_DOUBLE) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function COSH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SINH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TANH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function EXP(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function LN(D BINARY_DOUBLE) return BINARY_DOUBLE;

  function LOG (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;

  function TRUNC (D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (d BINARY_DOUBLE, e BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('POWER', 1452);

  function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER;
  function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
  function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;

  function GREATEST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function GREATEST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2


  function '+' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',15, 2, 41);
  function ABS(I PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 2, 42);
  function '-' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',14, 2, 43);
  function '*' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('*',14, 2, 44);

  function '='  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 45); -- PEMS_PLS_INTEGER, PEMDCMEQ
  function '!=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 46); -- PEMS_PLS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 47); -- PEMS_PLS_INTEGER, PEMDCMLT
  function '<=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 48); -- PEMS_PLS_INTEGER, PEMDCMLE
  function '>'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 49); -- PEMS_PLS_INTEGER, PEMDCMGT
  function '>=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 51); -- PEMS_PLS_INTEGER, PEMDCMGE

  function 'IS NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_PLS_INTEGER, PEMDNUL
  function 'IS NOT NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_PLS_INTEGER, PEMDNUL

  function NVL(I1 PLS_INTEGER, I2 PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('NVL', 1452);

  function TRUNC (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('ROUND', 1452);

  function SIGN(i PLS_INTEGER) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);

  function GREATEST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2

  -- MultiSet Functions and Operators.

  -- Equality
  function '='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('=',2, 16, 1);

  function '!='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('!=',2, 16, 2);

  function CARDINALITY (collection IN "<TABLE_1>") return PLS_INTEGER;

  function SET (collection IN "<TABLE_1>") return "<TABLE_1>";
    pragma BUILTIN('SET',18, 2, 40);-- Dummy

  function 'IS A SET' (collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS A SET',18, 2, 40);-- Dummy
  function 'IS NOT A SET'(collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT A SET',18, 2, 40);-- Dummy

  function 'IS EMPTY' (collection IN  "<TABLE_1>") return BOOLEAN;
  function 'IS NOT EMPTY'(collection IN  "<TABLE_1>") return BOOLEAN;

  -- IS A SUBMULTISET OF
  function 'SUBMULTISET' (collection IN  "<TABLE_1>",
                          collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('SUBMULTISET',18, 2, 40);

  function 'MULTISET_UNION_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
      pragma BUILTIN('MULTISET_UNION_ALL',18, 2, 40);

  function 'MULTISET_UNION_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_UNION_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_DISTINCT',18, 2, 40);-- Dummy

  -- These are dummy procedures for correct management of new control
  -- statements added to PL/SQL. They ensure local procedures which have the
  -- same names as newly introduced keywords are not masked by those keywords.

  procedure continue;

  -- REGEXP_COUNT --
  function REGEXP_COUNT(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  function REGEXP_COUNT(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  --#### All user-visible declarations should preceed this point.  The
  --#### following are implementation-oriented pragmas that may need
  --#### editing in the future; we would prefer to be able to edit them
  --#### without affecting the rft numbering of user-visible items.

  --#### interface pragmas

  --#### Note that for any ICD which maps directly to a PVM
  --#### Opcode MUST be mapped to pes_dummy.
  --#### An ICD which invokes another ICD by flipping operands is
  --#### mapped to pes_flip, and an ICD whose result is the inverse of
  --#### another ICD is mapped to pes_invert
  --#### New ICDs should be placed at the end of this list, and a
  --#### corresponding entry must be made in the ICD table in pdz7

  PRAGMA interface(c,length,"pes_dummy",1);
  PRAGMA interface(c,substr,"pes_dummy",1);
  PRAGMA interface(c,instr,"pesist",1);
  PRAGMA interface(c,UPPER,"pesupp",1);
  PRAGMA interface(c,LOWER,"peslow",1);
  PRAGMA interface(c,ASCII,"pesasc");
  PRAGMA interface(c,ASCIISTR,"pesastr");
  PRAGMA interface(c,UNISTR,"pesustr");
  PRAGMA interface(c,CHR,"peschr");
  PRAGMA interface(c," SYS$STANDARD_CHR","peschr");
  PRAGMA interface(c,INITCAP,"pesicp");
  PRAGMA interface(c,LPAD,"peslpd",1);
  PRAGMA interface(c,LPAD,"peslpd",2);
  PRAGMA interface(c,RPAD,"pesrpd",1);
  PRAGMA interface(c,RPAD,"pesrpd",2);
  PRAGMA interface(c,REPLACE,"pesrep",1);
  PRAGMA interface(c,LTRIM,"pesltr",1);
  PRAGMA interface(c,LTRIM,"pesltr",2);
  PRAGMA interface(c,RTRIM,"pesrtr",1);
  PRAGMA interface(c,RTRIM,"pesrtr",2);
  PRAGMA interface(c,'LIKE',"peslik",1);
  PRAGMA interface(c,'LIKE',"pesli2",2);
  PRAGMA interface(c,ABS,"pes_dummy",1);
  PRAGMA interface(c,'MOD',"pesmod", 1);
  PRAGMA interface(c,floor,"pesflo", 1);
  PRAGMA interface(c,CEIL,"pescei", 1);
  PRAGMA interface (c, SQRT, "pessqt", 1);
  PRAGMA interface(c,SIGN,"pessgn", 1);
  PRAGMA interface(c,cos,"pescos", 1);
  PRAGMA interface(c,sin,"pessin",1);
  PRAGMA interface(c,TAN,"pestan",1);
  PRAGMA interface(c,COSH,"pescsh",1);
  PRAGMA interface(c,SINH,"pessnh",1);
  PRAGMA interface(c,TANH,"pestnh",1);
  PRAGMA interface(c,EXP,"pesexp",1);
  PRAGMA interface(c,LN,"pesln",1);
  PRAGMA interface(c,BITAND,"pesbtd",1);
  PRAGMA interface(c,BITAND,"pesbtdn",2);
  PRAGMA interface(c,LOG,"peslog",1);
  PRAGMA interface(c,TRUNC,"pestru",1);
  PRAGMA interface(c,ROUND,"pesrnd",1);
  PRAGMA interface(c,POWER,"pespow",1);
  PRAGMA interface(c,NEW_TIME,"pesnwt");
  PRAGMA interface(c,TO_DATE,"pesc2d",4);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",3);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",4);
  PRAGMA interface(c,'>=',"pes_flip",5);
  PRAGMA interface(c,'>',"pes_flip",5);
  PRAGMA interface(c,'<=',"peszle",5);
  PRAGMA interface(c,'<',"peszlt",5);        -- ICD #50
  PRAGMA interface(c,'=',"peszeq",5);
  PRAGMA interface(c,'!=',"pes_invert",5);
  PRAGMA interface(c,nlssort,"pesxco",2);
  PRAGMA interface(c,NLS_UPPER,"pesxup",1);
  PRAGMA interface(c,NLS_UPPER,"peslcnup",3); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_UPPER,"peslcnup",4); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_LOWER,"pesxlo",1);
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",3); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",4); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_INITCAP,"pesxcp",1);
  PRAGMA interface(c,lengthb,"pes_dummy",1);
  PRAGMA interface(c,substrb,"pes_dummy",1);
  PRAGMA interface(c,instrb,"pesxis",1);
  PRAGMA interface(c,TO_SINGLE_BYTE, "pesxsi");
  PRAGMA interface(c,TO_MULTI_BYTE,"pesxmu");
  PRAGMA interface(c,TO_CHAR,"pesd2c",5);
  PRAGMA interface(c,TO_CHAR,"pesn2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesd2c",4);
  PRAGMA interface(c,TO_NCHAR,"pesn2c",5);
  PRAGMA interface(c," SYS$STANDARD_TRANSLATE","pesxcs");
  PRAGMA interface(c,ATAN,"pesatan",1);
  PRAGMA interface(c,EMPTY_CLOB,"peslcem");
  PRAGMA interface(c,EMPTY_BLOB,"peslbem");
  PRAGMA interface(c,BFILENAME,"pesfnm");
  PRAGMA interface(c,TO_TIME,"pes3tm",2);
  PRAGMA interface(c,TO_TIME,"pes3tm",3);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",2);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",3);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",2);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",3);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",2);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",3);
  PRAGMA interface(c,TO_DSINTERVAL,"pes2dsi",2);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",1);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",2);
  PRAGMA interface(c,SESSIONTIMEZONE,"pesstz",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",2);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",3);
  PRAGMA interface(c,TRIM,"pestrim",1);
  -- Datetime addition
  PRAGMA interface(c,'+',"pesati",5);    --  +(tsp, iym) return tsp
  PRAGMA interface(c,'+',"pesati",6);    --  +(tsp, ids) return tsp
  PRAGMA interface(c,'+',"pesati",7);    --  +(tsz, iym) return tsz
  PRAGMA interface(c,'+',"pesati",8);    --  +(tsz, ids) return tsz
  PRAGMA interface(c,'+',"pesati",9);    --  +(tim, ids) return tim
  PRAGMA interface(c,'+',"pesati",10);   --  +(tmz, ids) return tmz
  PRAGMA interface(c,'+',"pesadi",11);   --  +(dat, iym) return dat
  PRAGMA interface(c,'+',"pesadi",12);   --  +(dat, ids) return dat
  PRAGMA interface(c,'+',"pes_flip",13); --  +(iym, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",14); --  +(iym, tsz) return tsz -- ICD #100
  PRAGMA interface(c,'+',"pes_flip",15); --  +(iym, dat) return dat
  PRAGMA interface(c,'+',"pes_flip",16); --  +(ids, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",17); --  +(ids, tsz) return tsz
  PRAGMA interface(c,'+',"pes_flip",18); --  +(ids, tim) return tim
  PRAGMA interface(c,'+',"pes_flip",19); --  +(ids, tmz) return tmz
  PRAGMA interface(c,'+',"pes_flip",20); --  +(ids, dat) return dat
  PRAGMA interface(c,'+',"pesaii",21);   --  +(ids, ids) return ids
  PRAGMA interface(c,'+',"pesaii",22);   --  +(iym, iym) return iym
  PRAGMA interface(c,'+',"pesati",23);   --  +(ltz, iym) return ltz
  PRAGMA interface(c,'+',"pesati",24);   --  +(ltz, ids) return ltz
  PRAGMA interface(c,'+',"pes_flip",25);--  +(iym, ltz) return ltz
  PRAGMA interface(c,'+',"pes_flip",26);--  +(ids, ltz) return ltz
  -- Datetime subtraction
  PRAGMA interface(c,'-',"pessti",6);    --  -(tsp, iym) return tsp
  PRAGMA interface(c,'-',"pessti",7);    --  -(tsp, ids) return tsp
  PRAGMA interface(c,'-',"pessti",8);    --  -(tsz, iym) return tsz
  PRAGMA interface(c,'-',"pessti",9);    --  -(tsz, ids) return tsz
  PRAGMA interface(c,'-',"pessti",10);   --  -(tim, ids) return tim
  PRAGMA interface(c,'-',"pessti",11);   --  -(tmz, ids) return tmz
  PRAGMA interface(c,'-',"pessdi",12);   --  -(dat, iym) return dat
  PRAGMA interface(c,'-',"pessdi",13);   --  -(dat, ids) return dat
  PRAGMA interface(c,'-',"pessii",14);   --  -(iym, iym) return iym
  PRAGMA interface(c,'-',"pessii",15);   --  -(ids, ids) return ids
  PRAGMA interface(c,'-',"pessttds",16); --  -(tim, tim) return ids
  PRAGMA interface(c,'-',"pessttds",17); --  -(tsp, tsp) return ids
  PRAGMA interface(c,'-',"pessttds",18); --  -(tmz, tmz) return ids
  PRAGMA interface(c,'-',"pessttds",19); --  -(tsz, tsz) return ids
  PRAGMA interface(c,'-',"pessti",20);   --  -(ltz, iym) return iym
  PRAGMA interface(c,'-',"pessti",21);   --  -(ltz, ids) return ids
  PRAGMA interface(c,'-',"pessttds",22); --  -(ltz, ltz) return ids
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",1);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",2);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",3);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",4);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessddds",5);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",6);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",1);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",2);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessddym",3);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",4);
  -- Datetime multiplication
  PRAGMA interface(c,'*',"pesmni",2);    --  *(num, iym) return iym
  PRAGMA interface(c,'*',"pesmni",3);    --  *(num, ids) return ids
  PRAGMA interface(c,'*',"pes_flip",4);  --  *(iym, num) return iym
  PRAGMA interface(c,'*',"pes_flip",5);  --  *(ids, num) return ids
  -- Datetime division
  PRAGMA interface(c,'/',"pesdvin",2);   --  /(iym, num) return iym
  PRAGMA interface(c,'/',"pesdvin",3);   --  /(ids, num) return ids
  -- TIME
  PRAGMA interface(c,'=',"pes_dummy",9);
  PRAGMA interface(c,'!=',"pes_invert",9);
  PRAGMA interface(c,'>',"pes_flip",8);
  PRAGMA interface(c,'<',"pes_dummy",8);
  PRAGMA interface(c,'>=',"pes_flip",8);   -- ICD #150
  PRAGMA interface(c,'<=',"pes_dummy",8);
  -- TIME WITH TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",10);
  PRAGMA interface(c,'!=',"pes_invert",10);
  PRAGMA interface(c,'>',"pes_flip",9);
  PRAGMA interface(c,'<',"pes_dummy",9);
  PRAGMA interface(c,'>=',"pes_flip",9);
  PRAGMA interface(c,'<=',"pes_dummy",9);
  -- TIMESTAMP
  PRAGMA interface(c,'=',"pes_dummy",11);
  PRAGMA interface(c,'!=',"pes_invert",11);
  PRAGMA interface(c,'>',"pes_flip",10);
  PRAGMA interface(c,'<',"pes_dummy",10);
  PRAGMA interface(c,'>=',"pes_flip",10);
  PRAGMA interface(c,'<=',"pes_dummy",10);
  -- INTERVAL YEAR TO MONTH
  PRAGMA interface(c,'=',"pes_dummy",12);
  PRAGMA interface(c,'!=',"pes_invert",12);
  PRAGMA interface(c,'>',"pes_flip",11);
  PRAGMA interface(c,'<',"pes_dummy",11);
  PRAGMA interface(c,'>=',"pes_flip",11);
  PRAGMA interface(c,'<=',"pes_dummy",11);
  -- INTERVAL DAY TO SECOND
  PRAGMA interface(c,'=',"pes_dummy",13);
  PRAGMA interface(c,'!=',"pes_invert",13);
  PRAGMA interface(c,'>',"pes_flip",12);
  PRAGMA interface(c,'<',"pes_dummy",12);
  PRAGMA interface(c,'>=',"pes_flip",12);
  PRAGMA interface(c,'<=',"pes_dummy",12);
  -- TIMESTAMP_TZ_UNCONSTRAINED
  PRAGMA interface(c,'=',"pes_dummy",14);
  PRAGMA interface(c,'!=',"pes_invert",14);
  PRAGMA interface(c,'>',"pes_flip",13);
  PRAGMA interface(c,'<',"pes_dummy",13);
  PRAGMA interface(c,'>=',"pes_flip",13);
  PRAGMA interface(c,'<=',"pes_dummy",13);
  -- TIMESTAMP WITH LOCAL TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",15);
  PRAGMA interface(c,'!=',"pes_invert",15);
  PRAGMA interface(c,'>',"pes_flip",14);
  PRAGMA interface(c,'<',"pes_dummy",14);
  PRAGMA interface(c,'>=',"pes_flip",14);
  PRAGMA interface(c,'<=',"pes_dummy",14);
  -- Other datetime functions
  PRAGMA interface(c,'CURRENT_DATE',"pescdt",1);
  PRAGMA interface(c,'CURRENT_TIME',"pesctm",1);
  PRAGMA interface(c,'CURRENT_TIMESTAMP',"pescts",1);
  --  Internal calls to evaluate datetime/interval literals without NLS parms.
  PRAGMA interface(c,SYS_LITERALTOYMINTERVAL,"pesc2ymi",1);
  PRAGMA interface(c,SYS_LITERALTODSINTERVAL,"pesc2dsi",1);
  PRAGMA interface(c,SYS_LITERALTOTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTODATE,"pesc2date",1);
  -- extract(field from expr)
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",1);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",2);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",3);   -- ICD #200
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",4);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",5);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefdt",6);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",7);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",8);
  -- datetime is null
  PRAGMA interface(c,"IS NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NULL","pes_dummy",20); -- interval ds

  -- 8.2 LOB Built-in Functions
  PRAGMA interface(c,length, "peslcln",2);    -- LOB LENGTH
  PRAGMA interface(c,lengthb,"peslclb",2);    -- LOB LENGTHB
  PRAGMA interface(c,substr, "peslcst",2);    -- LOB SUBSTR
  PRAGMA interface(c,substrb,"peslcsb",2);    -- LOB SUBSTRB
  PRAGMA interface(c,instr,  "peslcin",2);    -- LOB INSTR
  PRAGMA interface(c,instrb, "peslcib",2);    -- LOB INSTRB
  PRAGMA interface(c,'||',   "peslcct",2);    -- LOB '||'
  PRAGMA interface(c,concat, "peslcct",2);    -- LOB CONCAT
  PRAGMA interface(c,lpad,   "peslclp",3);    -- LOB LPAD
  PRAGMA interface(c,lpad,   "peslclp",4);    -- LOB LPAD
  PRAGMA interface(c,rpad,   "peslcrp",3);    -- LOB RPAD
  PRAGMA interface(c,rpad,   "peslcrp",4);    -- LOB RPAD
  PRAGMA interface(c,lower,  "peslclr",2);    -- LOB LOWER
  PRAGMA interface(c,upper,  "peslcup",2);    -- LOB UPPER
  PRAGMA interface(c,ltrim,  "peslclm",3);    -- LOB LTRIM
  PRAGMA interface(c,ltrim,  "peslclm",4);    -- LOB LTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",3);    -- LOB RTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",4);    -- LOB RTRIM
  PRAGMA interface(c,trim,   "peslctr",2);    -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",4); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",5); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",6); -- LOB TRIM
  PRAGMA interface(c,'LIKE', "peslclk",3);    -- LOB LIKE
  PRAGMA interface(c,'LIKE', "peslcl2",4);    -- LOB LIKE
  PRAGMA interface(c,nvl,"peslcnl",17);       -- LOB NVL
  PRAGMA interface(c,replace, "peslcrl",2);   -- LOB REPLACE

     -- LOB Relational Operators
     -- LHS: CLOB,    RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_dummy",16);     -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",16);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",15);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pes_dummy",15);     -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",15);      -- LOB '>='
  PRAGMA interface(c,'<=',"pes_dummy",15);       -- LOB '<='
     -- LHS: CLOB,     RHS:VARCHAR2
  PRAGMA interface(c,'=' ,"pesleq2",17);       -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",17);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",16);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt2",16);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",16);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle2",16);       -- LOB '<='  -- ICD #250
     -- LHS: VARCHAR2, RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_flip",18);      -- LOB '='
  PRAGMA interface(c,'!=',"pes_flip",18);      -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",17);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt3",17);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",17);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle3",17);       -- LOB '<='

  PRAGMA interface(c,length, "peslbln",3);    -- BLOB LENGTH
  PRAGMA interface(c,lengthb,"peslblb",3);    -- BLOB LENGTHB
  -- End of 8.2 LOB Built-in Functions


  PRAGMA interface(c,tz_offset,"pestzo",1);
  PRAGMA interface(c,from_tz,"pesftz",1);

  PRAGMA interface(c,ISNCHAR,"pesinc", 1);

  PRAGMA interface(c,CONVERT,"pescnv", 1);
  PRAGMA interface(c,CONVERT,"pescnv", 2);
  PRAGMA interface(c,CONVERT,"peslccnv", 3);  -- LOB CONVERT
  PRAGMA interface(c,CONVERT,"peslccnv", 4);  -- LOB CONVERT

  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",1);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",2);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",3);

  PRAGMA interface(c,TO_CHAR,"pesdtm2c",7); -- datetime
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",8);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",9);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",10);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",11);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",12);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",13);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",14);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",15);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",16);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",17); -- interval
  PRAGMA interface(c,TO_CHAR,"pesitv2c",18);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",19);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",20);

  --#### new_names pragmas

  -- This is an internal pragma that restricts the use
  -- of particular new entries in package standard.
  -- It is only valid in package standard.
  -- Note that left out of the 8.1.5 set are non datetime
  -- entries urowid, "UROWID ", self_is_null and trim.

  pragma new_names('8.1.5',
                   time,"TIME WITH TIME ZONE",
                   timestamp,"TIMESTAMP WITH TIME ZONE",
                   "INTERVAL DAY TO SECOND",
                   "INTERVAL YEAR TO MONTH",
                   to_time, to_timestamp,
                   to_time_tz, to_timestamp_tz,
                   " SYS$DSINTERVALSUBTRACT",
                   " SYS$YMINTERVALSUBTRACT",
                   to_yminterval,to_dsinterval,
                   NUMTOYMINTERVAL, NUMTODSINTERVAL,
                   current_date,
                   current_time,current_timestamp);

  pragma new_names('8.1.6',
                   dbtimezone, sessiontimezone, localtimestamp,
                   localtime,
                   cube, rollup, grouping, "TIMESTAMP WITH LOCAL TIME ZONE");

  -- Should there be a 8.2 new names pragma ?

  -- 8.2 UCS2/UCS4/Complete Built-in Functions

  PRAGMA interface(c,INSTR2,"pesist2",1);
  PRAGMA interface(c,INSTR4,"pesist4",1);
  PRAGMA interface(c,INSTRC,"pesistc",1);

  PRAGMA interface(c,LENGTH2,"peslen2",1);
  PRAGMA interface(c,LENGTH4,"peslen4",1);
  PRAGMA interface(c,LENGTHC,"peslenc",1);

  PRAGMA interface(c,LIKE2,"peslik2",1);
  PRAGMA interface(c,LIKE2,"pesli22",2);
  PRAGMA interface(c,LIKE4,"peslik4",1);
  PRAGMA interface(c,LIKE4,"pesli42",2);
  PRAGMA interface(c,LIKEC,"peslikc",1);
  PRAGMA interface(c,LIKEC,"peslic2",2);

  PRAGMA interface(c,SUBSTR2,"pes_dummy",1);
  PRAGMA interface(c,SUBSTR4,"pes_dummy",1);
  PRAGMA interface(c,SUBSTRC,"pes_dummy",1);
  PRAGMA interface(c,SYS_EXTRACT_UTC,"pessexu");
  PRAGMA interface(c,COMPOSE,"pescomp");
  PRAGMA interface(c,DECOMPOSE,"pesdcmp");



  -- End of 8.2 UCS2/UCS4/Complete Built-in Functions

  -- Begin REGEXP support (10iR1) --
  PRAGMA interface(c,regexp_like,    "pes_dummy",1);
  PRAGMA interface(c,regexp_instr,   "pes_dummy",1);    -- ICD #300
  PRAGMA interface(c,regexp_substr,  "pes_dummy",1);
  PRAGMA interface(c,regexp_replace, "pes_dummy",1);
  PRAGMA interface(c,regexp_count,   "pes_dummy",1);
  PRAGMA interface(c,regexp_like,    "pes_dummy",2);    -- LOB REGEXP_LIKE
  PRAGMA interface(c,regexp_instr,   "pes_dummy",2);    -- LOB REGEXP_INSTR
  PRAGMA interface(c,regexp_substr,  "pes_dummy",2);    -- LOB REGEXP_SUBSTR
  PRAGMA interface(c,regexp_replace, "pes_dummy",2);    -- LOB REGEXP_REPLACE
  PRAGMA interface(c,regexp_count,   "pes_dummy",2);    -- LOB REGEXP_COUNT
  PRAGMA interface(c,regexp_replace, "pes_dummy",3);    -- LOB REGEXP_REPLACE

  -- End of REGEXP Built-in Functions --


  -- 10i Binary Floating-point Built-in Functions

  PRAGMA interface(c,"IS NAN","pesnanf",2);
  PRAGMA interface(c,"IS NAN","pesnand",3);
  PRAGMA interface(c,"IS INFINITE","pesinf",1);
  PRAGMA interface(c,"IS INFINITE","pesinff",2);
  PRAGMA interface(c,"IS INFINITE","pesinfd",3);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",2);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",3);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",2);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",3);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",21);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",22);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",23);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",24);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",7);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",8);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",9);
  PRAGMA interface(c,'REMAINDER',"pesrem", 1);
  PRAGMA interface(c,REMAINDER,"pesrem", 2);
  PRAGMA interface(c,'REMAINDER',"pesremf", 3);
  PRAGMA interface(c,REMAINDER,"pesremf", 4);
  PRAGMA interface(c,'REMAINDER',"pesremd", 5);
  PRAGMA interface(c,REMAINDER,"pesremd", 6);
  PRAGMA interface(c,ABS,"pes_dummy",2);
  PRAGMA interface(c,ABS,"pes_dummy",3);
  PRAGMA interface(c,ABS,"pes_dummy",4);
  PRAGMA interface(c,ATAN,"pesatand",2);
  PRAGMA interface(c,'MOD',"pesmodf", 2);
  PRAGMA interface(c,'MOD',"pesmodd", 3);
  PRAGMA interface(c,floor,"pesflof", 2);
  PRAGMA interface(c,floor,"pesflod", 3);
  PRAGMA interface(c,CEIL,"pesceif", 2);
  PRAGMA interface(c,CEIL,"pesceid", 3);
  PRAGMA interface (c, SQRT, "pessqtf", 2);
  PRAGMA interface (c, SQRT, "pessqtd", 3);
  PRAGMA interface(c,SIGN,"pessgnf", 2);
  PRAGMA interface(c,SIGN,"pessgnd", 3);
  PRAGMA interface(c,SIGN,"pessgni", 4);
  PRAGMA interface(c,cos,"pescosd", 2);
  PRAGMA interface(c,sin,"pessind",2);
  PRAGMA interface(c,TAN,"pestand",2);
  PRAGMA interface(c,COSH,"pescshd",2);
  PRAGMA interface(c,SINH,"pessnhd",2);   -- ICD #350
  PRAGMA interface(c,TANH,"pestnhd",2);
  PRAGMA interface(c,EXP,"pesexpd",2);
  PRAGMA interface(c,LN,"peslnd",2);
  PRAGMA interface(c,LOG,"peslogd",2);
  PRAGMA interface(c,TRUNC,"pestruf",4);
  PRAGMA interface(c,TRUNC,"pestrud",5);
  PRAGMA interface(c,TRUNC,"pestrui",6);
  PRAGMA interface(c,ROUND,"pesrndf",4);
  PRAGMA interface(c,ROUND,"pesrndd",5);
  PRAGMA interface(c,ROUND,"pesrndi",6);
  PRAGMA interface(c,POWER,"pespowd",2);

  -- End of 10i Binary Floating-point Built-in Functions

  -- ICDs for MULTISET

  PRAGMA interface(c,CARDINALITY,"pesmcnt");
  PRAGMA interface(c,"IS EMPTY","pesmie");
  PRAGMA interface(c,"IS NOT EMPTY","pes_invert",1);
  -- ICDs which used to be in the body of standard, but which new COG can
  -- handle directly

  -- NOT (some ICD)
  PRAGMA interface(c,NOT_LIKE,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",3);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",4);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",3);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",1);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",2);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",3);

  -- datetime is not null
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",20); -- interval ds

  -- Misc
  PRAGMA interface(c,"**",   "pespow",1);    -- number
  PRAGMA interface(c,"**",   "pespowd",2);   -- binary double
  PRAGMA interface(c,"ACOS", "pesacosd",2);  -- binary double
  PRAGMA interface(c,"ASIN", "pesasind",2);  -- binary double
  PRAGMA interface(c,"ATAN2","pesatn2d",2);  -- binary double

  -- All the flavors of NVL
  PRAGMA interface(c,nvl,"pes_dummy",1);       -- Boolean -- ICD #400
  PRAGMA interface(c,nvl,"pes_dummy",2);       -- Varchar2
  PRAGMA interface(c,nvl,"pes_dummy",3);       -- Number
  PRAGMA interface(c,nvl,"pes_dummy",4);       -- Date
  PRAGMA interface(c,nvl,"pes_dummy",5);       -- MLSLabel
  PRAGMA interface(c,nvl,"pes_dummy",6);       -- ADT
  PRAGMA interface(c,nvl,"pes_dummy",7);       -- Ref ADT
  PRAGMA interface(c,nvl,"pes_dummy",8);       -- Collection

--  Ref Cursor has problems. The MOVCR instruction needs more information than
--  the other MOV* instructions, including the PVM register of the destination
--  This cannot be easily supplied through the generic NVL instruction, so
--  for now, this flavor will continue to have a real body
--  PRAGMA interface(c,nvl,"pes_dummy",9);       -- Ref Cursor

  PRAGMA interface(c,nvl,"pes_dummy",10);       -- Time
  PRAGMA interface(c,nvl,"pes_dummy",11);       -- Time-tz
  PRAGMA interface(c,nvl,"pes_dummy",12);       -- Timestamp
  PRAGMA interface(c,nvl,"pes_dummy",13);       -- Timestamp-tz
  PRAGMA interface(c,nvl,"pes_dummy",14);       -- Timestamp-ltz
  PRAGMA interface(c,nvl,"pes_dummy",15);       -- Intervalym
  PRAGMA interface(c,nvl,"pes_dummy",16);       -- Intervalds
--  PRAGMA interface(c,nvl,"pes_dummy",17);       -- Clob (Handled above, ICD)
  PRAGMA interface(c,nvl,"pes_dummy",18);       -- Opaque
  PRAGMA interface(c,nvl,"pes_dummy",19);       -- Binaryfloat
  PRAGMA interface(c,nvl,"pes_dummy",20);       -- Binarydouble
  PRAGMA interface(c,nvl,"pes_dummy",21);       -- PLSInteger

  -- The following pragma overrides any other setting of the timestamp,
  -- and is used so that we recognize the client-side and server-side instances
  -- of package STANDARD as being the same.  Package STANDARD is special in
  -- that it is really the root of the PL/SQL dependencies graph; as such it
  -- itself doesn't ever need recompiling due to changes to things below it.
  -- The pragma mechanism used here is currently ignored except for
  -- package STANDARD, but in future may not be.  Do NOT add similar pragmas
  -- to your own code as it may in future interfere with the package
  -- consistency maintenance mechanisms and could have dire results.

  --#### timestamp pragma (please keep this last)
  pragma TIMESTAMP('2006-04-18:00:00:00');
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."STANDARD" AUTHID CURRENT_USER is              -- careful on this line; SED edit occurs!

  /********** Types and subtypes, do not reorder **********/
  type BOOLEAN is (FALSE, TRUE);

  type DATE is DATE_BASE;

  type NUMBER is NUMBER_BASE;
  subtype FLOAT is NUMBER; -- NUMBER(126)
  subtype REAL is FLOAT; -- FLOAT(63)
  subtype "DOUBLE PRECISION" is FLOAT;
  subtype INTEGER is NUMBER(38,0);
  subtype INT is INTEGER;
  subtype SMALLINT is NUMBER(38,0);
  subtype DECIMAL is NUMBER(38,0);
  subtype NUMERIC is DECIMAL;
  subtype DEC is DECIMAL;


  subtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;
  subtype NATURAL is BINARY_INTEGER range 0..2147483647;
  subtype NATURALN is NATURAL not null;
  subtype POSITIVE is BINARY_INTEGER range 1..2147483647;
  subtype POSITIVEN is POSITIVE not null;
  subtype SIGNTYPE is BINARY_INTEGER range '-1'..1;  -- for SIGN functions

  type VARCHAR2 is NEW CHAR_BASE;

  subtype VARCHAR is VARCHAR2;
  subtype STRING is VARCHAR2;

  subtype LONG is VARCHAR2(32760);

  subtype RAW is VARCHAR2;
  subtype "LONG RAW" is RAW(32760);

  subtype ROWID is VARCHAR2(256);

  -- Ansi fixed-length char
  -- Define synonyms for CHAR and CHARN.
  subtype CHAR is VARCHAR2;
  subtype CHARACTER is CHAR;

  type MLSLABEL is new CHAR_BASE;

  -- Large object data types.
  --  binary, character, binary file.
  type  BLOB is BLOB_BASE;
  type  CLOB is CLOB_BASE;
  type  BFILE is BFILE_BASE;

  -- Verbose and NCHAR type names
  subtype "CHARACTER VARYING" is VARCHAR;
  subtype "CHAR VARYING" is VARCHAR;
  subtype "NATIONAL CHARACTER" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHARACTER VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NVARCHAR2" is VARCHAR2 CHARACTER SET NCHAR_CS;
  subtype "CHARACTER LARGE OBJECT" is CLOB;
  subtype "CHAR LARGE OBJECT" is CLOB;
  subtype "NATIONAL CHARACTER LARGE OBJEC" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCHAR LARGE OBJECT" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCLOB" is CLOB CHARACTER SET NCHAR_CS;
  subtype "BINARY LARGE OBJECT" is BLOB;

  subtype pls_integer is binary_integer;

  type TIME is new DATE_BASE;
  type TIMESTAMP is new DATE_BASE;
  type "TIME WITH TIME ZONE" is new DATE_BASE;
  type "TIMESTAMP WITH TIME ZONE" is new DATE_BASE;
  type "INTERVAL YEAR TO MONTH" is new DATE_BASE;
  type "INTERVAL DAY TO SECOND" is new DATE_BASE;

  SUBTYPE TIME_UNCONSTRAINED IS TIME(9);
  SUBTYPE TIME_TZ_UNCONSTRAINED IS TIME(9) WITH TIME ZONE;
  SUBTYPE TIMESTAMP_UNCONSTRAINED IS TIMESTAMP(9);
  SUBTYPE TIMESTAMP_TZ_UNCONSTRAINED IS TIMESTAMP(9) WITH TIME ZONE;
  SUBTYPE YMINTERVAL_UNCONSTRAINED IS INTERVAL YEAR(9) TO MONTH;
  SUBTYPE DSINTERVAL_UNCONSTRAINED IS INTERVAL DAY(9) TO SECOND (9);

  TYPE UROWID IS NEW CHAR_BASE;

  type "TIMESTAMP WITH LOCAL TIME ZONE" is new DATE_BASE;
  subtype timestamp_ltz_unconstrained is timestamp(9) with local time zone;

  subtype BINARY_FLOAT is NUMBER;
  subtype BINARY_DOUBLE is NUMBER;

  -- The following data types are generics, used specially within package
  -- STANDARD and some other Oracle packages.  They are protected against
  -- other use; sorry.  True generic types are not yet part of the language.

  type "<ADT_1>" as object (dummy char(1));
  type "<RECORD_1>" is record (dummy char(1));
  type "<TUPLE_1>" as object (dummy char(1));
  type "<VARRAY_1>" is varray (1) of char(1);
  type "<V2_TABLE_1>" is table of char(1) index by binary_integer;
  type "<TABLE_1>" is table of char(1);
  type "<COLLECTION_1>" is table of char(1);
  type "<REF_CURSOR_1>" is ref cursor;

  -- This will actually match against a Q_TABLE
  type "<TYPED_TABLE>" is table of  "<ADT_1>";
  subtype "<ADT_WITH_OID>" is "<TYPED_TABLE>";

  -- The following generic index table data types are used by the PL/SQL
  -- compiler to materialize an array attribute at the runtime (for more
  -- details about the array attributes, please see Bulk Binds document).
  type " SYS$INT_V2TABLE" is table of pls_integer index by binary_integer;

  -- The following record type and the corresponding generic index table
  -- data types are used by the PL/SQL compiler to materialize a table
  -- at the runtime in order to record the exceptions raised during the
  -- execution of FORALL bulk bind statement (for more details, please
  -- see bulk binds extensions document in 8.2).
  type " SYS$BULK_ERROR_RECORD" is
          record (error_index pls_integer, error_code pls_integer);
  type " SYS$REC_V2TABLE" is table of " SYS$BULK_ERROR_RECORD"
                               index by binary_integer;

  /* Adding a generic weak ref cursor type */
  type sys_refcursor is ref cursor;

  /* the following data type is a generic for all opaque types */
  type "<OPAQUE_1>" as opaque FIXED(1) USING LIBRARY dummy_lib
    (static function dummy return number);

  type "<ASSOC_ARRAY_1>" is table of char(1) index by varchar2(1);

  /********** Add new types or subtypes here **********/

  -- Simple scalar types

  subtype SIMPLE_INTEGER is BINARY_INTEGER NOT NULL;
  subtype SIMPLE_FLOAT   is BINARY_FLOAT   NOT NULL;
  subtype SIMPLE_DOUBLE  is BINARY_DOUBLE  NOT NULL;

  /********** Predefined constants **********/

  BINARY_FLOAT_NAN constant BINARY_FLOAT;
  BINARY_FLOAT_INFINITY constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_SUBNORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_SUBNORMAL constant BINARY_FLOAT;
  BINARY_DOUBLE_NAN constant BINARY_DOUBLE;
  BINARY_DOUBLE_INFINITY constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_SUBNORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_SUBNORMAL constant BINARY_DOUBLE;

  /********** Add new constants here **********/

  /********** Predefined exceptions **********/

  CURSOR_ALREADY_OPEN exception;
    pragma EXCEPTION_INIT(CURSOR_ALREADY_OPEN, '-6511');

  DUP_VAL_ON_INDEX exception;
    pragma EXCEPTION_INIT(DUP_VAL_ON_INDEX, '-0001');

  TIMEOUT_ON_RESOURCE exception;
    pragma EXCEPTION_INIT(TIMEOUT_ON_RESOURCE, '-0051');

  INVALID_CURSOR exception;
    pragma EXCEPTION_INIT(INVALID_CURSOR, '-1001');

  NOT_LOGGED_ON exception;
    pragma EXCEPTION_INIT(NOT_LOGGED_ON, '-1012');

  LOGIN_DENIED exception;
    pragma EXCEPTION_INIT(LOGIN_DENIED, '-1017');

  NO_DATA_FOUND exception;
    pragma EXCEPTION_INIT(NO_DATA_FOUND, 100);

  ZERO_DIVIDE exception;
    pragma EXCEPTION_INIT(ZERO_DIVIDE, '-1476');

  INVALID_NUMBER exception;
    pragma EXCEPTION_INIT(INVALID_NUMBER, '-1722');

  TOO_MANY_ROWS exception;
    pragma EXCEPTION_INIT(TOO_MANY_ROWS, '-1422');

  STORAGE_ERROR exception;
    pragma EXCEPTION_INIT(STORAGE_ERROR, '-6500');

  PROGRAM_ERROR exception;
    pragma EXCEPTION_INIT(PROGRAM_ERROR, '-6501');

  VALUE_ERROR exception;
    pragma EXCEPTION_INIT(VALUE_ERROR, '-6502');

  ACCESS_INTO_NULL exception;
    pragma EXCEPTION_INIT(ACCESS_INTO_NULL, '-6530');

  COLLECTION_IS_NULL exception;
    pragma EXCEPTION_INIT(COLLECTION_IS_NULL , '-6531');

  SUBSCRIPT_OUTSIDE_LIMIT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_OUTSIDE_LIMIT,'-6532');

  SUBSCRIPT_BEYOND_COUNT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_BEYOND_COUNT ,'-6533');

  -- exception for ref cursors
  ROWTYPE_MISMATCH exception;
  pragma EXCEPTION_INIT(ROWTYPE_MISMATCH, '-6504');

  SYS_INVALID_ROWID  EXCEPTION;
  PRAGMA EXCEPTION_INIT(SYS_INVALID_ROWID, '-1410');

  -- The object instance i.e. SELF is null
  SELF_IS_NULL exception;
    pragma EXCEPTION_INIT(SELF_IS_NULL, '-30625');

  CASE_NOT_FOUND exception;
    pragma EXCEPTION_INIT(CASE_NOT_FOUND, '-6592');

  -- Added for USERENV enhancement, bug 1622213.
  USERENV_COMMITSCN_ERROR exception;
    pragma EXCEPTION_INIT(USERENV_COMMITSCN_ERROR, '-1725');

  -- Parallel and pipelined support
  NO_DATA_NEEDED exception;
    pragma EXCEPTION_INIT(NO_DATA_NEEDED, '-6548');
  -- End of 8.2 parallel and pipelined support

  /********** Add new exceptions here **********/

  /********** Function, operators and procedures **********/

  function "EXISTS" return BOOLEAN;
    pragma BUILTIN('EXISTS',10,240,240); -- This is special cased in PH2 -- Pj

  function GREATEST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DATE) return DATE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DATE) return DATE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr NUMBER, pat NUMBER, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER,
                   pat NUMBER,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER, pat NUMBER, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr DATE, pat DATE, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE,
                   pat DATE,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE, pat DATE, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function SQLCODE return PLS_INTEGER;
    pragma BUILTIN('SQLCODE',45, 10, 0); -- PEMS_DB, DB_SQLCODE

  function SQLERRM return varchar2;
    pragma FIPSFLAG('SQLERRM', 1452);

  function SQLERRM (code PLS_INTEGER) return varchar2;
    pragma BUILTIN('SQLERRM',46, 10, 1); -- PEMS_DB, DB_SQLERRM
    pragma FIPSFLAG('SQLERRM', 1452);

  function LEVEL return NUMBER;

  function ROWNUM return NUMBER;

  function '='  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('=',2, 3, 1); -- PEMS_INTEGER, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN; -- also <> and ~=
    pragma BUILTIN('!=',5, 3, 2); -- PEMS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<',4, 3, 3);  -- PEMS_INTEGER, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<=',6, 3, 4); -- PEMS_INTEGER, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>',1, 3, 5); -- PEMS_INTEGER, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>=',3, 3, 6); -- PEMS_INTEGER, PEMDMGE
    pragma FIPSFLAG('>=', 1450);

  --  Since SQL permits short-circuit evaluation, the 'and' and 'or'
  --  operations will always be interpreted as 'and then' and 'or else'
  --  when they occur in conditional statements.

  function XOR (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('XOR',8, 3, 9); -- PEMS_INTEGER, INT_XOR
    pragma FIPSFLAG('XOR', 1450);

  function 'NOT' (RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('NOT',9, 3, 10); -- PEMS_INTEGER, INT_NOT

  function 'IS NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);  -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50); -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 BOOLEAN, B2 BOOLEAN) return BOOLEAN;
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('=',2, 1, 14); -- PEMS_CHAR, PEMDCMEQ (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('=', 1454);
  function '!=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('!=',5, 1, 15);  -- PEMS_CHAR, PEMDCMNE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('!=', 1454);
  function '<'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<',4, 1, 16); -- PEMS_CHAR, PEMDCMLT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<', 1454);
  function '<=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<=',6, 1, 17); -- PEMS_CHAR, PEMDCMLE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<=', 1454);
  function '>'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>',1, 1, 18); -- PEMS_CHAR, PEMDCMGT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>', 1454);
  function '>=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>=',3, 1, 19); -- PEMS_CHAR, PEMDCMGE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>=', 1454);

  function '||' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN('||',25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT VARCHAR2 CHARACTER SET ANY_CS,
                  RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN(CONCAT,25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG(CONCAT, 1454);

  function LENGTH(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH', 1452);
  -- In SUBSTR, LEN defaults to remainder of string
  -- In substr and instr, a negative value of parameter POS means to
  -- count from the right end of the string.
  function SUBSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  POS PLS_INTEGER,
                  LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  -- Find nth occurrence of str1 in str2 starting at pos
  function INSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);
  function LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);
  function ASCII(ch VARCHAR2 CHARACTER SET ANY_CS)
        return PLS_INTEGER; -- should be ASCII.CHRANGE
    pragma FIPSFLAG('ASCII', 1452);
  function ASCIISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('ASCIISTR', 1452);
  function UNISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return NVARCHAR2;
    pragma FIPSFLAG('UNISTR', 1452);
  function CHR(n PLS_INTEGER) return varchar2;  -- N should be ASCII.CHRANGE
    pragma FIPSFLAG('CHR', 1452);
  function " SYS$STANDARD_CHR"(n PLS_INTEGER,csn VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET csn%CHARSET;
    pragma FIPSFLAG(' SYS$STANDARD_CHR', 1452);
  function INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('INITCAP', 1452);
  function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('SOUNDEX', 1452);

  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);
  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
  pragma FIPSFLAG('LPAD', 1452);

  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);
  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                     SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
                     DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('TRANSLATE', 1452);

  function REPLACE(SRCSTR VARCHAR2 CHARACTER SET ANY_CS,
                   OLDSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET := NULL)
        return VARCHAR2 CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);
  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);
  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'IS NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20);  -- PEMS_CHAR, PEMDNUL
  function 'IS NOT NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50); -- PEMS_CHAR, PEMDNUL

  function NVL(s1 VARCHAR2 CHARACTER SET ANY_CS,
               s2 VARCHAR2 CHARACTER SET s1%CHARSET)
        return VARCHAR2 CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);


  function '='  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 1); -- PEMS_NUMBER, PEMDCMEQ
  function '!=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 2); -- PEMS_NUMBER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 3); -- PEMS_NUMBER, PEMDCMLT
  function '<=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 4); -- PEMS_NUMBER, PEMDCMLE
  function '>'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 5); -- PEMS_NUMBER, PEMDCMGT
  function '>=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 6); -- PEMS_NUMBER, PEMDCMGE

  function 'IS NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_NUMBER, PEMDNUL

  function NVL(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 7); -- PEMS_NUMBER, NUM_NEG
  function ABS(n NUMBER) return NUMBER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 2, 8); -- PEMS_NUMBER, NUM_ADD
  function '-' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 9); -- PEMS_NUMBER, NUM_SUB
  function '*' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('*',17, 2, 10); -- PEMS_NUMBER, NUM_MUL
  function '/' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('/',18, 2, 11); -- PEMS_NUMBER, NUM_DIV

  function 'REM' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(n NUMBER) return NUMBER;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(n NUMBER) return NUMBER;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(n NUMBER) return NUMBER;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(n NUMBER) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COS', 1452);
  function SIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SIN', 1452);
  function TAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TAN', 1452);
  function COSH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COSH', 1452);
  function SINH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SINH', 1452);
  function TANH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TANH', 1452);

  function EXP(N NUMBER) return NUMBER;
  function LN(N NUMBER) return NUMBER;

  function BITAND (LEFT pls_integer, RIGHT pls_integer)
        return pls_integer;
  function BITAND (LEFT integer, RIGHT integer)
        return integer;
  function LOG (LEFT NUMBER, RIGHT NUMBER) return NUMBER;

  function TRUNC (n NUMBER, places pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT NUMBER, RIGHT pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (n NUMBER, e NUMBER) return NUMBER;
    pragma FIPSFLAG('POWER', 1452);

  function '='  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('=',2, 12, 1); -- PEMS_DATE, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT DATE, RIGHT DATE) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 12, 2); -- PEMS_DATE, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<',4, 12, 3); -- PEMS_DATE, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<=',6, 12, 4); -- PEMS_DATE, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>',1, 12, 5);  -- PEMS_DATE, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>=',3, 12, 6);  -- PEMS_DATE, PEMDCMGE
    pragma FIPSFLAG('>=', 1450);

  function '+' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('+',14, 12, 7); -- PEMS_DATE, DATE_ADD1
    pragma FIPSFLAG('+', 1450);
  function '+' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('+',14, 12, 8); -- PEMS_DATE, DATE_ADD2
    pragma FIPSFLAG('+', 1450);
  function '-' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('-',15, 12, 9); -- PEMS_DATE, DATE_SUB1
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('-',15, 12, 10); -- PEMS_DATE, DATE_SUB2
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('-',15, 12, 11); -- PEMS_DATE, DATE_SUB3
    pragma FIPSFLAG('-', 1450);

  function LAST_DAY(RIGHT DATE) return DATE;
    pragma BUILTIN('LAST_DAY',38, 12, 12); -- PEMS_DATE, DATE_LAST_DAY
    pragma FIPSFLAG('LAST_DAY', 1450);
  function ADD_MONTHS(LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 13); -- PEMS_DATE, DATE_ADD_MONTHS1
    pragma FIPSFLAG('ADD_MONTHS', 1450);
  function ADD_MONTHS(LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 14); -- PEMS_DATE, DATE_ADD_MONTHS2
    pragma FIPSFLAG('ADD_MONTHS', 1450);

  function MONTHS_BETWEEN(LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('MONTHS_BETWEEN',42, 12, 15); -- PEMS_DATE, DATE_MONTHS_BET
    pragma FIPSFLAG('MONTHS_BETWEEN', 1450);
  function NEXT_DAY(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('NEXT_DAY',43, 12, 16); -- PEMS_DATE, DATE_NEXT_DAY
    pragma FIPSFLAG('NEXT_DAY', 1450);
  function ROUND(RIGHT DATE) return DATE;
    pragma BUILTIN('ROUND',24, 12, 17); -- PEMS_DATE, DATE_ROUND
    pragma FIPSFLAG('ROUND', 1450);
  function NEW_TIME(RIGHT DATE, MIDDLE VARCHAR2, LEFT VARCHAR2) return DATE;
    pragma FIPSFLAG('NEW_TIME', 1450);

  function 'IS NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 12, 0);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 12, 50);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);
  function NVL (d1 DATE, d2 DATE) return DATE;
    pragma FIPSFLAG('NVL', 1450);

  function TRUNC(LEFT DATE) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 20); -- PEMS_DATE, DATE_TRUNC1
    pragma FIPSFLAG('TRUNC', 1450);
  function TRUNC(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 21); -- PEMS_DATE, DATE_TRUNC2
    pragma FIPSFLAG('TRUNC', 1450);
  function ROUND(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('ROUND',24, 12, 22); -- PEMS_DATE, DATE_ROUND2
    pragma FIPSFLAG('ROUND', 1450);

  function TO_DATE    (RIGHT VARCHAR2 character set any_cs)  return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 10); -- PEMS_CHAR, CHR_CNV_DAT
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT VARCHAR2 character set any_cs,
       RIGHT VARCHAR2 character set LEFT%charset) return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 8); -- PEMS_CHAR, CHR_CNV_DATE
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT NUMBER, RIGHT VARCHAR2) return DATE;
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE(left varchar2 character set any_cs,
                   format varchar2 character set LEFT%charset,
                   parms varchar2 character set LEFT%charset) return date;

  function TO_CHAR (RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',14, 0, 2);

  function TO_CHAR (LEFT DATE, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  function TO_CHAR (LEFT NUMBER, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function TO_NUMBER (RIGHT NUMBER) RETURN NUMBER;
    pragma BUILTIN('TO_NUMBER',14, 0, 1); -- PEMS_QUICK

  function TO_NUMBER (RIGHT VARCHAR2 character set any_cs)    return NUMBER;
    pragma BUILTIN('TO_NUMBER',48, 1, 9); -- PEMS_CHAR, CHR_CNV_NUM

  function TO_NUMBER(left varchar2 character set any_cs,
        format varchar2 character set LEFT%charset)
    return number;
  function TO_NUMBER(left varchar2 character set any_cs,
                     format varchar2 character set LEFT%charset,
                     parms varchar2 character set LEFT%charset)
    return number;

  -- Define SQL predicates.  These don't gen code, so no body is needed.

  -- PRIOR is WEIRD - For now, it will be treated as a function call.
  -- Does the function only take a column name?  how about its use in
  -- a predicate?
  function 'PRIOR'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname NUMBER) return NUMBER;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname DATE) return DATE;
      pragma FIPSFLAG('PRIOR', 1450);

  -- Outer Join has same problem as PRIOR
  function '(+)'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
  function '(+)'(colname NUMBER) return NUMBER;
  function '(+)'(colname DATE) return DATE;
      pragma FIPSFLAG('(+)', 1450);

  function '=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ANY', 1450);
  function '=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ANY', 1450);
  function '!=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ANY', 1450);
  function '<ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ANY', 1450);
  function '<=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ANY', 1450);
  function '>ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ANY', 1450);
  function '>=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ALL', 1450);
  function '=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ALL', 1450);
  function '!=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ALL', 1450);
  function '<ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ALL', 1450);
  function '<=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ALL', 1450);
  function '>ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ALL', 1450);
  function '>=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=SOME', 1450);
  function '=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=SOME', 1450);
  function '!=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<SOME', 1450);
  function '<SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=SOME', 1450);
  function '<=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>SOME', 1450);
  function '>SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=SOME', 1450);
  function '>=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  -- SQL Transaction routines
  procedure SET_TRANSACTION_USE(vc VARCHAR2);
  procedure COMMIT;
  procedure COMMIT_CM(vc VARCHAR2);
  procedure ROLLBACK_NR;
  procedure ROLLBACK_SV(Save_Point CHAR);
  procedure SAVEPOINT(Save_Point CHAR);

  function SYSDATE return DATE;
    pragma FIPSFLAG('SYSDATE', 1452);

  function UID return PLS_INTEGER;
    pragma FIPSFLAG('UID', 1452);

  function USER return VARCHAR2;

  function USERENV (envstr VARCHAR2) return VARCHAR2;
    pragma FIPSFLAG('USERENV', 1452);

  -- ROWID: this dreadful identifier is supposed to represent a datatype
  -- outside of SQL and and a pseudo-column (function, to us) when inside
  -- a sql statement.  ADA data model doesn't allow for any
  -- function X return X;
  -- so we must special case this.  Yuk.  There's special-case code in ph2nre
  -- which maps "rowid" to "rowid " if we're inside a SQL stmt.
  function "ROWID " return ROWID;
    pragma builtin('ROWID ', 1, 209, 240);  -- this had better never be called.

  function NULLFN (str VARCHAR2) return RAW;
    pragma builtin('NULLFN', 1, 0, 1);

  function HEXTORAW (c VARCHAR2) return RAW;
     pragma builtin('HEXTORAW', 1, 23, 1);

  function RAWTOHEX (r RAW) return VARCHAR2;
     pragma builtin('RAWTOHEX', 1, 23, 2);

  function CHARTOROWID (str VARCHAR2) return ROWID;
    pragma builtin('CHARTOROWID', 1, 0, 1);

  function ROWIDTOCHAR (str ROWID) return VARCHAR2;
    pragma builtin('ROWIDTOCHAR', 1, 0, 1);


  -- Trusted*Oracle additions
  Function ROWLABEL return MLSLABEL;                     -- pseudo column

  Function TO_CHAR(label MLSLABEL, format VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',90, 4, 19); -- PEMS_DATE, MLS_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  Function TO_LABEL(label VARCHAR2, format VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 8); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  Function TO_LABEL(label VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 2); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  -- vararg routines - icds in stdbdy
  Function LEAST_UB    (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('LEAST_UB',90, 4, 3); -- PEMS_CHAR, CHR_CNV_MLS
  Function GREATEST_LB (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('GREATEST_LB',90, 4, 4); -- PEMS_CHAR, CHR_CNV_MLS

  Function '>=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '>'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '='  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '!=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  function 'IS NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20); -- same "cod" as IS NULL(varchar2)
  function 'IS NOT NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50);

  function NVL(label1 MLSLABEL, label2 MLSLABEL) return MLSLABEL;
    pragma FIPSFLAG('NVL', 1452);

  -- group functions
  Function LUB (label MLSLABEL) return MLSLABEL;
  Function GLB (label MLSLABEL) return MLSLABEL;

  -- end of Trusted*Oracle additions


  -- beginning of NLS routines

  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS, c2 VARCHAR2) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS,
                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);

  function LENGTHB(ch VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
    pragma FIPSFLAG('LENGTHB', 1452);
  function SUBSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);
  function INSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  function TO_SINGLE_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_SINGLE_BYTE', 1452);
  function TO_MULTI_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_MULTI_BYTE', 1452);

  -- Next two added for NLS 6/3/92 JEM.
  function TO_CHAR(left date, format varchar2, parms varchar2) return varchar2;
  function TO_CHAR(left number, format varchar2, parms varchar2)
    return varchar2;
  function NLS_CHARSET_NAME(csetid PLS_INTEGER) return VARCHAR2;
  function NLS_CHARSET_ID(csetname VARCHAR2) return PLS_INTEGER;
  function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
    return PLS_INTEGER;

  -- end of NLS routines

  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2)
           return VARCHAR2 character set src%charset;
  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2,
                   srccset VARCHAR2)
          return VARCHAR2 character set src%charset;

  function " SYS$STANDARD_TRANSLATE" (src VARCHAR2 CHARACTER SET ANY_CS,
                                      csn VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET csn%CHARSET;
     pragma FIPSFLAG(' SYS$STANDARD_TRANSLATE',1452);

  function VSIZE (e number ) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e DATE) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);


  -- dump( expr [,display_format[,start_pos[,length]]]) return VARCHAR2
  function DUMP(e varchar2 character set any_cs,
                df pls_integer := null,sp pls_integer := null,
                len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e number,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e date,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  --
  -- ACOS, ASIN, ATAN, ATAN2
  --   Inverse Trigonometric functions
  --   These functions return NULL if any of the inputs are NULL
  --
  function ACOS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x NUMBER, y NUMBER) return NUMBER;
  pragma FIPSFLAG('ATAN2', 1452);

  --#### This is the end of 7.3 Standard

  -- LOB IS NULL
  function 'IS NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);
  -- end LOB IS NULL

  --****************************************************************
  -- 20 mar 96 =G=> In the following, arguments "1, 1, 1" to pragma BUILTIN
  -- e.g.,                pragma builtin('whatever', 1, 1, 1)
  -- indicate that those three numeric arguments to pragma BUILTIN are unknown,
  -- because they are not yet implemented by the backend.

  function '='  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<ADT_1>", pat "<ADT_1>", res "<ADT_1>")
        return "<ADT_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<ADT_1>", B2 "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function VALUE (item "<ADT_WITH_OID>") return "<ADT_1>";
    pragma BUILTIN('VALUE', 1, 1, 1);
    pragma FIPSFLAG('VALUE', 1450);

  function REF (item "<ADT_WITH_OID>") return REF "<ADT_1>";
    pragma BUILTIN('REF', 1, 1, 1);
    pragma FIPSFLAG('REF', 1450);

  function DEREF (r REF "<ADT_1>") return "<ADT_1>";
    pragma BUILTIN('DEREF', 1, 1, 1);
    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF ADT

  function 'IS NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function 'IS DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS DANGLING', 1450);

  function 'IS NOT DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  function NVL (B1 REF "<ADT_1>", B2 REF "<ADT_1>") return REF "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 0, 3, 1);
    pragma FIPSFLAG('=', 1450);

  function '!=' (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 0, 3, 2);
    pragma FIPSFLAG('!=', 1450);

  --  function '='  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('=', 1, 1, 1);
  --    pragma FIPSFLAG('=', 1450);
  --
  --  function '!=' (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('!=', 1, 1, 1);
  --    pragma FIPSFLAG('!=', 1450);
  --
  --  function '=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --
  --  function DECODE (expr "<COLLECTION_1>", pat "<COLLECTION_1>",
  --                                        res "<COLLECTION_1>")
  --      return "<COLLECTION_1>";
  --    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<COLLECTION_1>", B2 "<COLLECTION_1>")
        return "<COLLECTION_1>";
    pragma FIPSFLAG('NVL', 1450);

  function 'IS NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
        return "<REF_CURSOR_1>";
    pragma FIPSFLAG('NVL', 1450);

  function EMPTY_CLOB return clob;
  function EMPTY_BLOB return blob;

  function BFILENAME(directory varchar2,filename varchar2) return BFILE;

  function "SYS$LOB_REPLICATION" (x in blob) return blob;
  function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
    return clob character set x%charset;

  --#### This is the end of 8.0 Standard

  --  + overloadings

  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;

  function '+'(LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_UNCONSTRAINED;

  function '+'(LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_TZ_UNCONSTRAINED;

  function '+'(LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
                return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
                return TIME_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
                return TIME_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return DSINTERVAL_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return YMINTERVAL_UNCONSTRAINED ;

  -- begin subtract
  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return YMINTERVAL_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT" (LEFT TIME_UNCONSTRAINED,
                                      RIGHT TIME_UNCONSTRAINED)
     return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_UNCONSTRAINED ;
  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED ;
  function  " SYS$DSINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date;
  function '-' (LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date;

  function '-' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
   return DSINTERVAL_UNCONSTRAINED ;

  -- end subtract

  -- other datetime operators

  function '*' (LEFT number, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT number, RIGHT DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;

  function '*' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;

  function '/' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '/' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;


  function current_date return date;
  function current_time return TIME_TZ_UNCONSTRAINED;
  function current_timestamp return TIMESTAMP_TZ_UNCONSTRAINED;

  function TO_TIME (RIGHT varchar2 character set any_cs) return
    time_unconstrained;
    pragma BUILTIN('TO_TIME', 0, 15, 1);
    function TO_TIMESTAMP (RIGHT varchar2 character set any_cs)
                           return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 3);
  function TO_TIME_TZ (RIGHT varchar2 character set any_cs)
    return  TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 5);
  function TO_TIMESTAMP_TZ (RIGHT varchar2 character set any_cs)
    return  TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 7);
  function TO_YMINTERVAL (RIGHT varchar2 character set any_cs)
    return  YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_YMINTERVAL', 0, 15, 9);
  function TO_DSINTERVAL (RIGHT varchar2 character set any_cs)
    return  DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_DSINTERVAL', 0, 15, 11);

  -- with nls args
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset,
                   parms varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset,
                        parms varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset,
                           parms varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset,
                      parms varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_DSINTERVAL(RIGHT varchar2 character set any_cs,
                         parms varchar2 character set RIGHT%charset)
    return DSINTERVAL_UNCONSTRAINED;

  function NUMTOYMINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return YMINTERVAL_UNCONSTRAINED;
  function NUMTODSINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return DSINTERVAL_UNCONSTRAINED;

  function '='  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('=',0, 11, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',0, 11, 2);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<',0, 11, 3);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<=',0, 11, 4);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>',0, 11, 5);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>=',0, 11, 6);
    pragma FIPSFLAG('>=', 1450);

  function 'IS NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 14, 0); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 14, 50); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function "UROWID " return UROWID;
    pragma builtin('UROWID ', 1, 209, 240);  -- this had better never be called.

  -- New built-in function SYS_GUID, returns globally unique id
  function SYS_GUID return RAW;

  -- New built-in function SYS_CONTEXT
  function SYS_CONTEXT (namespace varchar2, attribute varchar2)
    return varchar2;

  function TRIM(v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  --#### This is the end of 8.1.5 Standard

  -- SYS_CONTEXT now has an additional optional parameter
  function SYS_CONTEXT(namespace varchar2, attribute varchar2,
                       newoptional varchar2)
    return varchar2;

  -- CUBE and ROLLUP are not real functions; they are variants on the GROUP
  -- BY clause (GROUP BY CUBE (...) and GROUP BY ROLLUP (...)). They have
  -- been added here as functions to avoid name capture issues.
  --
  -- Note that both CUBE and ROLLUP look like true vararg functions with
  -- *no* repeating pattern of formals - hence they are special cased in
  -- the overloading code.
  function CUBE return NUMBER;
  function ROLLUP return NUMBER;

  -- The GROUPING function must be used in conjunction with CUBE and ROLLUP
  -- in the GROUP BY clause. The type of the parameter to GROUPING can be
  -- any type that can appear in a GROUP BY list.
  function GROUPING(v VARCHAR2) return NUMBER;
  function GROUPING(a "<ADT_1>") return NUMBER;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 VARCHAR2 CHARACTER SET ANY_CS ,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   VARCHAR2 CHARACTER SET ANY_CS ,
                                 TSET   VARCHAR2 CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  --#### This is the end of the supported parts of 8.1.6 Standard

  --## Support for ANSI datetime data types is under development.
  --## The following operations, as well as the related types and
  --## operations defined above in the 8.1.5 section, are not yet
  --## available for use and are still subject to change.

  --- datetime equivalence
  function '='  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function TO_TIME (RIGHT TIME_TZ_UNCONSTRAINED)  return TIME_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME', 0, 15, 13);
  function TO_TIME_TZ (RIGHT TIME_UNCONSTRAINED)  return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 14);
  function TO_TIMESTAMP (RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 15);
  function TO_TIMESTAMP_TZ (RIGHT TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 16);

  function '-'
      (LEFT TIME_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  -- timezone functions
  function SYS_AT_TIME_ZONE(t time_tz_unconstrained,
                            i varchar2) RETURN time_tz_unconstrained;
  function SYS_AT_TIME_ZONE(t timestamp_tz_unconstrained,
                            i varchar2) RETURN timestamp_tz_unconstrained;
  FUNCTION systimestamp RETURN timestamp_tz_unconstrained;
  FUNCTION dbtimezone RETURN varchar2;
  FUNCTION sessiontimezone RETURN varchar2;
  FUNCTION localtimestamp RETURN timestamp_unconstrained;
  FUNCTION localtime RETURN time_unconstrained;

  function TO_TIMESTAMP (RIGHT DATE)  return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 17);

  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT yminterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '+'(LEFT dsinterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return yminterval_unconstrained;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;

  function '='  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;

  function SYS_LITERALTOYMINTERVAL(numerator varchar2, units varchar2)
    return YMINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTODSINTERVAL(numerator varchar2, units varchar2)
    return DSINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTOTIME(numerator varchar2)
    return TIME_UNCONSTRAINED;
  function SYS_LITERALTOTZTIME(numerator varchar2)
    return TIME_TZ_UNCONSTRAINED;
  function SYS_LITERALTOTIMESTAMP(numerator varchar2)
    return TIMESTAMP_UNCONSTRAINED;
  function SYS_LITERALTOTZTIMESTAMP(numerator varchar2)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function SYS_LITERALTODATE(numerator varchar2) return DATE;


  -- Explicit conversions between date and datetime
  function TO_TIMESTAMP(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 24);

  function TO_TIMESTAMP_TZ(ARG DATE) return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 27);

  function TO_TIMESTAMP_TZ(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 26);

  -- IS [NOT] NULL / NVL for datetime
  function 'IS NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_UNCONSTRAINED,
                b2 TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;

  function 'IS NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_TZ_UNCONSTRAINED, b2 TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_UNCONSTRAINED,
                b2 TIMESTAMP_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_TZ_UNCONSTRAINED, b2 TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_LTZ_UNCONSTRAINED,
                b2 TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;

  function 'IS NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 YMINTERVAL_UNCONSTRAINED, b2 YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;

  function 'IS NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 DSINTERVAL_UNCONSTRAINED, b2 DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  function " SYS$EXTRACT_FROM"
              (T TIME_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T DATE,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I YMINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I DSINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;

  -- ##########      8.2 LOB Built-in Functions       ######## --

  -- LENGTH --
  function LENGTH(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  function LENGTH(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  -- SUBSTR --
  function SUBSTR(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  function SUBSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);

  -- INSTR --
  function INSTR(STR1 CLOB CHARACTER SET ANY_CS,
                 STR2 CLOB CHARACTER SET STR1%CHARSET,
                 POS INTEGER := 1,
                 NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function INSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  STR2 CLOB CHARACTER SET STR1%CHARSET,
                  POS INTEGER := 1,
                  NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  -- CONCAT --
  function '||' (LEFT CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT CLOB CHARACTER SET ANY_CS,
                  RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG(CONCAT, 1454);

  -- UPPER --
  function UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);

  -- LOWER --
  function LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);

  -- LPAD --
  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  -- RPAD --
  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  -- LTRIM --
  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  -- RTRIM --
  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  -- TRIM --
  function TRIM(v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 CLOB CHARACTER SET ANY_CS ,
                               TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   CLOB CHARACTER SET ANY_CS ,
                                 TSET   CLOB CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;


  -- LIKE --
  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  -- NVL --
  function NVL(s1 CLOB CHARACTER SET ANY_CS,
               s2 CLOB CHARACTER SET s1%CHARSET)
    return CLOB CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);

  -- REPLACE --
  function REPLACE(SRCSTR CLOB CHARACTER SET ANY_CS,
                   OLDSUB CLOB CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB CLOB CHARACTER SET SRCSTR%CHARSET := NULL)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  -- LOB RELATIONAL OPERATORS --

  Function '='  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;

  /* LOB-related conversion functions */
  function TO_CLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS) return CLOB;
    pragma BUILTIN('TO_CLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  function TO_BLOB(RIGHT RAW) return BLOB;
    pragma BUILTIN('TO_BLOB', 0, 15, 30); -- OPC_CVT_RAW2BLB
  function TO_RAW(RIGHT BLOB) return RAW;
    pragma BUILTIN('TO_RAW', 0, 15, 32); -- OPC_CVT_BLB2RAW

  -- ####### end of 8.2 LOB Built-in Functions  ######## --

  function NULLIF(v1 VARCHAR2, v2 VARCHAR2) return VARCHAR2;
  function NULLIF(v1 BOOLEAN, v2 BOOLEAN) return VARCHAR2;
  function NULLIF(a1 "<ADT_1>", a2 "<ADT_1>") return VARCHAR2;

  function COALESCE return VARCHAR2;

  /* Daylight Saving Time Functions */
  FUNCTION tz_offset(region VARCHAR2)  RETURN VARCHAR2;
  FUNCTION from_tz(t TIMESTAMP_UNCONSTRAINED,timezone VARCHAR2)
    RETURN timestamp_tz_unconstrained;

  function " SYS$EXTRACT_STRING_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;

  function INSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR2', 1452);

  function INSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR4', 1452);

  function INSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRC', 1452);

  function LENGTH2(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH2', 1452);

  function LENGTH4(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH4', 1452);

  function LENGTHC(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTHC', 1452);

  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function SUBSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR2', 1452);

  function SUBSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR4', 1452);

  function SUBSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRC', 1452);

  /**** char <--> nchar conversion functions in Unicode project ********/

  function TO_NCHAR(RIGHT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',14, 0, 2);

  function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB;
  function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB;

  function TO_NCLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return NCLOB;
    pragma BUILTIN('TO_NCLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  /* convert to either CLOB or NCLOB respectively if parm is char or nchar */
  function TO_ANYLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET RIGHT%CHARSET;
    pragma BUILTIN('TO_ANYLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB

  /* Followings are the same builtin op codes as without N prefix functions,
   * implementation relys on impilcit conversion MCODEs
   */
  function TO_NCHAR (LEFT DATE, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_NCHAR', 1450);
  function TO_NCHAR (LEFT NUMBER, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function NHEXTORAW (c NVARCHAR2) return RAW;
    pragma builtin('NHEXTORAW', 1, 23, 1);
  function RAWTONHEX (r RAW) return NVARCHAR2;
    pragma builtin('RAWTONHEX', 1, 23, 2);
  function NCHARTOROWID (str NVARCHAR2) return ROWID;
    pragma builtin('NCHARTOROWID', 1, 0, 1);
  function ROWIDTONCHAR (str ROWID) return NVARCHAR2;
    pragma builtin('ROWIDTONCHAR', 1, 0, 1);

  function NCHR(n pls_integer) return NVARCHAR2;

  /* implemented by icd calls as the same as TO_CHAR */
  function TO_NCHAR(left date, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left number, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  /* implemented as a icd call, return TRUE if nchar, otherwise FALSE */
  function ISNCHAR(c VARCHAR2 character set any_cs) return boolean;

  /************ end of char <--> nchar conversion functions ************/

  /* Create overloads for all standard functions that work with <ADT_1> for
     <OPAQUE_1> */
  function '='  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<OPAQUE_1>", pat "<OPAQUE_1>", res "<OPAQUE_1>")
    return "<OPAQUE_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<OPAQUE_1>", B2 "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('NVL', 1450);

  --  REFs to opaques are not supported yet.
  --  function VALUE (item "<ADT_WITH_OID>") return "<OPAQUE_1>";
  --    pragma BUILTIN('VALUE', 1, 1, 1);
  --    pragma FIPSFLAG('VALUE', 1450);

  --  function REF (item "<ADT_WITH_OID>") return REF "<OPAQUE_1>";
  --    pragma BUILTIN('REF', 1, 1, 1);
  --    pragma FIPSFLAG('REF', 1450);

  --  function DEREF (r REF "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('DEREF', 1, 1, 1);
  --    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF OPAQUE

  --  function 'IS NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NULL', 0, 3, 0);
  --    pragma FIPSFLAG('IS NULL', 1450);

  --  function 'IS NOT NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma FIPSFLAG('IS NOT NULL', 1450);

  --  function 'IS DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS DANGLING', 1450);

  --  function 'IS NOT DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
  --    return REF "<OPAQUE_1>";
  --    pragma FIPSFLAG('NVL', 1450);

  --  function '='  (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('=', 0, 3, 1);
  --    pragma FIPSFLAG('=', 1450);

  --  function '!=' (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('!=', 0, 3, 2);
  --    pragma FIPSFLAG('!=', 1450);

  function GROUPING(a "<OPAQUE_1>") return NUMBER;
  function NULLIF(a1 "<OPAQUE_1>", a2 "<OPAQUE_1>") return VARCHAR2;

  function GREATEST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIME_TZ_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj

  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;

  -- CONVERT FOR LOB --
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2,
                   SRCCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;

  -- NLS_UPPER/NLS_LOWER FOR LOB --
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);

  function COMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS)
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('COMPOSE', 1452);
  function DECOMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS,
                     canmode in VARCHAR2 DEFAULT 'CANONICAL')
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('DECOMPOSE', 1452);
  FUNCTION SYS_EXTRACT_UTC(t timestamp_tz_unconstrained)
    return TIMESTAMP_UNCONSTRAINED;

  -- Begin REGEXP Support (10iR1) --

  -- REGEXP_LIKE --
  function REGEXP_LIKE (srcstr   VARCHAR2 CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  function REGEXP_LIKE (srcstr   CLOB CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  -- REGEXP_INSTR --
  function REGEXP_INSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        occurrence  PLS_INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);

  function REGEXP_INSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        occurrence  INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);


  -- REGEXP_SUBSTR --
  function REGEXP_SUBSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    PLS_INTEGER := 1,
                         occurrence  PLS_INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  function REGEXP_SUBSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    INTEGER := 1,
                         occurrence  INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  -- REGEXP_REPLACE --
  function REGEXP_REPLACE(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    PLS_INTEGER := 1,
                          occurrence  PLS_INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  CLOB CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  -- End REGEXP Support --

  -- binary_float and binary_double functions and operators.
  function TO_BINARY_FLOAT (RIGHT BINARY_FLOAT) RETURN BINARY_FLOAT;
    pragma BUILTIN('TO_BINARY_FLOAT',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;

  function TO_BINARY_DOUBLE (RIGHT BINARY_DOUBLE) RETURN BINARY_DOUBLE;
    pragma BUILTIN('TO_BINARY_DOUBLE',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;

  function 'IS NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;

  function TO_CHAR (left binary_float, format varchar2)
    return VARCHAR2;
  function TO_CHAR (left binary_double, format varchar2)
    return VARCHAR2;

  function TO_CHAR(left binary_float, format varchar2, parms varchar2)
    return varchar2;
  function TO_CHAR(left binary_double, format varchar2, parms varchar2)
    return varchar2;

  function TO_NCHAR(left binary_float, format nvarchar2) return NVARCHAR2;
  function TO_NCHAR(left binary_double, format nvarchar2) return NVARCHAR2;

  function TO_NCHAR(left binary_float, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left binary_double, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  function 'REMAINDER'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG(REMAINDER, 1452);

  function '='  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 15);
  function '!=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('!=',5, 2, 16);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 17);
  function '<=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 18);
  function '>'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 19);
  function '>=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 20);

  function 'IS NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 23);
  function ABS(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 2, 24);
  function '-' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 25);
  function '*' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('*',17, 2, 26);
  function '/' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('/',18, 2, 27);

  function 'REM' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(F1 BINARY_FLOAT, F2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('MOD', 1452);

  function FLOOR(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('CEIL', 1452);
  function SIGN(f BINARY_FLOAT) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);
  function SQRT(f BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('SQRT', 1452);

  function TRUNC (F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ROUND', 1452);

  function '='  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 28);
  function '!=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 29);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 30);
  function '<=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 31);
  function '>'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 32);
  function '>=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 33);

  function 'IS NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 36);
  function ABS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ABS', 1452);

  function ACOS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x BINARY_DOUBLE, y BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN2', 1452);

  function '+' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 2, 37);
  function '-' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 38);
  function '*' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('*',17, 2, 39);
  function '/' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('/',18, 2, 40);

  function 'REM' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(D1 BINARY_DOUBLE, D2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(d BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(d BINARY_DOUBLE) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function COSH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SINH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TANH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function EXP(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function LN(D BINARY_DOUBLE) return BINARY_DOUBLE;

  function LOG (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;

  function TRUNC (D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (d BINARY_DOUBLE, e BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('POWER', 1452);

  function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER;
  function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
  function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;

  function GREATEST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function GREATEST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2


  function '+' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',15, 2, 41);
  function ABS(I PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 2, 42);
  function '-' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',14, 2, 43);
  function '*' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('*',14, 2, 44);

  function '='  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 45); -- PEMS_PLS_INTEGER, PEMDCMEQ
  function '!=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 46); -- PEMS_PLS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 47); -- PEMS_PLS_INTEGER, PEMDCMLT
  function '<=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 48); -- PEMS_PLS_INTEGER, PEMDCMLE
  function '>'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 49); -- PEMS_PLS_INTEGER, PEMDCMGT
  function '>=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 51); -- PEMS_PLS_INTEGER, PEMDCMGE

  function 'IS NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_PLS_INTEGER, PEMDNUL
  function 'IS NOT NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_PLS_INTEGER, PEMDNUL

  function NVL(I1 PLS_INTEGER, I2 PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('NVL', 1452);

  function TRUNC (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('ROUND', 1452);

  function SIGN(i PLS_INTEGER) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);

  function GREATEST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2

  -- MultiSet Functions and Operators.

  -- Equality
  function '='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('=',2, 16, 1);

  function '!='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('!=',2, 16, 2);

  function CARDINALITY (collection IN "<TABLE_1>") return PLS_INTEGER;

  function SET (collection IN "<TABLE_1>") return "<TABLE_1>";
    pragma BUILTIN('SET',18, 2, 40);-- Dummy

  function 'IS A SET' (collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS A SET',18, 2, 40);-- Dummy
  function 'IS NOT A SET'(collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT A SET',18, 2, 40);-- Dummy

  function 'IS EMPTY' (collection IN  "<TABLE_1>") return BOOLEAN;
  function 'IS NOT EMPTY'(collection IN  "<TABLE_1>") return BOOLEAN;

  -- IS A SUBMULTISET OF
  function 'SUBMULTISET' (collection IN  "<TABLE_1>",
                          collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('SUBMULTISET',18, 2, 40);

  function 'MULTISET_UNION_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
      pragma BUILTIN('MULTISET_UNION_ALL',18, 2, 40);

  function 'MULTISET_UNION_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_UNION_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_DISTINCT',18, 2, 40);-- Dummy

  -- These are dummy procedures for correct management of new control
  -- statements added to PL/SQL. They ensure local procedures which have the
  -- same names as newly introduced keywords are not masked by those keywords.

  procedure continue;

  -- REGEXP_COUNT --
  function REGEXP_COUNT(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  function REGEXP_COUNT(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  --#### All user-visible declarations should preceed this point.  The
  --#### following are implementation-oriented pragmas that may need
  --#### editing in the future; we would prefer to be able to edit them
  --#### without affecting the rft numbering of user-visible items.

  --#### interface pragmas

  --#### Note that for any ICD which maps directly to a PVM
  --#### Opcode MUST be mapped to pes_dummy.
  --#### An ICD which invokes another ICD by flipping operands is
  --#### mapped to pes_flip, and an ICD whose result is the inverse of
  --#### another ICD is mapped to pes_invert
  --#### New ICDs should be placed at the end of this list, and a
  --#### corresponding entry must be made in the ICD table in pdz7

  PRAGMA interface(c,length,"pes_dummy",1);
  PRAGMA interface(c,substr,"pes_dummy",1);
  PRAGMA interface(c,instr,"pesist",1);
  PRAGMA interface(c,UPPER,"pesupp",1);
  PRAGMA interface(c,LOWER,"peslow",1);
  PRAGMA interface(c,ASCII,"pesasc");
  PRAGMA interface(c,ASCIISTR,"pesastr");
  PRAGMA interface(c,UNISTR,"pesustr");
  PRAGMA interface(c,CHR,"peschr");
  PRAGMA interface(c," SYS$STANDARD_CHR","peschr");
  PRAGMA interface(c,INITCAP,"pesicp");
  PRAGMA interface(c,LPAD,"peslpd",1);
  PRAGMA interface(c,LPAD,"peslpd",2);
  PRAGMA interface(c,RPAD,"pesrpd",1);
  PRAGMA interface(c,RPAD,"pesrpd",2);
  PRAGMA interface(c,REPLACE,"pesrep",1);
  PRAGMA interface(c,LTRIM,"pesltr",1);
  PRAGMA interface(c,LTRIM,"pesltr",2);
  PRAGMA interface(c,RTRIM,"pesrtr",1);
  PRAGMA interface(c,RTRIM,"pesrtr",2);
  PRAGMA interface(c,'LIKE',"peslik",1);
  PRAGMA interface(c,'LIKE',"pesli2",2);
  PRAGMA interface(c,ABS,"pes_dummy",1);
  PRAGMA interface(c,'MOD',"pesmod", 1);
  PRAGMA interface(c,floor,"pesflo", 1);
  PRAGMA interface(c,CEIL,"pescei", 1);
  PRAGMA interface (c, SQRT, "pessqt", 1);
  PRAGMA interface(c,SIGN,"pessgn", 1);
  PRAGMA interface(c,cos,"pescos", 1);
  PRAGMA interface(c,sin,"pessin",1);
  PRAGMA interface(c,TAN,"pestan",1);
  PRAGMA interface(c,COSH,"pescsh",1);
  PRAGMA interface(c,SINH,"pessnh",1);
  PRAGMA interface(c,TANH,"pestnh",1);
  PRAGMA interface(c,EXP,"pesexp",1);
  PRAGMA interface(c,LN,"pesln",1);
  PRAGMA interface(c,BITAND,"pesbtd",1);
  PRAGMA interface(c,BITAND,"pesbtdn",2);
  PRAGMA interface(c,LOG,"peslog",1);
  PRAGMA interface(c,TRUNC,"pestru",1);
  PRAGMA interface(c,ROUND,"pesrnd",1);
  PRAGMA interface(c,POWER,"pespow",1);
  PRAGMA interface(c,NEW_TIME,"pesnwt");
  PRAGMA interface(c,TO_DATE,"pesc2d",4);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",3);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",4);
  PRAGMA interface(c,'>=',"pes_flip",5);
  PRAGMA interface(c,'>',"pes_flip",5);
  PRAGMA interface(c,'<=',"peszle",5);
  PRAGMA interface(c,'<',"peszlt",5);        -- ICD #50
  PRAGMA interface(c,'=',"peszeq",5);
  PRAGMA interface(c,'!=',"pes_invert",5);
  PRAGMA interface(c,nlssort,"pesxco",2);
  PRAGMA interface(c,NLS_UPPER,"pesxup",1);
  PRAGMA interface(c,NLS_UPPER,"peslcnup",3); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_UPPER,"peslcnup",4); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_LOWER,"pesxlo",1);
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",3); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",4); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_INITCAP,"pesxcp",1);
  PRAGMA interface(c,lengthb,"pes_dummy",1);
  PRAGMA interface(c,substrb,"pes_dummy",1);
  PRAGMA interface(c,instrb,"pesxis",1);
  PRAGMA interface(c,TO_SINGLE_BYTE, "pesxsi");
  PRAGMA interface(c,TO_MULTI_BYTE,"pesxmu");
  PRAGMA interface(c,TO_CHAR,"pesd2c",5);
  PRAGMA interface(c,TO_CHAR,"pesn2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesd2c",4);
  PRAGMA interface(c,TO_NCHAR,"pesn2c",5);
  PRAGMA interface(c," SYS$STANDARD_TRANSLATE","pesxcs");
  PRAGMA interface(c,ATAN,"pesatan",1);
  PRAGMA interface(c,EMPTY_CLOB,"peslcem");
  PRAGMA interface(c,EMPTY_BLOB,"peslbem");
  PRAGMA interface(c,BFILENAME,"pesfnm");
  PRAGMA interface(c,TO_TIME,"pes3tm",2);
  PRAGMA interface(c,TO_TIME,"pes3tm",3);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",2);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",3);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",2);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",3);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",2);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",3);
  PRAGMA interface(c,TO_DSINTERVAL,"pes2dsi",2);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",1);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",2);
  PRAGMA interface(c,SESSIONTIMEZONE,"pesstz",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",2);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",3);
  PRAGMA interface(c,TRIM,"pestrim",1);
  -- Datetime addition
  PRAGMA interface(c,'+',"pesati",5);    --  +(tsp, iym) return tsp
  PRAGMA interface(c,'+',"pesati",6);    --  +(tsp, ids) return tsp
  PRAGMA interface(c,'+',"pesati",7);    --  +(tsz, iym) return tsz
  PRAGMA interface(c,'+',"pesati",8);    --  +(tsz, ids) return tsz
  PRAGMA interface(c,'+',"pesati",9);    --  +(tim, ids) return tim
  PRAGMA interface(c,'+',"pesati",10);   --  +(tmz, ids) return tmz
  PRAGMA interface(c,'+',"pesadi",11);   --  +(dat, iym) return dat
  PRAGMA interface(c,'+',"pesadi",12);   --  +(dat, ids) return dat
  PRAGMA interface(c,'+',"pes_flip",13); --  +(iym, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",14); --  +(iym, tsz) return tsz -- ICD #100
  PRAGMA interface(c,'+',"pes_flip",15); --  +(iym, dat) return dat
  PRAGMA interface(c,'+',"pes_flip",16); --  +(ids, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",17); --  +(ids, tsz) return tsz
  PRAGMA interface(c,'+',"pes_flip",18); --  +(ids, tim) return tim
  PRAGMA interface(c,'+',"pes_flip",19); --  +(ids, tmz) return tmz
  PRAGMA interface(c,'+',"pes_flip",20); --  +(ids, dat) return dat
  PRAGMA interface(c,'+',"pesaii",21);   --  +(ids, ids) return ids
  PRAGMA interface(c,'+',"pesaii",22);   --  +(iym, iym) return iym
  PRAGMA interface(c,'+',"pesati",23);   --  +(ltz, iym) return ltz
  PRAGMA interface(c,'+',"pesati",24);   --  +(ltz, ids) return ltz
  PRAGMA interface(c,'+',"pes_flip",25);--  +(iym, ltz) return ltz
  PRAGMA interface(c,'+',"pes_flip",26);--  +(ids, ltz) return ltz
  -- Datetime subtraction
  PRAGMA interface(c,'-',"pessti",6);    --  -(tsp, iym) return tsp
  PRAGMA interface(c,'-',"pessti",7);    --  -(tsp, ids) return tsp
  PRAGMA interface(c,'-',"pessti",8);    --  -(tsz, iym) return tsz
  PRAGMA interface(c,'-',"pessti",9);    --  -(tsz, ids) return tsz
  PRAGMA interface(c,'-',"pessti",10);   --  -(tim, ids) return tim
  PRAGMA interface(c,'-',"pessti",11);   --  -(tmz, ids) return tmz
  PRAGMA interface(c,'-',"pessdi",12);   --  -(dat, iym) return dat
  PRAGMA interface(c,'-',"pessdi",13);   --  -(dat, ids) return dat
  PRAGMA interface(c,'-',"pessii",14);   --  -(iym, iym) return iym
  PRAGMA interface(c,'-',"pessii",15);   --  -(ids, ids) return ids
  PRAGMA interface(c,'-',"pessttds",16); --  -(tim, tim) return ids
  PRAGMA interface(c,'-',"pessttds",17); --  -(tsp, tsp) return ids
  PRAGMA interface(c,'-',"pessttds",18); --  -(tmz, tmz) return ids
  PRAGMA interface(c,'-',"pessttds",19); --  -(tsz, tsz) return ids
  PRAGMA interface(c,'-',"pessti",20);   --  -(ltz, iym) return iym
  PRAGMA interface(c,'-',"pessti",21);   --  -(ltz, ids) return ids
  PRAGMA interface(c,'-',"pessttds",22); --  -(ltz, ltz) return ids
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",1);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",2);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",3);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",4);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessddds",5);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",6);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",1);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",2);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessddym",3);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",4);
  -- Datetime multiplication
  PRAGMA interface(c,'*',"pesmni",2);    --  *(num, iym) return iym
  PRAGMA interface(c,'*',"pesmni",3);    --  *(num, ids) return ids
  PRAGMA interface(c,'*',"pes_flip",4);  --  *(iym, num) return iym
  PRAGMA interface(c,'*',"pes_flip",5);  --  *(ids, num) return ids
  -- Datetime division
  PRAGMA interface(c,'/',"pesdvin",2);   --  /(iym, num) return iym
  PRAGMA interface(c,'/',"pesdvin",3);   --  /(ids, num) return ids
  -- TIME
  PRAGMA interface(c,'=',"pes_dummy",9);
  PRAGMA interface(c,'!=',"pes_invert",9);
  PRAGMA interface(c,'>',"pes_flip",8);
  PRAGMA interface(c,'<',"pes_dummy",8);
  PRAGMA interface(c,'>=',"pes_flip",8);   -- ICD #150
  PRAGMA interface(c,'<=',"pes_dummy",8);
  -- TIME WITH TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",10);
  PRAGMA interface(c,'!=',"pes_invert",10);
  PRAGMA interface(c,'>',"pes_flip",9);
  PRAGMA interface(c,'<',"pes_dummy",9);
  PRAGMA interface(c,'>=',"pes_flip",9);
  PRAGMA interface(c,'<=',"pes_dummy",9);
  -- TIMESTAMP
  PRAGMA interface(c,'=',"pes_dummy",11);
  PRAGMA interface(c,'!=',"pes_invert",11);
  PRAGMA interface(c,'>',"pes_flip",10);
  PRAGMA interface(c,'<',"pes_dummy",10);
  PRAGMA interface(c,'>=',"pes_flip",10);
  PRAGMA interface(c,'<=',"pes_dummy",10);
  -- INTERVAL YEAR TO MONTH
  PRAGMA interface(c,'=',"pes_dummy",12);
  PRAGMA interface(c,'!=',"pes_invert",12);
  PRAGMA interface(c,'>',"pes_flip",11);
  PRAGMA interface(c,'<',"pes_dummy",11);
  PRAGMA interface(c,'>=',"pes_flip",11);
  PRAGMA interface(c,'<=',"pes_dummy",11);
  -- INTERVAL DAY TO SECOND
  PRAGMA interface(c,'=',"pes_dummy",13);
  PRAGMA interface(c,'!=',"pes_invert",13);
  PRAGMA interface(c,'>',"pes_flip",12);
  PRAGMA interface(c,'<',"pes_dummy",12);
  PRAGMA interface(c,'>=',"pes_flip",12);
  PRAGMA interface(c,'<=',"pes_dummy",12);
  -- TIMESTAMP_TZ_UNCONSTRAINED
  PRAGMA interface(c,'=',"pes_dummy",14);
  PRAGMA interface(c,'!=',"pes_invert",14);
  PRAGMA interface(c,'>',"pes_flip",13);
  PRAGMA interface(c,'<',"pes_dummy",13);
  PRAGMA interface(c,'>=',"pes_flip",13);
  PRAGMA interface(c,'<=',"pes_dummy",13);
  -- TIMESTAMP WITH LOCAL TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",15);
  PRAGMA interface(c,'!=',"pes_invert",15);
  PRAGMA interface(c,'>',"pes_flip",14);
  PRAGMA interface(c,'<',"pes_dummy",14);
  PRAGMA interface(c,'>=',"pes_flip",14);
  PRAGMA interface(c,'<=',"pes_dummy",14);
  -- Other datetime functions
  PRAGMA interface(c,'CURRENT_DATE',"pescdt",1);
  PRAGMA interface(c,'CURRENT_TIME',"pesctm",1);
  PRAGMA interface(c,'CURRENT_TIMESTAMP',"pescts",1);
  --  Internal calls to evaluate datetime/interval literals without NLS parms.
  PRAGMA interface(c,SYS_LITERALTOYMINTERVAL,"pesc2ymi",1);
  PRAGMA interface(c,SYS_LITERALTODSINTERVAL,"pesc2dsi",1);
  PRAGMA interface(c,SYS_LITERALTOTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTODATE,"pesc2date",1);
  -- extract(field from expr)
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",1);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",2);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",3);   -- ICD #200
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",4);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",5);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefdt",6);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",7);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",8);
  -- datetime is null
  PRAGMA interface(c,"IS NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NULL","pes_dummy",20); -- interval ds

  -- 8.2 LOB Built-in Functions
  PRAGMA interface(c,length, "peslcln",2);    -- LOB LENGTH
  PRAGMA interface(c,lengthb,"peslclb",2);    -- LOB LENGTHB
  PRAGMA interface(c,substr, "peslcst",2);    -- LOB SUBSTR
  PRAGMA interface(c,substrb,"peslcsb",2);    -- LOB SUBSTRB
  PRAGMA interface(c,instr,  "peslcin",2);    -- LOB INSTR
  PRAGMA interface(c,instrb, "peslcib",2);    -- LOB INSTRB
  PRAGMA interface(c,'||',   "peslcct",2);    -- LOB '||'
  PRAGMA interface(c,concat, "peslcct",2);    -- LOB CONCAT
  PRAGMA interface(c,lpad,   "peslclp",3);    -- LOB LPAD
  PRAGMA interface(c,lpad,   "peslclp",4);    -- LOB LPAD
  PRAGMA interface(c,rpad,   "peslcrp",3);    -- LOB RPAD
  PRAGMA interface(c,rpad,   "peslcrp",4);    -- LOB RPAD
  PRAGMA interface(c,lower,  "peslclr",2);    -- LOB LOWER
  PRAGMA interface(c,upper,  "peslcup",2);    -- LOB UPPER
  PRAGMA interface(c,ltrim,  "peslclm",3);    -- LOB LTRIM
  PRAGMA interface(c,ltrim,  "peslclm",4);    -- LOB LTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",3);    -- LOB RTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",4);    -- LOB RTRIM
  PRAGMA interface(c,trim,   "peslctr",2);    -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",4); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",5); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",6); -- LOB TRIM
  PRAGMA interface(c,'LIKE', "peslclk",3);    -- LOB LIKE
  PRAGMA interface(c,'LIKE', "peslcl2",4);    -- LOB LIKE
  PRAGMA interface(c,nvl,"peslcnl",17);       -- LOB NVL
  PRAGMA interface(c,replace, "peslcrl",2);   -- LOB REPLACE

     -- LOB Relational Operators
     -- LHS: CLOB,    RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_dummy",16);     -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",16);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",15);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pes_dummy",15);     -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",15);      -- LOB '>='
  PRAGMA interface(c,'<=',"pes_dummy",15);       -- LOB '<='
     -- LHS: CLOB,     RHS:VARCHAR2
  PRAGMA interface(c,'=' ,"pesleq2",17);       -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",17);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",16);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt2",16);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",16);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle2",16);       -- LOB '<='  -- ICD #250
     -- LHS: VARCHAR2, RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_flip",18);      -- LOB '='
  PRAGMA interface(c,'!=',"pes_flip",18);      -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",17);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt3",17);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",17);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle3",17);       -- LOB '<='

  PRAGMA interface(c,length, "peslbln",3);    -- BLOB LENGTH
  PRAGMA interface(c,lengthb,"peslblb",3);    -- BLOB LENGTHB
  -- End of 8.2 LOB Built-in Functions


  PRAGMA interface(c,tz_offset,"pestzo",1);
  PRAGMA interface(c,from_tz,"pesftz",1);

  PRAGMA interface(c,ISNCHAR,"pesinc", 1);

  PRAGMA interface(c,CONVERT,"pescnv", 1);
  PRAGMA interface(c,CONVERT,"pescnv", 2);
  PRAGMA interface(c,CONVERT,"peslccnv", 3);  -- LOB CONVERT
  PRAGMA interface(c,CONVERT,"peslccnv", 4);  -- LOB CONVERT

  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",1);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",2);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",3);

  PRAGMA interface(c,TO_CHAR,"pesdtm2c",7); -- datetime
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",8);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",9);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",10);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",11);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",12);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",13);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",14);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",15);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",16);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",17); -- interval
  PRAGMA interface(c,TO_CHAR,"pesitv2c",18);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",19);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",20);

  --#### new_names pragmas

  -- This is an internal pragma that restricts the use
  -- of particular new entries in package standard.
  -- It is only valid in package standard.
  -- Note that left out of the 8.1.5 set are non datetime
  -- entries urowid, "UROWID ", self_is_null and trim.

  pragma new_names('8.1.5',
                   time,"TIME WITH TIME ZONE",
                   timestamp,"TIMESTAMP WITH TIME ZONE",
                   "INTERVAL DAY TO SECOND",
                   "INTERVAL YEAR TO MONTH",
                   to_time, to_timestamp,
                   to_time_tz, to_timestamp_tz,
                   " SYS$DSINTERVALSUBTRACT",
                   " SYS$YMINTERVALSUBTRACT",
                   to_yminterval,to_dsinterval,
                   NUMTOYMINTERVAL, NUMTODSINTERVAL,
                   current_date,
                   current_time,current_timestamp);

  pragma new_names('8.1.6',
                   dbtimezone, sessiontimezone, localtimestamp,
                   localtime,
                   cube, rollup, grouping, "TIMESTAMP WITH LOCAL TIME ZONE");

  -- Should there be a 8.2 new names pragma ?

  -- 8.2 UCS2/UCS4/Complete Built-in Functions

  PRAGMA interface(c,INSTR2,"pesist2",1);
  PRAGMA interface(c,INSTR4,"pesist4",1);
  PRAGMA interface(c,INSTRC,"pesistc",1);

  PRAGMA interface(c,LENGTH2,"peslen2",1);
  PRAGMA interface(c,LENGTH4,"peslen4",1);
  PRAGMA interface(c,LENGTHC,"peslenc",1);

  PRAGMA interface(c,LIKE2,"peslik2",1);
  PRAGMA interface(c,LIKE2,"pesli22",2);
  PRAGMA interface(c,LIKE4,"peslik4",1);
  PRAGMA interface(c,LIKE4,"pesli42",2);
  PRAGMA interface(c,LIKEC,"peslikc",1);
  PRAGMA interface(c,LIKEC,"peslic2",2);

  PRAGMA interface(c,SUBSTR2,"pes_dummy",1);
  PRAGMA interface(c,SUBSTR4,"pes_dummy",1);
  PRAGMA interface(c,SUBSTRC,"pes_dummy",1);
  PRAGMA interface(c,SYS_EXTRACT_UTC,"pessexu");
  PRAGMA interface(c,COMPOSE,"pescomp");
  PRAGMA interface(c,DECOMPOSE,"pesdcmp");



  -- End of 8.2 UCS2/UCS4/Complete Built-in Functions

  -- Begin REGEXP support (10iR1) --
  PRAGMA interface(c,regexp_like,    "pes_dummy",1);
  PRAGMA interface(c,regexp_instr,   "pes_dummy",1);    -- ICD #300
  PRAGMA interface(c,regexp_substr,  "pes_dummy",1);
  PRAGMA interface(c,regexp_replace, "pes_dummy",1);
  PRAGMA interface(c,regexp_count,   "pes_dummy",1);
  PRAGMA interface(c,regexp_like,    "pes_dummy",2);    -- LOB REGEXP_LIKE
  PRAGMA interface(c,regexp_instr,   "pes_dummy",2);    -- LOB REGEXP_INSTR
  PRAGMA interface(c,regexp_substr,  "pes_dummy",2);    -- LOB REGEXP_SUBSTR
  PRAGMA interface(c,regexp_replace, "pes_dummy",2);    -- LOB REGEXP_REPLACE
  PRAGMA interface(c,regexp_count,   "pes_dummy",2);    -- LOB REGEXP_COUNT
  PRAGMA interface(c,regexp_replace, "pes_dummy",3);    -- LOB REGEXP_REPLACE

  -- End of REGEXP Built-in Functions --


  -- 10i Binary Floating-point Built-in Functions

  PRAGMA interface(c,"IS NAN","pesnanf",2);
  PRAGMA interface(c,"IS NAN","pesnand",3);
  PRAGMA interface(c,"IS INFINITE","pesinf",1);
  PRAGMA interface(c,"IS INFINITE","pesinff",2);
  PRAGMA interface(c,"IS INFINITE","pesinfd",3);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",2);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",3);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",2);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",3);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",21);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",22);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",23);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",24);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",7);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",8);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",9);
  PRAGMA interface(c,'REMAINDER',"pesrem", 1);
  PRAGMA interface(c,REMAINDER,"pesrem", 2);
  PRAGMA interface(c,'REMAINDER',"pesremf", 3);
  PRAGMA interface(c,REMAINDER,"pesremf", 4);
  PRAGMA interface(c,'REMAINDER',"pesremd", 5);
  PRAGMA interface(c,REMAINDER,"pesremd", 6);
  PRAGMA interface(c,ABS,"pes_dummy",2);
  PRAGMA interface(c,ABS,"pes_dummy",3);
  PRAGMA interface(c,ABS,"pes_dummy",4);
  PRAGMA interface(c,ATAN,"pesatand",2);
  PRAGMA interface(c,'MOD',"pesmodf", 2);
  PRAGMA interface(c,'MOD',"pesmodd", 3);
  PRAGMA interface(c,floor,"pesflof", 2);
  PRAGMA interface(c,floor,"pesflod", 3);
  PRAGMA interface(c,CEIL,"pesceif", 2);
  PRAGMA interface(c,CEIL,"pesceid", 3);
  PRAGMA interface (c, SQRT, "pessqtf", 2);
  PRAGMA interface (c, SQRT, "pessqtd", 3);
  PRAGMA interface(c,SIGN,"pessgnf", 2);
  PRAGMA interface(c,SIGN,"pessgnd", 3);
  PRAGMA interface(c,SIGN,"pessgni", 4);
  PRAGMA interface(c,cos,"pescosd", 2);
  PRAGMA interface(c,sin,"pessind",2);
  PRAGMA interface(c,TAN,"pestand",2);
  PRAGMA interface(c,COSH,"pescshd",2);
  PRAGMA interface(c,SINH,"pessnhd",2);   -- ICD #350
  PRAGMA interface(c,TANH,"pestnhd",2);
  PRAGMA interface(c,EXP,"pesexpd",2);
  PRAGMA interface(c,LN,"peslnd",2);
  PRAGMA interface(c,LOG,"peslogd",2);
  PRAGMA interface(c,TRUNC,"pestruf",4);
  PRAGMA interface(c,TRUNC,"pestrud",5);
  PRAGMA interface(c,TRUNC,"pestrui",6);
  PRAGMA interface(c,ROUND,"pesrndf",4);
  PRAGMA interface(c,ROUND,"pesrndd",5);
  PRAGMA interface(c,ROUND,"pesrndi",6);
  PRAGMA interface(c,POWER,"pespowd",2);

  -- End of 10i Binary Floating-point Built-in Functions

  -- ICDs for MULTISET

  PRAGMA interface(c,CARDINALITY,"pesmcnt");
  PRAGMA interface(c,"IS EMPTY","pesmie");
  PRAGMA interface(c,"IS NOT EMPTY","pes_invert",1);
  -- ICDs which used to be in the body of standard, but which new COG can
  -- handle directly

  -- NOT (some ICD)
  PRAGMA interface(c,NOT_LIKE,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",3);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",4);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",3);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",1);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",2);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",3);

  -- datetime is not null
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",20); -- interval ds

  -- Misc
  PRAGMA interface(c,"**",   "pespow",1);    -- number
  PRAGMA interface(c,"**",   "pespowd",2);   -- binary double
  PRAGMA interface(c,"ACOS", "pesacosd",2);  -- binary double
  PRAGMA interface(c,"ASIN", "pesasind",2);  -- binary double
  PRAGMA interface(c,"ATAN2","pesatn2d",2);  -- binary double

  -- All the flavors of NVL
  PRAGMA interface(c,nvl,"pes_dummy",1);       -- Boolean -- ICD #400
  PRAGMA interface(c,nvl,"pes_dummy",2);       -- Varchar2
  PRAGMA interface(c,nvl,"pes_dummy",3);       -- Number
  PRAGMA interface(c,nvl,"pes_dummy",4);       -- Date
  PRAGMA interface(c,nvl,"pes_dummy",5);       -- MLSLabel
  PRAGMA interface(c,nvl,"pes_dummy",6);       -- ADT
  PRAGMA interface(c,nvl,"pes_dummy",7);       -- Ref ADT
  PRAGMA interface(c,nvl,"pes_dummy",8);       -- Collection

--  Ref Cursor has problems. The MOVCR instruction needs more information than
--  the other MOV* instructions, including the PVM register of the destination
--  This cannot be easily supplied through the generic NVL instruction, so
--  for now, this flavor will continue to have a real body
--  PRAGMA interface(c,nvl,"pes_dummy",9);       -- Ref Cursor

  PRAGMA interface(c,nvl,"pes_dummy",10);       -- Time
  PRAGMA interface(c,nvl,"pes_dummy",11);       -- Time-tz
  PRAGMA interface(c,nvl,"pes_dummy",12);       -- Timestamp
  PRAGMA interface(c,nvl,"pes_dummy",13);       -- Timestamp-tz
  PRAGMA interface(c,nvl,"pes_dummy",14);       -- Timestamp-ltz
  PRAGMA interface(c,nvl,"pes_dummy",15);       -- Intervalym
  PRAGMA interface(c,nvl,"pes_dummy",16);       -- Intervalds
--  PRAGMA interface(c,nvl,"pes_dummy",17);       -- Clob (Handled above, ICD)
  PRAGMA interface(c,nvl,"pes_dummy",18);       -- Opaque
  PRAGMA interface(c,nvl,"pes_dummy",19);       -- Binaryfloat
  PRAGMA interface(c,nvl,"pes_dummy",20);       -- Binarydouble
  PRAGMA interface(c,nvl,"pes_dummy",21);       -- PLSInteger

  -- The following pragma overrides any other setting of the timestamp,
  -- and is used so that we recognize the client-side and server-side instances
  -- of package STANDARD as being the same.  Package STANDARD is special in
  -- that it is really the root of the PL/SQL dependencies graph; as such it
  -- itself doesn't ever need recompiling due to changes to things below it.
  -- The pragma mechanism used here is currently ignored except for
  -- package STANDARD, but in future may not be.  Do NOT add similar pragmas
  -- to your own code as it may in future interfere with the package
  -- consistency maintenance mechanisms and could have dire results.

  --#### timestamp pragma (please keep this last)
  pragma TIMESTAMP('2006-04-18:00:00:00');
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."STANDARD" AUTHID CURRENT_USER is              -- careful on this line; SED edit occurs!

  /********** Types and subtypes, do not reorder **********/
  type BOOLEAN is (FALSE, TRUE);

  type DATE is DATE_BASE;

  type NUMBER is NUMBER_BASE;
  subtype FLOAT is NUMBER; -- NUMBER(126)
  subtype REAL is FLOAT; -- FLOAT(63)
  subtype "DOUBLE PRECISION" is FLOAT;
  subtype INTEGER is NUMBER(38,0);
  subtype INT is INTEGER;
  subtype SMALLINT is NUMBER(38,0);
  subtype DECIMAL is NUMBER(38,0);
  subtype NUMERIC is DECIMAL;
  subtype DEC is DECIMAL;


  subtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;
  subtype NATURAL is BINARY_INTEGER range 0..2147483647;
  subtype NATURALN is NATURAL not null;
  subtype POSITIVE is BINARY_INTEGER range 1..2147483647;
  subtype POSITIVEN is POSITIVE not null;
  subtype SIGNTYPE is BINARY_INTEGER range '-1'..1;  -- for SIGN functions

  type VARCHAR2 is NEW CHAR_BASE;

  subtype VARCHAR is VARCHAR2;
  subtype STRING is VARCHAR2;

  subtype LONG is VARCHAR2(32760);

  subtype RAW is VARCHAR2;
  subtype "LONG RAW" is RAW(32760);

  subtype ROWID is VARCHAR2(256);

  -- Ansi fixed-length char
  -- Define synonyms for CHAR and CHARN.
  subtype CHAR is VARCHAR2;
  subtype CHARACTER is CHAR;

  type MLSLABEL is new CHAR_BASE;

  -- Large object data types.
  --  binary, character, binary file.
  type  BLOB is BLOB_BASE;
  type  CLOB is CLOB_BASE;
  type  BFILE is BFILE_BASE;

  -- Verbose and NCHAR type names
  subtype "CHARACTER VARYING" is VARCHAR;
  subtype "CHAR VARYING" is VARCHAR;
  subtype "NATIONAL CHARACTER" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHARACTER VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NVARCHAR2" is VARCHAR2 CHARACTER SET NCHAR_CS;
  subtype "CHARACTER LARGE OBJECT" is CLOB;
  subtype "CHAR LARGE OBJECT" is CLOB;
  subtype "NATIONAL CHARACTER LARGE OBJEC" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCHAR LARGE OBJECT" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCLOB" is CLOB CHARACTER SET NCHAR_CS;
  subtype "BINARY LARGE OBJECT" is BLOB;

  subtype pls_integer is binary_integer;

  type TIME is new DATE_BASE;
  type TIMESTAMP is new DATE_BASE;
  type "TIME WITH TIME ZONE" is new DATE_BASE;
  type "TIMESTAMP WITH TIME ZONE" is new DATE_BASE;
  type "INTERVAL YEAR TO MONTH" is new DATE_BASE;
  type "INTERVAL DAY TO SECOND" is new DATE_BASE;

  SUBTYPE TIME_UNCONSTRAINED IS TIME(9);
  SUBTYPE TIME_TZ_UNCONSTRAINED IS TIME(9) WITH TIME ZONE;
  SUBTYPE TIMESTAMP_UNCONSTRAINED IS TIMESTAMP(9);
  SUBTYPE TIMESTAMP_TZ_UNCONSTRAINED IS TIMESTAMP(9) WITH TIME ZONE;
  SUBTYPE YMINTERVAL_UNCONSTRAINED IS INTERVAL YEAR(9) TO MONTH;
  SUBTYPE DSINTERVAL_UNCONSTRAINED IS INTERVAL DAY(9) TO SECOND (9);

  TYPE UROWID IS NEW CHAR_BASE;

  type "TIMESTAMP WITH LOCAL TIME ZONE" is new DATE_BASE;
  subtype timestamp_ltz_unconstrained is timestamp(9) with local time zone;

  subtype BINARY_FLOAT is NUMBER;
  subtype BINARY_DOUBLE is NUMBER;

  -- The following data types are generics, used specially within package
  -- STANDARD and some other Oracle packages.  They are protected against
  -- other use; sorry.  True generic types are not yet part of the language.

  type "<ADT_1>" as object (dummy char(1));
  type "<RECORD_1>" is record (dummy char(1));
  type "<TUPLE_1>" as object (dummy char(1));
  type "<VARRAY_1>" is varray (1) of char(1);
  type "<V2_TABLE_1>" is table of char(1) index by binary_integer;
  type "<TABLE_1>" is table of char(1);
  type "<COLLECTION_1>" is table of char(1);
  type "<REF_CURSOR_1>" is ref cursor;

  -- This will actually match against a Q_TABLE
  type "<TYPED_TABLE>" is table of  "<ADT_1>";
  subtype "<ADT_WITH_OID>" is "<TYPED_TABLE>";

  -- The following generic index table data types are used by the PL/SQL
  -- compiler to materialize an array attribute at the runtime (for more
  -- details about the array attributes, please see Bulk Binds document).
  type " SYS$INT_V2TABLE" is table of pls_integer index by binary_integer;

  -- The following record type and the corresponding generic index table
  -- data types are used by the PL/SQL compiler to materialize a table
  -- at the runtime in order to record the exceptions raised during the
  -- execution of FORALL bulk bind statement (for more details, please
  -- see bulk binds extensions document in 8.2).
  type " SYS$BULK_ERROR_RECORD" is
          record (error_index pls_integer, error_code pls_integer);
  type " SYS$REC_V2TABLE" is table of " SYS$BULK_ERROR_RECORD"
                               index by binary_integer;

  /* Adding a generic weak ref cursor type */
  type sys_refcursor is ref cursor;

  /* the following data type is a generic for all opaque types */
  type "<OPAQUE_1>" as opaque FIXED(1) USING LIBRARY dummy_lib
    (static function dummy return number);

  type "<ASSOC_ARRAY_1>" is table of char(1) index by varchar2(1);

  /********** Add new types or subtypes here **********/

  -- Simple scalar types

  subtype SIMPLE_INTEGER is BINARY_INTEGER NOT NULL;
  subtype SIMPLE_FLOAT   is BINARY_FLOAT   NOT NULL;
  subtype SIMPLE_DOUBLE  is BINARY_DOUBLE  NOT NULL;

  /********** Predefined constants **********/

  BINARY_FLOAT_NAN constant BINARY_FLOAT;
  BINARY_FLOAT_INFINITY constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_SUBNORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_SUBNORMAL constant BINARY_FLOAT;
  BINARY_DOUBLE_NAN constant BINARY_DOUBLE;
  BINARY_DOUBLE_INFINITY constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_SUBNORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_SUBNORMAL constant BINARY_DOUBLE;

  /********** Add new constants here **********/

  /********** Predefined exceptions **********/

  CURSOR_ALREADY_OPEN exception;
    pragma EXCEPTION_INIT(CURSOR_ALREADY_OPEN, '-6511');

  DUP_VAL_ON_INDEX exception;
    pragma EXCEPTION_INIT(DUP_VAL_ON_INDEX, '-0001');

  TIMEOUT_ON_RESOURCE exception;
    pragma EXCEPTION_INIT(TIMEOUT_ON_RESOURCE, '-0051');

  INVALID_CURSOR exception;
    pragma EXCEPTION_INIT(INVALID_CURSOR, '-1001');

  NOT_LOGGED_ON exception;
    pragma EXCEPTION_INIT(NOT_LOGGED_ON, '-1012');

  LOGIN_DENIED exception;
    pragma EXCEPTION_INIT(LOGIN_DENIED, '-1017');

  NO_DATA_FOUND exception;
    pragma EXCEPTION_INIT(NO_DATA_FOUND, 100);

  ZERO_DIVIDE exception;
    pragma EXCEPTION_INIT(ZERO_DIVIDE, '-1476');

  INVALID_NUMBER exception;
    pragma EXCEPTION_INIT(INVALID_NUMBER, '-1722');

  TOO_MANY_ROWS exception;
    pragma EXCEPTION_INIT(TOO_MANY_ROWS, '-1422');

  STORAGE_ERROR exception;
    pragma EXCEPTION_INIT(STORAGE_ERROR, '-6500');

  PROGRAM_ERROR exception;
    pragma EXCEPTION_INIT(PROGRAM_ERROR, '-6501');

  VALUE_ERROR exception;
    pragma EXCEPTION_INIT(VALUE_ERROR, '-6502');

  ACCESS_INTO_NULL exception;
    pragma EXCEPTION_INIT(ACCESS_INTO_NULL, '-6530');

  COLLECTION_IS_NULL exception;
    pragma EXCEPTION_INIT(COLLECTION_IS_NULL , '-6531');

  SUBSCRIPT_OUTSIDE_LIMIT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_OUTSIDE_LIMIT,'-6532');

  SUBSCRIPT_BEYOND_COUNT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_BEYOND_COUNT ,'-6533');

  -- exception for ref cursors
  ROWTYPE_MISMATCH exception;
  pragma EXCEPTION_INIT(ROWTYPE_MISMATCH, '-6504');

  SYS_INVALID_ROWID  EXCEPTION;
  PRAGMA EXCEPTION_INIT(SYS_INVALID_ROWID, '-1410');

  -- The object instance i.e. SELF is null
  SELF_IS_NULL exception;
    pragma EXCEPTION_INIT(SELF_IS_NULL, '-30625');

  CASE_NOT_FOUND exception;
    pragma EXCEPTION_INIT(CASE_NOT_FOUND, '-6592');

  -- Added for USERENV enhancement, bug 1622213.
  USERENV_COMMITSCN_ERROR exception;
    pragma EXCEPTION_INIT(USERENV_COMMITSCN_ERROR, '-1725');

  -- Parallel and pipelined support
  NO_DATA_NEEDED exception;
    pragma EXCEPTION_INIT(NO_DATA_NEEDED, '-6548');
  -- End of 8.2 parallel and pipelined support

  /********** Add new exceptions here **********/

  /********** Function, operators and procedures **********/

  function "EXISTS" return BOOLEAN;
    pragma BUILTIN('EXISTS',10,240,240); -- This is special cased in PH2 -- Pj

  function GREATEST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DATE) return DATE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DATE) return DATE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr NUMBER, pat NUMBER, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER,
                   pat NUMBER,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER, pat NUMBER, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr DATE, pat DATE, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE,
                   pat DATE,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE, pat DATE, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function SQLCODE return PLS_INTEGER;
    pragma BUILTIN('SQLCODE',45, 10, 0); -- PEMS_DB, DB_SQLCODE

  function SQLERRM return varchar2;
    pragma FIPSFLAG('SQLERRM', 1452);

  function SQLERRM (code PLS_INTEGER) return varchar2;
    pragma BUILTIN('SQLERRM',46, 10, 1); -- PEMS_DB, DB_SQLERRM
    pragma FIPSFLAG('SQLERRM', 1452);

  function LEVEL return NUMBER;

  function ROWNUM return NUMBER;

  function '='  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('=',2, 3, 1); -- PEMS_INTEGER, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN; -- also <> and ~=
    pragma BUILTIN('!=',5, 3, 2); -- PEMS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<',4, 3, 3);  -- PEMS_INTEGER, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<=',6, 3, 4); -- PEMS_INTEGER, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>',1, 3, 5); -- PEMS_INTEGER, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>=',3, 3, 6); -- PEMS_INTEGER, PEMDMGE
    pragma FIPSFLAG('>=', 1450);

  --  Since SQL permits short-circuit evaluation, the 'and' and 'or'
  --  operations will always be interpreted as 'and then' and 'or else'
  --  when they occur in conditional statements.

  function XOR (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('XOR',8, 3, 9); -- PEMS_INTEGER, INT_XOR
    pragma FIPSFLAG('XOR', 1450);

  function 'NOT' (RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('NOT',9, 3, 10); -- PEMS_INTEGER, INT_NOT

  function 'IS NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);  -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50); -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 BOOLEAN, B2 BOOLEAN) return BOOLEAN;
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('=',2, 1, 14); -- PEMS_CHAR, PEMDCMEQ (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('=', 1454);
  function '!=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('!=',5, 1, 15);  -- PEMS_CHAR, PEMDCMNE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('!=', 1454);
  function '<'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<',4, 1, 16); -- PEMS_CHAR, PEMDCMLT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<', 1454);
  function '<=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<=',6, 1, 17); -- PEMS_CHAR, PEMDCMLE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<=', 1454);
  function '>'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>',1, 1, 18); -- PEMS_CHAR, PEMDCMGT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>', 1454);
  function '>=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>=',3, 1, 19); -- PEMS_CHAR, PEMDCMGE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>=', 1454);

  function '||' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN('||',25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT VARCHAR2 CHARACTER SET ANY_CS,
                  RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN(CONCAT,25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG(CONCAT, 1454);

  function LENGTH(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH', 1452);
  -- In SUBSTR, LEN defaults to remainder of string
  -- In substr and instr, a negative value of parameter POS means to
  -- count from the right end of the string.
  function SUBSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  POS PLS_INTEGER,
                  LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  -- Find nth occurrence of str1 in str2 starting at pos
  function INSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);
  function LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);
  function ASCII(ch VARCHAR2 CHARACTER SET ANY_CS)
        return PLS_INTEGER; -- should be ASCII.CHRANGE
    pragma FIPSFLAG('ASCII', 1452);
  function ASCIISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('ASCIISTR', 1452);
  function UNISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return NVARCHAR2;
    pragma FIPSFLAG('UNISTR', 1452);
  function CHR(n PLS_INTEGER) return varchar2;  -- N should be ASCII.CHRANGE
    pragma FIPSFLAG('CHR', 1452);
  function " SYS$STANDARD_CHR"(n PLS_INTEGER,csn VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET csn%CHARSET;
    pragma FIPSFLAG(' SYS$STANDARD_CHR', 1452);
  function INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('INITCAP', 1452);
  function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('SOUNDEX', 1452);

  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);
  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
  pragma FIPSFLAG('LPAD', 1452);

  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);
  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                     SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
                     DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('TRANSLATE', 1452);

  function REPLACE(SRCSTR VARCHAR2 CHARACTER SET ANY_CS,
                   OLDSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET := NULL)
        return VARCHAR2 CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);
  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);
  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'IS NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20);  -- PEMS_CHAR, PEMDNUL
  function 'IS NOT NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50); -- PEMS_CHAR, PEMDNUL

  function NVL(s1 VARCHAR2 CHARACTER SET ANY_CS,
               s2 VARCHAR2 CHARACTER SET s1%CHARSET)
        return VARCHAR2 CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);


  function '='  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 1); -- PEMS_NUMBER, PEMDCMEQ
  function '!=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 2); -- PEMS_NUMBER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 3); -- PEMS_NUMBER, PEMDCMLT
  function '<=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 4); -- PEMS_NUMBER, PEMDCMLE
  function '>'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 5); -- PEMS_NUMBER, PEMDCMGT
  function '>=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 6); -- PEMS_NUMBER, PEMDCMGE

  function 'IS NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_NUMBER, PEMDNUL

  function NVL(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 7); -- PEMS_NUMBER, NUM_NEG
  function ABS(n NUMBER) return NUMBER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 2, 8); -- PEMS_NUMBER, NUM_ADD
  function '-' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 9); -- PEMS_NUMBER, NUM_SUB
  function '*' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('*',17, 2, 10); -- PEMS_NUMBER, NUM_MUL
  function '/' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('/',18, 2, 11); -- PEMS_NUMBER, NUM_DIV

  function 'REM' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(n NUMBER) return NUMBER;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(n NUMBER) return NUMBER;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(n NUMBER) return NUMBER;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(n NUMBER) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COS', 1452);
  function SIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SIN', 1452);
  function TAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TAN', 1452);
  function COSH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COSH', 1452);
  function SINH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SINH', 1452);
  function TANH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TANH', 1452);

  function EXP(N NUMBER) return NUMBER;
  function LN(N NUMBER) return NUMBER;

  function BITAND (LEFT pls_integer, RIGHT pls_integer)
        return pls_integer;
  function BITAND (LEFT integer, RIGHT integer)
        return integer;
  function LOG (LEFT NUMBER, RIGHT NUMBER) return NUMBER;

  function TRUNC (n NUMBER, places pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT NUMBER, RIGHT pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (n NUMBER, e NUMBER) return NUMBER;
    pragma FIPSFLAG('POWER', 1452);

  function '='  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('=',2, 12, 1); -- PEMS_DATE, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT DATE, RIGHT DATE) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 12, 2); -- PEMS_DATE, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<',4, 12, 3); -- PEMS_DATE, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<=',6, 12, 4); -- PEMS_DATE, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>',1, 12, 5);  -- PEMS_DATE, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>=',3, 12, 6);  -- PEMS_DATE, PEMDCMGE
    pragma FIPSFLAG('>=', 1450);

  function '+' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('+',14, 12, 7); -- PEMS_DATE, DATE_ADD1
    pragma FIPSFLAG('+', 1450);
  function '+' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('+',14, 12, 8); -- PEMS_DATE, DATE_ADD2
    pragma FIPSFLAG('+', 1450);
  function '-' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('-',15, 12, 9); -- PEMS_DATE, DATE_SUB1
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('-',15, 12, 10); -- PEMS_DATE, DATE_SUB2
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('-',15, 12, 11); -- PEMS_DATE, DATE_SUB3
    pragma FIPSFLAG('-', 1450);

  function LAST_DAY(RIGHT DATE) return DATE;
    pragma BUILTIN('LAST_DAY',38, 12, 12); -- PEMS_DATE, DATE_LAST_DAY
    pragma FIPSFLAG('LAST_DAY', 1450);
  function ADD_MONTHS(LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 13); -- PEMS_DATE, DATE_ADD_MONTHS1
    pragma FIPSFLAG('ADD_MONTHS', 1450);
  function ADD_MONTHS(LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 14); -- PEMS_DATE, DATE_ADD_MONTHS2
    pragma FIPSFLAG('ADD_MONTHS', 1450);

  function MONTHS_BETWEEN(LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('MONTHS_BETWEEN',42, 12, 15); -- PEMS_DATE, DATE_MONTHS_BET
    pragma FIPSFLAG('MONTHS_BETWEEN', 1450);
  function NEXT_DAY(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('NEXT_DAY',43, 12, 16); -- PEMS_DATE, DATE_NEXT_DAY
    pragma FIPSFLAG('NEXT_DAY', 1450);
  function ROUND(RIGHT DATE) return DATE;
    pragma BUILTIN('ROUND',24, 12, 17); -- PEMS_DATE, DATE_ROUND
    pragma FIPSFLAG('ROUND', 1450);
  function NEW_TIME(RIGHT DATE, MIDDLE VARCHAR2, LEFT VARCHAR2) return DATE;
    pragma FIPSFLAG('NEW_TIME', 1450);

  function 'IS NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 12, 0);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 12, 50);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);
  function NVL (d1 DATE, d2 DATE) return DATE;
    pragma FIPSFLAG('NVL', 1450);

  function TRUNC(LEFT DATE) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 20); -- PEMS_DATE, DATE_TRUNC1
    pragma FIPSFLAG('TRUNC', 1450);
  function TRUNC(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 21); -- PEMS_DATE, DATE_TRUNC2
    pragma FIPSFLAG('TRUNC', 1450);
  function ROUND(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('ROUND',24, 12, 22); -- PEMS_DATE, DATE_ROUND2
    pragma FIPSFLAG('ROUND', 1450);

  function TO_DATE    (RIGHT VARCHAR2 character set any_cs)  return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 10); -- PEMS_CHAR, CHR_CNV_DAT
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT VARCHAR2 character set any_cs,
       RIGHT VARCHAR2 character set LEFT%charset) return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 8); -- PEMS_CHAR, CHR_CNV_DATE
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT NUMBER, RIGHT VARCHAR2) return DATE;
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE(left varchar2 character set any_cs,
                   format varchar2 character set LEFT%charset,
                   parms varchar2 character set LEFT%charset) return date;

  function TO_CHAR (RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',14, 0, 2);

  function TO_CHAR (LEFT DATE, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  function TO_CHAR (LEFT NUMBER, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function TO_NUMBER (RIGHT NUMBER) RETURN NUMBER;
    pragma BUILTIN('TO_NUMBER',14, 0, 1); -- PEMS_QUICK

  function TO_NUMBER (RIGHT VARCHAR2 character set any_cs)    return NUMBER;
    pragma BUILTIN('TO_NUMBER',48, 1, 9); -- PEMS_CHAR, CHR_CNV_NUM

  function TO_NUMBER(left varchar2 character set any_cs,
        format varchar2 character set LEFT%charset)
    return number;
  function TO_NUMBER(left varchar2 character set any_cs,
                     format varchar2 character set LEFT%charset,
                     parms varchar2 character set LEFT%charset)
    return number;

  -- Define SQL predicates.  These don't gen code, so no body is needed.

  -- PRIOR is WEIRD - For now, it will be treated as a function call.
  -- Does the function only take a column name?  how about its use in
  -- a predicate?
  function 'PRIOR'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname NUMBER) return NUMBER;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname DATE) return DATE;
      pragma FIPSFLAG('PRIOR', 1450);

  -- Outer Join has same problem as PRIOR
  function '(+)'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
  function '(+)'(colname NUMBER) return NUMBER;
  function '(+)'(colname DATE) return DATE;
      pragma FIPSFLAG('(+)', 1450);

  function '=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ANY', 1450);
  function '=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ANY', 1450);
  function '!=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ANY', 1450);
  function '<ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ANY', 1450);
  function '<=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ANY', 1450);
  function '>ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ANY', 1450);
  function '>=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ALL', 1450);
  function '=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ALL', 1450);
  function '!=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ALL', 1450);
  function '<ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ALL', 1450);
  function '<=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ALL', 1450);
  function '>ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ALL', 1450);
  function '>=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=SOME', 1450);
  function '=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=SOME', 1450);
  function '!=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<SOME', 1450);
  function '<SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=SOME', 1450);
  function '<=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>SOME', 1450);
  function '>SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=SOME', 1450);
  function '>=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  -- SQL Transaction routines
  procedure SET_TRANSACTION_USE(vc VARCHAR2);
  procedure COMMIT;
  procedure COMMIT_CM(vc VARCHAR2);
  procedure ROLLBACK_NR;
  procedure ROLLBACK_SV(Save_Point CHAR);
  procedure SAVEPOINT(Save_Point CHAR);

  function SYSDATE return DATE;
    pragma FIPSFLAG('SYSDATE', 1452);

  function UID return PLS_INTEGER;
    pragma FIPSFLAG('UID', 1452);

  function USER return VARCHAR2;

  function USERENV (envstr VARCHAR2) return VARCHAR2;
    pragma FIPSFLAG('USERENV', 1452);

  -- ROWID: this dreadful identifier is supposed to represent a datatype
  -- outside of SQL and and a pseudo-column (function, to us) when inside
  -- a sql statement.  ADA data model doesn't allow for any
  -- function X return X;
  -- so we must special case this.  Yuk.  There's special-case code in ph2nre
  -- which maps "rowid" to "rowid " if we're inside a SQL stmt.
  function "ROWID " return ROWID;
    pragma builtin('ROWID ', 1, 209, 240);  -- this had better never be called.

  function NULLFN (str VARCHAR2) return RAW;
    pragma builtin('NULLFN', 1, 0, 1);

  function HEXTORAW (c VARCHAR2) return RAW;
     pragma builtin('HEXTORAW', 1, 23, 1);

  function RAWTOHEX (r RAW) return VARCHAR2;
     pragma builtin('RAWTOHEX', 1, 23, 2);

  function CHARTOROWID (str VARCHAR2) return ROWID;
    pragma builtin('CHARTOROWID', 1, 0, 1);

  function ROWIDTOCHAR (str ROWID) return VARCHAR2;
    pragma builtin('ROWIDTOCHAR', 1, 0, 1);


  -- Trusted*Oracle additions
  Function ROWLABEL return MLSLABEL;                     -- pseudo column

  Function TO_CHAR(label MLSLABEL, format VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',90, 4, 19); -- PEMS_DATE, MLS_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  Function TO_LABEL(label VARCHAR2, format VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 8); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  Function TO_LABEL(label VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 2); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  -- vararg routines - icds in stdbdy
  Function LEAST_UB    (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('LEAST_UB',90, 4, 3); -- PEMS_CHAR, CHR_CNV_MLS
  Function GREATEST_LB (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('GREATEST_LB',90, 4, 4); -- PEMS_CHAR, CHR_CNV_MLS

  Function '>=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '>'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '='  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '!=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  function 'IS NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20); -- same "cod" as IS NULL(varchar2)
  function 'IS NOT NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50);

  function NVL(label1 MLSLABEL, label2 MLSLABEL) return MLSLABEL;
    pragma FIPSFLAG('NVL', 1452);

  -- group functions
  Function LUB (label MLSLABEL) return MLSLABEL;
  Function GLB (label MLSLABEL) return MLSLABEL;

  -- end of Trusted*Oracle additions


  -- beginning of NLS routines

  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS, c2 VARCHAR2) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS,
                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);

  function LENGTHB(ch VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
    pragma FIPSFLAG('LENGTHB', 1452);
  function SUBSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);
  function INSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  function TO_SINGLE_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_SINGLE_BYTE', 1452);
  function TO_MULTI_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_MULTI_BYTE', 1452);

  -- Next two added for NLS 6/3/92 JEM.
  function TO_CHAR(left date, format varchar2, parms varchar2) return varchar2;
  function TO_CHAR(left number, format varchar2, parms varchar2)
    return varchar2;
  function NLS_CHARSET_NAME(csetid PLS_INTEGER) return VARCHAR2;
  function NLS_CHARSET_ID(csetname VARCHAR2) return PLS_INTEGER;
  function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
    return PLS_INTEGER;

  -- end of NLS routines

  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2)
           return VARCHAR2 character set src%charset;
  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2,
                   srccset VARCHAR2)
          return VARCHAR2 character set src%charset;

  function " SYS$STANDARD_TRANSLATE" (src VARCHAR2 CHARACTER SET ANY_CS,
                                      csn VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET csn%CHARSET;
     pragma FIPSFLAG(' SYS$STANDARD_TRANSLATE',1452);

  function VSIZE (e number ) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e DATE) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);


  -- dump( expr [,display_format[,start_pos[,length]]]) return VARCHAR2
  function DUMP(e varchar2 character set any_cs,
                df pls_integer := null,sp pls_integer := null,
                len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e number,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e date,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  --
  -- ACOS, ASIN, ATAN, ATAN2
  --   Inverse Trigonometric functions
  --   These functions return NULL if any of the inputs are NULL
  --
  function ACOS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x NUMBER, y NUMBER) return NUMBER;
  pragma FIPSFLAG('ATAN2', 1452);

  --#### This is the end of 7.3 Standard

  -- LOB IS NULL
  function 'IS NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);
  -- end LOB IS NULL

  --****************************************************************
  -- 20 mar 96 =G=> In the following, arguments "1, 1, 1" to pragma BUILTIN
  -- e.g.,                pragma builtin('whatever', 1, 1, 1)
  -- indicate that those three numeric arguments to pragma BUILTIN are unknown,
  -- because they are not yet implemented by the backend.

  function '='  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<ADT_1>", pat "<ADT_1>", res "<ADT_1>")
        return "<ADT_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<ADT_1>", B2 "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function VALUE (item "<ADT_WITH_OID>") return "<ADT_1>";
    pragma BUILTIN('VALUE', 1, 1, 1);
    pragma FIPSFLAG('VALUE', 1450);

  function REF (item "<ADT_WITH_OID>") return REF "<ADT_1>";
    pragma BUILTIN('REF', 1, 1, 1);
    pragma FIPSFLAG('REF', 1450);

  function DEREF (r REF "<ADT_1>") return "<ADT_1>";
    pragma BUILTIN('DEREF', 1, 1, 1);
    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF ADT

  function 'IS NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function 'IS DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS DANGLING', 1450);

  function 'IS NOT DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  function NVL (B1 REF "<ADT_1>", B2 REF "<ADT_1>") return REF "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 0, 3, 1);
    pragma FIPSFLAG('=', 1450);

  function '!=' (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 0, 3, 2);
    pragma FIPSFLAG('!=', 1450);

  --  function '='  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('=', 1, 1, 1);
  --    pragma FIPSFLAG('=', 1450);
  --
  --  function '!=' (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('!=', 1, 1, 1);
  --    pragma FIPSFLAG('!=', 1450);
  --
  --  function '=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --
  --  function DECODE (expr "<COLLECTION_1>", pat "<COLLECTION_1>",
  --                                        res "<COLLECTION_1>")
  --      return "<COLLECTION_1>";
  --    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<COLLECTION_1>", B2 "<COLLECTION_1>")
        return "<COLLECTION_1>";
    pragma FIPSFLAG('NVL', 1450);

  function 'IS NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
        return "<REF_CURSOR_1>";
    pragma FIPSFLAG('NVL', 1450);

  function EMPTY_CLOB return clob;
  function EMPTY_BLOB return blob;

  function BFILENAME(directory varchar2,filename varchar2) return BFILE;

  function "SYS$LOB_REPLICATION" (x in blob) return blob;
  function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
    return clob character set x%charset;

  --#### This is the end of 8.0 Standard

  --  + overloadings

  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;

  function '+'(LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_UNCONSTRAINED;

  function '+'(LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_TZ_UNCONSTRAINED;

  function '+'(LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
                return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
                return TIME_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
                return TIME_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return DSINTERVAL_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return YMINTERVAL_UNCONSTRAINED ;

  -- begin subtract
  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return YMINTERVAL_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT" (LEFT TIME_UNCONSTRAINED,
                                      RIGHT TIME_UNCONSTRAINED)
     return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_UNCONSTRAINED ;
  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED ;
  function  " SYS$DSINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date;
  function '-' (LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date;

  function '-' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
   return DSINTERVAL_UNCONSTRAINED ;

  -- end subtract

  -- other datetime operators

  function '*' (LEFT number, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT number, RIGHT DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;

  function '*' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;

  function '/' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '/' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;


  function current_date return date;
  function current_time return TIME_TZ_UNCONSTRAINED;
  function current_timestamp return TIMESTAMP_TZ_UNCONSTRAINED;

  function TO_TIME (RIGHT varchar2 character set any_cs) return
    time_unconstrained;
    pragma BUILTIN('TO_TIME', 0, 15, 1);
    function TO_TIMESTAMP (RIGHT varchar2 character set any_cs)
                           return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 3);
  function TO_TIME_TZ (RIGHT varchar2 character set any_cs)
    return  TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 5);
  function TO_TIMESTAMP_TZ (RIGHT varchar2 character set any_cs)
    return  TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 7);
  function TO_YMINTERVAL (RIGHT varchar2 character set any_cs)
    return  YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_YMINTERVAL', 0, 15, 9);
  function TO_DSINTERVAL (RIGHT varchar2 character set any_cs)
    return  DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_DSINTERVAL', 0, 15, 11);

  -- with nls args
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset,
                   parms varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset,
                        parms varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset,
                           parms varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset,
                      parms varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_DSINTERVAL(RIGHT varchar2 character set any_cs,
                         parms varchar2 character set RIGHT%charset)
    return DSINTERVAL_UNCONSTRAINED;

  function NUMTOYMINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return YMINTERVAL_UNCONSTRAINED;
  function NUMTODSINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return DSINTERVAL_UNCONSTRAINED;

  function '='  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('=',0, 11, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',0, 11, 2);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<',0, 11, 3);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<=',0, 11, 4);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>',0, 11, 5);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>=',0, 11, 6);
    pragma FIPSFLAG('>=', 1450);

  function 'IS NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 14, 0); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 14, 50); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function "UROWID " return UROWID;
    pragma builtin('UROWID ', 1, 209, 240);  -- this had better never be called.

  -- New built-in function SYS_GUID, returns globally unique id
  function SYS_GUID return RAW;

  -- New built-in function SYS_CONTEXT
  function SYS_CONTEXT (namespace varchar2, attribute varchar2)
    return varchar2;

  function TRIM(v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  --#### This is the end of 8.1.5 Standard

  -- SYS_CONTEXT now has an additional optional parameter
  function SYS_CONTEXT(namespace varchar2, attribute varchar2,
                       newoptional varchar2)
    return varchar2;

  -- CUBE and ROLLUP are not real functions; they are variants on the GROUP
  -- BY clause (GROUP BY CUBE (...) and GROUP BY ROLLUP (...)). They have
  -- been added here as functions to avoid name capture issues.
  --
  -- Note that both CUBE and ROLLUP look like true vararg functions with
  -- *no* repeating pattern of formals - hence they are special cased in
  -- the overloading code.
  function CUBE return NUMBER;
  function ROLLUP return NUMBER;

  -- The GROUPING function must be used in conjunction with CUBE and ROLLUP
  -- in the GROUP BY clause. The type of the parameter to GROUPING can be
  -- any type that can appear in a GROUP BY list.
  function GROUPING(v VARCHAR2) return NUMBER;
  function GROUPING(a "<ADT_1>") return NUMBER;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 VARCHAR2 CHARACTER SET ANY_CS ,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   VARCHAR2 CHARACTER SET ANY_CS ,
                                 TSET   VARCHAR2 CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  --#### This is the end of the supported parts of 8.1.6 Standard

  --## Support for ANSI datetime data types is under development.
  --## The following operations, as well as the related types and
  --## operations defined above in the 8.1.5 section, are not yet
  --## available for use and are still subject to change.

  --- datetime equivalence
  function '='  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function TO_TIME (RIGHT TIME_TZ_UNCONSTRAINED)  return TIME_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME', 0, 15, 13);
  function TO_TIME_TZ (RIGHT TIME_UNCONSTRAINED)  return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 14);
  function TO_TIMESTAMP (RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 15);
  function TO_TIMESTAMP_TZ (RIGHT TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 16);

  function '-'
      (LEFT TIME_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  -- timezone functions
  function SYS_AT_TIME_ZONE(t time_tz_unconstrained,
                            i varchar2) RETURN time_tz_unconstrained;
  function SYS_AT_TIME_ZONE(t timestamp_tz_unconstrained,
                            i varchar2) RETURN timestamp_tz_unconstrained;
  FUNCTION systimestamp RETURN timestamp_tz_unconstrained;
  FUNCTION dbtimezone RETURN varchar2;
  FUNCTION sessiontimezone RETURN varchar2;
  FUNCTION localtimestamp RETURN timestamp_unconstrained;
  FUNCTION localtime RETURN time_unconstrained;

  function TO_TIMESTAMP (RIGHT DATE)  return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 17);

  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT yminterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '+'(LEFT dsinterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return yminterval_unconstrained;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;

  function '='  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;

  function SYS_LITERALTOYMINTERVAL(numerator varchar2, units varchar2)
    return YMINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTODSINTERVAL(numerator varchar2, units varchar2)
    return DSINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTOTIME(numerator varchar2)
    return TIME_UNCONSTRAINED;
  function SYS_LITERALTOTZTIME(numerator varchar2)
    return TIME_TZ_UNCONSTRAINED;
  function SYS_LITERALTOTIMESTAMP(numerator varchar2)
    return TIMESTAMP_UNCONSTRAINED;
  function SYS_LITERALTOTZTIMESTAMP(numerator varchar2)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function SYS_LITERALTODATE(numerator varchar2) return DATE;


  -- Explicit conversions between date and datetime
  function TO_TIMESTAMP(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 24);

  function TO_TIMESTAMP_TZ(ARG DATE) return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 27);

  function TO_TIMESTAMP_TZ(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 26);

  -- IS [NOT] NULL / NVL for datetime
  function 'IS NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_UNCONSTRAINED,
                b2 TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;

  function 'IS NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_TZ_UNCONSTRAINED, b2 TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_UNCONSTRAINED,
                b2 TIMESTAMP_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_TZ_UNCONSTRAINED, b2 TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_LTZ_UNCONSTRAINED,
                b2 TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;

  function 'IS NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 YMINTERVAL_UNCONSTRAINED, b2 YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;

  function 'IS NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 DSINTERVAL_UNCONSTRAINED, b2 DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  function " SYS$EXTRACT_FROM"
              (T TIME_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T DATE,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I YMINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I DSINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;

  -- ##########      8.2 LOB Built-in Functions       ######## --

  -- LENGTH --
  function LENGTH(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  function LENGTH(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  -- SUBSTR --
  function SUBSTR(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  function SUBSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);

  -- INSTR --
  function INSTR(STR1 CLOB CHARACTER SET ANY_CS,
                 STR2 CLOB CHARACTER SET STR1%CHARSET,
                 POS INTEGER := 1,
                 NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function INSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  STR2 CLOB CHARACTER SET STR1%CHARSET,
                  POS INTEGER := 1,
                  NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  -- CONCAT --
  function '||' (LEFT CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT CLOB CHARACTER SET ANY_CS,
                  RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG(CONCAT, 1454);

  -- UPPER --
  function UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);

  -- LOWER --
  function LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);

  -- LPAD --
  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  -- RPAD --
  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  -- LTRIM --
  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  -- RTRIM --
  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  -- TRIM --
  function TRIM(v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 CLOB CHARACTER SET ANY_CS ,
                               TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   CLOB CHARACTER SET ANY_CS ,
                                 TSET   CLOB CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;


  -- LIKE --
  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  -- NVL --
  function NVL(s1 CLOB CHARACTER SET ANY_CS,
               s2 CLOB CHARACTER SET s1%CHARSET)
    return CLOB CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);

  -- REPLACE --
  function REPLACE(SRCSTR CLOB CHARACTER SET ANY_CS,
                   OLDSUB CLOB CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB CLOB CHARACTER SET SRCSTR%CHARSET := NULL)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  -- LOB RELATIONAL OPERATORS --

  Function '='  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;

  /* LOB-related conversion functions */
  function TO_CLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS) return CLOB;
    pragma BUILTIN('TO_CLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  function TO_BLOB(RIGHT RAW) return BLOB;
    pragma BUILTIN('TO_BLOB', 0, 15, 30); -- OPC_CVT_RAW2BLB
  function TO_RAW(RIGHT BLOB) return RAW;
    pragma BUILTIN('TO_RAW', 0, 15, 32); -- OPC_CVT_BLB2RAW

  -- ####### end of 8.2 LOB Built-in Functions  ######## --

  function NULLIF(v1 VARCHAR2, v2 VARCHAR2) return VARCHAR2;
  function NULLIF(v1 BOOLEAN, v2 BOOLEAN) return VARCHAR2;
  function NULLIF(a1 "<ADT_1>", a2 "<ADT_1>") return VARCHAR2;

  function COALESCE return VARCHAR2;

  /* Daylight Saving Time Functions */
  FUNCTION tz_offset(region VARCHAR2)  RETURN VARCHAR2;
  FUNCTION from_tz(t TIMESTAMP_UNCONSTRAINED,timezone VARCHAR2)
    RETURN timestamp_tz_unconstrained;

  function " SYS$EXTRACT_STRING_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;

  function INSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR2', 1452);

  function INSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR4', 1452);

  function INSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRC', 1452);

  function LENGTH2(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH2', 1452);

  function LENGTH4(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH4', 1452);

  function LENGTHC(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTHC', 1452);

  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function SUBSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR2', 1452);

  function SUBSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR4', 1452);

  function SUBSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRC', 1452);

  /**** char <--> nchar conversion functions in Unicode project ********/

  function TO_NCHAR(RIGHT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',14, 0, 2);

  function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB;
  function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB;

  function TO_NCLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return NCLOB;
    pragma BUILTIN('TO_NCLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  /* convert to either CLOB or NCLOB respectively if parm is char or nchar */
  function TO_ANYLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET RIGHT%CHARSET;
    pragma BUILTIN('TO_ANYLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB

  /* Followings are the same builtin op codes as without N prefix functions,
   * implementation relys on impilcit conversion MCODEs
   */
  function TO_NCHAR (LEFT DATE, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_NCHAR', 1450);
  function TO_NCHAR (LEFT NUMBER, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function NHEXTORAW (c NVARCHAR2) return RAW;
    pragma builtin('NHEXTORAW', 1, 23, 1);
  function RAWTONHEX (r RAW) return NVARCHAR2;
    pragma builtin('RAWTONHEX', 1, 23, 2);
  function NCHARTOROWID (str NVARCHAR2) return ROWID;
    pragma builtin('NCHARTOROWID', 1, 0, 1);
  function ROWIDTONCHAR (str ROWID) return NVARCHAR2;
    pragma builtin('ROWIDTONCHAR', 1, 0, 1);

  function NCHR(n pls_integer) return NVARCHAR2;

  /* implemented by icd calls as the same as TO_CHAR */
  function TO_NCHAR(left date, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left number, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  /* implemented as a icd call, return TRUE if nchar, otherwise FALSE */
  function ISNCHAR(c VARCHAR2 character set any_cs) return boolean;

  /************ end of char <--> nchar conversion functions ************/

  /* Create overloads for all standard functions that work with <ADT_1> for
     <OPAQUE_1> */
  function '='  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<OPAQUE_1>", pat "<OPAQUE_1>", res "<OPAQUE_1>")
    return "<OPAQUE_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<OPAQUE_1>", B2 "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('NVL', 1450);

  --  REFs to opaques are not supported yet.
  --  function VALUE (item "<ADT_WITH_OID>") return "<OPAQUE_1>";
  --    pragma BUILTIN('VALUE', 1, 1, 1);
  --    pragma FIPSFLAG('VALUE', 1450);

  --  function REF (item "<ADT_WITH_OID>") return REF "<OPAQUE_1>";
  --    pragma BUILTIN('REF', 1, 1, 1);
  --    pragma FIPSFLAG('REF', 1450);

  --  function DEREF (r REF "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('DEREF', 1, 1, 1);
  --    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF OPAQUE

  --  function 'IS NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NULL', 0, 3, 0);
  --    pragma FIPSFLAG('IS NULL', 1450);

  --  function 'IS NOT NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma FIPSFLAG('IS NOT NULL', 1450);

  --  function 'IS DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS DANGLING', 1450);

  --  function 'IS NOT DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
  --    return REF "<OPAQUE_1>";
  --    pragma FIPSFLAG('NVL', 1450);

  --  function '='  (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('=', 0, 3, 1);
  --    pragma FIPSFLAG('=', 1450);

  --  function '!=' (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('!=', 0, 3, 2);
  --    pragma FIPSFLAG('!=', 1450);

  function GROUPING(a "<OPAQUE_1>") return NUMBER;
  function NULLIF(a1 "<OPAQUE_1>", a2 "<OPAQUE_1>") return VARCHAR2;

  function GREATEST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIME_TZ_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj

  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;

  -- CONVERT FOR LOB --
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2,
                   SRCCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;

  -- NLS_UPPER/NLS_LOWER FOR LOB --
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);

  function COMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS)
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('COMPOSE', 1452);
  function DECOMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS,
                     canmode in VARCHAR2 DEFAULT 'CANONICAL')
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('DECOMPOSE', 1452);
  FUNCTION SYS_EXTRACT_UTC(t timestamp_tz_unconstrained)
    return TIMESTAMP_UNCONSTRAINED;

  -- Begin REGEXP Support (10iR1) --

  -- REGEXP_LIKE --
  function REGEXP_LIKE (srcstr   VARCHAR2 CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  function REGEXP_LIKE (srcstr   CLOB CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  -- REGEXP_INSTR --
  function REGEXP_INSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        occurrence  PLS_INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);

  function REGEXP_INSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        occurrence  INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);


  -- REGEXP_SUBSTR --
  function REGEXP_SUBSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    PLS_INTEGER := 1,
                         occurrence  PLS_INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  function REGEXP_SUBSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    INTEGER := 1,
                         occurrence  INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  -- REGEXP_REPLACE --
  function REGEXP_REPLACE(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    PLS_INTEGER := 1,
                          occurrence  PLS_INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  CLOB CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  -- End REGEXP Support --

  -- binary_float and binary_double functions and operators.
  function TO_BINARY_FLOAT (RIGHT BINARY_FLOAT) RETURN BINARY_FLOAT;
    pragma BUILTIN('TO_BINARY_FLOAT',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;

  function TO_BINARY_DOUBLE (RIGHT BINARY_DOUBLE) RETURN BINARY_DOUBLE;
    pragma BUILTIN('TO_BINARY_DOUBLE',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;

  function 'IS NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;

  function TO_CHAR (left binary_float, format varchar2)
    return VARCHAR2;
  function TO_CHAR (left binary_double, format varchar2)
    return VARCHAR2;

  function TO_CHAR(left binary_float, format varchar2, parms varchar2)
    return varchar2;
  function TO_CHAR(left binary_double, format varchar2, parms varchar2)
    return varchar2;

  function TO_NCHAR(left binary_float, format nvarchar2) return NVARCHAR2;
  function TO_NCHAR(left binary_double, format nvarchar2) return NVARCHAR2;

  function TO_NCHAR(left binary_float, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left binary_double, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  function 'REMAINDER'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG(REMAINDER, 1452);

  function '='  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 15);
  function '!=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('!=',5, 2, 16);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 17);
  function '<=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 18);
  function '>'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 19);
  function '>=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 20);

  function 'IS NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 23);
  function ABS(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 2, 24);
  function '-' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 25);
  function '*' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('*',17, 2, 26);
  function '/' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('/',18, 2, 27);

  function 'REM' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(F1 BINARY_FLOAT, F2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('MOD', 1452);

  function FLOOR(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('CEIL', 1452);
  function SIGN(f BINARY_FLOAT) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);
  function SQRT(f BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('SQRT', 1452);

  function TRUNC (F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ROUND', 1452);

  function '='  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 28);
  function '!=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 29);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 30);
  function '<=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 31);
  function '>'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 32);
  function '>=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 33);

  function 'IS NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 36);
  function ABS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ABS', 1452);

  function ACOS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x BINARY_DOUBLE, y BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN2', 1452);

  function '+' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 2, 37);
  function '-' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 38);
  function '*' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('*',17, 2, 39);
  function '/' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('/',18, 2, 40);

  function 'REM' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(D1 BINARY_DOUBLE, D2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(d BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(d BINARY_DOUBLE) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function COSH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SINH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TANH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function EXP(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function LN(D BINARY_DOUBLE) return BINARY_DOUBLE;

  function LOG (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;

  function TRUNC (D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (d BINARY_DOUBLE, e BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('POWER', 1452);

  function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER;
  function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
  function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;

  function GREATEST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function GREATEST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2


  function '+' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',15, 2, 41);
  function ABS(I PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 2, 42);
  function '-' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',14, 2, 43);
  function '*' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('*',14, 2, 44);

  function '='  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 45); -- PEMS_PLS_INTEGER, PEMDCMEQ
  function '!=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 46); -- PEMS_PLS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 47); -- PEMS_PLS_INTEGER, PEMDCMLT
  function '<=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 48); -- PEMS_PLS_INTEGER, PEMDCMLE
  function '>'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 49); -- PEMS_PLS_INTEGER, PEMDCMGT
  function '>=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 51); -- PEMS_PLS_INTEGER, PEMDCMGE

  function 'IS NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_PLS_INTEGER, PEMDNUL
  function 'IS NOT NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_PLS_INTEGER, PEMDNUL

  function NVL(I1 PLS_INTEGER, I2 PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('NVL', 1452);

  function TRUNC (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('ROUND', 1452);

  function SIGN(i PLS_INTEGER) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);

  function GREATEST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2

  -- MultiSet Functions and Operators.

  -- Equality
  function '='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('=',2, 16, 1);

  function '!='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('!=',2, 16, 2);

  function CARDINALITY (collection IN "<TABLE_1>") return PLS_INTEGER;

  function SET (collection IN "<TABLE_1>") return "<TABLE_1>";
    pragma BUILTIN('SET',18, 2, 40);-- Dummy

  function 'IS A SET' (collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS A SET',18, 2, 40);-- Dummy
  function 'IS NOT A SET'(collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT A SET',18, 2, 40);-- Dummy

  function 'IS EMPTY' (collection IN  "<TABLE_1>") return BOOLEAN;
  function 'IS NOT EMPTY'(collection IN  "<TABLE_1>") return BOOLEAN;

  -- IS A SUBMULTISET OF
  function 'SUBMULTISET' (collection IN  "<TABLE_1>",
                          collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('SUBMULTISET',18, 2, 40);

  function 'MULTISET_UNION_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
      pragma BUILTIN('MULTISET_UNION_ALL',18, 2, 40);

  function 'MULTISET_UNION_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_UNION_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_DISTINCT',18, 2, 40);-- Dummy

  -- These are dummy procedures for correct management of new control
  -- statements added to PL/SQL. They ensure local procedures which have the
  -- same names as newly introduced keywords are not masked by those keywords.

  procedure continue;

  -- REGEXP_COUNT --
  function REGEXP_COUNT(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  function REGEXP_COUNT(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  --#### All user-visible declarations should preceed this point.  The
  --#### following are implementation-oriented pragmas that may need
  --#### editing in the future; we would prefer to be able to edit them
  --#### without affecting the rft numbering of user-visible items.

  --#### interface pragmas

  --#### Note that for any ICD which maps directly to a PVM
  --#### Opcode MUST be mapped to pes_dummy.
  --#### An ICD which invokes another ICD by flipping operands is
  --#### mapped to pes_flip, and an ICD whose result is the inverse of
  --#### another ICD is mapped to pes_invert
  --#### New ICDs should be placed at the end of this list, and a
  --#### corresponding entry must be made in the ICD table in pdz7

  PRAGMA interface(c,length,"pes_dummy",1);
  PRAGMA interface(c,substr,"pes_dummy",1);
  PRAGMA interface(c,instr,"pesist",1);
  PRAGMA interface(c,UPPER,"pesupp",1);
  PRAGMA interface(c,LOWER,"peslow",1);
  PRAGMA interface(c,ASCII,"pesasc");
  PRAGMA interface(c,ASCIISTR,"pesastr");
  PRAGMA interface(c,UNISTR,"pesustr");
  PRAGMA interface(c,CHR,"peschr");
  PRAGMA interface(c," SYS$STANDARD_CHR","peschr");
  PRAGMA interface(c,INITCAP,"pesicp");
  PRAGMA interface(c,LPAD,"peslpd",1);
  PRAGMA interface(c,LPAD,"peslpd",2);
  PRAGMA interface(c,RPAD,"pesrpd",1);
  PRAGMA interface(c,RPAD,"pesrpd",2);
  PRAGMA interface(c,REPLACE,"pesrep",1);
  PRAGMA interface(c,LTRIM,"pesltr",1);
  PRAGMA interface(c,LTRIM,"pesltr",2);
  PRAGMA interface(c,RTRIM,"pesrtr",1);
  PRAGMA interface(c,RTRIM,"pesrtr",2);
  PRAGMA interface(c,'LIKE',"peslik",1);
  PRAGMA interface(c,'LIKE',"pesli2",2);
  PRAGMA interface(c,ABS,"pes_dummy",1);
  PRAGMA interface(c,'MOD',"pesmod", 1);
  PRAGMA interface(c,floor,"pesflo", 1);
  PRAGMA interface(c,CEIL,"pescei", 1);
  PRAGMA interface (c, SQRT, "pessqt", 1);
  PRAGMA interface(c,SIGN,"pessgn", 1);
  PRAGMA interface(c,cos,"pescos", 1);
  PRAGMA interface(c,sin,"pessin",1);
  PRAGMA interface(c,TAN,"pestan",1);
  PRAGMA interface(c,COSH,"pescsh",1);
  PRAGMA interface(c,SINH,"pessnh",1);
  PRAGMA interface(c,TANH,"pestnh",1);
  PRAGMA interface(c,EXP,"pesexp",1);
  PRAGMA interface(c,LN,"pesln",1);
  PRAGMA interface(c,BITAND,"pesbtd",1);
  PRAGMA interface(c,BITAND,"pesbtdn",2);
  PRAGMA interface(c,LOG,"peslog",1);
  PRAGMA interface(c,TRUNC,"pestru",1);
  PRAGMA interface(c,ROUND,"pesrnd",1);
  PRAGMA interface(c,POWER,"pespow",1);
  PRAGMA interface(c,NEW_TIME,"pesnwt");
  PRAGMA interface(c,TO_DATE,"pesc2d",4);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",3);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",4);
  PRAGMA interface(c,'>=',"pes_flip",5);
  PRAGMA interface(c,'>',"pes_flip",5);
  PRAGMA interface(c,'<=',"peszle",5);
  PRAGMA interface(c,'<',"peszlt",5);        -- ICD #50
  PRAGMA interface(c,'=',"peszeq",5);
  PRAGMA interface(c,'!=',"pes_invert",5);
  PRAGMA interface(c,nlssort,"pesxco",2);
  PRAGMA interface(c,NLS_UPPER,"pesxup",1);
  PRAGMA interface(c,NLS_UPPER,"peslcnup",3); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_UPPER,"peslcnup",4); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_LOWER,"pesxlo",1);
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",3); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",4); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_INITCAP,"pesxcp",1);
  PRAGMA interface(c,lengthb,"pes_dummy",1);
  PRAGMA interface(c,substrb,"pes_dummy",1);
  PRAGMA interface(c,instrb,"pesxis",1);
  PRAGMA interface(c,TO_SINGLE_BYTE, "pesxsi");
  PRAGMA interface(c,TO_MULTI_BYTE,"pesxmu");
  PRAGMA interface(c,TO_CHAR,"pesd2c",5);
  PRAGMA interface(c,TO_CHAR,"pesn2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesd2c",4);
  PRAGMA interface(c,TO_NCHAR,"pesn2c",5);
  PRAGMA interface(c," SYS$STANDARD_TRANSLATE","pesxcs");
  PRAGMA interface(c,ATAN,"pesatan",1);
  PRAGMA interface(c,EMPTY_CLOB,"peslcem");
  PRAGMA interface(c,EMPTY_BLOB,"peslbem");
  PRAGMA interface(c,BFILENAME,"pesfnm");
  PRAGMA interface(c,TO_TIME,"pes3tm",2);
  PRAGMA interface(c,TO_TIME,"pes3tm",3);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",2);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",3);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",2);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",3);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",2);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",3);
  PRAGMA interface(c,TO_DSINTERVAL,"pes2dsi",2);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",1);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",2);
  PRAGMA interface(c,SESSIONTIMEZONE,"pesstz",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",2);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",3);
  PRAGMA interface(c,TRIM,"pestrim",1);
  -- Datetime addition
  PRAGMA interface(c,'+',"pesati",5);    --  +(tsp, iym) return tsp
  PRAGMA interface(c,'+',"pesati",6);    --  +(tsp, ids) return tsp
  PRAGMA interface(c,'+',"pesati",7);    --  +(tsz, iym) return tsz
  PRAGMA interface(c,'+',"pesati",8);    --  +(tsz, ids) return tsz
  PRAGMA interface(c,'+',"pesati",9);    --  +(tim, ids) return tim
  PRAGMA interface(c,'+',"pesati",10);   --  +(tmz, ids) return tmz
  PRAGMA interface(c,'+',"pesadi",11);   --  +(dat, iym) return dat
  PRAGMA interface(c,'+',"pesadi",12);   --  +(dat, ids) return dat
  PRAGMA interface(c,'+',"pes_flip",13); --  +(iym, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",14); --  +(iym, tsz) return tsz -- ICD #100
  PRAGMA interface(c,'+',"pes_flip",15); --  +(iym, dat) return dat
  PRAGMA interface(c,'+',"pes_flip",16); --  +(ids, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",17); --  +(ids, tsz) return tsz
  PRAGMA interface(c,'+',"pes_flip",18); --  +(ids, tim) return tim
  PRAGMA interface(c,'+',"pes_flip",19); --  +(ids, tmz) return tmz
  PRAGMA interface(c,'+',"pes_flip",20); --  +(ids, dat) return dat
  PRAGMA interface(c,'+',"pesaii",21);   --  +(ids, ids) return ids
  PRAGMA interface(c,'+',"pesaii",22);   --  +(iym, iym) return iym
  PRAGMA interface(c,'+',"pesati",23);   --  +(ltz, iym) return ltz
  PRAGMA interface(c,'+',"pesati",24);   --  +(ltz, ids) return ltz
  PRAGMA interface(c,'+',"pes_flip",25);--  +(iym, ltz) return ltz
  PRAGMA interface(c,'+',"pes_flip",26);--  +(ids, ltz) return ltz
  -- Datetime subtraction
  PRAGMA interface(c,'-',"pessti",6);    --  -(tsp, iym) return tsp
  PRAGMA interface(c,'-',"pessti",7);    --  -(tsp, ids) return tsp
  PRAGMA interface(c,'-',"pessti",8);    --  -(tsz, iym) return tsz
  PRAGMA interface(c,'-',"pessti",9);    --  -(tsz, ids) return tsz
  PRAGMA interface(c,'-',"pessti",10);   --  -(tim, ids) return tim
  PRAGMA interface(c,'-',"pessti",11);   --  -(tmz, ids) return tmz
  PRAGMA interface(c,'-',"pessdi",12);   --  -(dat, iym) return dat
  PRAGMA interface(c,'-',"pessdi",13);   --  -(dat, ids) return dat
  PRAGMA interface(c,'-',"pessii",14);   --  -(iym, iym) return iym
  PRAGMA interface(c,'-',"pessii",15);   --  -(ids, ids) return ids
  PRAGMA interface(c,'-',"pessttds",16); --  -(tim, tim) return ids
  PRAGMA interface(c,'-',"pessttds",17); --  -(tsp, tsp) return ids
  PRAGMA interface(c,'-',"pessttds",18); --  -(tmz, tmz) return ids
  PRAGMA interface(c,'-',"pessttds",19); --  -(tsz, tsz) return ids
  PRAGMA interface(c,'-',"pessti",20);   --  -(ltz, iym) return iym
  PRAGMA interface(c,'-',"pessti",21);   --  -(ltz, ids) return ids
  PRAGMA interface(c,'-',"pessttds",22); --  -(ltz, ltz) return ids
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",1);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",2);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",3);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",4);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessddds",5);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",6);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",1);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",2);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessddym",3);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",4);
  -- Datetime multiplication
  PRAGMA interface(c,'*',"pesmni",2);    --  *(num, iym) return iym
  PRAGMA interface(c,'*',"pesmni",3);    --  *(num, ids) return ids
  PRAGMA interface(c,'*',"pes_flip",4);  --  *(iym, num) return iym
  PRAGMA interface(c,'*',"pes_flip",5);  --  *(ids, num) return ids
  -- Datetime division
  PRAGMA interface(c,'/',"pesdvin",2);   --  /(iym, num) return iym
  PRAGMA interface(c,'/',"pesdvin",3);   --  /(ids, num) return ids
  -- TIME
  PRAGMA interface(c,'=',"pes_dummy",9);
  PRAGMA interface(c,'!=',"pes_invert",9);
  PRAGMA interface(c,'>',"pes_flip",8);
  PRAGMA interface(c,'<',"pes_dummy",8);
  PRAGMA interface(c,'>=',"pes_flip",8);   -- ICD #150
  PRAGMA interface(c,'<=',"pes_dummy",8);
  -- TIME WITH TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",10);
  PRAGMA interface(c,'!=',"pes_invert",10);
  PRAGMA interface(c,'>',"pes_flip",9);
  PRAGMA interface(c,'<',"pes_dummy",9);
  PRAGMA interface(c,'>=',"pes_flip",9);
  PRAGMA interface(c,'<=',"pes_dummy",9);
  -- TIMESTAMP
  PRAGMA interface(c,'=',"pes_dummy",11);
  PRAGMA interface(c,'!=',"pes_invert",11);
  PRAGMA interface(c,'>',"pes_flip",10);
  PRAGMA interface(c,'<',"pes_dummy",10);
  PRAGMA interface(c,'>=',"pes_flip",10);
  PRAGMA interface(c,'<=',"pes_dummy",10);
  -- INTERVAL YEAR TO MONTH
  PRAGMA interface(c,'=',"pes_dummy",12);
  PRAGMA interface(c,'!=',"pes_invert",12);
  PRAGMA interface(c,'>',"pes_flip",11);
  PRAGMA interface(c,'<',"pes_dummy",11);
  PRAGMA interface(c,'>=',"pes_flip",11);
  PRAGMA interface(c,'<=',"pes_dummy",11);
  -- INTERVAL DAY TO SECOND
  PRAGMA interface(c,'=',"pes_dummy",13);
  PRAGMA interface(c,'!=',"pes_invert",13);
  PRAGMA interface(c,'>',"pes_flip",12);
  PRAGMA interface(c,'<',"pes_dummy",12);
  PRAGMA interface(c,'>=',"pes_flip",12);
  PRAGMA interface(c,'<=',"pes_dummy",12);
  -- TIMESTAMP_TZ_UNCONSTRAINED
  PRAGMA interface(c,'=',"pes_dummy",14);
  PRAGMA interface(c,'!=',"pes_invert",14);
  PRAGMA interface(c,'>',"pes_flip",13);
  PRAGMA interface(c,'<',"pes_dummy",13);
  PRAGMA interface(c,'>=',"pes_flip",13);
  PRAGMA interface(c,'<=',"pes_dummy",13);
  -- TIMESTAMP WITH LOCAL TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",15);
  PRAGMA interface(c,'!=',"pes_invert",15);
  PRAGMA interface(c,'>',"pes_flip",14);
  PRAGMA interface(c,'<',"pes_dummy",14);
  PRAGMA interface(c,'>=',"pes_flip",14);
  PRAGMA interface(c,'<=',"pes_dummy",14);
  -- Other datetime functions
  PRAGMA interface(c,'CURRENT_DATE',"pescdt",1);
  PRAGMA interface(c,'CURRENT_TIME',"pesctm",1);
  PRAGMA interface(c,'CURRENT_TIMESTAMP',"pescts",1);
  --  Internal calls to evaluate datetime/interval literals without NLS parms.
  PRAGMA interface(c,SYS_LITERALTOYMINTERVAL,"pesc2ymi",1);
  PRAGMA interface(c,SYS_LITERALTODSINTERVAL,"pesc2dsi",1);
  PRAGMA interface(c,SYS_LITERALTOTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTODATE,"pesc2date",1);
  -- extract(field from expr)
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",1);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",2);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",3);   -- ICD #200
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",4);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",5);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefdt",6);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",7);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",8);
  -- datetime is null
  PRAGMA interface(c,"IS NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NULL","pes_dummy",20); -- interval ds

  -- 8.2 LOB Built-in Functions
  PRAGMA interface(c,length, "peslcln",2);    -- LOB LENGTH
  PRAGMA interface(c,lengthb,"peslclb",2);    -- LOB LENGTHB
  PRAGMA interface(c,substr, "peslcst",2);    -- LOB SUBSTR
  PRAGMA interface(c,substrb,"peslcsb",2);    -- LOB SUBSTRB
  PRAGMA interface(c,instr,  "peslcin",2);    -- LOB INSTR
  PRAGMA interface(c,instrb, "peslcib",2);    -- LOB INSTRB
  PRAGMA interface(c,'||',   "peslcct",2);    -- LOB '||'
  PRAGMA interface(c,concat, "peslcct",2);    -- LOB CONCAT
  PRAGMA interface(c,lpad,   "peslclp",3);    -- LOB LPAD
  PRAGMA interface(c,lpad,   "peslclp",4);    -- LOB LPAD
  PRAGMA interface(c,rpad,   "peslcrp",3);    -- LOB RPAD
  PRAGMA interface(c,rpad,   "peslcrp",4);    -- LOB RPAD
  PRAGMA interface(c,lower,  "peslclr",2);    -- LOB LOWER
  PRAGMA interface(c,upper,  "peslcup",2);    -- LOB UPPER
  PRAGMA interface(c,ltrim,  "peslclm",3);    -- LOB LTRIM
  PRAGMA interface(c,ltrim,  "peslclm",4);    -- LOB LTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",3);    -- LOB RTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",4);    -- LOB RTRIM
  PRAGMA interface(c,trim,   "peslctr",2);    -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",4); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",5); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",6); -- LOB TRIM
  PRAGMA interface(c,'LIKE', "peslclk",3);    -- LOB LIKE
  PRAGMA interface(c,'LIKE', "peslcl2",4);    -- LOB LIKE
  PRAGMA interface(c,nvl,"peslcnl",17);       -- LOB NVL
  PRAGMA interface(c,replace, "peslcrl",2);   -- LOB REPLACE

     -- LOB Relational Operators
     -- LHS: CLOB,    RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_dummy",16);     -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",16);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",15);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pes_dummy",15);     -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",15);      -- LOB '>='
  PRAGMA interface(c,'<=',"pes_dummy",15);       -- LOB '<='
     -- LHS: CLOB,     RHS:VARCHAR2
  PRAGMA interface(c,'=' ,"pesleq2",17);       -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",17);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",16);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt2",16);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",16);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle2",16);       -- LOB '<='  -- ICD #250
     -- LHS: VARCHAR2, RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_flip",18);      -- LOB '='
  PRAGMA interface(c,'!=',"pes_flip",18);      -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",17);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt3",17);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",17);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle3",17);       -- LOB '<='

  PRAGMA interface(c,length, "peslbln",3);    -- BLOB LENGTH
  PRAGMA interface(c,lengthb,"peslblb",3);    -- BLOB LENGTHB
  -- End of 8.2 LOB Built-in Functions


  PRAGMA interface(c,tz_offset,"pestzo",1);
  PRAGMA interface(c,from_tz,"pesftz",1);

  PRAGMA interface(c,ISNCHAR,"pesinc", 1);

  PRAGMA interface(c,CONVERT,"pescnv", 1);
  PRAGMA interface(c,CONVERT,"pescnv", 2);
  PRAGMA interface(c,CONVERT,"peslccnv", 3);  -- LOB CONVERT
  PRAGMA interface(c,CONVERT,"peslccnv", 4);  -- LOB CONVERT

  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",1);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",2);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",3);

  PRAGMA interface(c,TO_CHAR,"pesdtm2c",7); -- datetime
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",8);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",9);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",10);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",11);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",12);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",13);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",14);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",15);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",16);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",17); -- interval
  PRAGMA interface(c,TO_CHAR,"pesitv2c",18);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",19);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",20);

  --#### new_names pragmas

  -- This is an internal pragma that restricts the use
  -- of particular new entries in package standard.
  -- It is only valid in package standard.
  -- Note that left out of the 8.1.5 set are non datetime
  -- entries urowid, "UROWID ", self_is_null and trim.

  pragma new_names('8.1.5',
                   time,"TIME WITH TIME ZONE",
                   timestamp,"TIMESTAMP WITH TIME ZONE",
                   "INTERVAL DAY TO SECOND",
                   "INTERVAL YEAR TO MONTH",
                   to_time, to_timestamp,
                   to_time_tz, to_timestamp_tz,
                   " SYS$DSINTERVALSUBTRACT",
                   " SYS$YMINTERVALSUBTRACT",
                   to_yminterval,to_dsinterval,
                   NUMTOYMINTERVAL, NUMTODSINTERVAL,
                   current_date,
                   current_time,current_timestamp);

  pragma new_names('8.1.6',
                   dbtimezone, sessiontimezone, localtimestamp,
                   localtime,
                   cube, rollup, grouping, "TIMESTAMP WITH LOCAL TIME ZONE");

  -- Should there be a 8.2 new names pragma ?

  -- 8.2 UCS2/UCS4/Complete Built-in Functions

  PRAGMA interface(c,INSTR2,"pesist2",1);
  PRAGMA interface(c,INSTR4,"pesist4",1);
  PRAGMA interface(c,INSTRC,"pesistc",1);

  PRAGMA interface(c,LENGTH2,"peslen2",1);
  PRAGMA interface(c,LENGTH4,"peslen4",1);
  PRAGMA interface(c,LENGTHC,"peslenc",1);

  PRAGMA interface(c,LIKE2,"peslik2",1);
  PRAGMA interface(c,LIKE2,"pesli22",2);
  PRAGMA interface(c,LIKE4,"peslik4",1);
  PRAGMA interface(c,LIKE4,"pesli42",2);
  PRAGMA interface(c,LIKEC,"peslikc",1);
  PRAGMA interface(c,LIKEC,"peslic2",2);

  PRAGMA interface(c,SUBSTR2,"pes_dummy",1);
  PRAGMA interface(c,SUBSTR4,"pes_dummy",1);
  PRAGMA interface(c,SUBSTRC,"pes_dummy",1);
  PRAGMA interface(c,SYS_EXTRACT_UTC,"pessexu");
  PRAGMA interface(c,COMPOSE,"pescomp");
  PRAGMA interface(c,DECOMPOSE,"pesdcmp");



  -- End of 8.2 UCS2/UCS4/Complete Built-in Functions

  -- Begin REGEXP support (10iR1) --
  PRAGMA interface(c,regexp_like,    "pes_dummy",1);
  PRAGMA interface(c,regexp_instr,   "pes_dummy",1);    -- ICD #300
  PRAGMA interface(c,regexp_substr,  "pes_dummy",1);
  PRAGMA interface(c,regexp_replace, "pes_dummy",1);
  PRAGMA interface(c,regexp_count,   "pes_dummy",1);
  PRAGMA interface(c,regexp_like,    "pes_dummy",2);    -- LOB REGEXP_LIKE
  PRAGMA interface(c,regexp_instr,   "pes_dummy",2);    -- LOB REGEXP_INSTR
  PRAGMA interface(c,regexp_substr,  "pes_dummy",2);    -- LOB REGEXP_SUBSTR
  PRAGMA interface(c,regexp_replace, "pes_dummy",2);    -- LOB REGEXP_REPLACE
  PRAGMA interface(c,regexp_count,   "pes_dummy",2);    -- LOB REGEXP_COUNT
  PRAGMA interface(c,regexp_replace, "pes_dummy",3);    -- LOB REGEXP_REPLACE

  -- End of REGEXP Built-in Functions --


  -- 10i Binary Floating-point Built-in Functions

  PRAGMA interface(c,"IS NAN","pesnanf",2);
  PRAGMA interface(c,"IS NAN","pesnand",3);
  PRAGMA interface(c,"IS INFINITE","pesinf",1);
  PRAGMA interface(c,"IS INFINITE","pesinff",2);
  PRAGMA interface(c,"IS INFINITE","pesinfd",3);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",2);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",3);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",2);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",3);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",21);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",22);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",23);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",24);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",7);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",8);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",9);
  PRAGMA interface(c,'REMAINDER',"pesrem", 1);
  PRAGMA interface(c,REMAINDER,"pesrem", 2);
  PRAGMA interface(c,'REMAINDER',"pesremf", 3);
  PRAGMA interface(c,REMAINDER,"pesremf", 4);
  PRAGMA interface(c,'REMAINDER',"pesremd", 5);
  PRAGMA interface(c,REMAINDER,"pesremd", 6);
  PRAGMA interface(c,ABS,"pes_dummy",2);
  PRAGMA interface(c,ABS,"pes_dummy",3);
  PRAGMA interface(c,ABS,"pes_dummy",4);
  PRAGMA interface(c,ATAN,"pesatand",2);
  PRAGMA interface(c,'MOD',"pesmodf", 2);
  PRAGMA interface(c,'MOD',"pesmodd", 3);
  PRAGMA interface(c,floor,"pesflof", 2);
  PRAGMA interface(c,floor,"pesflod", 3);
  PRAGMA interface(c,CEIL,"pesceif", 2);
  PRAGMA interface(c,CEIL,"pesceid", 3);
  PRAGMA interface (c, SQRT, "pessqtf", 2);
  PRAGMA interface (c, SQRT, "pessqtd", 3);
  PRAGMA interface(c,SIGN,"pessgnf", 2);
  PRAGMA interface(c,SIGN,"pessgnd", 3);
  PRAGMA interface(c,SIGN,"pessgni", 4);
  PRAGMA interface(c,cos,"pescosd", 2);
  PRAGMA interface(c,sin,"pessind",2);
  PRAGMA interface(c,TAN,"pestand",2);
  PRAGMA interface(c,COSH,"pescshd",2);
  PRAGMA interface(c,SINH,"pessnhd",2);   -- ICD #350
  PRAGMA interface(c,TANH,"pestnhd",2);
  PRAGMA interface(c,EXP,"pesexpd",2);
  PRAGMA interface(c,LN,"peslnd",2);
  PRAGMA interface(c,LOG,"peslogd",2);
  PRAGMA interface(c,TRUNC,"pestruf",4);
  PRAGMA interface(c,TRUNC,"pestrud",5);
  PRAGMA interface(c,TRUNC,"pestrui",6);
  PRAGMA interface(c,ROUND,"pesrndf",4);
  PRAGMA interface(c,ROUND,"pesrndd",5);
  PRAGMA interface(c,ROUND,"pesrndi",6);
  PRAGMA interface(c,POWER,"pespowd",2);

  -- End of 10i Binary Floating-point Built-in Functions

  -- ICDs for MULTISET

  PRAGMA interface(c,CARDINALITY,"pesmcnt");
  PRAGMA interface(c,"IS EMPTY","pesmie");
  PRAGMA interface(c,"IS NOT EMPTY","pes_invert",1);
  -- ICDs which used to be in the body of standard, but which new COG can
  -- handle directly

  -- NOT (some ICD)
  PRAGMA interface(c,NOT_LIKE,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",3);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",4);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",3);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",1);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",2);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",3);

  -- datetime is not null
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",20); -- interval ds

  -- Misc
  PRAGMA interface(c,"**",   "pespow",1);    -- number
  PRAGMA interface(c,"**",   "pespowd",2);   -- binary double
  PRAGMA interface(c,"ACOS", "pesacosd",2);  -- binary double
  PRAGMA interface(c,"ASIN", "pesasind",2);  -- binary double
  PRAGMA interface(c,"ATAN2","pesatn2d",2);  -- binary double

  -- All the flavors of NVL
  PRAGMA interface(c,nvl,"pes_dummy",1);       -- Boolean -- ICD #400
  PRAGMA interface(c,nvl,"pes_dummy",2);       -- Varchar2
  PRAGMA interface(c,nvl,"pes_dummy",3);       -- Number
  PRAGMA interface(c,nvl,"pes_dummy",4);       -- Date
  PRAGMA interface(c,nvl,"pes_dummy",5);       -- MLSLabel
  PRAGMA interface(c,nvl,"pes_dummy",6);       -- ADT
  PRAGMA interface(c,nvl,"pes_dummy",7);       -- Ref ADT
  PRAGMA interface(c,nvl,"pes_dummy",8);       -- Collection

--  Ref Cursor has problems. The MOVCR instruction needs more information than
--  the other MOV* instructions, including the PVM register of the destination
--  This cannot be easily supplied through the generic NVL instruction, so
--  for now, this flavor will continue to have a real body
--  PRAGMA interface(c,nvl,"pes_dummy",9);       -- Ref Cursor

  PRAGMA interface(c,nvl,"pes_dummy",10);       -- Time
  PRAGMA interface(c,nvl,"pes_dummy",11);       -- Time-tz
  PRAGMA interface(c,nvl,"pes_dummy",12);       -- Timestamp
  PRAGMA interface(c,nvl,"pes_dummy",13);       -- Timestamp-tz
  PRAGMA interface(c,nvl,"pes_dummy",14);       -- Timestamp-ltz
  PRAGMA interface(c,nvl,"pes_dummy",15);       -- Intervalym
  PRAGMA interface(c,nvl,"pes_dummy",16);       -- Intervalds
--  PRAGMA interface(c,nvl,"pes_dummy",17);       -- Clob (Handled above, ICD)
  PRAGMA interface(c,nvl,"pes_dummy",18);       -- Opaque
  PRAGMA interface(c,nvl,"pes_dummy",19);       -- Binaryfloat
  PRAGMA interface(c,nvl,"pes_dummy",20);       -- Binarydouble
  PRAGMA interface(c,nvl,"pes_dummy",21);       -- PLSInteger

  -- The following pragma overrides any other setting of the timestamp,
  -- and is used so that we recognize the client-side and server-side instances
  -- of package STANDARD as being the same.  Package STANDARD is special in
  -- that it is really the root of the PL/SQL dependencies graph; as such it
  -- itself doesn't ever need recompiling due to changes to things below it.
  -- The pragma mechanism used here is currently ignored except for
  -- package STANDARD, but in future may not be.  Do NOT add similar pragmas
  -- to your own code as it may in future interfere with the package
  -- consistency maintenance mechanisms and could have dire results.

  --#### timestamp pragma (please keep this last)
  pragma TIMESTAMP('2006-04-18:00:00:00');
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."STANDARD" AUTHID CURRENT_USER is              -- careful on this line; SED edit occurs!

  /********** Types and subtypes, do not reorder **********/
  type BOOLEAN is (FALSE, TRUE);

  type DATE is DATE_BASE;

  type NUMBER is NUMBER_BASE;
  subtype FLOAT is NUMBER; -- NUMBER(126)
  subtype REAL is FLOAT; -- FLOAT(63)
  subtype "DOUBLE PRECISION" is FLOAT;
  subtype INTEGER is NUMBER(38,0);
  subtype INT is INTEGER;
  subtype SMALLINT is NUMBER(38,0);
  subtype DECIMAL is NUMBER(38,0);
  subtype NUMERIC is DECIMAL;
  subtype DEC is DECIMAL;


  subtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;
  subtype NATURAL is BINARY_INTEGER range 0..2147483647;
  subtype NATURALN is NATURAL not null;
  subtype POSITIVE is BINARY_INTEGER range 1..2147483647;
  subtype POSITIVEN is POSITIVE not null;
  subtype SIGNTYPE is BINARY_INTEGER range '-1'..1;  -- for SIGN functions

  type VARCHAR2 is NEW CHAR_BASE;

  subtype VARCHAR is VARCHAR2;
  subtype STRING is VARCHAR2;

  subtype LONG is VARCHAR2(32760);

  subtype RAW is VARCHAR2;
  subtype "LONG RAW" is RAW(32760);

  subtype ROWID is VARCHAR2(256);

  -- Ansi fixed-length char
  -- Define synonyms for CHAR and CHARN.
  subtype CHAR is VARCHAR2;
  subtype CHARACTER is CHAR;

  type MLSLABEL is new CHAR_BASE;

  -- Large object data types.
  --  binary, character, binary file.
  type  BLOB is BLOB_BASE;
  type  CLOB is CLOB_BASE;
  type  BFILE is BFILE_BASE;

  -- Verbose and NCHAR type names
  subtype "CHARACTER VARYING" is VARCHAR;
  subtype "CHAR VARYING" is VARCHAR;
  subtype "NATIONAL CHARACTER" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHARACTER VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NVARCHAR2" is VARCHAR2 CHARACTER SET NCHAR_CS;
  subtype "CHARACTER LARGE OBJECT" is CLOB;
  subtype "CHAR LARGE OBJECT" is CLOB;
  subtype "NATIONAL CHARACTER LARGE OBJEC" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCHAR LARGE OBJECT" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCLOB" is CLOB CHARACTER SET NCHAR_CS;
  subtype "BINARY LARGE OBJECT" is BLOB;

  subtype pls_integer is binary_integer;

  type TIME is new DATE_BASE;
  type TIMESTAMP is new DATE_BASE;
  type "TIME WITH TIME ZONE" is new DATE_BASE;
  type "TIMESTAMP WITH TIME ZONE" is new DATE_BASE;
  type "INTERVAL YEAR TO MONTH" is new DATE_BASE;
  type "INTERVAL DAY TO SECOND" is new DATE_BASE;

  SUBTYPE TIME_UNCONSTRAINED IS TIME(9);
  SUBTYPE TIME_TZ_UNCONSTRAINED IS TIME(9) WITH TIME ZONE;
  SUBTYPE TIMESTAMP_UNCONSTRAINED IS TIMESTAMP(9);
  SUBTYPE TIMESTAMP_TZ_UNCONSTRAINED IS TIMESTAMP(9) WITH TIME ZONE;
  SUBTYPE YMINTERVAL_UNCONSTRAINED IS INTERVAL YEAR(9) TO MONTH;
  SUBTYPE DSINTERVAL_UNCONSTRAINED IS INTERVAL DAY(9) TO SECOND (9);

  TYPE UROWID IS NEW CHAR_BASE;

  type "TIMESTAMP WITH LOCAL TIME ZONE" is new DATE_BASE;
  subtype timestamp_ltz_unconstrained is timestamp(9) with local time zone;

  subtype BINARY_FLOAT is NUMBER;
  subtype BINARY_DOUBLE is NUMBER;

  -- The following data types are generics, used specially within package
  -- STANDARD and some other Oracle packages.  They are protected against
  -- other use; sorry.  True generic types are not yet part of the language.

  type "<ADT_1>" as object (dummy char(1));
  type "<RECORD_1>" is record (dummy char(1));
  type "<TUPLE_1>" as object (dummy char(1));
  type "<VARRAY_1>" is varray (1) of char(1);
  type "<V2_TABLE_1>" is table of char(1) index by binary_integer;
  type "<TABLE_1>" is table of char(1);
  type "<COLLECTION_1>" is table of char(1);
  type "<REF_CURSOR_1>" is ref cursor;

  -- This will actually match against a Q_TABLE
  type "<TYPED_TABLE>" is table of  "<ADT_1>";
  subtype "<ADT_WITH_OID>" is "<TYPED_TABLE>";

  -- The following generic index table data types are used by the PL/SQL
  -- compiler to materialize an array attribute at the runtime (for more
  -- details about the array attributes, please see Bulk Binds document).
  type " SYS$INT_V2TABLE" is table of pls_integer index by binary_integer;

  -- The following record type and the corresponding generic index table
  -- data types are used by the PL/SQL compiler to materialize a table
  -- at the runtime in order to record the exceptions raised during the
  -- execution of FORALL bulk bind statement (for more details, please
  -- see bulk binds extensions document in 8.2).
  type " SYS$BULK_ERROR_RECORD" is
          record (error_index pls_integer, error_code pls_integer);
  type " SYS$REC_V2TABLE" is table of " SYS$BULK_ERROR_RECORD"
                               index by binary_integer;

  /* Adding a generic weak ref cursor type */
  type sys_refcursor is ref cursor;

  /* the following data type is a generic for all opaque types */
  type "<OPAQUE_1>" as opaque FIXED(1) USING LIBRARY dummy_lib
    (static function dummy return number);

  type "<ASSOC_ARRAY_1>" is table of char(1) index by varchar2(1);

  /********** Add new types or subtypes here **********/

  -- Simple scalar types

  subtype SIMPLE_INTEGER is BINARY_INTEGER NOT NULL;
  subtype SIMPLE_FLOAT   is BINARY_FLOAT   NOT NULL;
  subtype SIMPLE_DOUBLE  is BINARY_DOUBLE  NOT NULL;

  /********** Predefined constants **********/

  BINARY_FLOAT_NAN constant BINARY_FLOAT;
  BINARY_FLOAT_INFINITY constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_SUBNORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_SUBNORMAL constant BINARY_FLOAT;
  BINARY_DOUBLE_NAN constant BINARY_DOUBLE;
  BINARY_DOUBLE_INFINITY constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_SUBNORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_SUBNORMAL constant BINARY_DOUBLE;

  /********** Add new constants here **********/

  /********** Predefined exceptions **********/

  CURSOR_ALREADY_OPEN exception;
    pragma EXCEPTION_INIT(CURSOR_ALREADY_OPEN, '-6511');

  DUP_VAL_ON_INDEX exception;
    pragma EXCEPTION_INIT(DUP_VAL_ON_INDEX, '-0001');

  TIMEOUT_ON_RESOURCE exception;
    pragma EXCEPTION_INIT(TIMEOUT_ON_RESOURCE, '-0051');

  INVALID_CURSOR exception;
    pragma EXCEPTION_INIT(INVALID_CURSOR, '-1001');

  NOT_LOGGED_ON exception;
    pragma EXCEPTION_INIT(NOT_LOGGED_ON, '-1012');

  LOGIN_DENIED exception;
    pragma EXCEPTION_INIT(LOGIN_DENIED, '-1017');

  NO_DATA_FOUND exception;
    pragma EXCEPTION_INIT(NO_DATA_FOUND, 100);

  ZERO_DIVIDE exception;
    pragma EXCEPTION_INIT(ZERO_DIVIDE, '-1476');

  INVALID_NUMBER exception;
    pragma EXCEPTION_INIT(INVALID_NUMBER, '-1722');

  TOO_MANY_ROWS exception;
    pragma EXCEPTION_INIT(TOO_MANY_ROWS, '-1422');

  STORAGE_ERROR exception;
    pragma EXCEPTION_INIT(STORAGE_ERROR, '-6500');

  PROGRAM_ERROR exception;
    pragma EXCEPTION_INIT(PROGRAM_ERROR, '-6501');

  VALUE_ERROR exception;
    pragma EXCEPTION_INIT(VALUE_ERROR, '-6502');

  ACCESS_INTO_NULL exception;
    pragma EXCEPTION_INIT(ACCESS_INTO_NULL, '-6530');

  COLLECTION_IS_NULL exception;
    pragma EXCEPTION_INIT(COLLECTION_IS_NULL , '-6531');

  SUBSCRIPT_OUTSIDE_LIMIT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_OUTSIDE_LIMIT,'-6532');

  SUBSCRIPT_BEYOND_COUNT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_BEYOND_COUNT ,'-6533');

  -- exception for ref cursors
  ROWTYPE_MISMATCH exception;
  pragma EXCEPTION_INIT(ROWTYPE_MISMATCH, '-6504');

  SYS_INVALID_ROWID  EXCEPTION;
  PRAGMA EXCEPTION_INIT(SYS_INVALID_ROWID, '-1410');

  -- The object instance i.e. SELF is null
  SELF_IS_NULL exception;
    pragma EXCEPTION_INIT(SELF_IS_NULL, '-30625');

  CASE_NOT_FOUND exception;
    pragma EXCEPTION_INIT(CASE_NOT_FOUND, '-6592');

  -- Added for USERENV enhancement, bug 1622213.
  USERENV_COMMITSCN_ERROR exception;
    pragma EXCEPTION_INIT(USERENV_COMMITSCN_ERROR, '-1725');

  -- Parallel and pipelined support
  NO_DATA_NEEDED exception;
    pragma EXCEPTION_INIT(NO_DATA_NEEDED, '-6548');
  -- End of 8.2 parallel and pipelined support

  /********** Add new exceptions here **********/

  /********** Function, operators and procedures **********/

  function "EXISTS" return BOOLEAN;
    pragma BUILTIN('EXISTS',10,240,240); -- This is special cased in PH2 -- Pj

  function GREATEST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DATE) return DATE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DATE) return DATE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr NUMBER, pat NUMBER, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER,
                   pat NUMBER,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER, pat NUMBER, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr DATE, pat DATE, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE,
                   pat DATE,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE, pat DATE, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function SQLCODE return PLS_INTEGER;
    pragma BUILTIN('SQLCODE',45, 10, 0); -- PEMS_DB, DB_SQLCODE

  function SQLERRM return varchar2;
    pragma FIPSFLAG('SQLERRM', 1452);

  function SQLERRM (code PLS_INTEGER) return varchar2;
    pragma BUILTIN('SQLERRM',46, 10, 1); -- PEMS_DB, DB_SQLERRM
    pragma FIPSFLAG('SQLERRM', 1452);

  function LEVEL return NUMBER;

  function ROWNUM return NUMBER;

  function '='  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('=',2, 3, 1); -- PEMS_INTEGER, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN; -- also <> and ~=
    pragma BUILTIN('!=',5, 3, 2); -- PEMS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<',4, 3, 3);  -- PEMS_INTEGER, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<=',6, 3, 4); -- PEMS_INTEGER, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>',1, 3, 5); -- PEMS_INTEGER, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>=',3, 3, 6); -- PEMS_INTEGER, PEMDMGE
    pragma FIPSFLAG('>=', 1450);

  --  Since SQL permits short-circuit evaluation, the 'and' and 'or'
  --  operations will always be interpreted as 'and then' and 'or else'
  --  when they occur in conditional statements.

  function XOR (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('XOR',8, 3, 9); -- PEMS_INTEGER, INT_XOR
    pragma FIPSFLAG('XOR', 1450);

  function 'NOT' (RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('NOT',9, 3, 10); -- PEMS_INTEGER, INT_NOT

  function 'IS NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);  -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50); -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 BOOLEAN, B2 BOOLEAN) return BOOLEAN;
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('=',2, 1, 14); -- PEMS_CHAR, PEMDCMEQ (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('=', 1454);
  function '!=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('!=',5, 1, 15);  -- PEMS_CHAR, PEMDCMNE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('!=', 1454);
  function '<'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<',4, 1, 16); -- PEMS_CHAR, PEMDCMLT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<', 1454);
  function '<=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<=',6, 1, 17); -- PEMS_CHAR, PEMDCMLE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<=', 1454);
  function '>'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>',1, 1, 18); -- PEMS_CHAR, PEMDCMGT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>', 1454);
  function '>=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>=',3, 1, 19); -- PEMS_CHAR, PEMDCMGE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>=', 1454);

  function '||' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN('||',25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT VARCHAR2 CHARACTER SET ANY_CS,
                  RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN(CONCAT,25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG(CONCAT, 1454);

  function LENGTH(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH', 1452);
  -- In SUBSTR, LEN defaults to remainder of string
  -- In substr and instr, a negative value of parameter POS means to
  -- count from the right end of the string.
  function SUBSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  POS PLS_INTEGER,
                  LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  -- Find nth occurrence of str1 in str2 starting at pos
  function INSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);
  function LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);
  function ASCII(ch VARCHAR2 CHARACTER SET ANY_CS)
        return PLS_INTEGER; -- should be ASCII.CHRANGE
    pragma FIPSFLAG('ASCII', 1452);
  function ASCIISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('ASCIISTR', 1452);
  function UNISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return NVARCHAR2;
    pragma FIPSFLAG('UNISTR', 1452);
  function CHR(n PLS_INTEGER) return varchar2;  -- N should be ASCII.CHRANGE
    pragma FIPSFLAG('CHR', 1452);
  function " SYS$STANDARD_CHR"(n PLS_INTEGER,csn VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET csn%CHARSET;
    pragma FIPSFLAG(' SYS$STANDARD_CHR', 1452);
  function INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('INITCAP', 1452);
  function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('SOUNDEX', 1452);

  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);
  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
  pragma FIPSFLAG('LPAD', 1452);

  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);
  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                     SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
                     DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('TRANSLATE', 1452);

  function REPLACE(SRCSTR VARCHAR2 CHARACTER SET ANY_CS,
                   OLDSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET := NULL)
        return VARCHAR2 CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);
  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);
  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'IS NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20);  -- PEMS_CHAR, PEMDNUL
  function 'IS NOT NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50); -- PEMS_CHAR, PEMDNUL

  function NVL(s1 VARCHAR2 CHARACTER SET ANY_CS,
               s2 VARCHAR2 CHARACTER SET s1%CHARSET)
        return VARCHAR2 CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);


  function '='  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 1); -- PEMS_NUMBER, PEMDCMEQ
  function '!=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 2); -- PEMS_NUMBER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 3); -- PEMS_NUMBER, PEMDCMLT
  function '<=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 4); -- PEMS_NUMBER, PEMDCMLE
  function '>'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 5); -- PEMS_NUMBER, PEMDCMGT
  function '>=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 6); -- PEMS_NUMBER, PEMDCMGE

  function 'IS NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_NUMBER, PEMDNUL

  function NVL(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 7); -- PEMS_NUMBER, NUM_NEG
  function ABS(n NUMBER) return NUMBER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 2, 8); -- PEMS_NUMBER, NUM_ADD
  function '-' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 9); -- PEMS_NUMBER, NUM_SUB
  function '*' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('*',17, 2, 10); -- PEMS_NUMBER, NUM_MUL
  function '/' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('/',18, 2, 11); -- PEMS_NUMBER, NUM_DIV

  function 'REM' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(n NUMBER) return NUMBER;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(n NUMBER) return NUMBER;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(n NUMBER) return NUMBER;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(n NUMBER) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COS', 1452);
  function SIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SIN', 1452);
  function TAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TAN', 1452);
  function COSH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COSH', 1452);
  function SINH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SINH', 1452);
  function TANH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TANH', 1452);

  function EXP(N NUMBER) return NUMBER;
  function LN(N NUMBER) return NUMBER;

  function BITAND (LEFT pls_integer, RIGHT pls_integer)
        return pls_integer;
  function BITAND (LEFT integer, RIGHT integer)
        return integer;
  function LOG (LEFT NUMBER, RIGHT NUMBER) return NUMBER;

  function TRUNC (n NUMBER, places pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT NUMBER, RIGHT pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (n NUMBER, e NUMBER) return NUMBER;
    pragma FIPSFLAG('POWER', 1452);

  function '='  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('=',2, 12, 1); -- PEMS_DATE, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT DATE, RIGHT DATE) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 12, 2); -- PEMS_DATE, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<',4, 12, 3); -- PEMS_DATE, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<=',6, 12, 4); -- PEMS_DATE, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>',1, 12, 5);  -- PEMS_DATE, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>=',3, 12, 6);  -- PEMS_DATE, PEMDCMGE
    pragma FIPSFLAG('>=', 1450);

  function '+' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('+',14, 12, 7); -- PEMS_DATE, DATE_ADD1
    pragma FIPSFLAG('+', 1450);
  function '+' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('+',14, 12, 8); -- PEMS_DATE, DATE_ADD2
    pragma FIPSFLAG('+', 1450);
  function '-' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('-',15, 12, 9); -- PEMS_DATE, DATE_SUB1
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('-',15, 12, 10); -- PEMS_DATE, DATE_SUB2
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('-',15, 12, 11); -- PEMS_DATE, DATE_SUB3
    pragma FIPSFLAG('-', 1450);

  function LAST_DAY(RIGHT DATE) return DATE;
    pragma BUILTIN('LAST_DAY',38, 12, 12); -- PEMS_DATE, DATE_LAST_DAY
    pragma FIPSFLAG('LAST_DAY', 1450);
  function ADD_MONTHS(LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 13); -- PEMS_DATE, DATE_ADD_MONTHS1
    pragma FIPSFLAG('ADD_MONTHS', 1450);
  function ADD_MONTHS(LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 14); -- PEMS_DATE, DATE_ADD_MONTHS2
    pragma FIPSFLAG('ADD_MONTHS', 1450);

  function MONTHS_BETWEEN(LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('MONTHS_BETWEEN',42, 12, 15); -- PEMS_DATE, DATE_MONTHS_BET
    pragma FIPSFLAG('MONTHS_BETWEEN', 1450);
  function NEXT_DAY(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('NEXT_DAY',43, 12, 16); -- PEMS_DATE, DATE_NEXT_DAY
    pragma FIPSFLAG('NEXT_DAY', 1450);
  function ROUND(RIGHT DATE) return DATE;
    pragma BUILTIN('ROUND',24, 12, 17); -- PEMS_DATE, DATE_ROUND
    pragma FIPSFLAG('ROUND', 1450);
  function NEW_TIME(RIGHT DATE, MIDDLE VARCHAR2, LEFT VARCHAR2) return DATE;
    pragma FIPSFLAG('NEW_TIME', 1450);

  function 'IS NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 12, 0);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 12, 50);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);
  function NVL (d1 DATE, d2 DATE) return DATE;
    pragma FIPSFLAG('NVL', 1450);

  function TRUNC(LEFT DATE) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 20); -- PEMS_DATE, DATE_TRUNC1
    pragma FIPSFLAG('TRUNC', 1450);
  function TRUNC(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 21); -- PEMS_DATE, DATE_TRUNC2
    pragma FIPSFLAG('TRUNC', 1450);
  function ROUND(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('ROUND',24, 12, 22); -- PEMS_DATE, DATE_ROUND2
    pragma FIPSFLAG('ROUND', 1450);

  function TO_DATE    (RIGHT VARCHAR2 character set any_cs)  return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 10); -- PEMS_CHAR, CHR_CNV_DAT
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT VARCHAR2 character set any_cs,
       RIGHT VARCHAR2 character set LEFT%charset) return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 8); -- PEMS_CHAR, CHR_CNV_DATE
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT NUMBER, RIGHT VARCHAR2) return DATE;
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE(left varchar2 character set any_cs,
                   format varchar2 character set LEFT%charset,
                   parms varchar2 character set LEFT%charset) return date;

  function TO_CHAR (RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',14, 0, 2);

  function TO_CHAR (LEFT DATE, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  function TO_CHAR (LEFT NUMBER, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function TO_NUMBER (RIGHT NUMBER) RETURN NUMBER;
    pragma BUILTIN('TO_NUMBER',14, 0, 1); -- PEMS_QUICK

  function TO_NUMBER (RIGHT VARCHAR2 character set any_cs)    return NUMBER;
    pragma BUILTIN('TO_NUMBER',48, 1, 9); -- PEMS_CHAR, CHR_CNV_NUM

  function TO_NUMBER(left varchar2 character set any_cs,
        format varchar2 character set LEFT%charset)
    return number;
  function TO_NUMBER(left varchar2 character set any_cs,
                     format varchar2 character set LEFT%charset,
                     parms varchar2 character set LEFT%charset)
    return number;

  -- Define SQL predicates.  These don't gen code, so no body is needed.

  -- PRIOR is WEIRD - For now, it will be treated as a function call.
  -- Does the function only take a column name?  how about its use in
  -- a predicate?
  function 'PRIOR'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname NUMBER) return NUMBER;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname DATE) return DATE;
      pragma FIPSFLAG('PRIOR', 1450);

  -- Outer Join has same problem as PRIOR
  function '(+)'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
  function '(+)'(colname NUMBER) return NUMBER;
  function '(+)'(colname DATE) return DATE;
      pragma FIPSFLAG('(+)', 1450);

  function '=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ANY', 1450);
  function '=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ANY', 1450);
  function '!=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ANY', 1450);
  function '<ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ANY', 1450);
  function '<=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ANY', 1450);
  function '>ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ANY', 1450);
  function '>=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ALL', 1450);
  function '=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ALL', 1450);
  function '!=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ALL', 1450);
  function '<ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ALL', 1450);
  function '<=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ALL', 1450);
  function '>ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ALL', 1450);
  function '>=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=SOME', 1450);
  function '=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=SOME', 1450);
  function '!=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<SOME', 1450);
  function '<SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=SOME', 1450);
  function '<=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>SOME', 1450);
  function '>SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=SOME', 1450);
  function '>=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  -- SQL Transaction routines
  procedure SET_TRANSACTION_USE(vc VARCHAR2);
  procedure COMMIT;
  procedure COMMIT_CM(vc VARCHAR2);
  procedure ROLLBACK_NR;
  procedure ROLLBACK_SV(Save_Point CHAR);
  procedure SAVEPOINT(Save_Point CHAR);

  function SYSDATE return DATE;
    pragma FIPSFLAG('SYSDATE', 1452);

  function UID return PLS_INTEGER;
    pragma FIPSFLAG('UID', 1452);

  function USER return VARCHAR2;

  function USERENV (envstr VARCHAR2) return VARCHAR2;
    pragma FIPSFLAG('USERENV', 1452);

  -- ROWID: this dreadful identifier is supposed to represent a datatype
  -- outside of SQL and and a pseudo-column (function, to us) when inside
  -- a sql statement.  ADA data model doesn't allow for any
  -- function X return X;
  -- so we must special case this.  Yuk.  There's special-case code in ph2nre
  -- which maps "rowid" to "rowid " if we're inside a SQL stmt.
  function "ROWID " return ROWID;
    pragma builtin('ROWID ', 1, 209, 240);  -- this had better never be called.

  function NULLFN (str VARCHAR2) return RAW;
    pragma builtin('NULLFN', 1, 0, 1);

  function HEXTORAW (c VARCHAR2) return RAW;
     pragma builtin('HEXTORAW', 1, 23, 1);

  function RAWTOHEX (r RAW) return VARCHAR2;
     pragma builtin('RAWTOHEX', 1, 23, 2);

  function CHARTOROWID (str VARCHAR2) return ROWID;
    pragma builtin('CHARTOROWID', 1, 0, 1);

  function ROWIDTOCHAR (str ROWID) return VARCHAR2;
    pragma builtin('ROWIDTOCHAR', 1, 0, 1);


  -- Trusted*Oracle additions
  Function ROWLABEL return MLSLABEL;                     -- pseudo column

  Function TO_CHAR(label MLSLABEL, format VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',90, 4, 19); -- PEMS_DATE, MLS_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  Function TO_LABEL(label VARCHAR2, format VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 8); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  Function TO_LABEL(label VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 2); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  -- vararg routines - icds in stdbdy
  Function LEAST_UB    (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('LEAST_UB',90, 4, 3); -- PEMS_CHAR, CHR_CNV_MLS
  Function GREATEST_LB (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('GREATEST_LB',90, 4, 4); -- PEMS_CHAR, CHR_CNV_MLS

  Function '>=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '>'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '='  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '!=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  function 'IS NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20); -- same "cod" as IS NULL(varchar2)
  function 'IS NOT NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50);

  function NVL(label1 MLSLABEL, label2 MLSLABEL) return MLSLABEL;
    pragma FIPSFLAG('NVL', 1452);

  -- group functions
  Function LUB (label MLSLABEL) return MLSLABEL;
  Function GLB (label MLSLABEL) return MLSLABEL;

  -- end of Trusted*Oracle additions


  -- beginning of NLS routines

  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS, c2 VARCHAR2) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS,
                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);

  function LENGTHB(ch VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
    pragma FIPSFLAG('LENGTHB', 1452);
  function SUBSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);
  function INSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  function TO_SINGLE_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_SINGLE_BYTE', 1452);
  function TO_MULTI_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_MULTI_BYTE', 1452);

  -- Next two added for NLS 6/3/92 JEM.
  function TO_CHAR(left date, format varchar2, parms varchar2) return varchar2;
  function TO_CHAR(left number, format varchar2, parms varchar2)
    return varchar2;
  function NLS_CHARSET_NAME(csetid PLS_INTEGER) return VARCHAR2;
  function NLS_CHARSET_ID(csetname VARCHAR2) return PLS_INTEGER;
  function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
    return PLS_INTEGER;

  -- end of NLS routines

  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2)
           return VARCHAR2 character set src%charset;
  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2,
                   srccset VARCHAR2)
          return VARCHAR2 character set src%charset;

  function " SYS$STANDARD_TRANSLATE" (src VARCHAR2 CHARACTER SET ANY_CS,
                                      csn VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET csn%CHARSET;
     pragma FIPSFLAG(' SYS$STANDARD_TRANSLATE',1452);

  function VSIZE (e number ) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e DATE) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);


  -- dump( expr [,display_format[,start_pos[,length]]]) return VARCHAR2
  function DUMP(e varchar2 character set any_cs,
                df pls_integer := null,sp pls_integer := null,
                len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e number,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e date,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  --
  -- ACOS, ASIN, ATAN, ATAN2
  --   Inverse Trigonometric functions
  --   These functions return NULL if any of the inputs are NULL
  --
  function ACOS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x NUMBER, y NUMBER) return NUMBER;
  pragma FIPSFLAG('ATAN2', 1452);

  --#### This is the end of 7.3 Standard

  -- LOB IS NULL
  function 'IS NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);
  -- end LOB IS NULL

  --****************************************************************
  -- 20 mar 96 =G=> In the following, arguments "1, 1, 1" to pragma BUILTIN
  -- e.g.,                pragma builtin('whatever', 1, 1, 1)
  -- indicate that those three numeric arguments to pragma BUILTIN are unknown,
  -- because they are not yet implemented by the backend.

  function '='  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<ADT_1>", pat "<ADT_1>", res "<ADT_1>")
        return "<ADT_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<ADT_1>", B2 "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function VALUE (item "<ADT_WITH_OID>") return "<ADT_1>";
    pragma BUILTIN('VALUE', 1, 1, 1);
    pragma FIPSFLAG('VALUE', 1450);

  function REF (item "<ADT_WITH_OID>") return REF "<ADT_1>";
    pragma BUILTIN('REF', 1, 1, 1);
    pragma FIPSFLAG('REF', 1450);

  function DEREF (r REF "<ADT_1>") return "<ADT_1>";
    pragma BUILTIN('DEREF', 1, 1, 1);
    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF ADT

  function 'IS NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function 'IS DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS DANGLING', 1450);

  function 'IS NOT DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  function NVL (B1 REF "<ADT_1>", B2 REF "<ADT_1>") return REF "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 0, 3, 1);
    pragma FIPSFLAG('=', 1450);

  function '!=' (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 0, 3, 2);
    pragma FIPSFLAG('!=', 1450);

  --  function '='  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('=', 1, 1, 1);
  --    pragma FIPSFLAG('=', 1450);
  --
  --  function '!=' (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('!=', 1, 1, 1);
  --    pragma FIPSFLAG('!=', 1450);
  --
  --  function '=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --
  --  function DECODE (expr "<COLLECTION_1>", pat "<COLLECTION_1>",
  --                                        res "<COLLECTION_1>")
  --      return "<COLLECTION_1>";
  --    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<COLLECTION_1>", B2 "<COLLECTION_1>")
        return "<COLLECTION_1>";
    pragma FIPSFLAG('NVL', 1450);

  function 'IS NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
        return "<REF_CURSOR_1>";
    pragma FIPSFLAG('NVL', 1450);

  function EMPTY_CLOB return clob;
  function EMPTY_BLOB return blob;

  function BFILENAME(directory varchar2,filename varchar2) return BFILE;

  function "SYS$LOB_REPLICATION" (x in blob) return blob;
  function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
    return clob character set x%charset;

  --#### This is the end of 8.0 Standard

  --  + overloadings

  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;

  function '+'(LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_UNCONSTRAINED;

  function '+'(LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_TZ_UNCONSTRAINED;

  function '+'(LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
                return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
                return TIME_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
                return TIME_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return DSINTERVAL_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return YMINTERVAL_UNCONSTRAINED ;

  -- begin subtract
  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return YMINTERVAL_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT" (LEFT TIME_UNCONSTRAINED,
                                      RIGHT TIME_UNCONSTRAINED)
     return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_UNCONSTRAINED ;
  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED ;
  function  " SYS$DSINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date;
  function '-' (LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date;

  function '-' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
   return DSINTERVAL_UNCONSTRAINED ;

  -- end subtract

  -- other datetime operators

  function '*' (LEFT number, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT number, RIGHT DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;

  function '*' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;

  function '/' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '/' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;


  function current_date return date;
  function current_time return TIME_TZ_UNCONSTRAINED;
  function current_timestamp return TIMESTAMP_TZ_UNCONSTRAINED;

  function TO_TIME (RIGHT varchar2 character set any_cs) return
    time_unconstrained;
    pragma BUILTIN('TO_TIME', 0, 15, 1);
    function TO_TIMESTAMP (RIGHT varchar2 character set any_cs)
                           return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 3);
  function TO_TIME_TZ (RIGHT varchar2 character set any_cs)
    return  TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 5);
  function TO_TIMESTAMP_TZ (RIGHT varchar2 character set any_cs)
    return  TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 7);
  function TO_YMINTERVAL (RIGHT varchar2 character set any_cs)
    return  YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_YMINTERVAL', 0, 15, 9);
  function TO_DSINTERVAL (RIGHT varchar2 character set any_cs)
    return  DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_DSINTERVAL', 0, 15, 11);

  -- with nls args
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset,
                   parms varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset,
                        parms varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset,
                           parms varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset,
                      parms varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_DSINTERVAL(RIGHT varchar2 character set any_cs,
                         parms varchar2 character set RIGHT%charset)
    return DSINTERVAL_UNCONSTRAINED;

  function NUMTOYMINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return YMINTERVAL_UNCONSTRAINED;
  function NUMTODSINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return DSINTERVAL_UNCONSTRAINED;

  function '='  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('=',0, 11, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',0, 11, 2);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<',0, 11, 3);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<=',0, 11, 4);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>',0, 11, 5);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>=',0, 11, 6);
    pragma FIPSFLAG('>=', 1450);

  function 'IS NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 14, 0); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 14, 50); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function "UROWID " return UROWID;
    pragma builtin('UROWID ', 1, 209, 240);  -- this had better never be called.

  -- New built-in function SYS_GUID, returns globally unique id
  function SYS_GUID return RAW;

  -- New built-in function SYS_CONTEXT
  function SYS_CONTEXT (namespace varchar2, attribute varchar2)
    return varchar2;

  function TRIM(v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  --#### This is the end of 8.1.5 Standard

  -- SYS_CONTEXT now has an additional optional parameter
  function SYS_CONTEXT(namespace varchar2, attribute varchar2,
                       newoptional varchar2)
    return varchar2;

  -- CUBE and ROLLUP are not real functions; they are variants on the GROUP
  -- BY clause (GROUP BY CUBE (...) and GROUP BY ROLLUP (...)). They have
  -- been added here as functions to avoid name capture issues.
  --
  -- Note that both CUBE and ROLLUP look like true vararg functions with
  -- *no* repeating pattern of formals - hence they are special cased in
  -- the overloading code.
  function CUBE return NUMBER;
  function ROLLUP return NUMBER;

  -- The GROUPING function must be used in conjunction with CUBE and ROLLUP
  -- in the GROUP BY clause. The type of the parameter to GROUPING can be
  -- any type that can appear in a GROUP BY list.
  function GROUPING(v VARCHAR2) return NUMBER;
  function GROUPING(a "<ADT_1>") return NUMBER;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 VARCHAR2 CHARACTER SET ANY_CS ,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   VARCHAR2 CHARACTER SET ANY_CS ,
                                 TSET   VARCHAR2 CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  --#### This is the end of the supported parts of 8.1.6 Standard

  --## Support for ANSI datetime data types is under development.
  --## The following operations, as well as the related types and
  --## operations defined above in the 8.1.5 section, are not yet
  --## available for use and are still subject to change.

  --- datetime equivalence
  function '='  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function TO_TIME (RIGHT TIME_TZ_UNCONSTRAINED)  return TIME_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME', 0, 15, 13);
  function TO_TIME_TZ (RIGHT TIME_UNCONSTRAINED)  return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 14);
  function TO_TIMESTAMP (RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 15);
  function TO_TIMESTAMP_TZ (RIGHT TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 16);

  function '-'
      (LEFT TIME_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  -- timezone functions
  function SYS_AT_TIME_ZONE(t time_tz_unconstrained,
                            i varchar2) RETURN time_tz_unconstrained;
  function SYS_AT_TIME_ZONE(t timestamp_tz_unconstrained,
                            i varchar2) RETURN timestamp_tz_unconstrained;
  FUNCTION systimestamp RETURN timestamp_tz_unconstrained;
  FUNCTION dbtimezone RETURN varchar2;
  FUNCTION sessiontimezone RETURN varchar2;
  FUNCTION localtimestamp RETURN timestamp_unconstrained;
  FUNCTION localtime RETURN time_unconstrained;

  function TO_TIMESTAMP (RIGHT DATE)  return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 17);

  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT yminterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '+'(LEFT dsinterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return yminterval_unconstrained;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;

  function '='  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;

  function SYS_LITERALTOYMINTERVAL(numerator varchar2, units varchar2)
    return YMINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTODSINTERVAL(numerator varchar2, units varchar2)
    return DSINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTOTIME(numerator varchar2)
    return TIME_UNCONSTRAINED;
  function SYS_LITERALTOTZTIME(numerator varchar2)
    return TIME_TZ_UNCONSTRAINED;
  function SYS_LITERALTOTIMESTAMP(numerator varchar2)
    return TIMESTAMP_UNCONSTRAINED;
  function SYS_LITERALTOTZTIMESTAMP(numerator varchar2)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function SYS_LITERALTODATE(numerator varchar2) return DATE;


  -- Explicit conversions between date and datetime
  function TO_TIMESTAMP(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 24);

  function TO_TIMESTAMP_TZ(ARG DATE) return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 27);

  function TO_TIMESTAMP_TZ(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 26);

  -- IS [NOT] NULL / NVL for datetime
  function 'IS NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_UNCONSTRAINED,
                b2 TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;

  function 'IS NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_TZ_UNCONSTRAINED, b2 TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_UNCONSTRAINED,
                b2 TIMESTAMP_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_TZ_UNCONSTRAINED, b2 TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_LTZ_UNCONSTRAINED,
                b2 TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;

  function 'IS NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 YMINTERVAL_UNCONSTRAINED, b2 YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;

  function 'IS NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 DSINTERVAL_UNCONSTRAINED, b2 DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  function " SYS$EXTRACT_FROM"
              (T TIME_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T DATE,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I YMINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I DSINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;

  -- ##########      8.2 LOB Built-in Functions       ######## --

  -- LENGTH --
  function LENGTH(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  function LENGTH(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  -- SUBSTR --
  function SUBSTR(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  function SUBSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);

  -- INSTR --
  function INSTR(STR1 CLOB CHARACTER SET ANY_CS,
                 STR2 CLOB CHARACTER SET STR1%CHARSET,
                 POS INTEGER := 1,
                 NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function INSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  STR2 CLOB CHARACTER SET STR1%CHARSET,
                  POS INTEGER := 1,
                  NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  -- CONCAT --
  function '||' (LEFT CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT CLOB CHARACTER SET ANY_CS,
                  RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG(CONCAT, 1454);

  -- UPPER --
  function UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);

  -- LOWER --
  function LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);

  -- LPAD --
  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  -- RPAD --
  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  -- LTRIM --
  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  -- RTRIM --
  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  -- TRIM --
  function TRIM(v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 CLOB CHARACTER SET ANY_CS ,
                               TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   CLOB CHARACTER SET ANY_CS ,
                                 TSET   CLOB CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;


  -- LIKE --
  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  -- NVL --
  function NVL(s1 CLOB CHARACTER SET ANY_CS,
               s2 CLOB CHARACTER SET s1%CHARSET)
    return CLOB CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);

  -- REPLACE --
  function REPLACE(SRCSTR CLOB CHARACTER SET ANY_CS,
                   OLDSUB CLOB CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB CLOB CHARACTER SET SRCSTR%CHARSET := NULL)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  -- LOB RELATIONAL OPERATORS --

  Function '='  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;

  /* LOB-related conversion functions */
  function TO_CLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS) return CLOB;
    pragma BUILTIN('TO_CLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  function TO_BLOB(RIGHT RAW) return BLOB;
    pragma BUILTIN('TO_BLOB', 0, 15, 30); -- OPC_CVT_RAW2BLB
  function TO_RAW(RIGHT BLOB) return RAW;
    pragma BUILTIN('TO_RAW', 0, 15, 32); -- OPC_CVT_BLB2RAW

  -- ####### end of 8.2 LOB Built-in Functions  ######## --

  function NULLIF(v1 VARCHAR2, v2 VARCHAR2) return VARCHAR2;
  function NULLIF(v1 BOOLEAN, v2 BOOLEAN) return VARCHAR2;
  function NULLIF(a1 "<ADT_1>", a2 "<ADT_1>") return VARCHAR2;

  function COALESCE return VARCHAR2;

  /* Daylight Saving Time Functions */
  FUNCTION tz_offset(region VARCHAR2)  RETURN VARCHAR2;
  FUNCTION from_tz(t TIMESTAMP_UNCONSTRAINED,timezone VARCHAR2)
    RETURN timestamp_tz_unconstrained;

  function " SYS$EXTRACT_STRING_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;

  function INSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR2', 1452);

  function INSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR4', 1452);

  function INSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRC', 1452);

  function LENGTH2(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH2', 1452);

  function LENGTH4(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH4', 1452);

  function LENGTHC(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTHC', 1452);

  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function SUBSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR2', 1452);

  function SUBSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR4', 1452);

  function SUBSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRC', 1452);

  /**** char <--> nchar conversion functions in Unicode project ********/

  function TO_NCHAR(RIGHT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',14, 0, 2);

  function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB;
  function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB;

  function TO_NCLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return NCLOB;
    pragma BUILTIN('TO_NCLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  /* convert to either CLOB or NCLOB respectively if parm is char or nchar */
  function TO_ANYLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET RIGHT%CHARSET;
    pragma BUILTIN('TO_ANYLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB

  /* Followings are the same builtin op codes as without N prefix functions,
   * implementation relys on impilcit conversion MCODEs
   */
  function TO_NCHAR (LEFT DATE, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_NCHAR', 1450);
  function TO_NCHAR (LEFT NUMBER, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function NHEXTORAW (c NVARCHAR2) return RAW;
    pragma builtin('NHEXTORAW', 1, 23, 1);
  function RAWTONHEX (r RAW) return NVARCHAR2;
    pragma builtin('RAWTONHEX', 1, 23, 2);
  function NCHARTOROWID (str NVARCHAR2) return ROWID;
    pragma builtin('NCHARTOROWID', 1, 0, 1);
  function ROWIDTONCHAR (str ROWID) return NVARCHAR2;
    pragma builtin('ROWIDTONCHAR', 1, 0, 1);

  function NCHR(n pls_integer) return NVARCHAR2;

  /* implemented by icd calls as the same as TO_CHAR */
  function TO_NCHAR(left date, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left number, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  /* implemented as a icd call, return TRUE if nchar, otherwise FALSE */
  function ISNCHAR(c VARCHAR2 character set any_cs) return boolean;

  /************ end of char <--> nchar conversion functions ************/

  /* Create overloads for all standard functions that work with <ADT_1> for
     <OPAQUE_1> */
  function '='  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<OPAQUE_1>", pat "<OPAQUE_1>", res "<OPAQUE_1>")
    return "<OPAQUE_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<OPAQUE_1>", B2 "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('NVL', 1450);

  --  REFs to opaques are not supported yet.
  --  function VALUE (item "<ADT_WITH_OID>") return "<OPAQUE_1>";
  --    pragma BUILTIN('VALUE', 1, 1, 1);
  --    pragma FIPSFLAG('VALUE', 1450);

  --  function REF (item "<ADT_WITH_OID>") return REF "<OPAQUE_1>";
  --    pragma BUILTIN('REF', 1, 1, 1);
  --    pragma FIPSFLAG('REF', 1450);

  --  function DEREF (r REF "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('DEREF', 1, 1, 1);
  --    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF OPAQUE

  --  function 'IS NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NULL', 0, 3, 0);
  --    pragma FIPSFLAG('IS NULL', 1450);

  --  function 'IS NOT NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma FIPSFLAG('IS NOT NULL', 1450);

  --  function 'IS DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS DANGLING', 1450);

  --  function 'IS NOT DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
  --    return REF "<OPAQUE_1>";
  --    pragma FIPSFLAG('NVL', 1450);

  --  function '='  (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('=', 0, 3, 1);
  --    pragma FIPSFLAG('=', 1450);

  --  function '!=' (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('!=', 0, 3, 2);
  --    pragma FIPSFLAG('!=', 1450);

  function GROUPING(a "<OPAQUE_1>") return NUMBER;
  function NULLIF(a1 "<OPAQUE_1>", a2 "<OPAQUE_1>") return VARCHAR2;

  function GREATEST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIME_TZ_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj

  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;

  -- CONVERT FOR LOB --
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2,
                   SRCCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;

  -- NLS_UPPER/NLS_LOWER FOR LOB --
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);

  function COMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS)
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('COMPOSE', 1452);
  function DECOMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS,
                     canmode in VARCHAR2 DEFAULT 'CANONICAL')
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('DECOMPOSE', 1452);
  FUNCTION SYS_EXTRACT_UTC(t timestamp_tz_unconstrained)
    return TIMESTAMP_UNCONSTRAINED;

  -- Begin REGEXP Support (10iR1) --

  -- REGEXP_LIKE --
  function REGEXP_LIKE (srcstr   VARCHAR2 CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  function REGEXP_LIKE (srcstr   CLOB CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  -- REGEXP_INSTR --
  function REGEXP_INSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        occurrence  PLS_INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);

  function REGEXP_INSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        occurrence  INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);


  -- REGEXP_SUBSTR --
  function REGEXP_SUBSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    PLS_INTEGER := 1,
                         occurrence  PLS_INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  function REGEXP_SUBSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    INTEGER := 1,
                         occurrence  INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  -- REGEXP_REPLACE --
  function REGEXP_REPLACE(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    PLS_INTEGER := 1,
                          occurrence  PLS_INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  CLOB CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  -- End REGEXP Support --

  -- binary_float and binary_double functions and operators.
  function TO_BINARY_FLOAT (RIGHT BINARY_FLOAT) RETURN BINARY_FLOAT;
    pragma BUILTIN('TO_BINARY_FLOAT',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;

  function TO_BINARY_DOUBLE (RIGHT BINARY_DOUBLE) RETURN BINARY_DOUBLE;
    pragma BUILTIN('TO_BINARY_DOUBLE',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;

  function 'IS NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;

  function TO_CHAR (left binary_float, format varchar2)
    return VARCHAR2;
  function TO_CHAR (left binary_double, format varchar2)
    return VARCHAR2;

  function TO_CHAR(left binary_float, format varchar2, parms varchar2)
    return varchar2;
  function TO_CHAR(left binary_double, format varchar2, parms varchar2)
    return varchar2;

  function TO_NCHAR(left binary_float, format nvarchar2) return NVARCHAR2;
  function TO_NCHAR(left binary_double, format nvarchar2) return NVARCHAR2;

  function TO_NCHAR(left binary_float, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left binary_double, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  function 'REMAINDER'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG(REMAINDER, 1452);

  function '='  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 15);
  function '!=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('!=',5, 2, 16);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 17);
  function '<=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 18);
  function '>'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 19);
  function '>=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 20);

  function 'IS NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 23);
  function ABS(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 2, 24);
  function '-' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 25);
  function '*' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('*',17, 2, 26);
  function '/' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('/',18, 2, 27);

  function 'REM' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(F1 BINARY_FLOAT, F2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('MOD', 1452);

  function FLOOR(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('CEIL', 1452);
  function SIGN(f BINARY_FLOAT) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);
  function SQRT(f BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('SQRT', 1452);

  function TRUNC (F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ROUND', 1452);

  function '='  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 28);
  function '!=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 29);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 30);
  function '<=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 31);
  function '>'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 32);
  function '>=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 33);

  function 'IS NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 36);
  function ABS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ABS', 1452);

  function ACOS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x BINARY_DOUBLE, y BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN2', 1452);

  function '+' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 2, 37);
  function '-' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 38);
  function '*' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('*',17, 2, 39);
  function '/' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('/',18, 2, 40);

  function 'REM' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(D1 BINARY_DOUBLE, D2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(d BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(d BINARY_DOUBLE) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function COSH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SINH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TANH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function EXP(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function LN(D BINARY_DOUBLE) return BINARY_DOUBLE;

  function LOG (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;

  function TRUNC (D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (d BINARY_DOUBLE, e BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('POWER', 1452);

  function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER;
  function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
  function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;

  function GREATEST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function GREATEST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2


  function '+' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',15, 2, 41);
  function ABS(I PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 2, 42);
  function '-' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',14, 2, 43);
  function '*' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('*',14, 2, 44);

  function '='  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 45); -- PEMS_PLS_INTEGER, PEMDCMEQ
  function '!=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 46); -- PEMS_PLS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 47); -- PEMS_PLS_INTEGER, PEMDCMLT
  function '<=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 48); -- PEMS_PLS_INTEGER, PEMDCMLE
  function '>'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 49); -- PEMS_PLS_INTEGER, PEMDCMGT
  function '>=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 51); -- PEMS_PLS_INTEGER, PEMDCMGE

  function 'IS NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_PLS_INTEGER, PEMDNUL
  function 'IS NOT NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_PLS_INTEGER, PEMDNUL

  function NVL(I1 PLS_INTEGER, I2 PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('NVL', 1452);

  function TRUNC (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('ROUND', 1452);

  function SIGN(i PLS_INTEGER) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);

  function GREATEST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2

  -- MultiSet Functions and Operators.

  -- Equality
  function '='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('=',2, 16, 1);

  function '!='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('!=',2, 16, 2);

  function CARDINALITY (collection IN "<TABLE_1>") return PLS_INTEGER;

  function SET (collection IN "<TABLE_1>") return "<TABLE_1>";
    pragma BUILTIN('SET',18, 2, 40);-- Dummy

  function 'IS A SET' (collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS A SET',18, 2, 40);-- Dummy
  function 'IS NOT A SET'(collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT A SET',18, 2, 40);-- Dummy

  function 'IS EMPTY' (collection IN  "<TABLE_1>") return BOOLEAN;
  function 'IS NOT EMPTY'(collection IN  "<TABLE_1>") return BOOLEAN;

  -- IS A SUBMULTISET OF
  function 'SUBMULTISET' (collection IN  "<TABLE_1>",
                          collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('SUBMULTISET',18, 2, 40);

  function 'MULTISET_UNION_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
      pragma BUILTIN('MULTISET_UNION_ALL',18, 2, 40);

  function 'MULTISET_UNION_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_UNION_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_DISTINCT',18, 2, 40);-- Dummy

  -- These are dummy procedures for correct management of new control
  -- statements added to PL/SQL. They ensure local procedures which have the
  -- same names as newly introduced keywords are not masked by those keywords.

  procedure continue;

  -- REGEXP_COUNT --
  function REGEXP_COUNT(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  function REGEXP_COUNT(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  --#### All user-visible declarations should preceed this point.  The
  --#### following are implementation-oriented pragmas that may need
  --#### editing in the future; we would prefer to be able to edit them
  --#### without affecting the rft numbering of user-visible items.

  --#### interface pragmas

  --#### Note that for any ICD which maps directly to a PVM
  --#### Opcode MUST be mapped to pes_dummy.
  --#### An ICD which invokes another ICD by flipping operands is
  --#### mapped to pes_flip, and an ICD whose result is the inverse of
  --#### another ICD is mapped to pes_invert
  --#### New ICDs should be placed at the end of this list, and a
  --#### corresponding entry must be made in the ICD table in pdz7

  PRAGMA interface(c,length,"pes_dummy",1);
  PRAGMA interface(c,substr,"pes_dummy",1);
  PRAGMA interface(c,instr,"pesist",1);
  PRAGMA interface(c,UPPER,"pesupp",1);
  PRAGMA interface(c,LOWER,"peslow",1);
  PRAGMA interface(c,ASCII,"pesasc");
  PRAGMA interface(c,ASCIISTR,"pesastr");
  PRAGMA interface(c,UNISTR,"pesustr");
  PRAGMA interface(c,CHR,"peschr");
  PRAGMA interface(c," SYS$STANDARD_CHR","peschr");
  PRAGMA interface(c,INITCAP,"pesicp");
  PRAGMA interface(c,LPAD,"peslpd",1);
  PRAGMA interface(c,LPAD,"peslpd",2);
  PRAGMA interface(c,RPAD,"pesrpd",1);
  PRAGMA interface(c,RPAD,"pesrpd",2);
  PRAGMA interface(c,REPLACE,"pesrep",1);
  PRAGMA interface(c,LTRIM,"pesltr",1);
  PRAGMA interface(c,LTRIM,"pesltr",2);
  PRAGMA interface(c,RTRIM,"pesrtr",1);
  PRAGMA interface(c,RTRIM,"pesrtr",2);
  PRAGMA interface(c,'LIKE',"peslik",1);
  PRAGMA interface(c,'LIKE',"pesli2",2);
  PRAGMA interface(c,ABS,"pes_dummy",1);
  PRAGMA interface(c,'MOD',"pesmod", 1);
  PRAGMA interface(c,floor,"pesflo", 1);
  PRAGMA interface(c,CEIL,"pescei", 1);
  PRAGMA interface (c, SQRT, "pessqt", 1);
  PRAGMA interface(c,SIGN,"pessgn", 1);
  PRAGMA interface(c,cos,"pescos", 1);
  PRAGMA interface(c,sin,"pessin",1);
  PRAGMA interface(c,TAN,"pestan",1);
  PRAGMA interface(c,COSH,"pescsh",1);
  PRAGMA interface(c,SINH,"pessnh",1);
  PRAGMA interface(c,TANH,"pestnh",1);
  PRAGMA interface(c,EXP,"pesexp",1);
  PRAGMA interface(c,LN,"pesln",1);
  PRAGMA interface(c,BITAND,"pesbtd",1);
  PRAGMA interface(c,BITAND,"pesbtdn",2);
  PRAGMA interface(c,LOG,"peslog",1);
  PRAGMA interface(c,TRUNC,"pestru",1);
  PRAGMA interface(c,ROUND,"pesrnd",1);
  PRAGMA interface(c,POWER,"pespow",1);
  PRAGMA interface(c,NEW_TIME,"pesnwt");
  PRAGMA interface(c,TO_DATE,"pesc2d",4);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",3);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",4);
  PRAGMA interface(c,'>=',"pes_flip",5);
  PRAGMA interface(c,'>',"pes_flip",5);
  PRAGMA interface(c,'<=',"peszle",5);
  PRAGMA interface(c,'<',"peszlt",5);        -- ICD #50
  PRAGMA interface(c,'=',"peszeq",5);
  PRAGMA interface(c,'!=',"pes_invert",5);
  PRAGMA interface(c,nlssort,"pesxco",2);
  PRAGMA interface(c,NLS_UPPER,"pesxup",1);
  PRAGMA interface(c,NLS_UPPER,"peslcnup",3); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_UPPER,"peslcnup",4); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_LOWER,"pesxlo",1);
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",3); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",4); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_INITCAP,"pesxcp",1);
  PRAGMA interface(c,lengthb,"pes_dummy",1);
  PRAGMA interface(c,substrb,"pes_dummy",1);
  PRAGMA interface(c,instrb,"pesxis",1);
  PRAGMA interface(c,TO_SINGLE_BYTE, "pesxsi");
  PRAGMA interface(c,TO_MULTI_BYTE,"pesxmu");
  PRAGMA interface(c,TO_CHAR,"pesd2c",5);
  PRAGMA interface(c,TO_CHAR,"pesn2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesd2c",4);
  PRAGMA interface(c,TO_NCHAR,"pesn2c",5);
  PRAGMA interface(c," SYS$STANDARD_TRANSLATE","pesxcs");
  PRAGMA interface(c,ATAN,"pesatan",1);
  PRAGMA interface(c,EMPTY_CLOB,"peslcem");
  PRAGMA interface(c,EMPTY_BLOB,"peslbem");
  PRAGMA interface(c,BFILENAME,"pesfnm");
  PRAGMA interface(c,TO_TIME,"pes3tm",2);
  PRAGMA interface(c,TO_TIME,"pes3tm",3);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",2);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",3);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",2);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",3);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",2);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",3);
  PRAGMA interface(c,TO_DSINTERVAL,"pes2dsi",2);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",1);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",2);
  PRAGMA interface(c,SESSIONTIMEZONE,"pesstz",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",2);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",3);
  PRAGMA interface(c,TRIM,"pestrim",1);
  -- Datetime addition
  PRAGMA interface(c,'+',"pesati",5);    --  +(tsp, iym) return tsp
  PRAGMA interface(c,'+',"pesati",6);    --  +(tsp, ids) return tsp
  PRAGMA interface(c,'+',"pesati",7);    --  +(tsz, iym) return tsz
  PRAGMA interface(c,'+',"pesati",8);    --  +(tsz, ids) return tsz
  PRAGMA interface(c,'+',"pesati",9);    --  +(tim, ids) return tim
  PRAGMA interface(c,'+',"pesati",10);   --  +(tmz, ids) return tmz
  PRAGMA interface(c,'+',"pesadi",11);   --  +(dat, iym) return dat
  PRAGMA interface(c,'+',"pesadi",12);   --  +(dat, ids) return dat
  PRAGMA interface(c,'+',"pes_flip",13); --  +(iym, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",14); --  +(iym, tsz) return tsz -- ICD #100
  PRAGMA interface(c,'+',"pes_flip",15); --  +(iym, dat) return dat
  PRAGMA interface(c,'+',"pes_flip",16); --  +(ids, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",17); --  +(ids, tsz) return tsz
  PRAGMA interface(c,'+',"pes_flip",18); --  +(ids, tim) return tim
  PRAGMA interface(c,'+',"pes_flip",19); --  +(ids, tmz) return tmz
  PRAGMA interface(c,'+',"pes_flip",20); --  +(ids, dat) return dat
  PRAGMA interface(c,'+',"pesaii",21);   --  +(ids, ids) return ids
  PRAGMA interface(c,'+',"pesaii",22);   --  +(iym, iym) return iym
  PRAGMA interface(c,'+',"pesati",23);   --  +(ltz, iym) return ltz
  PRAGMA interface(c,'+',"pesati",24);   --  +(ltz, ids) return ltz
  PRAGMA interface(c,'+',"pes_flip",25);--  +(iym, ltz) return ltz
  PRAGMA interface(c,'+',"pes_flip",26);--  +(ids, ltz) return ltz
  -- Datetime subtraction
  PRAGMA interface(c,'-',"pessti",6);    --  -(tsp, iym) return tsp
  PRAGMA interface(c,'-',"pessti",7);    --  -(tsp, ids) return tsp
  PRAGMA interface(c,'-',"pessti",8);    --  -(tsz, iym) return tsz
  PRAGMA interface(c,'-',"pessti",9);    --  -(tsz, ids) return tsz
  PRAGMA interface(c,'-',"pessti",10);   --  -(tim, ids) return tim
  PRAGMA interface(c,'-',"pessti",11);   --  -(tmz, ids) return tmz
  PRAGMA interface(c,'-',"pessdi",12);   --  -(dat, iym) return dat
  PRAGMA interface(c,'-',"pessdi",13);   --  -(dat, ids) return dat
  PRAGMA interface(c,'-',"pessii",14);   --  -(iym, iym) return iym
  PRAGMA interface(c,'-',"pessii",15);   --  -(ids, ids) return ids
  PRAGMA interface(c,'-',"pessttds",16); --  -(tim, tim) return ids
  PRAGMA interface(c,'-',"pessttds",17); --  -(tsp, tsp) return ids
  PRAGMA interface(c,'-',"pessttds",18); --  -(tmz, tmz) return ids
  PRAGMA interface(c,'-',"pessttds",19); --  -(tsz, tsz) return ids
  PRAGMA interface(c,'-',"pessti",20);   --  -(ltz, iym) return iym
  PRAGMA interface(c,'-',"pessti",21);   --  -(ltz, ids) return ids
  PRAGMA interface(c,'-',"pessttds",22); --  -(ltz, ltz) return ids
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",1);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",2);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",3);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",4);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessddds",5);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",6);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",1);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",2);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessddym",3);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",4);
  -- Datetime multiplication
  PRAGMA interface(c,'*',"pesmni",2);    --  *(num, iym) return iym
  PRAGMA interface(c,'*',"pesmni",3);    --  *(num, ids) return ids
  PRAGMA interface(c,'*',"pes_flip",4);  --  *(iym, num) return iym
  PRAGMA interface(c,'*',"pes_flip",5);  --  *(ids, num) return ids
  -- Datetime division
  PRAGMA interface(c,'/',"pesdvin",2);   --  /(iym, num) return iym
  PRAGMA interface(c,'/',"pesdvin",3);   --  /(ids, num) return ids
  -- TIME
  PRAGMA interface(c,'=',"pes_dummy",9);
  PRAGMA interface(c,'!=',"pes_invert",9);
  PRAGMA interface(c,'>',"pes_flip",8);
  PRAGMA interface(c,'<',"pes_dummy",8);
  PRAGMA interface(c,'>=',"pes_flip",8);   -- ICD #150
  PRAGMA interface(c,'<=',"pes_dummy",8);
  -- TIME WITH TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",10);
  PRAGMA interface(c,'!=',"pes_invert",10);
  PRAGMA interface(c,'>',"pes_flip",9);
  PRAGMA interface(c,'<',"pes_dummy",9);
  PRAGMA interface(c,'>=',"pes_flip",9);
  PRAGMA interface(c,'<=',"pes_dummy",9);
  -- TIMESTAMP
  PRAGMA interface(c,'=',"pes_dummy",11);
  PRAGMA interface(c,'!=',"pes_invert",11);
  PRAGMA interface(c,'>',"pes_flip",10);
  PRAGMA interface(c,'<',"pes_dummy",10);
  PRAGMA interface(c,'>=',"pes_flip",10);
  PRAGMA interface(c,'<=',"pes_dummy",10);
  -- INTERVAL YEAR TO MONTH
  PRAGMA interface(c,'=',"pes_dummy",12);
  PRAGMA interface(c,'!=',"pes_invert",12);
  PRAGMA interface(c,'>',"pes_flip",11);
  PRAGMA interface(c,'<',"pes_dummy",11);
  PRAGMA interface(c,'>=',"pes_flip",11);
  PRAGMA interface(c,'<=',"pes_dummy",11);
  -- INTERVAL DAY TO SECOND
  PRAGMA interface(c,'=',"pes_dummy",13);
  PRAGMA interface(c,'!=',"pes_invert",13);
  PRAGMA interface(c,'>',"pes_flip",12);
  PRAGMA interface(c,'<',"pes_dummy",12);
  PRAGMA interface(c,'>=',"pes_flip",12);
  PRAGMA interface(c,'<=',"pes_dummy",12);
  -- TIMESTAMP_TZ_UNCONSTRAINED
  PRAGMA interface(c,'=',"pes_dummy",14);
  PRAGMA interface(c,'!=',"pes_invert",14);
  PRAGMA interface(c,'>',"pes_flip",13);
  PRAGMA interface(c,'<',"pes_dummy",13);
  PRAGMA interface(c,'>=',"pes_flip",13);
  PRAGMA interface(c,'<=',"pes_dummy",13);
  -- TIMESTAMP WITH LOCAL TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",15);
  PRAGMA interface(c,'!=',"pes_invert",15);
  PRAGMA interface(c,'>',"pes_flip",14);
  PRAGMA interface(c,'<',"pes_dummy",14);
  PRAGMA interface(c,'>=',"pes_flip",14);
  PRAGMA interface(c,'<=',"pes_dummy",14);
  -- Other datetime functions
  PRAGMA interface(c,'CURRENT_DATE',"pescdt",1);
  PRAGMA interface(c,'CURRENT_TIME',"pesctm",1);
  PRAGMA interface(c,'CURRENT_TIMESTAMP',"pescts",1);
  --  Internal calls to evaluate datetime/interval literals without NLS parms.
  PRAGMA interface(c,SYS_LITERALTOYMINTERVAL,"pesc2ymi",1);
  PRAGMA interface(c,SYS_LITERALTODSINTERVAL,"pesc2dsi",1);
  PRAGMA interface(c,SYS_LITERALTOTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTODATE,"pesc2date",1);
  -- extract(field from expr)
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",1);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",2);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",3);   -- ICD #200
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",4);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",5);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefdt",6);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",7);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",8);
  -- datetime is null
  PRAGMA interface(c,"IS NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NULL","pes_dummy",20); -- interval ds

  -- 8.2 LOB Built-in Functions
  PRAGMA interface(c,length, "peslcln",2);    -- LOB LENGTH
  PRAGMA interface(c,lengthb,"peslclb",2);    -- LOB LENGTHB
  PRAGMA interface(c,substr, "peslcst",2);    -- LOB SUBSTR
  PRAGMA interface(c,substrb,"peslcsb",2);    -- LOB SUBSTRB
  PRAGMA interface(c,instr,  "peslcin",2);    -- LOB INSTR
  PRAGMA interface(c,instrb, "peslcib",2);    -- LOB INSTRB
  PRAGMA interface(c,'||',   "peslcct",2);    -- LOB '||'
  PRAGMA interface(c,concat, "peslcct",2);    -- LOB CONCAT
  PRAGMA interface(c,lpad,   "peslclp",3);    -- LOB LPAD
  PRAGMA interface(c,lpad,   "peslclp",4);    -- LOB LPAD
  PRAGMA interface(c,rpad,   "peslcrp",3);    -- LOB RPAD
  PRAGMA interface(c,rpad,   "peslcrp",4);    -- LOB RPAD
  PRAGMA interface(c,lower,  "peslclr",2);    -- LOB LOWER
  PRAGMA interface(c,upper,  "peslcup",2);    -- LOB UPPER
  PRAGMA interface(c,ltrim,  "peslclm",3);    -- LOB LTRIM
  PRAGMA interface(c,ltrim,  "peslclm",4);    -- LOB LTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",3);    -- LOB RTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",4);    -- LOB RTRIM
  PRAGMA interface(c,trim,   "peslctr",2);    -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",4); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",5); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",6); -- LOB TRIM
  PRAGMA interface(c,'LIKE', "peslclk",3);    -- LOB LIKE
  PRAGMA interface(c,'LIKE', "peslcl2",4);    -- LOB LIKE
  PRAGMA interface(c,nvl,"peslcnl",17);       -- LOB NVL
  PRAGMA interface(c,replace, "peslcrl",2);   -- LOB REPLACE

     -- LOB Relational Operators
     -- LHS: CLOB,    RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_dummy",16);     -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",16);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",15);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pes_dummy",15);     -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",15);      -- LOB '>='
  PRAGMA interface(c,'<=',"pes_dummy",15);       -- LOB '<='
     -- LHS: CLOB,     RHS:VARCHAR2
  PRAGMA interface(c,'=' ,"pesleq2",17);       -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",17);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",16);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt2",16);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",16);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle2",16);       -- LOB '<='  -- ICD #250
     -- LHS: VARCHAR2, RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_flip",18);      -- LOB '='
  PRAGMA interface(c,'!=',"pes_flip",18);      -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",17);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt3",17);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",17);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle3",17);       -- LOB '<='

  PRAGMA interface(c,length, "peslbln",3);    -- BLOB LENGTH
  PRAGMA interface(c,lengthb,"peslblb",3);    -- BLOB LENGTHB
  -- End of 8.2 LOB Built-in Functions


  PRAGMA interface(c,tz_offset,"pestzo",1);
  PRAGMA interface(c,from_tz,"pesftz",1);

  PRAGMA interface(c,ISNCHAR,"pesinc", 1);

  PRAGMA interface(c,CONVERT,"pescnv", 1);
  PRAGMA interface(c,CONVERT,"pescnv", 2);
  PRAGMA interface(c,CONVERT,"peslccnv", 3);  -- LOB CONVERT
  PRAGMA interface(c,CONVERT,"peslccnv", 4);  -- LOB CONVERT

  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",1);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",2);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",3);

  PRAGMA interface(c,TO_CHAR,"pesdtm2c",7); -- datetime
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",8);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",9);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",10);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",11);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",12);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",13);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",14);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",15);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",16);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",17); -- interval
  PRAGMA interface(c,TO_CHAR,"pesitv2c",18);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",19);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",20);

  --#### new_names pragmas

  -- This is an internal pragma that restricts the use
  -- of particular new entries in package standard.
  -- It is only valid in package standard.
  -- Note that left out of the 8.1.5 set are non datetime
  -- entries urowid, "UROWID ", self_is_null and trim.

  pragma new_names('8.1.5',
                   time,"TIME WITH TIME ZONE",
                   timestamp,"TIMESTAMP WITH TIME ZONE",
                   "INTERVAL DAY TO SECOND",
                   "INTERVAL YEAR TO MONTH",
                   to_time, to_timestamp,
                   to_time_tz, to_timestamp_tz,
                   " SYS$DSINTERVALSUBTRACT",
                   " SYS$YMINTERVALSUBTRACT",
                   to_yminterval,to_dsinterval,
                   NUMTOYMINTERVAL, NUMTODSINTERVAL,
                   current_date,
                   current_time,current_timestamp);

  pragma new_names('8.1.6',
                   dbtimezone, sessiontimezone, localtimestamp,
                   localtime,
                   cube, rollup, grouping, "TIMESTAMP WITH LOCAL TIME ZONE");

  -- Should there be a 8.2 new names pragma ?

  -- 8.2 UCS2/UCS4/Complete Built-in Functions

  PRAGMA interface(c,INSTR2,"pesist2",1);
  PRAGMA interface(c,INSTR4,"pesist4",1);
  PRAGMA interface(c,INSTRC,"pesistc",1);

  PRAGMA interface(c,LENGTH2,"peslen2",1);
  PRAGMA interface(c,LENGTH4,"peslen4",1);
  PRAGMA interface(c,LENGTHC,"peslenc",1);

  PRAGMA interface(c,LIKE2,"peslik2",1);
  PRAGMA interface(c,LIKE2,"pesli22",2);
  PRAGMA interface(c,LIKE4,"peslik4",1);
  PRAGMA interface(c,LIKE4,"pesli42",2);
  PRAGMA interface(c,LIKEC,"peslikc",1);
  PRAGMA interface(c,LIKEC,"peslic2",2);

  PRAGMA interface(c,SUBSTR2,"pes_dummy",1);
  PRAGMA interface(c,SUBSTR4,"pes_dummy",1);
  PRAGMA interface(c,SUBSTRC,"pes_dummy",1);
  PRAGMA interface(c,SYS_EXTRACT_UTC,"pessexu");
  PRAGMA interface(c,COMPOSE,"pescomp");
  PRAGMA interface(c,DECOMPOSE,"pesdcmp");



  -- End of 8.2 UCS2/UCS4/Complete Built-in Functions

  -- Begin REGEXP support (10iR1) --
  PRAGMA interface(c,regexp_like,    "pes_dummy",1);
  PRAGMA interface(c,regexp_instr,   "pes_dummy",1);    -- ICD #300
  PRAGMA interface(c,regexp_substr,  "pes_dummy",1);
  PRAGMA interface(c,regexp_replace, "pes_dummy",1);
  PRAGMA interface(c,regexp_count,   "pes_dummy",1);
  PRAGMA interface(c,regexp_like,    "pes_dummy",2);    -- LOB REGEXP_LIKE
  PRAGMA interface(c,regexp_instr,   "pes_dummy",2);    -- LOB REGEXP_INSTR
  PRAGMA interface(c,regexp_substr,  "pes_dummy",2);    -- LOB REGEXP_SUBSTR
  PRAGMA interface(c,regexp_replace, "pes_dummy",2);    -- LOB REGEXP_REPLACE
  PRAGMA interface(c,regexp_count,   "pes_dummy",2);    -- LOB REGEXP_COUNT
  PRAGMA interface(c,regexp_replace, "pes_dummy",3);    -- LOB REGEXP_REPLACE

  -- End of REGEXP Built-in Functions --


  -- 10i Binary Floating-point Built-in Functions

  PRAGMA interface(c,"IS NAN","pesnanf",2);
  PRAGMA interface(c,"IS NAN","pesnand",3);
  PRAGMA interface(c,"IS INFINITE","pesinf",1);
  PRAGMA interface(c,"IS INFINITE","pesinff",2);
  PRAGMA interface(c,"IS INFINITE","pesinfd",3);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",2);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",3);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",2);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",3);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",21);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",22);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",23);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",24);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",7);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",8);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",9);
  PRAGMA interface(c,'REMAINDER',"pesrem", 1);
  PRAGMA interface(c,REMAINDER,"pesrem", 2);
  PRAGMA interface(c,'REMAINDER',"pesremf", 3);
  PRAGMA interface(c,REMAINDER,"pesremf", 4);
  PRAGMA interface(c,'REMAINDER',"pesremd", 5);
  PRAGMA interface(c,REMAINDER,"pesremd", 6);
  PRAGMA interface(c,ABS,"pes_dummy",2);
  PRAGMA interface(c,ABS,"pes_dummy",3);
  PRAGMA interface(c,ABS,"pes_dummy",4);
  PRAGMA interface(c,ATAN,"pesatand",2);
  PRAGMA interface(c,'MOD',"pesmodf", 2);
  PRAGMA interface(c,'MOD',"pesmodd", 3);
  PRAGMA interface(c,floor,"pesflof", 2);
  PRAGMA interface(c,floor,"pesflod", 3);
  PRAGMA interface(c,CEIL,"pesceif", 2);
  PRAGMA interface(c,CEIL,"pesceid", 3);
  PRAGMA interface (c, SQRT, "pessqtf", 2);
  PRAGMA interface (c, SQRT, "pessqtd", 3);
  PRAGMA interface(c,SIGN,"pessgnf", 2);
  PRAGMA interface(c,SIGN,"pessgnd", 3);
  PRAGMA interface(c,SIGN,"pessgni", 4);
  PRAGMA interface(c,cos,"pescosd", 2);
  PRAGMA interface(c,sin,"pessind",2);
  PRAGMA interface(c,TAN,"pestand",2);
  PRAGMA interface(c,COSH,"pescshd",2);
  PRAGMA interface(c,SINH,"pessnhd",2);   -- ICD #350
  PRAGMA interface(c,TANH,"pestnhd",2);
  PRAGMA interface(c,EXP,"pesexpd",2);
  PRAGMA interface(c,LN,"peslnd",2);
  PRAGMA interface(c,LOG,"peslogd",2);
  PRAGMA interface(c,TRUNC,"pestruf",4);
  PRAGMA interface(c,TRUNC,"pestrud",5);
  PRAGMA interface(c,TRUNC,"pestrui",6);
  PRAGMA interface(c,ROUND,"pesrndf",4);
  PRAGMA interface(c,ROUND,"pesrndd",5);
  PRAGMA interface(c,ROUND,"pesrndi",6);
  PRAGMA interface(c,POWER,"pespowd",2);

  -- End of 10i Binary Floating-point Built-in Functions

  -- ICDs for MULTISET

  PRAGMA interface(c,CARDINALITY,"pesmcnt");
  PRAGMA interface(c,"IS EMPTY","pesmie");
  PRAGMA interface(c,"IS NOT EMPTY","pes_invert",1);
  -- ICDs which used to be in the body of standard, but which new COG can
  -- handle directly

  -- NOT (some ICD)
  PRAGMA interface(c,NOT_LIKE,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",3);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",4);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",3);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",1);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",2);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",3);

  -- datetime is not null
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",20); -- interval ds

  -- Misc
  PRAGMA interface(c,"**",   "pespow",1);    -- number
  PRAGMA interface(c,"**",   "pespowd",2);   -- binary double
  PRAGMA interface(c,"ACOS", "pesacosd",2);  -- binary double
  PRAGMA interface(c,"ASIN", "pesasind",2);  -- binary double
  PRAGMA interface(c,"ATAN2","pesatn2d",2);  -- binary double

  -- All the flavors of NVL
  PRAGMA interface(c,nvl,"pes_dummy",1);       -- Boolean -- ICD #400
  PRAGMA interface(c,nvl,"pes_dummy",2);       -- Varchar2
  PRAGMA interface(c,nvl,"pes_dummy",3);       -- Number
  PRAGMA interface(c,nvl,"pes_dummy",4);       -- Date
  PRAGMA interface(c,nvl,"pes_dummy",5);       -- MLSLabel
  PRAGMA interface(c,nvl,"pes_dummy",6);       -- ADT
  PRAGMA interface(c,nvl,"pes_dummy",7);       -- Ref ADT
  PRAGMA interface(c,nvl,"pes_dummy",8);       -- Collection

--  Ref Cursor has problems. The MOVCR instruction needs more information than
--  the other MOV* instructions, including the PVM register of the destination
--  This cannot be easily supplied through the generic NVL instruction, so
--  for now, this flavor will continue to have a real body
--  PRAGMA interface(c,nvl,"pes_dummy",9);       -- Ref Cursor

  PRAGMA interface(c,nvl,"pes_dummy",10);       -- Time
  PRAGMA interface(c,nvl,"pes_dummy",11);       -- Time-tz
  PRAGMA interface(c,nvl,"pes_dummy",12);       -- Timestamp
  PRAGMA interface(c,nvl,"pes_dummy",13);       -- Timestamp-tz
  PRAGMA interface(c,nvl,"pes_dummy",14);       -- Timestamp-ltz
  PRAGMA interface(c,nvl,"pes_dummy",15);       -- Intervalym
  PRAGMA interface(c,nvl,"pes_dummy",16);       -- Intervalds
--  PRAGMA interface(c,nvl,"pes_dummy",17);       -- Clob (Handled above, ICD)
  PRAGMA interface(c,nvl,"pes_dummy",18);       -- Opaque
  PRAGMA interface(c,nvl,"pes_dummy",19);       -- Binaryfloat
  PRAGMA interface(c,nvl,"pes_dummy",20);       -- Binarydouble
  PRAGMA interface(c,nvl,"pes_dummy",21);       -- PLSInteger

  -- The following pragma overrides any other setting of the timestamp,
  -- and is used so that we recognize the client-side and server-side instances
  -- of package STANDARD as being the same.  Package STANDARD is special in
  -- that it is really the root of the PL/SQL dependencies graph; as such it
  -- itself doesn't ever need recompiling due to changes to things below it.
  -- The pragma mechanism used here is currently ignored except for
  -- package STANDARD, but in future may not be.  Do NOT add similar pragmas
  -- to your own code as it may in future interfere with the package
  -- consistency maintenance mechanisms and could have dire results.

  --#### timestamp pragma (please keep this last)
  pragma TIMESTAMP('2006-04-18:00:00:00');
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."STANDARD" AUTHID CURRENT_USER is              -- careful on this line; SED edit occurs!

  /********** Types and subtypes, do not reorder **********/
  type BOOLEAN is (FALSE, TRUE);

  type DATE is DATE_BASE;

  type NUMBER is NUMBER_BASE;
  subtype FLOAT is NUMBER; -- NUMBER(126)
  subtype REAL is FLOAT; -- FLOAT(63)
  subtype "DOUBLE PRECISION" is FLOAT;
  subtype INTEGER is NUMBER(38,0);
  subtype INT is INTEGER;
  subtype SMALLINT is NUMBER(38,0);
  subtype DECIMAL is NUMBER(38,0);
  subtype NUMERIC is DECIMAL;
  subtype DEC is DECIMAL;


  subtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;
  subtype NATURAL is BINARY_INTEGER range 0..2147483647;
  subtype NATURALN is NATURAL not null;
  subtype POSITIVE is BINARY_INTEGER range 1..2147483647;
  subtype POSITIVEN is POSITIVE not null;
  subtype SIGNTYPE is BINARY_INTEGER range '-1'..1;  -- for SIGN functions

  type VARCHAR2 is NEW CHAR_BASE;

  subtype VARCHAR is VARCHAR2;
  subtype STRING is VARCHAR2;

  subtype LONG is VARCHAR2(32760);

  subtype RAW is VARCHAR2;
  subtype "LONG RAW" is RAW(32760);

  subtype ROWID is VARCHAR2(256);

  -- Ansi fixed-length char
  -- Define synonyms for CHAR and CHARN.
  subtype CHAR is VARCHAR2;
  subtype CHARACTER is CHAR;

  type MLSLABEL is new CHAR_BASE;

  -- Large object data types.
  --  binary, character, binary file.
  type  BLOB is BLOB_BASE;
  type  CLOB is CLOB_BASE;
  type  BFILE is BFILE_BASE;

  -- Verbose and NCHAR type names
  subtype "CHARACTER VARYING" is VARCHAR;
  subtype "CHAR VARYING" is VARCHAR;
  subtype "NATIONAL CHARACTER" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHARACTER VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NVARCHAR2" is VARCHAR2 CHARACTER SET NCHAR_CS;
  subtype "CHARACTER LARGE OBJECT" is CLOB;
  subtype "CHAR LARGE OBJECT" is CLOB;
  subtype "NATIONAL CHARACTER LARGE OBJEC" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCHAR LARGE OBJECT" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCLOB" is CLOB CHARACTER SET NCHAR_CS;
  subtype "BINARY LARGE OBJECT" is BLOB;

  subtype pls_integer is binary_integer;

  type TIME is new DATE_BASE;
  type TIMESTAMP is new DATE_BASE;
  type "TIME WITH TIME ZONE" is new DATE_BASE;
  type "TIMESTAMP WITH TIME ZONE" is new DATE_BASE;
  type "INTERVAL YEAR TO MONTH" is new DATE_BASE;
  type "INTERVAL DAY TO SECOND" is new DATE_BASE;

  SUBTYPE TIME_UNCONSTRAINED IS TIME(9);
  SUBTYPE TIME_TZ_UNCONSTRAINED IS TIME(9) WITH TIME ZONE;
  SUBTYPE TIMESTAMP_UNCONSTRAINED IS TIMESTAMP(9);
  SUBTYPE TIMESTAMP_TZ_UNCONSTRAINED IS TIMESTAMP(9) WITH TIME ZONE;
  SUBTYPE YMINTERVAL_UNCONSTRAINED IS INTERVAL YEAR(9) TO MONTH;
  SUBTYPE DSINTERVAL_UNCONSTRAINED IS INTERVAL DAY(9) TO SECOND (9);

  TYPE UROWID IS NEW CHAR_BASE;

  type "TIMESTAMP WITH LOCAL TIME ZONE" is new DATE_BASE;
  subtype timestamp_ltz_unconstrained is timestamp(9) with local time zone;

  subtype BINARY_FLOAT is NUMBER;
  subtype BINARY_DOUBLE is NUMBER;

  -- The following data types are generics, used specially within package
  -- STANDARD and some other Oracle packages.  They are protected against
  -- other use; sorry.  True generic types are not yet part of the language.

  type "<ADT_1>" as object (dummy char(1));
  type "<RECORD_1>" is record (dummy char(1));
  type "<TUPLE_1>" as object (dummy char(1));
  type "<VARRAY_1>" is varray (1) of char(1);
  type "<V2_TABLE_1>" is table of char(1) index by binary_integer;
  type "<TABLE_1>" is table of char(1);
  type "<COLLECTION_1>" is table of char(1);
  type "<REF_CURSOR_1>" is ref cursor;

  -- This will actually match against a Q_TABLE
  type "<TYPED_TABLE>" is table of  "<ADT_1>";
  subtype "<ADT_WITH_OID>" is "<TYPED_TABLE>";

  -- The following generic index table data types are used by the PL/SQL
  -- compiler to materialize an array attribute at the runtime (for more
  -- details about the array attributes, please see Bulk Binds document).
  type " SYS$INT_V2TABLE" is table of pls_integer index by binary_integer;

  -- The following record type and the corresponding generic index table
  -- data types are used by the PL/SQL compiler to materialize a table
  -- at the runtime in order to record the exceptions raised during the
  -- execution of FORALL bulk bind statement (for more details, please
  -- see bulk binds extensions document in 8.2).
  type " SYS$BULK_ERROR_RECORD" is
          record (error_index pls_integer, error_code pls_integer);
  type " SYS$REC_V2TABLE" is table of " SYS$BULK_ERROR_RECORD"
                               index by binary_integer;

  /* Adding a generic weak ref cursor type */
  type sys_refcursor is ref cursor;

  /* the following data type is a generic for all opaque types */
  type "<OPAQUE_1>" as opaque FIXED(1) USING LIBRARY dummy_lib
    (static function dummy return number);

  type "<ASSOC_ARRAY_1>" is table of char(1) index by varchar2(1);

  /********** Add new types or subtypes here **********/

  -- Simple scalar types

  subtype SIMPLE_INTEGER is BINARY_INTEGER NOT NULL;
  subtype SIMPLE_FLOAT   is BINARY_FLOAT   NOT NULL;
  subtype SIMPLE_DOUBLE  is BINARY_DOUBLE  NOT NULL;

  /********** Predefined constants **********/

  BINARY_FLOAT_NAN constant BINARY_FLOAT;
  BINARY_FLOAT_INFINITY constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_SUBNORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_SUBNORMAL constant BINARY_FLOAT;
  BINARY_DOUBLE_NAN constant BINARY_DOUBLE;
  BINARY_DOUBLE_INFINITY constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_SUBNORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_SUBNORMAL constant BINARY_DOUBLE;

  /********** Add new constants here **********/

  /********** Predefined exceptions **********/

  CURSOR_ALREADY_OPEN exception;
    pragma EXCEPTION_INIT(CURSOR_ALREADY_OPEN, '-6511');

  DUP_VAL_ON_INDEX exception;
    pragma EXCEPTION_INIT(DUP_VAL_ON_INDEX, '-0001');

  TIMEOUT_ON_RESOURCE exception;
    pragma EXCEPTION_INIT(TIMEOUT_ON_RESOURCE, '-0051');

  INVALID_CURSOR exception;
    pragma EXCEPTION_INIT(INVALID_CURSOR, '-1001');

  NOT_LOGGED_ON exception;
    pragma EXCEPTION_INIT(NOT_LOGGED_ON, '-1012');

  LOGIN_DENIED exception;
    pragma EXCEPTION_INIT(LOGIN_DENIED, '-1017');

  NO_DATA_FOUND exception;
    pragma EXCEPTION_INIT(NO_DATA_FOUND, 100);

  ZERO_DIVIDE exception;
    pragma EXCEPTION_INIT(ZERO_DIVIDE, '-1476');

  INVALID_NUMBER exception;
    pragma EXCEPTION_INIT(INVALID_NUMBER, '-1722');

  TOO_MANY_ROWS exception;
    pragma EXCEPTION_INIT(TOO_MANY_ROWS, '-1422');

  STORAGE_ERROR exception;
    pragma EXCEPTION_INIT(STORAGE_ERROR, '-6500');

  PROGRAM_ERROR exception;
    pragma EXCEPTION_INIT(PROGRAM_ERROR, '-6501');

  VALUE_ERROR exception;
    pragma EXCEPTION_INIT(VALUE_ERROR, '-6502');

  ACCESS_INTO_NULL exception;
    pragma EXCEPTION_INIT(ACCESS_INTO_NULL, '-6530');

  COLLECTION_IS_NULL exception;
    pragma EXCEPTION_INIT(COLLECTION_IS_NULL , '-6531');

  SUBSCRIPT_OUTSIDE_LIMIT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_OUTSIDE_LIMIT,'-6532');

  SUBSCRIPT_BEYOND_COUNT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_BEYOND_COUNT ,'-6533');

  -- exception for ref cursors
  ROWTYPE_MISMATCH exception;
  pragma EXCEPTION_INIT(ROWTYPE_MISMATCH, '-6504');

  SYS_INVALID_ROWID  EXCEPTION;
  PRAGMA EXCEPTION_INIT(SYS_INVALID_ROWID, '-1410');

  -- The object instance i.e. SELF is null
  SELF_IS_NULL exception;
    pragma EXCEPTION_INIT(SELF_IS_NULL, '-30625');

  CASE_NOT_FOUND exception;
    pragma EXCEPTION_INIT(CASE_NOT_FOUND, '-6592');

  -- Added for USERENV enhancement, bug 1622213.
  USERENV_COMMITSCN_ERROR exception;
    pragma EXCEPTION_INIT(USERENV_COMMITSCN_ERROR, '-1725');

  -- Parallel and pipelined support
  NO_DATA_NEEDED exception;
    pragma EXCEPTION_INIT(NO_DATA_NEEDED, '-6548');
  -- End of 8.2 parallel and pipelined support

  /********** Add new exceptions here **********/

  /********** Function, operators and procedures **********/

  function "EXISTS" return BOOLEAN;
    pragma BUILTIN('EXISTS',10,240,240); -- This is special cased in PH2 -- Pj

  function GREATEST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DATE) return DATE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DATE) return DATE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr NUMBER, pat NUMBER, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER,
                   pat NUMBER,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER, pat NUMBER, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr DATE, pat DATE, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE,
                   pat DATE,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE, pat DATE, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function SQLCODE return PLS_INTEGER;
    pragma BUILTIN('SQLCODE',45, 10, 0); -- PEMS_DB, DB_SQLCODE

  function SQLERRM return varchar2;
    pragma FIPSFLAG('SQLERRM', 1452);

  function SQLERRM (code PLS_INTEGER) return varchar2;
    pragma BUILTIN('SQLERRM',46, 10, 1); -- PEMS_DB, DB_SQLERRM
    pragma FIPSFLAG('SQLERRM', 1452);

  function LEVEL return NUMBER;

  function ROWNUM return NUMBER;

  function '='  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('=',2, 3, 1); -- PEMS_INTEGER, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN; -- also <> and ~=
    pragma BUILTIN('!=',5, 3, 2); -- PEMS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<',4, 3, 3);  -- PEMS_INTEGER, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<=',6, 3, 4); -- PEMS_INTEGER, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>',1, 3, 5); -- PEMS_INTEGER, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>=',3, 3, 6); -- PEMS_INTEGER, PEMDMGE
    pragma FIPSFLAG('>=', 1450);

  --  Since SQL permits short-circuit evaluation, the 'and' and 'or'
  --  operations will always be interpreted as 'and then' and 'or else'
  --  when they occur in conditional statements.

  function XOR (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('XOR',8, 3, 9); -- PEMS_INTEGER, INT_XOR
    pragma FIPSFLAG('XOR', 1450);

  function 'NOT' (RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('NOT',9, 3, 10); -- PEMS_INTEGER, INT_NOT

  function 'IS NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);  -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50); -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 BOOLEAN, B2 BOOLEAN) return BOOLEAN;
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('=',2, 1, 14); -- PEMS_CHAR, PEMDCMEQ (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('=', 1454);
  function '!=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('!=',5, 1, 15);  -- PEMS_CHAR, PEMDCMNE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('!=', 1454);
  function '<'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<',4, 1, 16); -- PEMS_CHAR, PEMDCMLT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<', 1454);
  function '<=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<=',6, 1, 17); -- PEMS_CHAR, PEMDCMLE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<=', 1454);
  function '>'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>',1, 1, 18); -- PEMS_CHAR, PEMDCMGT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>', 1454);
  function '>=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>=',3, 1, 19); -- PEMS_CHAR, PEMDCMGE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>=', 1454);

  function '||' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN('||',25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT VARCHAR2 CHARACTER SET ANY_CS,
                  RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN(CONCAT,25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG(CONCAT, 1454);

  function LENGTH(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH', 1452);
  -- In SUBSTR, LEN defaults to remainder of string
  -- In substr and instr, a negative value of parameter POS means to
  -- count from the right end of the string.
  function SUBSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  POS PLS_INTEGER,
                  LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  -- Find nth occurrence of str1 in str2 starting at pos
  function INSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);
  function LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);
  function ASCII(ch VARCHAR2 CHARACTER SET ANY_CS)
        return PLS_INTEGER; -- should be ASCII.CHRANGE
    pragma FIPSFLAG('ASCII', 1452);
  function ASCIISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('ASCIISTR', 1452);
  function UNISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return NVARCHAR2;
    pragma FIPSFLAG('UNISTR', 1452);
  function CHR(n PLS_INTEGER) return varchar2;  -- N should be ASCII.CHRANGE
    pragma FIPSFLAG('CHR', 1452);
  function " SYS$STANDARD_CHR"(n PLS_INTEGER,csn VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET csn%CHARSET;
    pragma FIPSFLAG(' SYS$STANDARD_CHR', 1452);
  function INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('INITCAP', 1452);
  function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('SOUNDEX', 1452);

  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);
  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
  pragma FIPSFLAG('LPAD', 1452);

  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);
  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                     SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
                     DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('TRANSLATE', 1452);

  function REPLACE(SRCSTR VARCHAR2 CHARACTER SET ANY_CS,
                   OLDSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET := NULL)
        return VARCHAR2 CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);
  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);
  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'IS NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20);  -- PEMS_CHAR, PEMDNUL
  function 'IS NOT NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50); -- PEMS_CHAR, PEMDNUL

  function NVL(s1 VARCHAR2 CHARACTER SET ANY_CS,
               s2 VARCHAR2 CHARACTER SET s1%CHARSET)
        return VARCHAR2 CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);


  function '='  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 1); -- PEMS_NUMBER, PEMDCMEQ
  function '!=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 2); -- PEMS_NUMBER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 3); -- PEMS_NUMBER, PEMDCMLT
  function '<=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 4); -- PEMS_NUMBER, PEMDCMLE
  function '>'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 5); -- PEMS_NUMBER, PEMDCMGT
  function '>=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 6); -- PEMS_NUMBER, PEMDCMGE

  function 'IS NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_NUMBER, PEMDNUL

  function NVL(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 7); -- PEMS_NUMBER, NUM_NEG
  function ABS(n NUMBER) return NUMBER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 2, 8); -- PEMS_NUMBER, NUM_ADD
  function '-' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 9); -- PEMS_NUMBER, NUM_SUB
  function '*' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('*',17, 2, 10); -- PEMS_NUMBER, NUM_MUL
  function '/' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('/',18, 2, 11); -- PEMS_NUMBER, NUM_DIV

  function 'REM' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(n NUMBER) return NUMBER;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(n NUMBER) return NUMBER;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(n NUMBER) return NUMBER;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(n NUMBER) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COS', 1452);
  function SIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SIN', 1452);
  function TAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TAN', 1452);
  function COSH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COSH', 1452);
  function SINH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SINH', 1452);
  function TANH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TANH', 1452);

  function EXP(N NUMBER) return NUMBER;
  function LN(N NUMBER) return NUMBER;

  function BITAND (LEFT pls_integer, RIGHT pls_integer)
        return pls_integer;
  function BITAND (LEFT integer, RIGHT integer)
        return integer;
  function LOG (LEFT NUMBER, RIGHT NUMBER) return NUMBER;

  function TRUNC (n NUMBER, places pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT NUMBER, RIGHT pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (n NUMBER, e NUMBER) return NUMBER;
    pragma FIPSFLAG('POWER', 1452);

  function '='  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('=',2, 12, 1); -- PEMS_DATE, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT DATE, RIGHT DATE) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 12, 2); -- PEMS_DATE, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<',4, 12, 3); -- PEMS_DATE, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<=',6, 12, 4); -- PEMS_DATE, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>',1, 12, 5);  -- PEMS_DATE, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>=',3, 12, 6);  -- PEMS_DATE, PEMDCMGE
    pragma FIPSFLAG('>=', 1450);

  function '+' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('+',14, 12, 7); -- PEMS_DATE, DATE_ADD1
    pragma FIPSFLAG('+', 1450);
  function '+' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('+',14, 12, 8); -- PEMS_DATE, DATE_ADD2
    pragma FIPSFLAG('+', 1450);
  function '-' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('-',15, 12, 9); -- PEMS_DATE, DATE_SUB1
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('-',15, 12, 10); -- PEMS_DATE, DATE_SUB2
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('-',15, 12, 11); -- PEMS_DATE, DATE_SUB3
    pragma FIPSFLAG('-', 1450);

  function LAST_DAY(RIGHT DATE) return DATE;
    pragma BUILTIN('LAST_DAY',38, 12, 12); -- PEMS_DATE, DATE_LAST_DAY
    pragma FIPSFLAG('LAST_DAY', 1450);
  function ADD_MONTHS(LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 13); -- PEMS_DATE, DATE_ADD_MONTHS1
    pragma FIPSFLAG('ADD_MONTHS', 1450);
  function ADD_MONTHS(LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 14); -- PEMS_DATE, DATE_ADD_MONTHS2
    pragma FIPSFLAG('ADD_MONTHS', 1450);

  function MONTHS_BETWEEN(LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('MONTHS_BETWEEN',42, 12, 15); -- PEMS_DATE, DATE_MONTHS_BET
    pragma FIPSFLAG('MONTHS_BETWEEN', 1450);
  function NEXT_DAY(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('NEXT_DAY',43, 12, 16); -- PEMS_DATE, DATE_NEXT_DAY
    pragma FIPSFLAG('NEXT_DAY', 1450);
  function ROUND(RIGHT DATE) return DATE;
    pragma BUILTIN('ROUND',24, 12, 17); -- PEMS_DATE, DATE_ROUND
    pragma FIPSFLAG('ROUND', 1450);
  function NEW_TIME(RIGHT DATE, MIDDLE VARCHAR2, LEFT VARCHAR2) return DATE;
    pragma FIPSFLAG('NEW_TIME', 1450);

  function 'IS NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 12, 0);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 12, 50);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);
  function NVL (d1 DATE, d2 DATE) return DATE;
    pragma FIPSFLAG('NVL', 1450);

  function TRUNC(LEFT DATE) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 20); -- PEMS_DATE, DATE_TRUNC1
    pragma FIPSFLAG('TRUNC', 1450);
  function TRUNC(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 21); -- PEMS_DATE, DATE_TRUNC2
    pragma FIPSFLAG('TRUNC', 1450);
  function ROUND(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('ROUND',24, 12, 22); -- PEMS_DATE, DATE_ROUND2
    pragma FIPSFLAG('ROUND', 1450);

  function TO_DATE    (RIGHT VARCHAR2 character set any_cs)  return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 10); -- PEMS_CHAR, CHR_CNV_DAT
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT VARCHAR2 character set any_cs,
       RIGHT VARCHAR2 character set LEFT%charset) return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 8); -- PEMS_CHAR, CHR_CNV_DATE
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT NUMBER, RIGHT VARCHAR2) return DATE;
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE(left varchar2 character set any_cs,
                   format varchar2 character set LEFT%charset,
                   parms varchar2 character set LEFT%charset) return date;

  function TO_CHAR (RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',14, 0, 2);

  function TO_CHAR (LEFT DATE, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  function TO_CHAR (LEFT NUMBER, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function TO_NUMBER (RIGHT NUMBER) RETURN NUMBER;
    pragma BUILTIN('TO_NUMBER',14, 0, 1); -- PEMS_QUICK

  function TO_NUMBER (RIGHT VARCHAR2 character set any_cs)    return NUMBER;
    pragma BUILTIN('TO_NUMBER',48, 1, 9); -- PEMS_CHAR, CHR_CNV_NUM

  function TO_NUMBER(left varchar2 character set any_cs,
        format varchar2 character set LEFT%charset)
    return number;
  function TO_NUMBER(left varchar2 character set any_cs,
                     format varchar2 character set LEFT%charset,
                     parms varchar2 character set LEFT%charset)
    return number;

  -- Define SQL predicates.  These don't gen code, so no body is needed.

  -- PRIOR is WEIRD - For now, it will be treated as a function call.
  -- Does the function only take a column name?  how about its use in
  -- a predicate?
  function 'PRIOR'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname NUMBER) return NUMBER;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname DATE) return DATE;
      pragma FIPSFLAG('PRIOR', 1450);

  -- Outer Join has same problem as PRIOR
  function '(+)'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
  function '(+)'(colname NUMBER) return NUMBER;
  function '(+)'(colname DATE) return DATE;
      pragma FIPSFLAG('(+)', 1450);

  function '=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ANY', 1450);
  function '=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ANY', 1450);
  function '!=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ANY', 1450);
  function '<ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ANY', 1450);
  function '<=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ANY', 1450);
  function '>ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ANY', 1450);
  function '>=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ALL', 1450);
  function '=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ALL', 1450);
  function '!=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ALL', 1450);
  function '<ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ALL', 1450);
  function '<=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ALL', 1450);
  function '>ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ALL', 1450);
  function '>=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=SOME', 1450);
  function '=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=SOME', 1450);
  function '!=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<SOME', 1450);
  function '<SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=SOME', 1450);
  function '<=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>SOME', 1450);
  function '>SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=SOME', 1450);
  function '>=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  -- SQL Transaction routines
  procedure SET_TRANSACTION_USE(vc VARCHAR2);
  procedure COMMIT;
  procedure COMMIT_CM(vc VARCHAR2);
  procedure ROLLBACK_NR;
  procedure ROLLBACK_SV(Save_Point CHAR);
  procedure SAVEPOINT(Save_Point CHAR);

  function SYSDATE return DATE;
    pragma FIPSFLAG('SYSDATE', 1452);

  function UID return PLS_INTEGER;
    pragma FIPSFLAG('UID', 1452);

  function USER return VARCHAR2;

  function USERENV (envstr VARCHAR2) return VARCHAR2;
    pragma FIPSFLAG('USERENV', 1452);

  -- ROWID: this dreadful identifier is supposed to represent a datatype
  -- outside of SQL and and a pseudo-column (function, to us) when inside
  -- a sql statement.  ADA data model doesn't allow for any
  -- function X return X;
  -- so we must special case this.  Yuk.  There's special-case code in ph2nre
  -- which maps "rowid" to "rowid " if we're inside a SQL stmt.
  function "ROWID " return ROWID;
    pragma builtin('ROWID ', 1, 209, 240);  -- this had better never be called.

  function NULLFN (str VARCHAR2) return RAW;
    pragma builtin('NULLFN', 1, 0, 1);

  function HEXTORAW (c VARCHAR2) return RAW;
     pragma builtin('HEXTORAW', 1, 23, 1);

  function RAWTOHEX (r RAW) return VARCHAR2;
     pragma builtin('RAWTOHEX', 1, 23, 2);

  function CHARTOROWID (str VARCHAR2) return ROWID;
    pragma builtin('CHARTOROWID', 1, 0, 1);

  function ROWIDTOCHAR (str ROWID) return VARCHAR2;
    pragma builtin('ROWIDTOCHAR', 1, 0, 1);


  -- Trusted*Oracle additions
  Function ROWLABEL return MLSLABEL;                     -- pseudo column

  Function TO_CHAR(label MLSLABEL, format VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',90, 4, 19); -- PEMS_DATE, MLS_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  Function TO_LABEL(label VARCHAR2, format VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 8); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  Function TO_LABEL(label VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 2); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  -- vararg routines - icds in stdbdy
  Function LEAST_UB    (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('LEAST_UB',90, 4, 3); -- PEMS_CHAR, CHR_CNV_MLS
  Function GREATEST_LB (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('GREATEST_LB',90, 4, 4); -- PEMS_CHAR, CHR_CNV_MLS

  Function '>=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '>'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '='  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '!=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  function 'IS NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20); -- same "cod" as IS NULL(varchar2)
  function 'IS NOT NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50);

  function NVL(label1 MLSLABEL, label2 MLSLABEL) return MLSLABEL;
    pragma FIPSFLAG('NVL', 1452);

  -- group functions
  Function LUB (label MLSLABEL) return MLSLABEL;
  Function GLB (label MLSLABEL) return MLSLABEL;

  -- end of Trusted*Oracle additions


  -- beginning of NLS routines

  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS, c2 VARCHAR2) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS,
                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);

  function LENGTHB(ch VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
    pragma FIPSFLAG('LENGTHB', 1452);
  function SUBSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);
  function INSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  function TO_SINGLE_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_SINGLE_BYTE', 1452);
  function TO_MULTI_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_MULTI_BYTE', 1452);

  -- Next two added for NLS 6/3/92 JEM.
  function TO_CHAR(left date, format varchar2, parms varchar2) return varchar2;
  function TO_CHAR(left number, format varchar2, parms varchar2)
    return varchar2;
  function NLS_CHARSET_NAME(csetid PLS_INTEGER) return VARCHAR2;
  function NLS_CHARSET_ID(csetname VARCHAR2) return PLS_INTEGER;
  function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
    return PLS_INTEGER;

  -- end of NLS routines

  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2)
           return VARCHAR2 character set src%charset;
  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2,
                   srccset VARCHAR2)
          return VARCHAR2 character set src%charset;

  function " SYS$STANDARD_TRANSLATE" (src VARCHAR2 CHARACTER SET ANY_CS,
                                      csn VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET csn%CHARSET;
     pragma FIPSFLAG(' SYS$STANDARD_TRANSLATE',1452);

  function VSIZE (e number ) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e DATE) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);


  -- dump( expr [,display_format[,start_pos[,length]]]) return VARCHAR2
  function DUMP(e varchar2 character set any_cs,
                df pls_integer := null,sp pls_integer := null,
                len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e number,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e date,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  --
  -- ACOS, ASIN, ATAN, ATAN2
  --   Inverse Trigonometric functions
  --   These functions return NULL if any of the inputs are NULL
  --
  function ACOS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x NUMBER, y NUMBER) return NUMBER;
  pragma FIPSFLAG('ATAN2', 1452);

  --#### This is the end of 7.3 Standard

  -- LOB IS NULL
  function 'IS NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);
  -- end LOB IS NULL

  --****************************************************************
  -- 20 mar 96 =G=> In the following, arguments "1, 1, 1" to pragma BUILTIN
  -- e.g.,                pragma builtin('whatever', 1, 1, 1)
  -- indicate that those three numeric arguments to pragma BUILTIN are unknown,
  -- because they are not yet implemented by the backend.

  function '='  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<ADT_1>", pat "<ADT_1>", res "<ADT_1>")
        return "<ADT_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<ADT_1>", B2 "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function VALUE (item "<ADT_WITH_OID>") return "<ADT_1>";
    pragma BUILTIN('VALUE', 1, 1, 1);
    pragma FIPSFLAG('VALUE', 1450);

  function REF (item "<ADT_WITH_OID>") return REF "<ADT_1>";
    pragma BUILTIN('REF', 1, 1, 1);
    pragma FIPSFLAG('REF', 1450);

  function DEREF (r REF "<ADT_1>") return "<ADT_1>";
    pragma BUILTIN('DEREF', 1, 1, 1);
    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF ADT

  function 'IS NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function 'IS DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS DANGLING', 1450);

  function 'IS NOT DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  function NVL (B1 REF "<ADT_1>", B2 REF "<ADT_1>") return REF "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 0, 3, 1);
    pragma FIPSFLAG('=', 1450);

  function '!=' (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 0, 3, 2);
    pragma FIPSFLAG('!=', 1450);

  --  function '='  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('=', 1, 1, 1);
  --    pragma FIPSFLAG('=', 1450);
  --
  --  function '!=' (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('!=', 1, 1, 1);
  --    pragma FIPSFLAG('!=', 1450);
  --
  --  function '=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --
  --  function DECODE (expr "<COLLECTION_1>", pat "<COLLECTION_1>",
  --                                        res "<COLLECTION_1>")
  --      return "<COLLECTION_1>";
  --    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<COLLECTION_1>", B2 "<COLLECTION_1>")
        return "<COLLECTION_1>";
    pragma FIPSFLAG('NVL', 1450);

  function 'IS NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
        return "<REF_CURSOR_1>";
    pragma FIPSFLAG('NVL', 1450);

  function EMPTY_CLOB return clob;
  function EMPTY_BLOB return blob;

  function BFILENAME(directory varchar2,filename varchar2) return BFILE;

  function "SYS$LOB_REPLICATION" (x in blob) return blob;
  function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
    return clob character set x%charset;

  --#### This is the end of 8.0 Standard

  --  + overloadings

  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;

  function '+'(LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_UNCONSTRAINED;

  function '+'(LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_TZ_UNCONSTRAINED;

  function '+'(LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
                return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
                return TIME_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
                return TIME_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return DSINTERVAL_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return YMINTERVAL_UNCONSTRAINED ;

  -- begin subtract
  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return YMINTERVAL_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT" (LEFT TIME_UNCONSTRAINED,
                                      RIGHT TIME_UNCONSTRAINED)
     return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_UNCONSTRAINED ;
  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED ;
  function  " SYS$DSINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date;
  function '-' (LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date;

  function '-' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
   return DSINTERVAL_UNCONSTRAINED ;

  -- end subtract

  -- other datetime operators

  function '*' (LEFT number, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT number, RIGHT DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;

  function '*' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;

  function '/' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '/' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;


  function current_date return date;
  function current_time return TIME_TZ_UNCONSTRAINED;
  function current_timestamp return TIMESTAMP_TZ_UNCONSTRAINED;

  function TO_TIME (RIGHT varchar2 character set any_cs) return
    time_unconstrained;
    pragma BUILTIN('TO_TIME', 0, 15, 1);
    function TO_TIMESTAMP (RIGHT varchar2 character set any_cs)
                           return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 3);
  function TO_TIME_TZ (RIGHT varchar2 character set any_cs)
    return  TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 5);
  function TO_TIMESTAMP_TZ (RIGHT varchar2 character set any_cs)
    return  TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 7);
  function TO_YMINTERVAL (RIGHT varchar2 character set any_cs)
    return  YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_YMINTERVAL', 0, 15, 9);
  function TO_DSINTERVAL (RIGHT varchar2 character set any_cs)
    return  DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_DSINTERVAL', 0, 15, 11);

  -- with nls args
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset,
                   parms varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset,
                        parms varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset,
                           parms varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset,
                      parms varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_DSINTERVAL(RIGHT varchar2 character set any_cs,
                         parms varchar2 character set RIGHT%charset)
    return DSINTERVAL_UNCONSTRAINED;

  function NUMTOYMINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return YMINTERVAL_UNCONSTRAINED;
  function NUMTODSINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return DSINTERVAL_UNCONSTRAINED;

  function '='  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('=',0, 11, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',0, 11, 2);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<',0, 11, 3);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<=',0, 11, 4);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>',0, 11, 5);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>=',0, 11, 6);
    pragma FIPSFLAG('>=', 1450);

  function 'IS NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 14, 0); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 14, 50); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function "UROWID " return UROWID;
    pragma builtin('UROWID ', 1, 209, 240);  -- this had better never be called.

  -- New built-in function SYS_GUID, returns globally unique id
  function SYS_GUID return RAW;

  -- New built-in function SYS_CONTEXT
  function SYS_CONTEXT (namespace varchar2, attribute varchar2)
    return varchar2;

  function TRIM(v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  --#### This is the end of 8.1.5 Standard

  -- SYS_CONTEXT now has an additional optional parameter
  function SYS_CONTEXT(namespace varchar2, attribute varchar2,
                       newoptional varchar2)
    return varchar2;

  -- CUBE and ROLLUP are not real functions; they are variants on the GROUP
  -- BY clause (GROUP BY CUBE (...) and GROUP BY ROLLUP (...)). They have
  -- been added here as functions to avoid name capture issues.
  --
  -- Note that both CUBE and ROLLUP look like true vararg functions with
  -- *no* repeating pattern of formals - hence they are special cased in
  -- the overloading code.
  function CUBE return NUMBER;
  function ROLLUP return NUMBER;

  -- The GROUPING function must be used in conjunction with CUBE and ROLLUP
  -- in the GROUP BY clause. The type of the parameter to GROUPING can be
  -- any type that can appear in a GROUP BY list.
  function GROUPING(v VARCHAR2) return NUMBER;
  function GROUPING(a "<ADT_1>") return NUMBER;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 VARCHAR2 CHARACTER SET ANY_CS ,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   VARCHAR2 CHARACTER SET ANY_CS ,
                                 TSET   VARCHAR2 CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  --#### This is the end of the supported parts of 8.1.6 Standard

  --## Support for ANSI datetime data types is under development.
  --## The following operations, as well as the related types and
  --## operations defined above in the 8.1.5 section, are not yet
  --## available for use and are still subject to change.

  --- datetime equivalence
  function '='  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function TO_TIME (RIGHT TIME_TZ_UNCONSTRAINED)  return TIME_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME', 0, 15, 13);
  function TO_TIME_TZ (RIGHT TIME_UNCONSTRAINED)  return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 14);
  function TO_TIMESTAMP (RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 15);
  function TO_TIMESTAMP_TZ (RIGHT TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 16);

  function '-'
      (LEFT TIME_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  -- timezone functions
  function SYS_AT_TIME_ZONE(t time_tz_unconstrained,
                            i varchar2) RETURN time_tz_unconstrained;
  function SYS_AT_TIME_ZONE(t timestamp_tz_unconstrained,
                            i varchar2) RETURN timestamp_tz_unconstrained;
  FUNCTION systimestamp RETURN timestamp_tz_unconstrained;
  FUNCTION dbtimezone RETURN varchar2;
  FUNCTION sessiontimezone RETURN varchar2;
  FUNCTION localtimestamp RETURN timestamp_unconstrained;
  FUNCTION localtime RETURN time_unconstrained;

  function TO_TIMESTAMP (RIGHT DATE)  return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 17);

  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT yminterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '+'(LEFT dsinterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return yminterval_unconstrained;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;

  function '='  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;

  function SYS_LITERALTOYMINTERVAL(numerator varchar2, units varchar2)
    return YMINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTODSINTERVAL(numerator varchar2, units varchar2)
    return DSINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTOTIME(numerator varchar2)
    return TIME_UNCONSTRAINED;
  function SYS_LITERALTOTZTIME(numerator varchar2)
    return TIME_TZ_UNCONSTRAINED;
  function SYS_LITERALTOTIMESTAMP(numerator varchar2)
    return TIMESTAMP_UNCONSTRAINED;
  function SYS_LITERALTOTZTIMESTAMP(numerator varchar2)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function SYS_LITERALTODATE(numerator varchar2) return DATE;


  -- Explicit conversions between date and datetime
  function TO_TIMESTAMP(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 24);

  function TO_TIMESTAMP_TZ(ARG DATE) return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 27);

  function TO_TIMESTAMP_TZ(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 26);

  -- IS [NOT] NULL / NVL for datetime
  function 'IS NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_UNCONSTRAINED,
                b2 TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;

  function 'IS NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_TZ_UNCONSTRAINED, b2 TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_UNCONSTRAINED,
                b2 TIMESTAMP_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_TZ_UNCONSTRAINED, b2 TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_LTZ_UNCONSTRAINED,
                b2 TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;

  function 'IS NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 YMINTERVAL_UNCONSTRAINED, b2 YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;

  function 'IS NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 DSINTERVAL_UNCONSTRAINED, b2 DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  function " SYS$EXTRACT_FROM"
              (T TIME_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T DATE,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I YMINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I DSINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;

  -- ##########      8.2 LOB Built-in Functions       ######## --

  -- LENGTH --
  function LENGTH(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  function LENGTH(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  -- SUBSTR --
  function SUBSTR(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  function SUBSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);

  -- INSTR --
  function INSTR(STR1 CLOB CHARACTER SET ANY_CS,
                 STR2 CLOB CHARACTER SET STR1%CHARSET,
                 POS INTEGER := 1,
                 NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function INSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  STR2 CLOB CHARACTER SET STR1%CHARSET,
                  POS INTEGER := 1,
                  NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  -- CONCAT --
  function '||' (LEFT CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT CLOB CHARACTER SET ANY_CS,
                  RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG(CONCAT, 1454);

  -- UPPER --
  function UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);

  -- LOWER --
  function LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);

  -- LPAD --
  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  -- RPAD --
  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  -- LTRIM --
  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  -- RTRIM --
  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  -- TRIM --
  function TRIM(v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 CLOB CHARACTER SET ANY_CS ,
                               TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   CLOB CHARACTER SET ANY_CS ,
                                 TSET   CLOB CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;


  -- LIKE --
  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  -- NVL --
  function NVL(s1 CLOB CHARACTER SET ANY_CS,
               s2 CLOB CHARACTER SET s1%CHARSET)
    return CLOB CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);

  -- REPLACE --
  function REPLACE(SRCSTR CLOB CHARACTER SET ANY_CS,
                   OLDSUB CLOB CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB CLOB CHARACTER SET SRCSTR%CHARSET := NULL)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  -- LOB RELATIONAL OPERATORS --

  Function '='  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;

  /* LOB-related conversion functions */
  function TO_CLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS) return CLOB;
    pragma BUILTIN('TO_CLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  function TO_BLOB(RIGHT RAW) return BLOB;
    pragma BUILTIN('TO_BLOB', 0, 15, 30); -- OPC_CVT_RAW2BLB
  function TO_RAW(RIGHT BLOB) return RAW;
    pragma BUILTIN('TO_RAW', 0, 15, 32); -- OPC_CVT_BLB2RAW

  -- ####### end of 8.2 LOB Built-in Functions  ######## --

  function NULLIF(v1 VARCHAR2, v2 VARCHAR2) return VARCHAR2;
  function NULLIF(v1 BOOLEAN, v2 BOOLEAN) return VARCHAR2;
  function NULLIF(a1 "<ADT_1>", a2 "<ADT_1>") return VARCHAR2;

  function COALESCE return VARCHAR2;

  /* Daylight Saving Time Functions */
  FUNCTION tz_offset(region VARCHAR2)  RETURN VARCHAR2;
  FUNCTION from_tz(t TIMESTAMP_UNCONSTRAINED,timezone VARCHAR2)
    RETURN timestamp_tz_unconstrained;

  function " SYS$EXTRACT_STRING_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;

  function INSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR2', 1452);

  function INSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR4', 1452);

  function INSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRC', 1452);

  function LENGTH2(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH2', 1452);

  function LENGTH4(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH4', 1452);

  function LENGTHC(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTHC', 1452);

  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function SUBSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR2', 1452);

  function SUBSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR4', 1452);

  function SUBSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRC', 1452);

  /**** char <--> nchar conversion functions in Unicode project ********/

  function TO_NCHAR(RIGHT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',14, 0, 2);

  function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB;
  function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB;

  function TO_NCLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return NCLOB;
    pragma BUILTIN('TO_NCLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  /* convert to either CLOB or NCLOB respectively if parm is char or nchar */
  function TO_ANYLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET RIGHT%CHARSET;
    pragma BUILTIN('TO_ANYLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB

  /* Followings are the same builtin op codes as without N prefix functions,
   * implementation relys on impilcit conversion MCODEs
   */
  function TO_NCHAR (LEFT DATE, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_NCHAR', 1450);
  function TO_NCHAR (LEFT NUMBER, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function NHEXTORAW (c NVARCHAR2) return RAW;
    pragma builtin('NHEXTORAW', 1, 23, 1);
  function RAWTONHEX (r RAW) return NVARCHAR2;
    pragma builtin('RAWTONHEX', 1, 23, 2);
  function NCHARTOROWID (str NVARCHAR2) return ROWID;
    pragma builtin('NCHARTOROWID', 1, 0, 1);
  function ROWIDTONCHAR (str ROWID) return NVARCHAR2;
    pragma builtin('ROWIDTONCHAR', 1, 0, 1);

  function NCHR(n pls_integer) return NVARCHAR2;

  /* implemented by icd calls as the same as TO_CHAR */
  function TO_NCHAR(left date, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left number, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  /* implemented as a icd call, return TRUE if nchar, otherwise FALSE */
  function ISNCHAR(c VARCHAR2 character set any_cs) return boolean;

  /************ end of char <--> nchar conversion functions ************/

  /* Create overloads for all standard functions that work with <ADT_1> for
     <OPAQUE_1> */
  function '='  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<OPAQUE_1>", pat "<OPAQUE_1>", res "<OPAQUE_1>")
    return "<OPAQUE_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<OPAQUE_1>", B2 "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('NVL', 1450);

  --  REFs to opaques are not supported yet.
  --  function VALUE (item "<ADT_WITH_OID>") return "<OPAQUE_1>";
  --    pragma BUILTIN('VALUE', 1, 1, 1);
  --    pragma FIPSFLAG('VALUE', 1450);

  --  function REF (item "<ADT_WITH_OID>") return REF "<OPAQUE_1>";
  --    pragma BUILTIN('REF', 1, 1, 1);
  --    pragma FIPSFLAG('REF', 1450);

  --  function DEREF (r REF "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('DEREF', 1, 1, 1);
  --    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF OPAQUE

  --  function 'IS NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NULL', 0, 3, 0);
  --    pragma FIPSFLAG('IS NULL', 1450);

  --  function 'IS NOT NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma FIPSFLAG('IS NOT NULL', 1450);

  --  function 'IS DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS DANGLING', 1450);

  --  function 'IS NOT DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
  --    return REF "<OPAQUE_1>";
  --    pragma FIPSFLAG('NVL', 1450);

  --  function '='  (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('=', 0, 3, 1);
  --    pragma FIPSFLAG('=', 1450);

  --  function '!=' (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('!=', 0, 3, 2);
  --    pragma FIPSFLAG('!=', 1450);

  function GROUPING(a "<OPAQUE_1>") return NUMBER;
  function NULLIF(a1 "<OPAQUE_1>", a2 "<OPAQUE_1>") return VARCHAR2;

  function GREATEST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIME_TZ_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj

  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;

  -- CONVERT FOR LOB --
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2,
                   SRCCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;

  -- NLS_UPPER/NLS_LOWER FOR LOB --
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);

  function COMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS)
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('COMPOSE', 1452);
  function DECOMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS,
                     canmode in VARCHAR2 DEFAULT 'CANONICAL')
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('DECOMPOSE', 1452);
  FUNCTION SYS_EXTRACT_UTC(t timestamp_tz_unconstrained)
    return TIMESTAMP_UNCONSTRAINED;

  -- Begin REGEXP Support (10iR1) --

  -- REGEXP_LIKE --
  function REGEXP_LIKE (srcstr   VARCHAR2 CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  function REGEXP_LIKE (srcstr   CLOB CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  -- REGEXP_INSTR --
  function REGEXP_INSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        occurrence  PLS_INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);

  function REGEXP_INSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        occurrence  INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);


  -- REGEXP_SUBSTR --
  function REGEXP_SUBSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    PLS_INTEGER := 1,
                         occurrence  PLS_INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  function REGEXP_SUBSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    INTEGER := 1,
                         occurrence  INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  -- REGEXP_REPLACE --
  function REGEXP_REPLACE(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    PLS_INTEGER := 1,
                          occurrence  PLS_INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  CLOB CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  -- End REGEXP Support --

  -- binary_float and binary_double functions and operators.
  function TO_BINARY_FLOAT (RIGHT BINARY_FLOAT) RETURN BINARY_FLOAT;
    pragma BUILTIN('TO_BINARY_FLOAT',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;

  function TO_BINARY_DOUBLE (RIGHT BINARY_DOUBLE) RETURN BINARY_DOUBLE;
    pragma BUILTIN('TO_BINARY_DOUBLE',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;

  function 'IS NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;

  function TO_CHAR (left binary_float, format varchar2)
    return VARCHAR2;
  function TO_CHAR (left binary_double, format varchar2)
    return VARCHAR2;

  function TO_CHAR(left binary_float, format varchar2, parms varchar2)
    return varchar2;
  function TO_CHAR(left binary_double, format varchar2, parms varchar2)
    return varchar2;

  function TO_NCHAR(left binary_float, format nvarchar2) return NVARCHAR2;
  function TO_NCHAR(left binary_double, format nvarchar2) return NVARCHAR2;

  function TO_NCHAR(left binary_float, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left binary_double, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  function 'REMAINDER'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG(REMAINDER, 1452);

  function '='  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 15);
  function '!=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('!=',5, 2, 16);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 17);
  function '<=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 18);
  function '>'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 19);
  function '>=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 20);

  function 'IS NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 23);
  function ABS(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 2, 24);
  function '-' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 25);
  function '*' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('*',17, 2, 26);
  function '/' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('/',18, 2, 27);

  function 'REM' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(F1 BINARY_FLOAT, F2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('MOD', 1452);

  function FLOOR(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('CEIL', 1452);
  function SIGN(f BINARY_FLOAT) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);
  function SQRT(f BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('SQRT', 1452);

  function TRUNC (F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ROUND', 1452);

  function '='  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 28);
  function '!=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 29);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 30);
  function '<=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 31);
  function '>'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 32);
  function '>=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 33);

  function 'IS NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 36);
  function ABS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ABS', 1452);

  function ACOS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x BINARY_DOUBLE, y BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN2', 1452);

  function '+' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 2, 37);
  function '-' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 38);
  function '*' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('*',17, 2, 39);
  function '/' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('/',18, 2, 40);

  function 'REM' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(D1 BINARY_DOUBLE, D2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(d BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(d BINARY_DOUBLE) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function COSH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SINH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TANH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function EXP(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function LN(D BINARY_DOUBLE) return BINARY_DOUBLE;

  function LOG (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;

  function TRUNC (D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (d BINARY_DOUBLE, e BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('POWER', 1452);

  function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER;
  function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
  function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;

  function GREATEST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function GREATEST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2


  function '+' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',15, 2, 41);
  function ABS(I PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 2, 42);
  function '-' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',14, 2, 43);
  function '*' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('*',14, 2, 44);

  function '='  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 45); -- PEMS_PLS_INTEGER, PEMDCMEQ
  function '!=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 46); -- PEMS_PLS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 47); -- PEMS_PLS_INTEGER, PEMDCMLT
  function '<=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 48); -- PEMS_PLS_INTEGER, PEMDCMLE
  function '>'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 49); -- PEMS_PLS_INTEGER, PEMDCMGT
  function '>=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 51); -- PEMS_PLS_INTEGER, PEMDCMGE

  function 'IS NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_PLS_INTEGER, PEMDNUL
  function 'IS NOT NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_PLS_INTEGER, PEMDNUL

  function NVL(I1 PLS_INTEGER, I2 PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('NVL', 1452);

  function TRUNC (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('ROUND', 1452);

  function SIGN(i PLS_INTEGER) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);

  function GREATEST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2

  -- MultiSet Functions and Operators.

  -- Equality
  function '='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('=',2, 16, 1);

  function '!='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('!=',2, 16, 2);

  function CARDINALITY (collection IN "<TABLE_1>") return PLS_INTEGER;

  function SET (collection IN "<TABLE_1>") return "<TABLE_1>";
    pragma BUILTIN('SET',18, 2, 40);-- Dummy

  function 'IS A SET' (collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS A SET',18, 2, 40);-- Dummy
  function 'IS NOT A SET'(collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT A SET',18, 2, 40);-- Dummy

  function 'IS EMPTY' (collection IN  "<TABLE_1>") return BOOLEAN;
  function 'IS NOT EMPTY'(collection IN  "<TABLE_1>") return BOOLEAN;

  -- IS A SUBMULTISET OF
  function 'SUBMULTISET' (collection IN  "<TABLE_1>",
                          collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('SUBMULTISET',18, 2, 40);

  function 'MULTISET_UNION_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
      pragma BUILTIN('MULTISET_UNION_ALL',18, 2, 40);

  function 'MULTISET_UNION_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_UNION_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_DISTINCT',18, 2, 40);-- Dummy

  -- These are dummy procedures for correct management of new control
  -- statements added to PL/SQL. They ensure local procedures which have the
  -- same names as newly introduced keywords are not masked by those keywords.

  procedure continue;

  -- REGEXP_COUNT --
  function REGEXP_COUNT(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  function REGEXP_COUNT(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  --#### All user-visible declarations should preceed this point.  The
  --#### following are implementation-oriented pragmas that may need
  --#### editing in the future; we would prefer to be able to edit them
  --#### without affecting the rft numbering of user-visible items.

  --#### interface pragmas

  --#### Note that for any ICD which maps directly to a PVM
  --#### Opcode MUST be mapped to pes_dummy.
  --#### An ICD which invokes another ICD by flipping operands is
  --#### mapped to pes_flip, and an ICD whose result is the inverse of
  --#### another ICD is mapped to pes_invert
  --#### New ICDs should be placed at the end of this list, and a
  --#### corresponding entry must be made in the ICD table in pdz7

  PRAGMA interface(c,length,"pes_dummy",1);
  PRAGMA interface(c,substr,"pes_dummy",1);
  PRAGMA interface(c,instr,"pesist",1);
  PRAGMA interface(c,UPPER,"pesupp",1);
  PRAGMA interface(c,LOWER,"peslow",1);
  PRAGMA interface(c,ASCII,"pesasc");
  PRAGMA interface(c,ASCIISTR,"pesastr");
  PRAGMA interface(c,UNISTR,"pesustr");
  PRAGMA interface(c,CHR,"peschr");
  PRAGMA interface(c," SYS$STANDARD_CHR","peschr");
  PRAGMA interface(c,INITCAP,"pesicp");
  PRAGMA interface(c,LPAD,"peslpd",1);
  PRAGMA interface(c,LPAD,"peslpd",2);
  PRAGMA interface(c,RPAD,"pesrpd",1);
  PRAGMA interface(c,RPAD,"pesrpd",2);
  PRAGMA interface(c,REPLACE,"pesrep",1);
  PRAGMA interface(c,LTRIM,"pesltr",1);
  PRAGMA interface(c,LTRIM,"pesltr",2);
  PRAGMA interface(c,RTRIM,"pesrtr",1);
  PRAGMA interface(c,RTRIM,"pesrtr",2);
  PRAGMA interface(c,'LIKE',"peslik",1);
  PRAGMA interface(c,'LIKE',"pesli2",2);
  PRAGMA interface(c,ABS,"pes_dummy",1);
  PRAGMA interface(c,'MOD',"pesmod", 1);
  PRAGMA interface(c,floor,"pesflo", 1);
  PRAGMA interface(c,CEIL,"pescei", 1);
  PRAGMA interface (c, SQRT, "pessqt", 1);
  PRAGMA interface(c,SIGN,"pessgn", 1);
  PRAGMA interface(c,cos,"pescos", 1);
  PRAGMA interface(c,sin,"pessin",1);
  PRAGMA interface(c,TAN,"pestan",1);
  PRAGMA interface(c,COSH,"pescsh",1);
  PRAGMA interface(c,SINH,"pessnh",1);
  PRAGMA interface(c,TANH,"pestnh",1);
  PRAGMA interface(c,EXP,"pesexp",1);
  PRAGMA interface(c,LN,"pesln",1);
  PRAGMA interface(c,BITAND,"pesbtd",1);
  PRAGMA interface(c,BITAND,"pesbtdn",2);
  PRAGMA interface(c,LOG,"peslog",1);
  PRAGMA interface(c,TRUNC,"pestru",1);
  PRAGMA interface(c,ROUND,"pesrnd",1);
  PRAGMA interface(c,POWER,"pespow",1);
  PRAGMA interface(c,NEW_TIME,"pesnwt");
  PRAGMA interface(c,TO_DATE,"pesc2d",4);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",3);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",4);
  PRAGMA interface(c,'>=',"pes_flip",5);
  PRAGMA interface(c,'>',"pes_flip",5);
  PRAGMA interface(c,'<=',"peszle",5);
  PRAGMA interface(c,'<',"peszlt",5);        -- ICD #50
  PRAGMA interface(c,'=',"peszeq",5);
  PRAGMA interface(c,'!=',"pes_invert",5);
  PRAGMA interface(c,nlssort,"pesxco",2);
  PRAGMA interface(c,NLS_UPPER,"pesxup",1);
  PRAGMA interface(c,NLS_UPPER,"peslcnup",3); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_UPPER,"peslcnup",4); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_LOWER,"pesxlo",1);
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",3); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",4); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_INITCAP,"pesxcp",1);
  PRAGMA interface(c,lengthb,"pes_dummy",1);
  PRAGMA interface(c,substrb,"pes_dummy",1);
  PRAGMA interface(c,instrb,"pesxis",1);
  PRAGMA interface(c,TO_SINGLE_BYTE, "pesxsi");
  PRAGMA interface(c,TO_MULTI_BYTE,"pesxmu");
  PRAGMA interface(c,TO_CHAR,"pesd2c",5);
  PRAGMA interface(c,TO_CHAR,"pesn2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesd2c",4);
  PRAGMA interface(c,TO_NCHAR,"pesn2c",5);
  PRAGMA interface(c," SYS$STANDARD_TRANSLATE","pesxcs");
  PRAGMA interface(c,ATAN,"pesatan",1);
  PRAGMA interface(c,EMPTY_CLOB,"peslcem");
  PRAGMA interface(c,EMPTY_BLOB,"peslbem");
  PRAGMA interface(c,BFILENAME,"pesfnm");
  PRAGMA interface(c,TO_TIME,"pes3tm",2);
  PRAGMA interface(c,TO_TIME,"pes3tm",3);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",2);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",3);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",2);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",3);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",2);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",3);
  PRAGMA interface(c,TO_DSINTERVAL,"pes2dsi",2);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",1);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",2);
  PRAGMA interface(c,SESSIONTIMEZONE,"pesstz",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",2);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",3);
  PRAGMA interface(c,TRIM,"pestrim",1);
  -- Datetime addition
  PRAGMA interface(c,'+',"pesati",5);    --  +(tsp, iym) return tsp
  PRAGMA interface(c,'+',"pesati",6);    --  +(tsp, ids) return tsp
  PRAGMA interface(c,'+',"pesati",7);    --  +(tsz, iym) return tsz
  PRAGMA interface(c,'+',"pesati",8);    --  +(tsz, ids) return tsz
  PRAGMA interface(c,'+',"pesati",9);    --  +(tim, ids) return tim
  PRAGMA interface(c,'+',"pesati",10);   --  +(tmz, ids) return tmz
  PRAGMA interface(c,'+',"pesadi",11);   --  +(dat, iym) return dat
  PRAGMA interface(c,'+',"pesadi",12);   --  +(dat, ids) return dat
  PRAGMA interface(c,'+',"pes_flip",13); --  +(iym, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",14); --  +(iym, tsz) return tsz -- ICD #100
  PRAGMA interface(c,'+',"pes_flip",15); --  +(iym, dat) return dat
  PRAGMA interface(c,'+',"pes_flip",16); --  +(ids, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",17); --  +(ids, tsz) return tsz
  PRAGMA interface(c,'+',"pes_flip",18); --  +(ids, tim) return tim
  PRAGMA interface(c,'+',"pes_flip",19); --  +(ids, tmz) return tmz
  PRAGMA interface(c,'+',"pes_flip",20); --  +(ids, dat) return dat
  PRAGMA interface(c,'+',"pesaii",21);   --  +(ids, ids) return ids
  PRAGMA interface(c,'+',"pesaii",22);   --  +(iym, iym) return iym
  PRAGMA interface(c,'+',"pesati",23);   --  +(ltz, iym) return ltz
  PRAGMA interface(c,'+',"pesati",24);   --  +(ltz, ids) return ltz
  PRAGMA interface(c,'+',"pes_flip",25);--  +(iym, ltz) return ltz
  PRAGMA interface(c,'+',"pes_flip",26);--  +(ids, ltz) return ltz
  -- Datetime subtraction
  PRAGMA interface(c,'-',"pessti",6);    --  -(tsp, iym) return tsp
  PRAGMA interface(c,'-',"pessti",7);    --  -(tsp, ids) return tsp
  PRAGMA interface(c,'-',"pessti",8);    --  -(tsz, iym) return tsz
  PRAGMA interface(c,'-',"pessti",9);    --  -(tsz, ids) return tsz
  PRAGMA interface(c,'-',"pessti",10);   --  -(tim, ids) return tim
  PRAGMA interface(c,'-',"pessti",11);   --  -(tmz, ids) return tmz
  PRAGMA interface(c,'-',"pessdi",12);   --  -(dat, iym) return dat
  PRAGMA interface(c,'-',"pessdi",13);   --  -(dat, ids) return dat
  PRAGMA interface(c,'-',"pessii",14);   --  -(iym, iym) return iym
  PRAGMA interface(c,'-',"pessii",15);   --  -(ids, ids) return ids
  PRAGMA interface(c,'-',"pessttds",16); --  -(tim, tim) return ids
  PRAGMA interface(c,'-',"pessttds",17); --  -(tsp, tsp) return ids
  PRAGMA interface(c,'-',"pessttds",18); --  -(tmz, tmz) return ids
  PRAGMA interface(c,'-',"pessttds",19); --  -(tsz, tsz) return ids
  PRAGMA interface(c,'-',"pessti",20);   --  -(ltz, iym) return iym
  PRAGMA interface(c,'-',"pessti",21);   --  -(ltz, ids) return ids
  PRAGMA interface(c,'-',"pessttds",22); --  -(ltz, ltz) return ids
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",1);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",2);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",3);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",4);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessddds",5);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",6);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",1);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",2);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessddym",3);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",4);
  -- Datetime multiplication
  PRAGMA interface(c,'*',"pesmni",2);    --  *(num, iym) return iym
  PRAGMA interface(c,'*',"pesmni",3);    --  *(num, ids) return ids
  PRAGMA interface(c,'*',"pes_flip",4);  --  *(iym, num) return iym
  PRAGMA interface(c,'*',"pes_flip",5);  --  *(ids, num) return ids
  -- Datetime division
  PRAGMA interface(c,'/',"pesdvin",2);   --  /(iym, num) return iym
  PRAGMA interface(c,'/',"pesdvin",3);   --  /(ids, num) return ids
  -- TIME
  PRAGMA interface(c,'=',"pes_dummy",9);
  PRAGMA interface(c,'!=',"pes_invert",9);
  PRAGMA interface(c,'>',"pes_flip",8);
  PRAGMA interface(c,'<',"pes_dummy",8);
  PRAGMA interface(c,'>=',"pes_flip",8);   -- ICD #150
  PRAGMA interface(c,'<=',"pes_dummy",8);
  -- TIME WITH TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",10);
  PRAGMA interface(c,'!=',"pes_invert",10);
  PRAGMA interface(c,'>',"pes_flip",9);
  PRAGMA interface(c,'<',"pes_dummy",9);
  PRAGMA interface(c,'>=',"pes_flip",9);
  PRAGMA interface(c,'<=',"pes_dummy",9);
  -- TIMESTAMP
  PRAGMA interface(c,'=',"pes_dummy",11);
  PRAGMA interface(c,'!=',"pes_invert",11);
  PRAGMA interface(c,'>',"pes_flip",10);
  PRAGMA interface(c,'<',"pes_dummy",10);
  PRAGMA interface(c,'>=',"pes_flip",10);
  PRAGMA interface(c,'<=',"pes_dummy",10);
  -- INTERVAL YEAR TO MONTH
  PRAGMA interface(c,'=',"pes_dummy",12);
  PRAGMA interface(c,'!=',"pes_invert",12);
  PRAGMA interface(c,'>',"pes_flip",11);
  PRAGMA interface(c,'<',"pes_dummy",11);
  PRAGMA interface(c,'>=',"pes_flip",11);
  PRAGMA interface(c,'<=',"pes_dummy",11);
  -- INTERVAL DAY TO SECOND
  PRAGMA interface(c,'=',"pes_dummy",13);
  PRAGMA interface(c,'!=',"pes_invert",13);
  PRAGMA interface(c,'>',"pes_flip",12);
  PRAGMA interface(c,'<',"pes_dummy",12);
  PRAGMA interface(c,'>=',"pes_flip",12);
  PRAGMA interface(c,'<=',"pes_dummy",12);
  -- TIMESTAMP_TZ_UNCONSTRAINED
  PRAGMA interface(c,'=',"pes_dummy",14);
  PRAGMA interface(c,'!=',"pes_invert",14);
  PRAGMA interface(c,'>',"pes_flip",13);
  PRAGMA interface(c,'<',"pes_dummy",13);
  PRAGMA interface(c,'>=',"pes_flip",13);
  PRAGMA interface(c,'<=',"pes_dummy",13);
  -- TIMESTAMP WITH LOCAL TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",15);
  PRAGMA interface(c,'!=',"pes_invert",15);
  PRAGMA interface(c,'>',"pes_flip",14);
  PRAGMA interface(c,'<',"pes_dummy",14);
  PRAGMA interface(c,'>=',"pes_flip",14);
  PRAGMA interface(c,'<=',"pes_dummy",14);
  -- Other datetime functions
  PRAGMA interface(c,'CURRENT_DATE',"pescdt",1);
  PRAGMA interface(c,'CURRENT_TIME',"pesctm",1);
  PRAGMA interface(c,'CURRENT_TIMESTAMP',"pescts",1);
  --  Internal calls to evaluate datetime/interval literals without NLS parms.
  PRAGMA interface(c,SYS_LITERALTOYMINTERVAL,"pesc2ymi",1);
  PRAGMA interface(c,SYS_LITERALTODSINTERVAL,"pesc2dsi",1);
  PRAGMA interface(c,SYS_LITERALTOTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTODATE,"pesc2date",1);
  -- extract(field from expr)
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",1);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",2);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",3);   -- ICD #200
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",4);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",5);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefdt",6);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",7);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",8);
  -- datetime is null
  PRAGMA interface(c,"IS NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NULL","pes_dummy",20); -- interval ds

  -- 8.2 LOB Built-in Functions
  PRAGMA interface(c,length, "peslcln",2);    -- LOB LENGTH
  PRAGMA interface(c,lengthb,"peslclb",2);    -- LOB LENGTHB
  PRAGMA interface(c,substr, "peslcst",2);    -- LOB SUBSTR
  PRAGMA interface(c,substrb,"peslcsb",2);    -- LOB SUBSTRB
  PRAGMA interface(c,instr,  "peslcin",2);    -- LOB INSTR
  PRAGMA interface(c,instrb, "peslcib",2);    -- LOB INSTRB
  PRAGMA interface(c,'||',   "peslcct",2);    -- LOB '||'
  PRAGMA interface(c,concat, "peslcct",2);    -- LOB CONCAT
  PRAGMA interface(c,lpad,   "peslclp",3);    -- LOB LPAD
  PRAGMA interface(c,lpad,   "peslclp",4);    -- LOB LPAD
  PRAGMA interface(c,rpad,   "peslcrp",3);    -- LOB RPAD
  PRAGMA interface(c,rpad,   "peslcrp",4);    -- LOB RPAD
  PRAGMA interface(c,lower,  "peslclr",2);    -- LOB LOWER
  PRAGMA interface(c,upper,  "peslcup",2);    -- LOB UPPER
  PRAGMA interface(c,ltrim,  "peslclm",3);    -- LOB LTRIM
  PRAGMA interface(c,ltrim,  "peslclm",4);    -- LOB LTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",3);    -- LOB RTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",4);    -- LOB RTRIM
  PRAGMA interface(c,trim,   "peslctr",2);    -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",4); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",5); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",6); -- LOB TRIM
  PRAGMA interface(c,'LIKE', "peslclk",3);    -- LOB LIKE
  PRAGMA interface(c,'LIKE', "peslcl2",4);    -- LOB LIKE
  PRAGMA interface(c,nvl,"peslcnl",17);       -- LOB NVL
  PRAGMA interface(c,replace, "peslcrl",2);   -- LOB REPLACE

     -- LOB Relational Operators
     -- LHS: CLOB,    RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_dummy",16);     -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",16);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",15);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pes_dummy",15);     -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",15);      -- LOB '>='
  PRAGMA interface(c,'<=',"pes_dummy",15);       -- LOB '<='
     -- LHS: CLOB,     RHS:VARCHAR2
  PRAGMA interface(c,'=' ,"pesleq2",17);       -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",17);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",16);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt2",16);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",16);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle2",16);       -- LOB '<='  -- ICD #250
     -- LHS: VARCHAR2, RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_flip",18);      -- LOB '='
  PRAGMA interface(c,'!=',"pes_flip",18);      -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",17);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt3",17);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",17);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle3",17);       -- LOB '<='

  PRAGMA interface(c,length, "peslbln",3);    -- BLOB LENGTH
  PRAGMA interface(c,lengthb,"peslblb",3);    -- BLOB LENGTHB
  -- End of 8.2 LOB Built-in Functions


  PRAGMA interface(c,tz_offset,"pestzo",1);
  PRAGMA interface(c,from_tz,"pesftz",1);

  PRAGMA interface(c,ISNCHAR,"pesinc", 1);

  PRAGMA interface(c,CONVERT,"pescnv", 1);
  PRAGMA interface(c,CONVERT,"pescnv", 2);
  PRAGMA interface(c,CONVERT,"peslccnv", 3);  -- LOB CONVERT
  PRAGMA interface(c,CONVERT,"peslccnv", 4);  -- LOB CONVERT

  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",1);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",2);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",3);

  PRAGMA interface(c,TO_CHAR,"pesdtm2c",7); -- datetime
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",8);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",9);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",10);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",11);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",12);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",13);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",14);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",15);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",16);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",17); -- interval
  PRAGMA interface(c,TO_CHAR,"pesitv2c",18);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",19);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",20);

  --#### new_names pragmas

  -- This is an internal pragma that restricts the use
  -- of particular new entries in package standard.
  -- It is only valid in package standard.
  -- Note that left out of the 8.1.5 set are non datetime
  -- entries urowid, "UROWID ", self_is_null and trim.

  pragma new_names('8.1.5',
                   time,"TIME WITH TIME ZONE",
                   timestamp,"TIMESTAMP WITH TIME ZONE",
                   "INTERVAL DAY TO SECOND",
                   "INTERVAL YEAR TO MONTH",
                   to_time, to_timestamp,
                   to_time_tz, to_timestamp_tz,
                   " SYS$DSINTERVALSUBTRACT",
                   " SYS$YMINTERVALSUBTRACT",
                   to_yminterval,to_dsinterval,
                   NUMTOYMINTERVAL, NUMTODSINTERVAL,
                   current_date,
                   current_time,current_timestamp);

  pragma new_names('8.1.6',
                   dbtimezone, sessiontimezone, localtimestamp,
                   localtime,
                   cube, rollup, grouping, "TIMESTAMP WITH LOCAL TIME ZONE");

  -- Should there be a 8.2 new names pragma ?

  -- 8.2 UCS2/UCS4/Complete Built-in Functions

  PRAGMA interface(c,INSTR2,"pesist2",1);
  PRAGMA interface(c,INSTR4,"pesist4",1);
  PRAGMA interface(c,INSTRC,"pesistc",1);

  PRAGMA interface(c,LENGTH2,"peslen2",1);
  PRAGMA interface(c,LENGTH4,"peslen4",1);
  PRAGMA interface(c,LENGTHC,"peslenc",1);

  PRAGMA interface(c,LIKE2,"peslik2",1);
  PRAGMA interface(c,LIKE2,"pesli22",2);
  PRAGMA interface(c,LIKE4,"peslik4",1);
  PRAGMA interface(c,LIKE4,"pesli42",2);
  PRAGMA interface(c,LIKEC,"peslikc",1);
  PRAGMA interface(c,LIKEC,"peslic2",2);

  PRAGMA interface(c,SUBSTR2,"pes_dummy",1);
  PRAGMA interface(c,SUBSTR4,"pes_dummy",1);
  PRAGMA interface(c,SUBSTRC,"pes_dummy",1);
  PRAGMA interface(c,SYS_EXTRACT_UTC,"pessexu");
  PRAGMA interface(c,COMPOSE,"pescomp");
  PRAGMA interface(c,DECOMPOSE,"pesdcmp");



  -- End of 8.2 UCS2/UCS4/Complete Built-in Functions

  -- Begin REGEXP support (10iR1) --
  PRAGMA interface(c,regexp_like,    "pes_dummy",1);
  PRAGMA interface(c,regexp_instr,   "pes_dummy",1);    -- ICD #300
  PRAGMA interface(c,regexp_substr,  "pes_dummy",1);
  PRAGMA interface(c,regexp_replace, "pes_dummy",1);
  PRAGMA interface(c,regexp_count,   "pes_dummy",1);
  PRAGMA interface(c,regexp_like,    "pes_dummy",2);    -- LOB REGEXP_LIKE
  PRAGMA interface(c,regexp_instr,   "pes_dummy",2);    -- LOB REGEXP_INSTR
  PRAGMA interface(c,regexp_substr,  "pes_dummy",2);    -- LOB REGEXP_SUBSTR
  PRAGMA interface(c,regexp_replace, "pes_dummy",2);    -- LOB REGEXP_REPLACE
  PRAGMA interface(c,regexp_count,   "pes_dummy",2);    -- LOB REGEXP_COUNT
  PRAGMA interface(c,regexp_replace, "pes_dummy",3);    -- LOB REGEXP_REPLACE

  -- End of REGEXP Built-in Functions --


  -- 10i Binary Floating-point Built-in Functions

  PRAGMA interface(c,"IS NAN","pesnanf",2);
  PRAGMA interface(c,"IS NAN","pesnand",3);
  PRAGMA interface(c,"IS INFINITE","pesinf",1);
  PRAGMA interface(c,"IS INFINITE","pesinff",2);
  PRAGMA interface(c,"IS INFINITE","pesinfd",3);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",2);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",3);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",2);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",3);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",21);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",22);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",23);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",24);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",7);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",8);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",9);
  PRAGMA interface(c,'REMAINDER',"pesrem", 1);
  PRAGMA interface(c,REMAINDER,"pesrem", 2);
  PRAGMA interface(c,'REMAINDER',"pesremf", 3);
  PRAGMA interface(c,REMAINDER,"pesremf", 4);
  PRAGMA interface(c,'REMAINDER',"pesremd", 5);
  PRAGMA interface(c,REMAINDER,"pesremd", 6);
  PRAGMA interface(c,ABS,"pes_dummy",2);
  PRAGMA interface(c,ABS,"pes_dummy",3);
  PRAGMA interface(c,ABS,"pes_dummy",4);
  PRAGMA interface(c,ATAN,"pesatand",2);
  PRAGMA interface(c,'MOD',"pesmodf", 2);
  PRAGMA interface(c,'MOD',"pesmodd", 3);
  PRAGMA interface(c,floor,"pesflof", 2);
  PRAGMA interface(c,floor,"pesflod", 3);
  PRAGMA interface(c,CEIL,"pesceif", 2);
  PRAGMA interface(c,CEIL,"pesceid", 3);
  PRAGMA interface (c, SQRT, "pessqtf", 2);
  PRAGMA interface (c, SQRT, "pessqtd", 3);
  PRAGMA interface(c,SIGN,"pessgnf", 2);
  PRAGMA interface(c,SIGN,"pessgnd", 3);
  PRAGMA interface(c,SIGN,"pessgni", 4);
  PRAGMA interface(c,cos,"pescosd", 2);
  PRAGMA interface(c,sin,"pessind",2);
  PRAGMA interface(c,TAN,"pestand",2);
  PRAGMA interface(c,COSH,"pescshd",2);
  PRAGMA interface(c,SINH,"pessnhd",2);   -- ICD #350
  PRAGMA interface(c,TANH,"pestnhd",2);
  PRAGMA interface(c,EXP,"pesexpd",2);
  PRAGMA interface(c,LN,"peslnd",2);
  PRAGMA interface(c,LOG,"peslogd",2);
  PRAGMA interface(c,TRUNC,"pestruf",4);
  PRAGMA interface(c,TRUNC,"pestrud",5);
  PRAGMA interface(c,TRUNC,"pestrui",6);
  PRAGMA interface(c,ROUND,"pesrndf",4);
  PRAGMA interface(c,ROUND,"pesrndd",5);
  PRAGMA interface(c,ROUND,"pesrndi",6);
  PRAGMA interface(c,POWER,"pespowd",2);

  -- End of 10i Binary Floating-point Built-in Functions

  -- ICDs for MULTISET

  PRAGMA interface(c,CARDINALITY,"pesmcnt");
  PRAGMA interface(c,"IS EMPTY","pesmie");
  PRAGMA interface(c,"IS NOT EMPTY","pes_invert",1);
  -- ICDs which used to be in the body of standard, but which new COG can
  -- handle directly

  -- NOT (some ICD)
  PRAGMA interface(c,NOT_LIKE,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",3);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",4);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",3);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",1);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",2);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",3);

  -- datetime is not null
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",20); -- interval ds

  -- Misc
  PRAGMA interface(c,"**",   "pespow",1);    -- number
  PRAGMA interface(c,"**",   "pespowd",2);   -- binary double
  PRAGMA interface(c,"ACOS", "pesacosd",2);  -- binary double
  PRAGMA interface(c,"ASIN", "pesasind",2);  -- binary double
  PRAGMA interface(c,"ATAN2","pesatn2d",2);  -- binary double

  -- All the flavors of NVL
  PRAGMA interface(c,nvl,"pes_dummy",1);       -- Boolean -- ICD #400
  PRAGMA interface(c,nvl,"pes_dummy",2);       -- Varchar2
  PRAGMA interface(c,nvl,"pes_dummy",3);       -- Number
  PRAGMA interface(c,nvl,"pes_dummy",4);       -- Date
  PRAGMA interface(c,nvl,"pes_dummy",5);       -- MLSLabel
  PRAGMA interface(c,nvl,"pes_dummy",6);       -- ADT
  PRAGMA interface(c,nvl,"pes_dummy",7);       -- Ref ADT
  PRAGMA interface(c,nvl,"pes_dummy",8);       -- Collection

--  Ref Cursor has problems. The MOVCR instruction needs more information than
--  the other MOV* instructions, including the PVM register of the destination
--  This cannot be easily supplied through the generic NVL instruction, so
--  for now, this flavor will continue to have a real body
--  PRAGMA interface(c,nvl,"pes_dummy",9);       -- Ref Cursor

  PRAGMA interface(c,nvl,"pes_dummy",10);       -- Time
  PRAGMA interface(c,nvl,"pes_dummy",11);       -- Time-tz
  PRAGMA interface(c,nvl,"pes_dummy",12);       -- Timestamp
  PRAGMA interface(c,nvl,"pes_dummy",13);       -- Timestamp-tz
  PRAGMA interface(c,nvl,"pes_dummy",14);       -- Timestamp-ltz
  PRAGMA interface(c,nvl,"pes_dummy",15);       -- Intervalym
  PRAGMA interface(c,nvl,"pes_dummy",16);       -- Intervalds
--  PRAGMA interface(c,nvl,"pes_dummy",17);       -- Clob (Handled above, ICD)
  PRAGMA interface(c,nvl,"pes_dummy",18);       -- Opaque
  PRAGMA interface(c,nvl,"pes_dummy",19);       -- Binaryfloat
  PRAGMA interface(c,nvl,"pes_dummy",20);       -- Binarydouble
  PRAGMA interface(c,nvl,"pes_dummy",21);       -- PLSInteger

  -- The following pragma overrides any other setting of the timestamp,
  -- and is used so that we recognize the client-side and server-side instances
  -- of package STANDARD as being the same.  Package STANDARD is special in
  -- that it is really the root of the PL/SQL dependencies graph; as such it
  -- itself doesn't ever need recompiling due to changes to things below it.
  -- The pragma mechanism used here is currently ignored except for
  -- package STANDARD, but in future may not be.  Do NOT add similar pragmas
  -- to your own code as it may in future interfere with the package
  -- consistency maintenance mechanisms and could have dire results.

  --#### timestamp pragma (please keep this last)
  pragma TIMESTAMP('2006-04-18:00:00:00');
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Package STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."STANDARD" AUTHID CURRENT_USER is              -- careful on this line; SED edit occurs!

  /********** Types and subtypes, do not reorder **********/
  type BOOLEAN is (FALSE, TRUE);

  type DATE is DATE_BASE;

  type NUMBER is NUMBER_BASE;
  subtype FLOAT is NUMBER; -- NUMBER(126)
  subtype REAL is FLOAT; -- FLOAT(63)
  subtype "DOUBLE PRECISION" is FLOAT;
  subtype INTEGER is NUMBER(38,0);
  subtype INT is INTEGER;
  subtype SMALLINT is NUMBER(38,0);
  subtype DECIMAL is NUMBER(38,0);
  subtype NUMERIC is DECIMAL;
  subtype DEC is DECIMAL;


  subtype BINARY_INTEGER is INTEGER range '-2147483647'..2147483647;
  subtype NATURAL is BINARY_INTEGER range 0..2147483647;
  subtype NATURALN is NATURAL not null;
  subtype POSITIVE is BINARY_INTEGER range 1..2147483647;
  subtype POSITIVEN is POSITIVE not null;
  subtype SIGNTYPE is BINARY_INTEGER range '-1'..1;  -- for SIGN functions

  type VARCHAR2 is NEW CHAR_BASE;

  subtype VARCHAR is VARCHAR2;
  subtype STRING is VARCHAR2;

  subtype LONG is VARCHAR2(32760);

  subtype RAW is VARCHAR2;
  subtype "LONG RAW" is RAW(32760);

  subtype ROWID is VARCHAR2(256);

  -- Ansi fixed-length char
  -- Define synonyms for CHAR and CHARN.
  subtype CHAR is VARCHAR2;
  subtype CHARACTER is CHAR;

  type MLSLABEL is new CHAR_BASE;

  -- Large object data types.
  --  binary, character, binary file.
  type  BLOB is BLOB_BASE;
  type  CLOB is CLOB_BASE;
  type  BFILE is BFILE_BASE;

  -- Verbose and NCHAR type names
  subtype "CHARACTER VARYING" is VARCHAR;
  subtype "CHAR VARYING" is VARCHAR;
  subtype "NATIONAL CHARACTER" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR" is CHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHARACTER VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NATIONAL CHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NCHAR VARYING" is VARCHAR CHARACTER SET NCHAR_CS;
  subtype "NVARCHAR2" is VARCHAR2 CHARACTER SET NCHAR_CS;
  subtype "CHARACTER LARGE OBJECT" is CLOB;
  subtype "CHAR LARGE OBJECT" is CLOB;
  subtype "NATIONAL CHARACTER LARGE OBJEC" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCHAR LARGE OBJECT" is CLOB CHARACTER SET NCHAR_CS;
  subtype "NCLOB" is CLOB CHARACTER SET NCHAR_CS;
  subtype "BINARY LARGE OBJECT" is BLOB;

  subtype pls_integer is binary_integer;

  type TIME is new DATE_BASE;
  type TIMESTAMP is new DATE_BASE;
  type "TIME WITH TIME ZONE" is new DATE_BASE;
  type "TIMESTAMP WITH TIME ZONE" is new DATE_BASE;
  type "INTERVAL YEAR TO MONTH" is new DATE_BASE;
  type "INTERVAL DAY TO SECOND" is new DATE_BASE;

  SUBTYPE TIME_UNCONSTRAINED IS TIME(9);
  SUBTYPE TIME_TZ_UNCONSTRAINED IS TIME(9) WITH TIME ZONE;
  SUBTYPE TIMESTAMP_UNCONSTRAINED IS TIMESTAMP(9);
  SUBTYPE TIMESTAMP_TZ_UNCONSTRAINED IS TIMESTAMP(9) WITH TIME ZONE;
  SUBTYPE YMINTERVAL_UNCONSTRAINED IS INTERVAL YEAR(9) TO MONTH;
  SUBTYPE DSINTERVAL_UNCONSTRAINED IS INTERVAL DAY(9) TO SECOND (9);

  TYPE UROWID IS NEW CHAR_BASE;

  type "TIMESTAMP WITH LOCAL TIME ZONE" is new DATE_BASE;
  subtype timestamp_ltz_unconstrained is timestamp(9) with local time zone;

  subtype BINARY_FLOAT is NUMBER;
  subtype BINARY_DOUBLE is NUMBER;

  -- The following data types are generics, used specially within package
  -- STANDARD and some other Oracle packages.  They are protected against
  -- other use; sorry.  True generic types are not yet part of the language.

  type "<ADT_1>" as object (dummy char(1));
  type "<RECORD_1>" is record (dummy char(1));
  type "<TUPLE_1>" as object (dummy char(1));
  type "<VARRAY_1>" is varray (1) of char(1);
  type "<V2_TABLE_1>" is table of char(1) index by binary_integer;
  type "<TABLE_1>" is table of char(1);
  type "<COLLECTION_1>" is table of char(1);
  type "<REF_CURSOR_1>" is ref cursor;

  -- This will actually match against a Q_TABLE
  type "<TYPED_TABLE>" is table of  "<ADT_1>";
  subtype "<ADT_WITH_OID>" is "<TYPED_TABLE>";

  -- The following generic index table data types are used by the PL/SQL
  -- compiler to materialize an array attribute at the runtime (for more
  -- details about the array attributes, please see Bulk Binds document).
  type " SYS$INT_V2TABLE" is table of pls_integer index by binary_integer;

  -- The following record type and the corresponding generic index table
  -- data types are used by the PL/SQL compiler to materialize a table
  -- at the runtime in order to record the exceptions raised during the
  -- execution of FORALL bulk bind statement (for more details, please
  -- see bulk binds extensions document in 8.2).
  type " SYS$BULK_ERROR_RECORD" is
          record (error_index pls_integer, error_code pls_integer);
  type " SYS$REC_V2TABLE" is table of " SYS$BULK_ERROR_RECORD"
                               index by binary_integer;

  /* Adding a generic weak ref cursor type */
  type sys_refcursor is ref cursor;

  /* the following data type is a generic for all opaque types */
  type "<OPAQUE_1>" as opaque FIXED(1) USING LIBRARY dummy_lib
    (static function dummy return number);

  type "<ASSOC_ARRAY_1>" is table of char(1) index by varchar2(1);

  /********** Add new types or subtypes here **********/

  -- Simple scalar types

  subtype SIMPLE_INTEGER is BINARY_INTEGER NOT NULL;
  subtype SIMPLE_FLOAT   is BINARY_FLOAT   NOT NULL;
  subtype SIMPLE_DOUBLE  is BINARY_DOUBLE  NOT NULL;

  /********** Predefined constants **********/

  BINARY_FLOAT_NAN constant BINARY_FLOAT;
  BINARY_FLOAT_INFINITY constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_NORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MAX_SUBNORMAL constant BINARY_FLOAT;
  BINARY_FLOAT_MIN_SUBNORMAL constant BINARY_FLOAT;
  BINARY_DOUBLE_NAN constant BINARY_DOUBLE;
  BINARY_DOUBLE_INFINITY constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_NORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MAX_SUBNORMAL constant BINARY_DOUBLE;
  BINARY_DOUBLE_MIN_SUBNORMAL constant BINARY_DOUBLE;

  /********** Add new constants here **********/

  /********** Predefined exceptions **********/

  CURSOR_ALREADY_OPEN exception;
    pragma EXCEPTION_INIT(CURSOR_ALREADY_OPEN, '-6511');

  DUP_VAL_ON_INDEX exception;
    pragma EXCEPTION_INIT(DUP_VAL_ON_INDEX, '-0001');

  TIMEOUT_ON_RESOURCE exception;
    pragma EXCEPTION_INIT(TIMEOUT_ON_RESOURCE, '-0051');

  INVALID_CURSOR exception;
    pragma EXCEPTION_INIT(INVALID_CURSOR, '-1001');

  NOT_LOGGED_ON exception;
    pragma EXCEPTION_INIT(NOT_LOGGED_ON, '-1012');

  LOGIN_DENIED exception;
    pragma EXCEPTION_INIT(LOGIN_DENIED, '-1017');

  NO_DATA_FOUND exception;
    pragma EXCEPTION_INIT(NO_DATA_FOUND, 100);

  ZERO_DIVIDE exception;
    pragma EXCEPTION_INIT(ZERO_DIVIDE, '-1476');

  INVALID_NUMBER exception;
    pragma EXCEPTION_INIT(INVALID_NUMBER, '-1722');

  TOO_MANY_ROWS exception;
    pragma EXCEPTION_INIT(TOO_MANY_ROWS, '-1422');

  STORAGE_ERROR exception;
    pragma EXCEPTION_INIT(STORAGE_ERROR, '-6500');

  PROGRAM_ERROR exception;
    pragma EXCEPTION_INIT(PROGRAM_ERROR, '-6501');

  VALUE_ERROR exception;
    pragma EXCEPTION_INIT(VALUE_ERROR, '-6502');

  ACCESS_INTO_NULL exception;
    pragma EXCEPTION_INIT(ACCESS_INTO_NULL, '-6530');

  COLLECTION_IS_NULL exception;
    pragma EXCEPTION_INIT(COLLECTION_IS_NULL , '-6531');

  SUBSCRIPT_OUTSIDE_LIMIT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_OUTSIDE_LIMIT,'-6532');

  SUBSCRIPT_BEYOND_COUNT exception;
    pragma EXCEPTION_INIT(SUBSCRIPT_BEYOND_COUNT ,'-6533');

  -- exception for ref cursors
  ROWTYPE_MISMATCH exception;
  pragma EXCEPTION_INIT(ROWTYPE_MISMATCH, '-6504');

  SYS_INVALID_ROWID  EXCEPTION;
  PRAGMA EXCEPTION_INIT(SYS_INVALID_ROWID, '-1410');

  -- The object instance i.e. SELF is null
  SELF_IS_NULL exception;
    pragma EXCEPTION_INIT(SELF_IS_NULL, '-30625');

  CASE_NOT_FOUND exception;
    pragma EXCEPTION_INIT(CASE_NOT_FOUND, '-6592');

  -- Added for USERENV enhancement, bug 1622213.
  USERENV_COMMITSCN_ERROR exception;
    pragma EXCEPTION_INIT(USERENV_COMMITSCN_ERROR, '-1725');

  -- Parallel and pipelined support
  NO_DATA_NEEDED exception;
    pragma EXCEPTION_INIT(NO_DATA_NEEDED, '-6548');
  -- End of 8.2 parallel and pipelined support

  /********** Add new exceptions here **********/

  /********** Function, operators and procedures **********/

  function "EXISTS" return BOOLEAN;
    pragma BUILTIN('EXISTS',10,240,240); -- This is special cased in PH2 -- Pj

  function GREATEST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DATE) return DATE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern NUMBER) return NUMBER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET pattern%CHARSET;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DATE) return DATE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr NUMBER, pat NUMBER, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER,
                   pat NUMBER,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr NUMBER, pat NUMBER, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET expr%CHARSET,
                   res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function DECODE (expr DATE, pat DATE, res NUMBER) return NUMBER;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE,
                   pat DATE,
                   res VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET res%CHARSET;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj
  function DECODE (expr DATE, pat DATE, res DATE) return DATE;
    pragma BUILTIN('DECODE',22,240,240);-- This is special cased in PH2 -- Pj

  function SQLCODE return PLS_INTEGER;
    pragma BUILTIN('SQLCODE',45, 10, 0); -- PEMS_DB, DB_SQLCODE

  function SQLERRM return varchar2;
    pragma FIPSFLAG('SQLERRM', 1452);

  function SQLERRM (code PLS_INTEGER) return varchar2;
    pragma BUILTIN('SQLERRM',46, 10, 1); -- PEMS_DB, DB_SQLERRM
    pragma FIPSFLAG('SQLERRM', 1452);

  function LEVEL return NUMBER;

  function ROWNUM return NUMBER;

  function '='  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('=',2, 3, 1); -- PEMS_INTEGER, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN; -- also <> and ~=
    pragma BUILTIN('!=',5, 3, 2); -- PEMS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<',4, 3, 3);  -- PEMS_INTEGER, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('<=',6, 3, 4); -- PEMS_INTEGER, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>',1, 3, 5); -- PEMS_INTEGER, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('>=',3, 3, 6); -- PEMS_INTEGER, PEMDMGE
    pragma FIPSFLAG('>=', 1450);

  --  Since SQL permits short-circuit evaluation, the 'and' and 'or'
  --  operations will always be interpreted as 'and then' and 'or else'
  --  when they occur in conditional statements.

  function XOR (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('XOR',8, 3, 9); -- PEMS_INTEGER, INT_XOR
    pragma FIPSFLAG('XOR', 1450);

  function 'NOT' (RIGHT BOOLEAN) return BOOLEAN;
    pragma BUILTIN('NOT',9, 3, 10); -- PEMS_INTEGER, INT_NOT

  function 'IS NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);  -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B BOOLEAN) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50); -- PEMS_INTEGER, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 BOOLEAN, B2 BOOLEAN) return BOOLEAN;
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('=',2, 1, 14); -- PEMS_CHAR, PEMDCMEQ (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('=', 1454);
  function '!=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('!=',5, 1, 15);  -- PEMS_CHAR, PEMDCMNE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('!=', 1454);
  function '<'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<',4, 1, 16); -- PEMS_CHAR, PEMDCMLT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<', 1454);
  function '<=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('<=',6, 1, 17); -- PEMS_CHAR, PEMDCMLE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('<=', 1454);
  function '>'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>',1, 1, 18); -- PEMS_CHAR, PEMDCMGT (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>', 1454);
  function '>=' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('>=',3, 1, 19); -- PEMS_CHAR, PEMDCMGE (VARCHAR2 SEMANTICS)
    pragma FIPSFLAG('>=', 1454);

  function '||' (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN('||',25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT VARCHAR2 CHARACTER SET ANY_CS,
                  RIGHT VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET LEFT%CHARSET;
    pragma BUILTIN(CONCAT,25, 1, 7); -- PEMS_CHAR, CHAR_CONCAT
    pragma FIPSFLAG(CONCAT, 1454);

  function LENGTH(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH', 1452);
  -- In SUBSTR, LEN defaults to remainder of string
  -- In substr and instr, a negative value of parameter POS means to
  -- count from the right end of the string.
  function SUBSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  POS PLS_INTEGER,
                  LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  -- Find nth occurrence of str1 in str2 starting at pos
  function INSTR(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);
  function LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);
  function ASCII(ch VARCHAR2 CHARACTER SET ANY_CS)
        return PLS_INTEGER; -- should be ASCII.CHRANGE
    pragma FIPSFLAG('ASCII', 1452);
  function ASCIISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('ASCIISTR', 1452);
  function UNISTR(ch VARCHAR2 CHARACTER SET ANY_CS)
        return NVARCHAR2;
    pragma FIPSFLAG('UNISTR', 1452);
  function CHR(n PLS_INTEGER) return varchar2;  -- N should be ASCII.CHRANGE
    pragma FIPSFLAG('CHR', 1452);
  function " SYS$STANDARD_CHR"(n PLS_INTEGER,csn VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET csn%CHARSET;
    pragma FIPSFLAG(' SYS$STANDARD_CHR', 1452);
  function INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('INITCAP', 1452);
  function SOUNDEX(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('SOUNDEX', 1452);

  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);
  function LPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
  pragma FIPSFLAG('LPAD', 1452);

  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer,
                PAD VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);
  function RPAD(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                LEN pls_integer)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function TRANSLATE(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                     SRC VARCHAR2 CHARACTER SET STR1%CHARSET,
                     DEST VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('TRANSLATE', 1452);

  function REPLACE(SRCSTR VARCHAR2 CHARACTER SET ANY_CS,
                   OLDSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB VARCHAR2 CHARACTER SET SRCSTR%CHARSET := NULL)
        return VARCHAR2 CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);
  function LTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ',
                 TSET VARCHAR2 CHARACTER SET STR1%CHARSET)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);
  function RTRIM(STR1 VARCHAR2 CHARACTER SET ANY_CS := ' ')
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                   pat VARCHAR2 CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'NOT_LIKE' (str VARCHAR2 CHARACTER SET ANY_CS,
                       pat VARCHAR2 CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
        return BOOLEAN;
  function 'IS NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20);  -- PEMS_CHAR, PEMDNUL
  function 'IS NOT NULL' (s VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50); -- PEMS_CHAR, PEMDNUL

  function NVL(s1 VARCHAR2 CHARACTER SET ANY_CS,
               s2 VARCHAR2 CHARACTER SET s1%CHARSET)
        return VARCHAR2 CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);


  function '='  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 1); -- PEMS_NUMBER, PEMDCMEQ
  function '!=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 2); -- PEMS_NUMBER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 3); -- PEMS_NUMBER, PEMDCMLT
  function '<=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 4); -- PEMS_NUMBER, PEMDCMLE
  function '>'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 5); -- PEMS_NUMBER, PEMDCMGT
  function '>=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 6); -- PEMS_NUMBER, PEMDCMGE

  function 'IS NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n NUMBER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_NUMBER, PEMDNUL

  function NVL(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 7); -- PEMS_NUMBER, NUM_NEG
  function ABS(n NUMBER) return NUMBER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('+',14, 2, 8); -- PEMS_NUMBER, NUM_ADD
  function '-' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('-',15, 2, 9); -- PEMS_NUMBER, NUM_SUB
  function '*' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('*',17, 2, 10); -- PEMS_NUMBER, NUM_MUL
  function '/' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma BUILTIN('/',18, 2, 11); -- PEMS_NUMBER, NUM_DIV

  function 'REM' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(n NUMBER) return NUMBER;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(n NUMBER) return NUMBER;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(n NUMBER) return NUMBER;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(n NUMBER) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COS', 1452);
  function SIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SIN', 1452);
  function TAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TAN', 1452);
  function COSH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('COSH', 1452);
  function SINH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('SINH', 1452);
  function TANH(N NUMBER) return NUMBER;
    pragma FIPSFLAG('TANH', 1452);

  function EXP(N NUMBER) return NUMBER;
  function LN(N NUMBER) return NUMBER;

  function BITAND (LEFT pls_integer, RIGHT pls_integer)
        return pls_integer;
  function BITAND (LEFT integer, RIGHT integer)
        return integer;
  function LOG (LEFT NUMBER, RIGHT NUMBER) return NUMBER;

  function TRUNC (n NUMBER, places pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT NUMBER, RIGHT pls_integer := 0) return NUMBER;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (n NUMBER, e NUMBER) return NUMBER;
    pragma FIPSFLAG('POWER', 1452);

  function '='  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('=',2, 12, 1); -- PEMS_DATE, PEMDCMEQ
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT DATE, RIGHT DATE) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',5, 12, 2); -- PEMS_DATE, PEMDCMNE
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<',4, 12, 3); -- PEMS_DATE, PEMDCMLT
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('<=',6, 12, 4); -- PEMS_DATE, PEMDCMLE
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>',1, 12, 5);  -- PEMS_DATE, PEMDCMGT
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT DATE, RIGHT DATE) return BOOLEAN;
    pragma BUILTIN('>=',3, 12, 6);  -- PEMS_DATE, PEMDCMGE
    pragma FIPSFLAG('>=', 1450);

  function '+' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('+',14, 12, 7); -- PEMS_DATE, DATE_ADD1
    pragma FIPSFLAG('+', 1450);
  function '+' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('+',14, 12, 8); -- PEMS_DATE, DATE_ADD2
    pragma FIPSFLAG('+', 1450);
  function '-' (LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('-',15, 12, 9); -- PEMS_DATE, DATE_SUB1
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('-',15, 12, 10); -- PEMS_DATE, DATE_SUB2
    pragma FIPSFLAG('-', 1450);
  function '-' (LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('-',15, 12, 11); -- PEMS_DATE, DATE_SUB3
    pragma FIPSFLAG('-', 1450);

  function LAST_DAY(RIGHT DATE) return DATE;
    pragma BUILTIN('LAST_DAY',38, 12, 12); -- PEMS_DATE, DATE_LAST_DAY
    pragma FIPSFLAG('LAST_DAY', 1450);
  function ADD_MONTHS(LEFT DATE, RIGHT NUMBER) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 13); -- PEMS_DATE, DATE_ADD_MONTHS1
    pragma FIPSFLAG('ADD_MONTHS', 1450);
  function ADD_MONTHS(LEFT NUMBER, RIGHT DATE) return DATE;
    pragma BUILTIN('ADD_MONTHS',39, 12, 14); -- PEMS_DATE, DATE_ADD_MONTHS2
    pragma FIPSFLAG('ADD_MONTHS', 1450);

  function MONTHS_BETWEEN(LEFT DATE, RIGHT DATE) return NUMBER;
    pragma BUILTIN('MONTHS_BETWEEN',42, 12, 15); -- PEMS_DATE, DATE_MONTHS_BET
    pragma FIPSFLAG('MONTHS_BETWEEN', 1450);
  function NEXT_DAY(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('NEXT_DAY',43, 12, 16); -- PEMS_DATE, DATE_NEXT_DAY
    pragma FIPSFLAG('NEXT_DAY', 1450);
  function ROUND(RIGHT DATE) return DATE;
    pragma BUILTIN('ROUND',24, 12, 17); -- PEMS_DATE, DATE_ROUND
    pragma FIPSFLAG('ROUND', 1450);
  function NEW_TIME(RIGHT DATE, MIDDLE VARCHAR2, LEFT VARCHAR2) return DATE;
    pragma FIPSFLAG('NEW_TIME', 1450);

  function 'IS NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 12, 0);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (d DATE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 12, 50);  -- PEMS_DATE, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);
  function NVL (d1 DATE, d2 DATE) return DATE;
    pragma FIPSFLAG('NVL', 1450);

  function TRUNC(LEFT DATE) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 20); -- PEMS_DATE, DATE_TRUNC1
    pragma FIPSFLAG('TRUNC', 1450);
  function TRUNC(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('TRUNC',51, 12, 21); -- PEMS_DATE, DATE_TRUNC2
    pragma FIPSFLAG('TRUNC', 1450);
  function ROUND(LEFT DATE, RIGHT VARCHAR2) return DATE;
    pragma BUILTIN('ROUND',24, 12, 22); -- PEMS_DATE, DATE_ROUND2
    pragma FIPSFLAG('ROUND', 1450);

  function TO_DATE    (RIGHT VARCHAR2 character set any_cs)  return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 10); -- PEMS_CHAR, CHR_CNV_DAT
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT VARCHAR2 character set any_cs,
       RIGHT VARCHAR2 character set LEFT%charset) return DATE;
    pragma BUILTIN('TO_DATE',40, 1, 8); -- PEMS_CHAR, CHR_CNV_DATE
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE (LEFT NUMBER, RIGHT VARCHAR2) return DATE;
    pragma FIPSFLAG('TO_DATE', 1450);

  function TO_DATE(left varchar2 character set any_cs,
                   format varchar2 character set LEFT%charset,
                   parms varchar2 character set LEFT%charset) return date;

  function TO_CHAR (RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',14, 0, 2);

  function TO_CHAR (LEFT DATE, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  function TO_CHAR (LEFT NUMBER, RIGHT VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function TO_NUMBER (RIGHT NUMBER) RETURN NUMBER;
    pragma BUILTIN('TO_NUMBER',14, 0, 1); -- PEMS_QUICK

  function TO_NUMBER (RIGHT VARCHAR2 character set any_cs)    return NUMBER;
    pragma BUILTIN('TO_NUMBER',48, 1, 9); -- PEMS_CHAR, CHR_CNV_NUM

  function TO_NUMBER(left varchar2 character set any_cs,
        format varchar2 character set LEFT%charset)
    return number;
  function TO_NUMBER(left varchar2 character set any_cs,
                     format varchar2 character set LEFT%charset,
                     parms varchar2 character set LEFT%charset)
    return number;

  -- Define SQL predicates.  These don't gen code, so no body is needed.

  -- PRIOR is WEIRD - For now, it will be treated as a function call.
  -- Does the function only take a column name?  how about its use in
  -- a predicate?
  function 'PRIOR'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname NUMBER) return NUMBER;
      pragma FIPSFLAG('PRIOR', 1452);
  function 'PRIOR'(colname DATE) return DATE;
      pragma FIPSFLAG('PRIOR', 1450);

  -- Outer Join has same problem as PRIOR
  function '(+)'(colname VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET colname%CHARSET;
  function '(+)'(colname NUMBER) return NUMBER;
  function '(+)'(colname DATE) return DATE;
      pragma FIPSFLAG('(+)', 1450);

  function '=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ANY', 1450);
  function '=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ANY', 1450);
  function '!=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ANY', 1450);
  function '<ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ANY', 1450);
  function '<=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ANY', 1450);
  function '>ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ANY'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ANY'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ANY', 1450);
  function '>=ANY'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=ALL', 1450);
  function '=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=ALL', 1450);
  function '!=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<ALL', 1450);
  function '<ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=ALL', 1450);
  function '<=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                    RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>ALL', 1450);
  function '>ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=ALL'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=ALL'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=ALL', 1450);
  function '>=ALL'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('=SOME', 1450);
  function '=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '!=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '!=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('!=SOME', 1450);
  function '!=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<SOME', 1450);
  function '<SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '<=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '<=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('<=SOME', 1450);
  function '<=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>SOME', 1450);
  function '>SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  function '>=SOME'  (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                      RIGHT VARCHAR2 CHARACTER SET LEFT%CHARSET)
          return BOOLEAN;
  function '>=SOME'  (LEFT DATE, RIGHT DATE) return BOOLEAN;
      pragma FIPSFLAG('>=SOME', 1450);
  function '>=SOME'  (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;

  -- SQL Transaction routines
  procedure SET_TRANSACTION_USE(vc VARCHAR2);
  procedure COMMIT;
  procedure COMMIT_CM(vc VARCHAR2);
  procedure ROLLBACK_NR;
  procedure ROLLBACK_SV(Save_Point CHAR);
  procedure SAVEPOINT(Save_Point CHAR);

  function SYSDATE return DATE;
    pragma FIPSFLAG('SYSDATE', 1452);

  function UID return PLS_INTEGER;
    pragma FIPSFLAG('UID', 1452);

  function USER return VARCHAR2;

  function USERENV (envstr VARCHAR2) return VARCHAR2;
    pragma FIPSFLAG('USERENV', 1452);

  -- ROWID: this dreadful identifier is supposed to represent a datatype
  -- outside of SQL and and a pseudo-column (function, to us) when inside
  -- a sql statement.  ADA data model doesn't allow for any
  -- function X return X;
  -- so we must special case this.  Yuk.  There's special-case code in ph2nre
  -- which maps "rowid" to "rowid " if we're inside a SQL stmt.
  function "ROWID " return ROWID;
    pragma builtin('ROWID ', 1, 209, 240);  -- this had better never be called.

  function NULLFN (str VARCHAR2) return RAW;
    pragma builtin('NULLFN', 1, 0, 1);

  function HEXTORAW (c VARCHAR2) return RAW;
     pragma builtin('HEXTORAW', 1, 23, 1);

  function RAWTOHEX (r RAW) return VARCHAR2;
     pragma builtin('RAWTOHEX', 1, 23, 2);

  function CHARTOROWID (str VARCHAR2) return ROWID;
    pragma builtin('CHARTOROWID', 1, 0, 1);

  function ROWIDTOCHAR (str ROWID) return VARCHAR2;
    pragma builtin('ROWIDTOCHAR', 1, 0, 1);


  -- Trusted*Oracle additions
  Function ROWLABEL return MLSLABEL;                     -- pseudo column

  Function TO_CHAR(label MLSLABEL, format VARCHAR2) return VARCHAR2;
    pragma BUILTIN('TO_CHAR',90, 4, 19); -- PEMS_DATE, MLS_CNV_CHR1
    pragma FIPSFLAG('TO_CHAR', 1450);

  Function TO_LABEL(label VARCHAR2, format VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 8); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  Function TO_LABEL(label VARCHAR2 ) return  MLSLABEL;
    pragma BUILTIN('TO_LABEL',90, 4, 2); -- PEMS_CHAR, CHR_CNV_MLS
    pragma FIPSFLAG('TO_LABEL', 1450);

  -- vararg routines - icds in stdbdy
  Function LEAST_UB    (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('LEAST_UB',90, 4, 3); -- PEMS_CHAR, CHR_CNV_MLS
  Function GREATEST_LB (pattern MLSLABEL) return MLSLABEL;
    pragma BUILTIN('GREATEST_LB',90, 4, 4); -- PEMS_CHAR, CHR_CNV_MLS

  Function '>=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '>'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '<'  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '='  (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  Function '!=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;
  function 'IS NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 1, 20); -- same "cod" as IS NULL(varchar2)
  function 'IS NOT NULL' (label MLSLABEL) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 1, 50);

  function NVL(label1 MLSLABEL, label2 MLSLABEL) return MLSLABEL;
    pragma FIPSFLAG('NVL', 1452);

  -- group functions
  Function LUB (label MLSLABEL) return MLSLABEL;
  Function GLB (label MLSLABEL) return MLSLABEL;

  -- end of Trusted*Oracle additions


  -- beginning of NLS routines

  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLSSORT(c VARCHAR2 CHARACTER SET ANY_CS, c2 VARCHAR2) return RAW;
    pragma FIPSFLAG('NLSSORT', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS,
                       parms VARCHAR2 CHARACTER SET ch%CHARSET)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);
  function NLS_INITCAP(ch VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_INITCAP', 1452);

  function LENGTHB(ch VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
    pragma FIPSFLAG('LENGTHB', 1452);
  function SUBSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
        return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);
  function INSTRB(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                 STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                 POS PLS_INTEGER := 1,
                 NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  function TO_SINGLE_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_SINGLE_BYTE', 1452);
  function TO_MULTI_BYTE(c VARCHAR2 CHARACTER SET ANY_CS)
        return VARCHAR2 CHARACTER SET c%CHARSET;
    pragma FIPSFLAG('TO_MULTI_BYTE', 1452);

  -- Next two added for NLS 6/3/92 JEM.
  function TO_CHAR(left date, format varchar2, parms varchar2) return varchar2;
  function TO_CHAR(left number, format varchar2, parms varchar2)
    return varchar2;
  function NLS_CHARSET_NAME(csetid PLS_INTEGER) return VARCHAR2;
  function NLS_CHARSET_ID(csetname VARCHAR2) return PLS_INTEGER;
  function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER)
    return PLS_INTEGER;

  -- end of NLS routines

  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2)
           return VARCHAR2 character set src%charset;
  function CONVERT(src VARCHAR2 character set any_cs,
                   destcset VARCHAR2,
                   srccset VARCHAR2)
          return VARCHAR2 character set src%charset;

  function " SYS$STANDARD_TRANSLATE" (src VARCHAR2 CHARACTER SET ANY_CS,
                                      csn VARCHAR2 CHARACTER SET ANY_CS)
          return VARCHAR2 CHARACTER SET csn%CHARSET;
     pragma FIPSFLAG(' SYS$STANDARD_TRANSLATE',1452);

  function VSIZE (e number ) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e DATE) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);
  function VSIZE (e VARCHAR2 CHARACTER SET ANY_CS) return NUMBER;
      pragma builtin('VSIZE', 1, 0, 1);


  -- dump( expr [,display_format[,start_pos[,length]]]) return VARCHAR2
  function DUMP(e varchar2 character set any_cs,
                df pls_integer := null,sp pls_integer := null,
                len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e number,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  function DUMP(e date,df pls_integer := null,sp pls_integer := null,
                  len pls_integer := null) return VARCHAR2;
      pragma builtin('DUMP', 1, 0, 1);

  --
  -- ACOS, ASIN, ATAN, ATAN2
  --   Inverse Trigonometric functions
  --   These functions return NULL if any of the inputs are NULL
  --
  function ACOS(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(N NUMBER) return NUMBER;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x NUMBER, y NUMBER) return NUMBER;
  pragma FIPSFLAG('ATAN2', 1452);

  --#### This is the end of 7.3 Standard

  -- LOB IS NULL
  function 'IS NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n CLOB CHARACTER SET ANY_CS) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BLOB) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function 'IS NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_NUMBER, PEMDNUL
  function 'IS NOT NULL' (n BFILE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);
  -- end LOB IS NULL

  --****************************************************************
  -- 20 mar 96 =G=> In the following, arguments "1, 1, 1" to pragma BUILTIN
  -- e.g.,                pragma builtin('whatever', 1, 1, 1)
  -- indicate that those three numeric arguments to pragma BUILTIN are unknown,
  -- because they are not yet implemented by the backend.

  function '='  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<ADT_1>", RIGHT "<ADT_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<ADT_1>") return "<ADT_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<ADT_1>", pat "<ADT_1>", res "<ADT_1>")
        return "<ADT_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<ADT_1>", B2 "<ADT_1>") return "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function VALUE (item "<ADT_WITH_OID>") return "<ADT_1>";
    pragma BUILTIN('VALUE', 1, 1, 1);
    pragma FIPSFLAG('VALUE', 1450);

  function REF (item "<ADT_WITH_OID>") return REF "<ADT_1>";
    pragma BUILTIN('REF', 1, 1, 1);
    pragma FIPSFLAG('REF', 1450);

  function DEREF (r REF "<ADT_1>") return "<ADT_1>";
    pragma BUILTIN('DEREF', 1, 1, 1);
    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF ADT

  function 'IS NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function 'IS DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS DANGLING', 1450);

  function 'IS NOT DANGLING' (B REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  function NVL (B1 REF "<ADT_1>", B2 REF "<ADT_1>") return REF "<ADT_1>";
    pragma FIPSFLAG('NVL', 1450);

  function '='  (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('=', 0, 3, 1);
    pragma FIPSFLAG('=', 1450);

  function '!=' (LEFT REF "<ADT_1>", RIGHT REF "<ADT_1>") return BOOLEAN;
    pragma BUILTIN('!=', 0, 3, 2);
    pragma FIPSFLAG('!=', 1450);

  --  function '='  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('=', 1, 1, 1);
  --    pragma FIPSFLAG('=', 1450);
  --
  --  function '!=' (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --    pragma BUILTIN('!=', 1, 1, 1);
  --    pragma FIPSFLAG('!=', 1450);
  --
  --  function '=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ANY'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=ALL'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --  function '!=SOME'  (LEFT "<COLLECTION_1>", RIGHT "<COLLECTION_1>")
  --      return BOOLEAN;
  --
  --  function DECODE (expr "<COLLECTION_1>", pat "<COLLECTION_1>",
  --                                        res "<COLLECTION_1>")
  --      return "<COLLECTION_1>";
  --    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<COLLECTION_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<COLLECTION_1>", B2 "<COLLECTION_1>")
        return "<COLLECTION_1>";
    pragma FIPSFLAG('NVL', 1450);

  function 'IS NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<REF_CURSOR_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<REF_CURSOR_1>", B2 "<REF_CURSOR_1>")
        return "<REF_CURSOR_1>";
    pragma FIPSFLAG('NVL', 1450);

  function EMPTY_CLOB return clob;
  function EMPTY_BLOB return blob;

  function BFILENAME(directory varchar2,filename varchar2) return BFILE;

  function "SYS$LOB_REPLICATION" (x in blob) return blob;
  function "SYS$LOB_REPLICATION" (x in clob character set any_cs)
    return clob character set x%charset;

  --#### This is the end of 8.0 Standard

  --  + overloadings

  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;

  function '+'(LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_UNCONSTRAINED;

  function '+'(LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIME_TZ_UNCONSTRAINED;

  function '+'(LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
               return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
                return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
                return TIME_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
                return TIME_TZ_UNCONSTRAINED ;
  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT date) return date ;

  function '+'(LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return DSINTERVAL_UNCONSTRAINED ;
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return YMINTERVAL_UNCONSTRAINED ;

  -- begin subtract
  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_UNCONSTRAINED)
           return YMINTERVAL_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;
  function '-'(LEFT TIMESTAMP_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
               return TIMESTAMP_UNCONSTRAINED;

  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT"
   (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;
  function '-' (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT" (LEFT TIME_UNCONSTRAINED,
                                      RIGHT TIME_UNCONSTRAINED)
     return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_UNCONSTRAINED ;
  function " SYS$DSINTERVALSUBTRACT"
   (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT TIME_TZ_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED ;
  function  " SYS$DSINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return DSINTERVAL_UNCONSTRAINED ;
  function " SYS$YMINTERVALSUBTRACT" (LEFT date, RIGHT date)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED) return date;
  function '-' (LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date;

  function '-' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '-' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT DSINTERVAL_UNCONSTRAINED)
   return DSINTERVAL_UNCONSTRAINED ;

  -- end subtract

  -- other datetime operators

  function '*' (LEFT number, RIGHT YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT number, RIGHT DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED ;

  function '*' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '*' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;

  function '/' (LEFT YMINTERVAL_UNCONSTRAINED, RIGHT number)
    return YMINTERVAL_UNCONSTRAINED ;
  function '/' (LEFT DSINTERVAL_UNCONSTRAINED, RIGHT number)
    return DSINTERVAL_UNCONSTRAINED ;


  function current_date return date;
  function current_time return TIME_TZ_UNCONSTRAINED;
  function current_timestamp return TIMESTAMP_TZ_UNCONSTRAINED;

  function TO_TIME (RIGHT varchar2 character set any_cs) return
    time_unconstrained;
    pragma BUILTIN('TO_TIME', 0, 15, 1);
    function TO_TIMESTAMP (RIGHT varchar2 character set any_cs)
                           return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 3);
  function TO_TIME_TZ (RIGHT varchar2 character set any_cs)
    return  TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 5);
  function TO_TIMESTAMP_TZ (RIGHT varchar2 character set any_cs)
    return  TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 7);
  function TO_YMINTERVAL (RIGHT varchar2 character set any_cs)
    return  YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_YMINTERVAL', 0, 15, 9);
  function TO_DSINTERVAL (RIGHT varchar2 character set any_cs)
    return  DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('TO_DSINTERVAL', 0, 15, 11);

  -- with nls args
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset,
                   parms varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIME(left varchar2 character set any_cs,
                   format varchar2 character set left%charset)
    return TIME_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset,
                        parms varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP(left varchar2 character set any_cs,
                        format varchar2 character set left%charset)
    return TIMESTAMP_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset,
                           parms varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIMESTAMP_TZ(left varchar2 character set any_cs,
                           format varchar2 character set left%charset)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset,
                      parms varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_TIME_TZ(left varchar2 character set any_cs,
                      format varchar2 character set left%charset)
    return TIME_TZ_UNCONSTRAINED;
  function TO_DSINTERVAL(RIGHT varchar2 character set any_cs,
                         parms varchar2 character set RIGHT%charset)
    return DSINTERVAL_UNCONSTRAINED;

  function NUMTOYMINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return YMINTERVAL_UNCONSTRAINED;
  function NUMTODSINTERVAL(numerator number,
                           units varchar2 character set any_cs)
    return DSINTERVAL_UNCONSTRAINED;

  function '='  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('=',0, 11, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;  -- also <> and ~=
    pragma BUILTIN('!=',0, 11, 2);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<',0, 11, 3);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('<=',0, 11, 4);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>',0, 11, 5);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;
    pragma BUILTIN('>=',0, 11, 6);
    pragma FIPSFLAG('>=', 1450);

  function 'IS NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 14, 0); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NULL', 1450);
  function 'IS NOT NULL' (u UROWID) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 14, 50); -- PEMS_UROWID, PEMDNUL
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function "UROWID " return UROWID;
    pragma builtin('UROWID ', 1, 209, 240);  -- this had better never be called.

  -- New built-in function SYS_GUID, returns globally unique id
  function SYS_GUID return RAW;

  -- New built-in function SYS_CONTEXT
  function SYS_CONTEXT (namespace varchar2, attribute varchar2)
    return varchar2;

  function TRIM(v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  --#### This is the end of 8.1.5 Standard

  -- SYS_CONTEXT now has an additional optional parameter
  function SYS_CONTEXT(namespace varchar2, attribute varchar2,
                       newoptional varchar2)
    return varchar2;

  -- CUBE and ROLLUP are not real functions; they are variants on the GROUP
  -- BY clause (GROUP BY CUBE (...) and GROUP BY ROLLUP (...)). They have
  -- been added here as functions to avoid name capture issues.
  --
  -- Note that both CUBE and ROLLUP look like true vararg functions with
  -- *no* repeating pattern of formals - hence they are special cased in
  -- the overloading code.
  function CUBE return NUMBER;
  function ROLLUP return NUMBER;

  -- The GROUPING function must be used in conjunction with CUBE and ROLLUP
  -- in the GROUP BY clause. The type of the parameter to GROUPING can be
  -- any type that can appear in a GROUP BY list.
  function GROUPING(v VARCHAR2) return NUMBER;
  function GROUPING(a "<ADT_1>") return NUMBER;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v VARCHAR2 CHARACTER SET ANY_CS)
    return VARCHAR2 CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 VARCHAR2 CHARACTER SET ANY_CS ,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   VARCHAR2 CHARACTER SET ANY_CS ,
                                 TSET   VARCHAR2 CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;

  --#### This is the end of the supported parts of 8.1.6 Standard

  --## Support for ANSI datetime data types is under development.
  --## The following operations, as well as the related types and
  --## operations defined above in the 8.1.5 section, are not yet
  --## available for use and are still subject to change.

  --- datetime equivalence
  function '='  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_UNCONSTRAINED,
                 RIGHT TIME_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_UNCONSTRAINED,
                 RIGHT TIMESTAMP_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIME_TZ_UNCONSTRAINED,
                 RIGHT TIME_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT YMINTERVAL_UNCONSTRAINED,
                 RIGHT YMINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT DSINTERVAL_UNCONSTRAINED,
                 RIGHT DSINTERVAL_UNCONSTRAINED) return BOOLEAN;

  function TO_TIME (RIGHT TIME_TZ_UNCONSTRAINED)  return TIME_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME', 0, 15, 13);
  function TO_TIME_TZ (RIGHT TIME_UNCONSTRAINED)  return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIME_TZ', 0, 15, 14);
  function TO_TIMESTAMP (RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 15);
  function TO_TIMESTAMP_TZ (RIGHT TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 16);

  function '-'
      (LEFT TIME_UNCONSTRAINED, RIGHT TIME_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_UNCONSTRAINED, RIGHT TIMESTAMP_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIME_TZ_UNCONSTRAINED, RIGHT TIME_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
  function '-'
      (LEFT TIMESTAMP_TZ_UNCONSTRAINED, RIGHT TIMESTAMP_TZ_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  -- timezone functions
  function SYS_AT_TIME_ZONE(t time_tz_unconstrained,
                            i varchar2) RETURN time_tz_unconstrained;
  function SYS_AT_TIME_ZONE(t timestamp_tz_unconstrained,
                            i varchar2) RETURN timestamp_tz_unconstrained;
  FUNCTION systimestamp RETURN timestamp_tz_unconstrained;
  FUNCTION dbtimezone RETURN varchar2;
  FUNCTION sessiontimezone RETURN varchar2;
  FUNCTION localtimestamp RETURN timestamp_unconstrained;
  FUNCTION localtime RETURN time_unconstrained;

  function TO_TIMESTAMP (RIGHT DATE)  return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 17);

  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
  function '+'(LEFT yminterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '+'(LEFT dsinterval_unconstrained,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT yminterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;
  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT dsinterval_unconstrained)
    return TIMESTAMP_LTZ_UNCONSTRAINED ;

  function " SYS$DSINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;
  function " SYS$YMINTERVALSUBTRACT"(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                                     RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return yminterval_unconstrained;

  function '-'(LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
               RIGHT TIMESTAMP_LTZ_UNCONSTRAINED)
    return dsinterval_unconstrained;

  function '='  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_TZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;

  function '='  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '!=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '<=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>'  (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function '>=' (LEFT TIMESTAMP_LTZ_UNCONSTRAINED,
                 RIGHT TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;

  function SYS_LITERALTOYMINTERVAL(numerator varchar2, units varchar2)
    return YMINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTODSINTERVAL(numerator varchar2, units varchar2)
    return DSINTERVAL_UNCONSTRAINED;
  function SYS_LITERALTOTIME(numerator varchar2)
    return TIME_UNCONSTRAINED;
  function SYS_LITERALTOTZTIME(numerator varchar2)
    return TIME_TZ_UNCONSTRAINED;
  function SYS_LITERALTOTIMESTAMP(numerator varchar2)
    return TIMESTAMP_UNCONSTRAINED;
  function SYS_LITERALTOTZTIMESTAMP(numerator varchar2)
    return TIMESTAMP_TZ_UNCONSTRAINED;
  function SYS_LITERALTODATE(numerator varchar2) return DATE;


  -- Explicit conversions between date and datetime
  function TO_TIMESTAMP(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP', 0, 15, 24);

  function TO_TIMESTAMP_TZ(ARG DATE) return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 27);

  function TO_TIMESTAMP_TZ(ARG TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 26);

  -- IS [NOT] NULL / NVL for datetime
  function 'IS NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_UNCONSTRAINED,
                b2 TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;

  function 'IS NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIME_TZ_UNCONSTRAINED, b2 TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_UNCONSTRAINED,
                b2 TIMESTAMP_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_TZ_UNCONSTRAINED, b2 TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;

  function 'IS NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 TIMESTAMP_LTZ_UNCONSTRAINED,
                b2 TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;

  function 'IS NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 YMINTERVAL_UNCONSTRAINED, b2 YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;

  function 'IS NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function 'IS NOT NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;
  function NVL (b1 DSINTERVAL_UNCONSTRAINED, b2 DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;

  function " SYS$EXTRACT_FROM"
              (T TIME_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (T DATE,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I YMINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;
  function " SYS$EXTRACT_FROM"
              (I DSINTERVAL_UNCONSTRAINED,FIELD VARCHAR2) return NUMBER;

  -- ##########      8.2 LOB Built-in Functions       ######## --

  -- LENGTH --
  function LENGTH(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(ch CLOB CHARACTER SET ANY_CS) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  function LENGTH(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTH', 1452);

  function LENGTHB(bl BLOB) return integer;
    pragma FIPSFLAG('LENGTHB', 1452);

  -- SUBSTR --
  function SUBSTR(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR', 1452);

  function SUBSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  POS INTEGER,
                  LEN INTEGER := 18446744073709551615)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRB', 1452);

  -- INSTR --
  function INSTR(STR1 CLOB CHARACTER SET ANY_CS,
                 STR2 CLOB CHARACTER SET STR1%CHARSET,
                 POS INTEGER := 1,
                 NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTR', 1452);

  function INSTRB(STR1 CLOB CHARACTER SET ANY_CS,
                  STR2 CLOB CHARACTER SET STR1%CHARSET,
                  POS INTEGER := 1,
                  NTH INTEGER := 1) return INTEGER;
    pragma FIPSFLAG('INSTRB', 1452);

  -- CONCAT --
  function '||' (LEFT CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG('||', 1454);

  function CONCAT(LEFT CLOB CHARACTER SET ANY_CS,
                  RIGHT CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET LEFT%CHARSET;
    pragma FIPSFLAG(CONCAT, 1454);

  -- UPPER --
  function UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('UPPER', 1452);

  -- LOWER --
  function LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('LOWER', 1452);

  -- LPAD --
  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  function LPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LPAD', 1452);

  -- RPAD --
  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer,
                PAD CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  function RPAD(STR1 CLOB CHARACTER SET ANY_CS,
                LEN integer)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RPAD', 1452);

  -- LTRIM --
  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  function LTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('LTRIM', 1452);

  -- RTRIM --
  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS,
                 TSET CLOB CHARACTER SET STR1%CHARSET)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  function RTRIM(STR1 CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('RTRIM', 1452);

  -- TRIM --
  function TRIM(v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(x). No trim set.
  function " SYS$STANDARD_TRIM" (v CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET v%CHARSET;

  -- This is for TRIM(LEADING/TRAILING FROM x). No trim set.
  function " SYS$STANDARD_TRIM" (STR1 CLOB CHARACTER SET ANY_CS ,
                               TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;

  -- General TRIM. LEADING, TRAILING and BOTH options as 3rd argument.
  -- This one takes a trim set.
  function " SYS$STANDARD_TRIM" (STR1   CLOB CHARACTER SET ANY_CS ,
                                 TSET   CLOB CHARACTER SET STR1%CHARSET,
                                 TRFLAG PLS_INTEGER)
    return CLOB CHARACTER SET STR1%CHARSET;


  -- LIKE --
  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE' (str CLOB CHARACTER SET ANY_CS,
                   pat CLOB CHARACTER SET str%CHARSET,
                   esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE' (str CLOB CHARACTER SET ANY_CS,
                       pat CLOB CHARACTER SET str%CHARSET,
                       esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  -- NVL --
  function NVL(s1 CLOB CHARACTER SET ANY_CS,
               s2 CLOB CHARACTER SET s1%CHARSET)
    return CLOB CHARACTER SET s1%CHARSET;
    pragma FIPSFLAG('NVL', 1452);

  -- REPLACE --
  function REPLACE(SRCSTR CLOB CHARACTER SET ANY_CS,
                   OLDSUB CLOB CHARACTER SET SRCSTR%CHARSET,
                   NEWSUB CLOB CHARACTER SET SRCSTR%CHARSET := NULL)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
    pragma FIPSFLAG('REPLACE', 1452);

  -- LOB RELATIONAL OPERATORS --

  Function '='  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB CHARACTER SET ANY_CS,
	         RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB CHARACTER SET ANY_CS,
                 RIGHT CLOB CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  CLOB     CHARACTER SET ANY_CS,
                 RIGHT VARCHAR2 CHARACTER SET ANY_CS) return BOOLEAN;

  Function '='  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '!=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<'  (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '>=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;
  Function '<=' (LEFT  VARCHAR2 CHARACTER SET ANY_CS,
                 RIGHT CLOB     CHARACTER SET ANY_CS) return BOOLEAN;

  /* LOB-related conversion functions */
  function TO_CLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS) return CLOB;
    pragma BUILTIN('TO_CLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  function TO_BLOB(RIGHT RAW) return BLOB;
    pragma BUILTIN('TO_BLOB', 0, 15, 30); -- OPC_CVT_RAW2BLB
  function TO_RAW(RIGHT BLOB) return RAW;
    pragma BUILTIN('TO_RAW', 0, 15, 32); -- OPC_CVT_BLB2RAW

  -- ####### end of 8.2 LOB Built-in Functions  ######## --

  function NULLIF(v1 VARCHAR2, v2 VARCHAR2) return VARCHAR2;
  function NULLIF(v1 BOOLEAN, v2 BOOLEAN) return VARCHAR2;
  function NULLIF(a1 "<ADT_1>", a2 "<ADT_1>") return VARCHAR2;

  function COALESCE return VARCHAR2;

  /* Daylight Saving Time Functions */
  FUNCTION tz_offset(region VARCHAR2)  RETURN VARCHAR2;
  FUNCTION from_tz(t TIMESTAMP_UNCONSTRAINED,timezone VARCHAR2)
    RETURN timestamp_tz_unconstrained;

  function " SYS$EXTRACT_STRING_FROM"
              (T TIME_TZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_TZ_UNCONSTRAINED,FIELD VARCHAR2) return VARCHAR2;
  function " SYS$EXTRACT_STRING_FROM"
              (T TIMESTAMP_LTZ_UNCONSTRAINED,FIELD varchar2) return VARCHAR2;

  function INSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR2', 1452);

  function INSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTR4', 1452);

  function INSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                  STR2 VARCHAR2 CHARACTER SET STR1%CHARSET,
                  POS PLS_INTEGER := 1,
                  NTH POSITIVE := 1) return PLS_INTEGER;
    pragma FIPSFLAG('INSTRC', 1452);

  function LENGTH2(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH2', 1452);

  function LENGTH4(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTH4', 1452);

  function LENGTHC(ch VARCHAR2 CHARACTER SET ANY_CS) return natural;
    pragma FIPSFLAG('LENGTHC', 1452);

  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE2' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKE4' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                    pat VARCHAR2 CHARACTER SET str%CHARSET,
                    esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;
  function 'NOT_LIKEC' (str VARCHAR2 CHARACTER SET ANY_CS,
                        pat VARCHAR2 CHARACTER SET str%CHARSET,
                        esc VARCHAR2 CHARACTER SET str%CHARSET)
    return BOOLEAN;

  function SUBSTR2(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR2', 1452);

  function SUBSTR4(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTR4', 1452);

  function SUBSTRC(STR1 VARCHAR2 CHARACTER SET ANY_CS,
                   POS PLS_INTEGER,
                   LEN PLS_INTEGER := 2147483647)
    return VARCHAR2 CHARACTER SET STR1%CHARSET;
    pragma FIPSFLAG('SUBSTRC', 1452);

  /**** char <--> nchar conversion functions in Unicode project ********/

  function TO_NCHAR(RIGHT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',14, 0, 2);

  function TO_NCLOB(cl CLOB CHARACTER SET ANY_CS) return NCLOB;
  function TO_CLOB(cl CLOB CHARACTER SET ANY_CS) return CLOB;

  function TO_NCLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return NCLOB;
    pragma BUILTIN('TO_NCLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB
  /* convert to either CLOB or NCLOB respectively if parm is char or nchar */
  function TO_ANYLOB(RIGHT VARCHAR2 CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET RIGHT%CHARSET;
    pragma BUILTIN('TO_ANYLOB', 0, 15, 29); -- OPC_CVT_CHR2CLB

  /* Followings are the same builtin op codes as without N prefix functions,
   * implementation relys on impilcit conversion MCODEs
   */
  function TO_NCHAR (LEFT DATE, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 12, 19); -- PEMS_DATE, DAT_CNV_CHR1
    pragma FIPSFLAG('TO_NCHAR', 1450);
  function TO_NCHAR (LEFT NUMBER, FORMAT NVARCHAR2) return NVARCHAR2;
    pragma BUILTIN('TO_NCHAR',41, 2, 14); -- PEMS_NUMBER, NUM_CNV_CHR

  function NHEXTORAW (c NVARCHAR2) return RAW;
    pragma builtin('NHEXTORAW', 1, 23, 1);
  function RAWTONHEX (r RAW) return NVARCHAR2;
    pragma builtin('RAWTONHEX', 1, 23, 2);
  function NCHARTOROWID (str NVARCHAR2) return ROWID;
    pragma builtin('NCHARTOROWID', 1, 0, 1);
  function ROWIDTONCHAR (str ROWID) return NVARCHAR2;
    pragma builtin('ROWIDTONCHAR', 1, 0, 1);

  function NCHR(n pls_integer) return NVARCHAR2;

  /* implemented by icd calls as the same as TO_CHAR */
  function TO_NCHAR(left date, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left number, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  /* implemented as a icd call, return TRUE if nchar, otherwise FALSE */
  function ISNCHAR(c VARCHAR2 character set any_cs) return boolean;

  /************ end of char <--> nchar conversion functions ************/

  /* Create overloads for all standard functions that work with <ADT_1> for
     <OPAQUE_1> */
  function '='  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('=', 1, 1, 1);
    pragma FIPSFLAG('=', 1450);
  function '!=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('!=', 1, 1, 1);
    pragma FIPSFLAG('!=', 1450);
  function '<'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<', 1, 1, 1);
    pragma FIPSFLAG('<', 1450);
  function '<=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('<=', 1, 1, 1);
    pragma FIPSFLAG('<=', 1450);
  function '>'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>', 1, 1, 1);
    pragma FIPSFLAG('>', 1450);
  function '>=' (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('>=', 1, 1, 1);
    pragma FIPSFLAG('>=', 1450);

  function '=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ANY'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=ALL'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '!=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '<=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;
  function '>=SOME'  (LEFT "<OPAQUE_1>", RIGHT "<OPAQUE_1>") return BOOLEAN;

  -- Outer Join
  function '(+)'  ( colname "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('(+)', 1450);

  --  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.
  --  function GREATEST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('GREATEST', 1, 1, 1);

  --  function LEAST (pattern "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('LEAST', 1, 1, 1);

  function DECODE (expr "<OPAQUE_1>", pat "<OPAQUE_1>", res "<OPAQUE_1>")
    return "<OPAQUE_1>";
    pragma BUILTIN('DECODE', 1, 1, 1);

  function 'IS NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 3, 0);
    pragma FIPSFLAG('IS NULL', 1450);

  function 'IS NOT NULL' (B "<OPAQUE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 3, 50);
    pragma FIPSFLAG('IS NOT NULL', 1450);

  function NVL (B1 "<OPAQUE_1>", B2 "<OPAQUE_1>") return "<OPAQUE_1>";
    pragma FIPSFLAG('NVL', 1450);

  --  REFs to opaques are not supported yet.
  --  function VALUE (item "<ADT_WITH_OID>") return "<OPAQUE_1>";
  --    pragma BUILTIN('VALUE', 1, 1, 1);
  --    pragma FIPSFLAG('VALUE', 1450);

  --  function REF (item "<ADT_WITH_OID>") return REF "<OPAQUE_1>";
  --    pragma BUILTIN('REF', 1, 1, 1);
  --    pragma FIPSFLAG('REF', 1450);

  --  function DEREF (r REF "<OPAQUE_1>") return "<OPAQUE_1>";
  --    pragma BUILTIN('DEREF', 1, 1, 1);
  --    pragma FIPSFLAG('DEREF', 1450);

  -- overloadings for REF OPAQUE

  --  function 'IS NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NULL', 0, 3, 0);
  --    pragma FIPSFLAG('IS NULL', 1450);

  --  function 'IS NOT NULL' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma FIPSFLAG('IS NOT NULL', 1450);

  --  function 'IS DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS DANGLING', 1450);

  --  function 'IS NOT DANGLING' (B REF "<OPAQUE_1>") return BOOLEAN;
  --    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);
  --    pragma FIPSFLAG('IS NOT DANGLING', 1450);

  --  function NVL (B1 REF "<OPAQUE_1>", B2 REF "<OPAQUE_1>")
  --    return REF "<OPAQUE_1>";
  --    pragma FIPSFLAG('NVL', 1450);

  --  function '='  (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('=', 0, 3, 1);
  --    pragma FIPSFLAG('=', 1450);

  --  function '!=' (LEFT REF "<OPAQUE_1>", RIGHT REF "<OPAQUE_1>")
  --    return BOOLEAN;
  --    pragma BUILTIN('!=', 0, 3, 2);
  --    pragma FIPSFLAG('!=', 1450);

  function GROUPING(a "<OPAQUE_1>") return NUMBER;
  function NULLIF(a1 "<OPAQUE_1>", a2 "<OPAQUE_1>") return VARCHAR2;

  function GREATEST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIME_TZ_UNCONSTRAINED)
    return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj
  function GREATEST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2 -- Pj

  function LEAST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIME_TZ_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_UNCONSTRAINED)
    return TIMESTAMP_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_TZ_UNCONSTRAINED)
    return TIMESTAMP_TZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)
    return TIMESTAMP_LTZ_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern YMINTERVAL_UNCONSTRAINED)
    return YMINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj
  function LEAST (pattern DSINTERVAL_UNCONSTRAINED)
    return DSINTERVAL_UNCONSTRAINED;
    pragma BUILTIN('LEAST',12,240,240);-- This is special cased in PH2 -- Pj

  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left TIMESTAMP_LTZ_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left YMINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2,
                   parms VARCHAR2) return VARCHAR2;
  function TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2)
    return VARCHAR2;

  -- CONVERT FOR LOB --
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;
  function CONVERT(SRCSTR CLOB CHARACTER SET ANY_CS,
                   DSTCSN VARCHAR2,
                   SRCCSN VARCHAR2)
    return CLOB CHARACTER SET SRCSTR%CHARSET;

  -- NLS_UPPER/NLS_LOWER FOR LOB --
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_UPPER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_UPPER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS,
                     parms VARCHAR2 CHARACTER SET ch%CHARSET)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);
  function NLS_LOWER(ch CLOB CHARACTER SET ANY_CS)
    return CLOB CHARACTER SET ch%CHARSET;
    pragma FIPSFLAG('NLS_LOWER', 1452);

  function COMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS)
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('COMPOSE', 1452);
  function DECOMPOSE(ch VARCHAR2 CHARACTER SET ANY_CS,
                     canmode in VARCHAR2 DEFAULT 'CANONICAL')
    return varchar2 character set ch%charset;
    pragma FIPSFLAG('DECOMPOSE', 1452);
  FUNCTION SYS_EXTRACT_UTC(t timestamp_tz_unconstrained)
    return TIMESTAMP_UNCONSTRAINED;

  -- Begin REGEXP Support (10iR1) --

  -- REGEXP_LIKE --
  function REGEXP_LIKE (srcstr   VARCHAR2 CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  function REGEXP_LIKE (srcstr   CLOB CHARACTER SET ANY_CS,
                        pattern  VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        modifier VARCHAR2 DEFAULT NULL)
    return BOOLEAN;
    pragma FIPSFLAG('REGEXP_LIKE', 1452);

  -- REGEXP_INSTR --
  function REGEXP_INSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        occurrence  PLS_INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);

  function REGEXP_INSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        occurrence  INTEGER := 1,
                        returnparam PLS_INTEGER := 0,
                        modifier    VARCHAR2 DEFAULT NULL,
                        subexpression PLS_INTEGER := 0)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_INSTR', 1452);


  -- REGEXP_SUBSTR --
  function REGEXP_SUBSTR(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    PLS_INTEGER := 1,
                         occurrence  PLS_INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  function REGEXP_SUBSTR(srcstr      CLOB CHARACTER SET ANY_CS,
                         pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                         position    INTEGER := 1,
                         occurrence  INTEGER := 1,
                         modifier    VARCHAR2 DEFAULT NULL,
                         subexpression PLS_INTEGER := 0)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_SUBSTR', 1452);

  -- REGEXP_REPLACE --
  function REGEXP_REPLACE(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    PLS_INTEGER := 1,
                          occurrence  PLS_INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return VARCHAR2 CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  CLOB CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  function REGEXP_REPLACE(srcstr      CLOB CHARACTER SET ANY_CS,
                          pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                          replacestr  VARCHAR2 CHARACTER SET srcstr%CHARSET
                                        DEFAULT NULL,
                          position    INTEGER := 1,
                          occurrence  INTEGER := 0,
                          modifier    VARCHAR2 DEFAULT NULL)
    return CLOB CHARACTER SET srcstr%CHARSET;
    pragma FIPSFLAG('REGEXP_REPLACE', 1452);

  -- End REGEXP Support --

  -- binary_float and binary_double functions and operators.
  function TO_BINARY_FLOAT (RIGHT BINARY_FLOAT) RETURN BINARY_FLOAT;
    pragma BUILTIN('TO_BINARY_FLOAT',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;
  function TO_BINARY_FLOAT (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_FLOAT;

  function TO_BINARY_DOUBLE (RIGHT BINARY_DOUBLE) RETURN BINARY_DOUBLE;
    pragma BUILTIN('TO_BINARY_DOUBLE',14, 0, 1); -- PEMS_QUICK
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;
  function TO_BINARY_DOUBLE (LEFT VARCHAR2 CHARACTER SET ANY_CS,
                     FORMAT VARCHAR2 CHARACTER SET LEFT%CHARSET,
                     PARMS VARCHAR2 CHARACTER SET LEFT%CHARSET)
    RETURN BINARY_DOUBLE;

  function 'IS NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT NAN' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT NAN' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (N NUMBER) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;
  function 'IS NOT INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;

  function TO_CHAR (left binary_float, format varchar2)
    return VARCHAR2;
  function TO_CHAR (left binary_double, format varchar2)
    return VARCHAR2;

  function TO_CHAR(left binary_float, format varchar2, parms varchar2)
    return varchar2;
  function TO_CHAR(left binary_double, format varchar2, parms varchar2)
    return varchar2;

  function TO_NCHAR(left binary_float, format nvarchar2) return NVARCHAR2;
  function TO_NCHAR(left binary_double, format nvarchar2) return NVARCHAR2;

  function TO_NCHAR(left binary_float, format nvarchar2, parms nvarchar2)
    return nvarchar2;
  function TO_NCHAR(left binary_double, format nvarchar2, parms nvarchar2)
    return nvarchar2;

  function 'REMAINDER'(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(n1 NUMBER, n2 NUMBER) return NUMBER;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG(REMAINDER, 1452);
  function 'REMAINDER'(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('REMAINDER', 1452);
  function REMAINDER(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG(REMAINDER, 1452);

  function '='  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 15);
  function '!=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('!=',5, 2, 16);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 17);
  function '<=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 18);
  function '>'  (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 19);
  function '>=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 20);

  function 'IS NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_FLOAT) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 23);
  function ABS(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('+',14, 2, 24);
  function '-' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('-',15, 2, 25);
  function '*' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('*',17, 2, 26);
  function '/' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('/',18, 2, 27);

  function 'REM' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(F1 BINARY_FLOAT, F2 BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('MOD', 1452);

  function FLOOR(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('CEIL', 1452);
  function SIGN(f BINARY_FLOAT) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);
  function SQRT(f BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('SQRT', 1452);

  function TRUNC (F BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_FLOAT) return BINARY_FLOAT;
    pragma FIPSFLAG('ROUND', 1452);

  function '='  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 28);
  function '!=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 29);
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 30);
  function '<=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 31);
  function '>'  (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 32);
  function '>=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 33);

  function 'IS NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0);
  function 'IS NOT NULL' (n BINARY_DOUBLE) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50);

  function NVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('NVL', 1452);

  function '+' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 0, 1);
  function '-' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 36);
  function ABS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ABS', 1452);

  function ACOS(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ACOS', 1452);

  function ASIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ASIN', 1452);

  function ATAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN', 1452);

  function ATAN2(x BINARY_DOUBLE, y BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ATAN2', 1452);

  function '+' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('+',14, 2, 37);
  function '-' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('-',15, 2, 38);
  function '*' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('*',17, 2, 39);
  function '/' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('/',18, 2, 40);

  function 'REM' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('REM', 1452);
  function 'MOD'(D1 BINARY_DOUBLE, D2 BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('MOD', 1452);

  function '**' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)
    return BINARY_DOUBLE;
    pragma FIPSFLAG('**', 1452);

  function FLOOR(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('FLOOR', 1452);
  function CEIL(D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('CEIL', 1452);
  function SQRT(d BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('SQRT', 1452);
  function SIGN(d BINARY_DOUBLE) return SIGNTYPE;
  pragma FIPSFLAG('SIGN', 1452);

  function COS(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SIN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TAN(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function COSH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function SINH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function TANH(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function EXP(D BINARY_DOUBLE) return BINARY_DOUBLE;
  function LN(D BINARY_DOUBLE) return BINARY_DOUBLE;

  function LOG (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;

  function TRUNC (D BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (LEFT BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('ROUND', 1452);

  function POWER (d BINARY_DOUBLE, e BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma FIPSFLAG('POWER', 1452);

  function NANVL(n1 NUMBER, n2 NUMBER) return NUMBER;
  function NANVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;
  function NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;

  function GREATEST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function GREATEST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_FLOAT) return BINARY_FLOAT;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2
  function LEAST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2


  function '+' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 0, 1); -- PEMS_QUICK
  function '-' (RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',15, 2, 41);
  function ABS(I PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('ABS', 1452);

  function '+' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('+',14, 2, 42);
  function '-' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('-',14, 2, 43);
  function '*' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('*',14, 2, 44);

  function '='  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('=',2, 2, 45); -- PEMS_PLS_INTEGER, PEMDCMEQ
  function '!=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    -- also <> and ~=
    pragma BUILTIN('!=',5, 2, 46); -- PEMS_PLS_INTEGER, PEMDCMNE
    pragma FIPSFLAG('!=', 1452);
  function '<'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<',4, 2, 47); -- PEMS_PLS_INTEGER, PEMDCMLT
  function '<=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('<=',6, 2, 48); -- PEMS_PLS_INTEGER, PEMDCMLE
  function '>'  (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>',1, 2, 49); -- PEMS_PLS_INTEGER, PEMDCMGT
  function '>=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('>=',3, 2, 51); -- PEMS_PLS_INTEGER, PEMDCMGE

  function 'IS NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NULL', 0, 2, 0); -- PEMS_PLS_INTEGER, PEMDNUL
  function 'IS NOT NULL' (I PLS_INTEGER) return BOOLEAN;
    pragma BUILTIN('IS NOT NULL', 0, 2, 50); -- PEMS_PLS_INTEGER, PEMDNUL

  function NVL(I1 PLS_INTEGER, I2 PLS_INTEGER) return PLS_INTEGER;
    pragma FIPSFLAG('NVL', 1452);

  function TRUNC (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('TRUNC', 1452);

  function ROUND (i pls_integer, places pls_integer := 0) return pls_integer;
    pragma FIPSFLAG('ROUND', 1452);

  function SIGN(i PLS_INTEGER) return SIGNTYPE;
    pragma FIPSFLAG('SIGN', 1452);

  function GREATEST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('GREATEST',12,240,240);-- This is special cased in PH2
  function LEAST (pattern PLS_INTEGER) return PLS_INTEGER;
    pragma BUILTIN('LEAST',13,240,240);-- This is special cased in PH2

  -- MultiSet Functions and Operators.

  -- Equality
  function '='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('=',2, 16, 1);

  function '!='(collection1 IN "<TABLE_1>",collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('!=',2, 16, 2);

  function CARDINALITY (collection IN "<TABLE_1>") return PLS_INTEGER;

  function SET (collection IN "<TABLE_1>") return "<TABLE_1>";
    pragma BUILTIN('SET',18, 2, 40);-- Dummy

  function 'IS A SET' (collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS A SET',18, 2, 40);-- Dummy
  function 'IS NOT A SET'(collection IN  "<TABLE_1>") return BOOLEAN;
    pragma BUILTIN('IS NOT A SET',18, 2, 40);-- Dummy

  function 'IS EMPTY' (collection IN  "<TABLE_1>") return BOOLEAN;
  function 'IS NOT EMPTY'(collection IN  "<TABLE_1>") return BOOLEAN;

  -- IS A SUBMULTISET OF
  function 'SUBMULTISET' (collection IN  "<TABLE_1>",
                          collection2 IN "<TABLE_1>")
    return BOOLEAN;
      pragma BUILTIN('SUBMULTISET',18, 2, 40);

  function 'MULTISET_UNION_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
      pragma BUILTIN('MULTISET_UNION_ALL',18, 2, 40);

  function 'MULTISET_UNION_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_UNION_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_EXCEPT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_EXCEPT_DISTINCT',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_ALL' (collection IN  "<TABLE_1>",
                                 collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_ALL',18, 2, 40);-- Dummy

  function 'MULTISET_INTERSECT_DISTINCT' (collection IN  "<TABLE_1>",
                                      collection2 IN "<TABLE_1>")
    return "<TABLE_1>";
    pragma BUILTIN('MULTISET_INTERSECT_DISTINCT',18, 2, 40);-- Dummy

  -- These are dummy procedures for correct management of new control
  -- statements added to PL/SQL. They ensure local procedures which have the
  -- same names as newly introduced keywords are not masked by those keywords.

  procedure continue;

  -- REGEXP_COUNT --
  function REGEXP_COUNT(srcstr      VARCHAR2 CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    PLS_INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return PLS_INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  function REGEXP_COUNT(srcstr      CLOB CHARACTER SET ANY_CS,
                        pattern     VARCHAR2 CHARACTER SET srcstr%CHARSET,
                        position    INTEGER := 1,
                        modifier    VARCHAR2 DEFAULT NULL)
    return INTEGER;
    pragma FIPSFLAG('REGEXP_COUNT', 1452);

  --#### All user-visible declarations should preceed this point.  The
  --#### following are implementation-oriented pragmas that may need
  --#### editing in the future; we would prefer to be able to edit them
  --#### without affecting the rft numbering of user-visible items.

  --#### interface pragmas

  --#### Note that for any ICD which maps directly to a PVM
  --#### Opcode MUST be mapped to pes_dummy.
  --#### An ICD which invokes another ICD by flipping operands is
  --#### mapped to pes_flip, and an ICD whose result is the inverse of
  --#### another ICD is mapped to pes_invert
  --#### New ICDs should be placed at the end of this list, and a
  --#### corresponding entry must be made in the ICD table in pdz7

  PRAGMA interface(c,length,"pes_dummy",1);
  PRAGMA interface(c,substr,"pes_dummy",1);
  PRAGMA interface(c,instr,"pesist",1);
  PRAGMA interface(c,UPPER,"pesupp",1);
  PRAGMA interface(c,LOWER,"peslow",1);
  PRAGMA interface(c,ASCII,"pesasc");
  PRAGMA interface(c,ASCIISTR,"pesastr");
  PRAGMA interface(c,UNISTR,"pesustr");
  PRAGMA interface(c,CHR,"peschr");
  PRAGMA interface(c," SYS$STANDARD_CHR","peschr");
  PRAGMA interface(c,INITCAP,"pesicp");
  PRAGMA interface(c,LPAD,"peslpd",1);
  PRAGMA interface(c,LPAD,"peslpd",2);
  PRAGMA interface(c,RPAD,"pesrpd",1);
  PRAGMA interface(c,RPAD,"pesrpd",2);
  PRAGMA interface(c,REPLACE,"pesrep",1);
  PRAGMA interface(c,LTRIM,"pesltr",1);
  PRAGMA interface(c,LTRIM,"pesltr",2);
  PRAGMA interface(c,RTRIM,"pesrtr",1);
  PRAGMA interface(c,RTRIM,"pesrtr",2);
  PRAGMA interface(c,'LIKE',"peslik",1);
  PRAGMA interface(c,'LIKE',"pesli2",2);
  PRAGMA interface(c,ABS,"pes_dummy",1);
  PRAGMA interface(c,'MOD',"pesmod", 1);
  PRAGMA interface(c,floor,"pesflo", 1);
  PRAGMA interface(c,CEIL,"pescei", 1);
  PRAGMA interface (c, SQRT, "pessqt", 1);
  PRAGMA interface(c,SIGN,"pessgn", 1);
  PRAGMA interface(c,cos,"pescos", 1);
  PRAGMA interface(c,sin,"pessin",1);
  PRAGMA interface(c,TAN,"pestan",1);
  PRAGMA interface(c,COSH,"pescsh",1);
  PRAGMA interface(c,SINH,"pessnh",1);
  PRAGMA interface(c,TANH,"pestnh",1);
  PRAGMA interface(c,EXP,"pesexp",1);
  PRAGMA interface(c,LN,"pesln",1);
  PRAGMA interface(c,BITAND,"pesbtd",1);
  PRAGMA interface(c,BITAND,"pesbtdn",2);
  PRAGMA interface(c,LOG,"peslog",1);
  PRAGMA interface(c,TRUNC,"pestru",1);
  PRAGMA interface(c,ROUND,"pesrnd",1);
  PRAGMA interface(c,POWER,"pespow",1);
  PRAGMA interface(c,NEW_TIME,"pesnwt");
  PRAGMA interface(c,TO_DATE,"pesc2d",4);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",3);
  PRAGMA interface(c,TO_NUMBER,"pesc2n",4);
  PRAGMA interface(c,'>=',"pes_flip",5);
  PRAGMA interface(c,'>',"pes_flip",5);
  PRAGMA interface(c,'<=',"peszle",5);
  PRAGMA interface(c,'<',"peszlt",5);        -- ICD #50
  PRAGMA interface(c,'=',"peszeq",5);
  PRAGMA interface(c,'!=',"pes_invert",5);
  PRAGMA interface(c,nlssort,"pesxco",2);
  PRAGMA interface(c,NLS_UPPER,"pesxup",1);
  PRAGMA interface(c,NLS_UPPER,"peslcnup",3); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_UPPER,"peslcnup",4); -- LOB NLS_UPPER
  PRAGMA interface(c,NLS_LOWER,"pesxlo",1);
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",3); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_LOWER,"peslcnlr",4); -- LOB NLS_LOWER
  PRAGMA interface(c,NLS_INITCAP,"pesxcp",1);
  PRAGMA interface(c,lengthb,"pes_dummy",1);
  PRAGMA interface(c,substrb,"pes_dummy",1);
  PRAGMA interface(c,instrb,"pesxis",1);
  PRAGMA interface(c,TO_SINGLE_BYTE, "pesxsi");
  PRAGMA interface(c,TO_MULTI_BYTE,"pesxmu");
  PRAGMA interface(c,TO_CHAR,"pesd2c",5);
  PRAGMA interface(c,TO_CHAR,"pesn2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesd2c",4);
  PRAGMA interface(c,TO_NCHAR,"pesn2c",5);
  PRAGMA interface(c," SYS$STANDARD_TRANSLATE","pesxcs");
  PRAGMA interface(c,ATAN,"pesatan",1);
  PRAGMA interface(c,EMPTY_CLOB,"peslcem");
  PRAGMA interface(c,EMPTY_BLOB,"peslbem");
  PRAGMA interface(c,BFILENAME,"pesfnm");
  PRAGMA interface(c,TO_TIME,"pes3tm",2);
  PRAGMA interface(c,TO_TIME,"pes3tm",3);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",2);
  PRAGMA interface(c,TO_TIMESTAMP,"pes3ts",3);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",2);
  PRAGMA interface(c,TO_TIMESTAMP_TZ,"pes3tp",3);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",2);
  PRAGMA interface(c,TO_TIME_TZ,"pes3te",3);
  PRAGMA interface(c,TO_DSINTERVAL,"pes2dsi",2);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",1);
  PRAGMA interface(c,SYS_AT_TIME_ZONE,"pesatz",2);
  PRAGMA interface(c,SESSIONTIMEZONE,"pesstz",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",1);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",2);
  PRAGMA interface(c," SYS$STANDARD_TRIM","pestrim",3);
  PRAGMA interface(c,TRIM,"pestrim",1);
  -- Datetime addition
  PRAGMA interface(c,'+',"pesati",5);    --  +(tsp, iym) return tsp
  PRAGMA interface(c,'+',"pesati",6);    --  +(tsp, ids) return tsp
  PRAGMA interface(c,'+',"pesati",7);    --  +(tsz, iym) return tsz
  PRAGMA interface(c,'+',"pesati",8);    --  +(tsz, ids) return tsz
  PRAGMA interface(c,'+',"pesati",9);    --  +(tim, ids) return tim
  PRAGMA interface(c,'+',"pesati",10);   --  +(tmz, ids) return tmz
  PRAGMA interface(c,'+',"pesadi",11);   --  +(dat, iym) return dat
  PRAGMA interface(c,'+',"pesadi",12);   --  +(dat, ids) return dat
  PRAGMA interface(c,'+',"pes_flip",13); --  +(iym, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",14); --  +(iym, tsz) return tsz -- ICD #100
  PRAGMA interface(c,'+',"pes_flip",15); --  +(iym, dat) return dat
  PRAGMA interface(c,'+',"pes_flip",16); --  +(ids, tsp) return tsp
  PRAGMA interface(c,'+',"pes_flip",17); --  +(ids, tsz) return tsz
  PRAGMA interface(c,'+',"pes_flip",18); --  +(ids, tim) return tim
  PRAGMA interface(c,'+',"pes_flip",19); --  +(ids, tmz) return tmz
  PRAGMA interface(c,'+',"pes_flip",20); --  +(ids, dat) return dat
  PRAGMA interface(c,'+',"pesaii",21);   --  +(ids, ids) return ids
  PRAGMA interface(c,'+',"pesaii",22);   --  +(iym, iym) return iym
  PRAGMA interface(c,'+',"pesati",23);   --  +(ltz, iym) return ltz
  PRAGMA interface(c,'+',"pesati",24);   --  +(ltz, ids) return ltz
  PRAGMA interface(c,'+',"pes_flip",25);--  +(iym, ltz) return ltz
  PRAGMA interface(c,'+',"pes_flip",26);--  +(ids, ltz) return ltz
  -- Datetime subtraction
  PRAGMA interface(c,'-',"pessti",6);    --  -(tsp, iym) return tsp
  PRAGMA interface(c,'-',"pessti",7);    --  -(tsp, ids) return tsp
  PRAGMA interface(c,'-',"pessti",8);    --  -(tsz, iym) return tsz
  PRAGMA interface(c,'-',"pessti",9);    --  -(tsz, ids) return tsz
  PRAGMA interface(c,'-',"pessti",10);   --  -(tim, ids) return tim
  PRAGMA interface(c,'-',"pessti",11);   --  -(tmz, ids) return tmz
  PRAGMA interface(c,'-',"pessdi",12);   --  -(dat, iym) return dat
  PRAGMA interface(c,'-',"pessdi",13);   --  -(dat, ids) return dat
  PRAGMA interface(c,'-',"pessii",14);   --  -(iym, iym) return iym
  PRAGMA interface(c,'-',"pessii",15);   --  -(ids, ids) return ids
  PRAGMA interface(c,'-',"pessttds",16); --  -(tim, tim) return ids
  PRAGMA interface(c,'-',"pessttds",17); --  -(tsp, tsp) return ids
  PRAGMA interface(c,'-',"pessttds",18); --  -(tmz, tmz) return ids
  PRAGMA interface(c,'-',"pessttds",19); --  -(tsz, tsz) return ids
  PRAGMA interface(c,'-',"pessti",20);   --  -(ltz, iym) return iym
  PRAGMA interface(c,'-',"pessti",21);   --  -(ltz, ids) return ids
  PRAGMA interface(c,'-',"pessttds",22); --  -(ltz, ltz) return ids
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",1);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",2);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",3);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",4);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessddds",5);
  PRAGMA interface(c," SYS$DSINTERVALSUBTRACT","pessttds",6);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",1);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",2);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessddym",3);
  PRAGMA interface(c," SYS$YMINTERVALSUBTRACT","pessttym",4);
  -- Datetime multiplication
  PRAGMA interface(c,'*',"pesmni",2);    --  *(num, iym) return iym
  PRAGMA interface(c,'*',"pesmni",3);    --  *(num, ids) return ids
  PRAGMA interface(c,'*',"pes_flip",4);  --  *(iym, num) return iym
  PRAGMA interface(c,'*',"pes_flip",5);  --  *(ids, num) return ids
  -- Datetime division
  PRAGMA interface(c,'/',"pesdvin",2);   --  /(iym, num) return iym
  PRAGMA interface(c,'/',"pesdvin",3);   --  /(ids, num) return ids
  -- TIME
  PRAGMA interface(c,'=',"pes_dummy",9);
  PRAGMA interface(c,'!=',"pes_invert",9);
  PRAGMA interface(c,'>',"pes_flip",8);
  PRAGMA interface(c,'<',"pes_dummy",8);
  PRAGMA interface(c,'>=',"pes_flip",8);   -- ICD #150
  PRAGMA interface(c,'<=',"pes_dummy",8);
  -- TIME WITH TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",10);
  PRAGMA interface(c,'!=',"pes_invert",10);
  PRAGMA interface(c,'>',"pes_flip",9);
  PRAGMA interface(c,'<',"pes_dummy",9);
  PRAGMA interface(c,'>=',"pes_flip",9);
  PRAGMA interface(c,'<=',"pes_dummy",9);
  -- TIMESTAMP
  PRAGMA interface(c,'=',"pes_dummy",11);
  PRAGMA interface(c,'!=',"pes_invert",11);
  PRAGMA interface(c,'>',"pes_flip",10);
  PRAGMA interface(c,'<',"pes_dummy",10);
  PRAGMA interface(c,'>=',"pes_flip",10);
  PRAGMA interface(c,'<=',"pes_dummy",10);
  -- INTERVAL YEAR TO MONTH
  PRAGMA interface(c,'=',"pes_dummy",12);
  PRAGMA interface(c,'!=',"pes_invert",12);
  PRAGMA interface(c,'>',"pes_flip",11);
  PRAGMA interface(c,'<',"pes_dummy",11);
  PRAGMA interface(c,'>=',"pes_flip",11);
  PRAGMA interface(c,'<=',"pes_dummy",11);
  -- INTERVAL DAY TO SECOND
  PRAGMA interface(c,'=',"pes_dummy",13);
  PRAGMA interface(c,'!=',"pes_invert",13);
  PRAGMA interface(c,'>',"pes_flip",12);
  PRAGMA interface(c,'<',"pes_dummy",12);
  PRAGMA interface(c,'>=',"pes_flip",12);
  PRAGMA interface(c,'<=',"pes_dummy",12);
  -- TIMESTAMP_TZ_UNCONSTRAINED
  PRAGMA interface(c,'=',"pes_dummy",14);
  PRAGMA interface(c,'!=',"pes_invert",14);
  PRAGMA interface(c,'>',"pes_flip",13);
  PRAGMA interface(c,'<',"pes_dummy",13);
  PRAGMA interface(c,'>=',"pes_flip",13);
  PRAGMA interface(c,'<=',"pes_dummy",13);
  -- TIMESTAMP WITH LOCAL TIME ZONE
  PRAGMA interface(c,'=',"pes_dummy",15);
  PRAGMA interface(c,'!=',"pes_invert",15);
  PRAGMA interface(c,'>',"pes_flip",14);
  PRAGMA interface(c,'<',"pes_dummy",14);
  PRAGMA interface(c,'>=',"pes_flip",14);
  PRAGMA interface(c,'<=',"pes_dummy",14);
  -- Other datetime functions
  PRAGMA interface(c,'CURRENT_DATE',"pescdt",1);
  PRAGMA interface(c,'CURRENT_TIME',"pesctm",1);
  PRAGMA interface(c,'CURRENT_TIMESTAMP',"pescts",1);
  --  Internal calls to evaluate datetime/interval literals without NLS parms.
  PRAGMA interface(c,SYS_LITERALTOYMINTERVAL,"pesc2ymi",1);
  PRAGMA interface(c,SYS_LITERALTODSINTERVAL,"pesc2dsi",1);
  PRAGMA interface(c,SYS_LITERALTOTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIME,"pesc2tim",1);
  PRAGMA interface(c,SYS_LITERALTOTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTOTZTIMESTAMP,"pesc2tsp",1);
  PRAGMA interface(c,SYS_LITERALTODATE,"pesc2date",1);
  -- extract(field from expr)
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",1);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",2);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",3);   -- ICD #200
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",4);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefd",5);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefdt",6);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",7);
  PRAGMA interface(c," SYS$EXTRACT_FROM","pesefi",8);
  -- datetime is null
  PRAGMA interface(c,"IS NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NULL","pes_dummy",20); -- interval ds

  -- 8.2 LOB Built-in Functions
  PRAGMA interface(c,length, "peslcln",2);    -- LOB LENGTH
  PRAGMA interface(c,lengthb,"peslclb",2);    -- LOB LENGTHB
  PRAGMA interface(c,substr, "peslcst",2);    -- LOB SUBSTR
  PRAGMA interface(c,substrb,"peslcsb",2);    -- LOB SUBSTRB
  PRAGMA interface(c,instr,  "peslcin",2);    -- LOB INSTR
  PRAGMA interface(c,instrb, "peslcib",2);    -- LOB INSTRB
  PRAGMA interface(c,'||',   "peslcct",2);    -- LOB '||'
  PRAGMA interface(c,concat, "peslcct",2);    -- LOB CONCAT
  PRAGMA interface(c,lpad,   "peslclp",3);    -- LOB LPAD
  PRAGMA interface(c,lpad,   "peslclp",4);    -- LOB LPAD
  PRAGMA interface(c,rpad,   "peslcrp",3);    -- LOB RPAD
  PRAGMA interface(c,rpad,   "peslcrp",4);    -- LOB RPAD
  PRAGMA interface(c,lower,  "peslclr",2);    -- LOB LOWER
  PRAGMA interface(c,upper,  "peslcup",2);    -- LOB UPPER
  PRAGMA interface(c,ltrim,  "peslclm",3);    -- LOB LTRIM
  PRAGMA interface(c,ltrim,  "peslclm",4);    -- LOB LTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",3);    -- LOB RTRIM
  PRAGMA interface(c,rtrim,  "peslcrm",4);    -- LOB RTRIM
  PRAGMA interface(c,trim,   "peslctr",2);    -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",4); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",5); -- LOB TRIM
  PRAGMA interface(c," SYS$STANDARD_TRIM","peslctr",6); -- LOB TRIM
  PRAGMA interface(c,'LIKE', "peslclk",3);    -- LOB LIKE
  PRAGMA interface(c,'LIKE', "peslcl2",4);    -- LOB LIKE
  PRAGMA interface(c,nvl,"peslcnl",17);       -- LOB NVL
  PRAGMA interface(c,replace, "peslcrl",2);   -- LOB REPLACE

     -- LOB Relational Operators
     -- LHS: CLOB,    RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_dummy",16);     -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",16);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",15);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pes_dummy",15);     -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",15);      -- LOB '>='
  PRAGMA interface(c,'<=',"pes_dummy",15);       -- LOB '<='
     -- LHS: CLOB,     RHS:VARCHAR2
  PRAGMA interface(c,'=' ,"pesleq2",17);       -- LOB '='
  PRAGMA interface(c,'!=',"pes_invert",17);    -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",16);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt2",16);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",16);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle2",16);       -- LOB '<='  -- ICD #250
     -- LHS: VARCHAR2, RHS:CLOB
  PRAGMA interface(c,'=' ,"pes_flip",18);      -- LOB '='
  PRAGMA interface(c,'!=',"pes_flip",18);      -- LOB '!='
  PRAGMA interface(c,'>' ,"pes_flip",17);      -- LOB '>'
  PRAGMA interface(c,'<' ,"pesllt3",17);       -- LOB '<'
  PRAGMA interface(c,'>=',"pes_flip",17);      -- LOB '>='
  PRAGMA interface(c,'<=',"peslle3",17);       -- LOB '<='

  PRAGMA interface(c,length, "peslbln",3);    -- BLOB LENGTH
  PRAGMA interface(c,lengthb,"peslblb",3);    -- BLOB LENGTHB
  -- End of 8.2 LOB Built-in Functions


  PRAGMA interface(c,tz_offset,"pestzo",1);
  PRAGMA interface(c,from_tz,"pesftz",1);

  PRAGMA interface(c,ISNCHAR,"pesinc", 1);

  PRAGMA interface(c,CONVERT,"pescnv", 1);
  PRAGMA interface(c,CONVERT,"pescnv", 2);
  PRAGMA interface(c,CONVERT,"peslccnv", 3);  -- LOB CONVERT
  PRAGMA interface(c,CONVERT,"peslccnv", 4);  -- LOB CONVERT

  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",1);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",2);
  PRAGMA interface(c," SYS$EXTRACT_STRING_FROM","pesefdrvc2",3);

  PRAGMA interface(c,TO_CHAR,"pesdtm2c",7); -- datetime
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",8);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",9);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",10);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",11);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",12);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",13);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",14);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",15);
  PRAGMA interface(c,TO_CHAR,"pesdtm2c",16);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",17); -- interval
  PRAGMA interface(c,TO_CHAR,"pesitv2c",18);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",19);
  PRAGMA interface(c,TO_CHAR,"pesitv2c",20);

  --#### new_names pragmas

  -- This is an internal pragma that restricts the use
  -- of particular new entries in package standard.
  -- It is only valid in package standard.
  -- Note that left out of the 8.1.5 set are non datetime
  -- entries urowid, "UROWID ", self_is_null and trim.

  pragma new_names('8.1.5',
                   time,"TIME WITH TIME ZONE",
                   timestamp,"TIMESTAMP WITH TIME ZONE",
                   "INTERVAL DAY TO SECOND",
                   "INTERVAL YEAR TO MONTH",
                   to_time, to_timestamp,
                   to_time_tz, to_timestamp_tz,
                   " SYS$DSINTERVALSUBTRACT",
                   " SYS$YMINTERVALSUBTRACT",
                   to_yminterval,to_dsinterval,
                   NUMTOYMINTERVAL, NUMTODSINTERVAL,
                   current_date,
                   current_time,current_timestamp);

  pragma new_names('8.1.6',
                   dbtimezone, sessiontimezone, localtimestamp,
                   localtime,
                   cube, rollup, grouping, "TIMESTAMP WITH LOCAL TIME ZONE");

  -- Should there be a 8.2 new names pragma ?

  -- 8.2 UCS2/UCS4/Complete Built-in Functions

  PRAGMA interface(c,INSTR2,"pesist2",1);
  PRAGMA interface(c,INSTR4,"pesist4",1);
  PRAGMA interface(c,INSTRC,"pesistc",1);

  PRAGMA interface(c,LENGTH2,"peslen2",1);
  PRAGMA interface(c,LENGTH4,"peslen4",1);
  PRAGMA interface(c,LENGTHC,"peslenc",1);

  PRAGMA interface(c,LIKE2,"peslik2",1);
  PRAGMA interface(c,LIKE2,"pesli22",2);
  PRAGMA interface(c,LIKE4,"peslik4",1);
  PRAGMA interface(c,LIKE4,"pesli42",2);
  PRAGMA interface(c,LIKEC,"peslikc",1);
  PRAGMA interface(c,LIKEC,"peslic2",2);

  PRAGMA interface(c,SUBSTR2,"pes_dummy",1);
  PRAGMA interface(c,SUBSTR4,"pes_dummy",1);
  PRAGMA interface(c,SUBSTRC,"pes_dummy",1);
  PRAGMA interface(c,SYS_EXTRACT_UTC,"pessexu");
  PRAGMA interface(c,COMPOSE,"pescomp");
  PRAGMA interface(c,DECOMPOSE,"pesdcmp");



  -- End of 8.2 UCS2/UCS4/Complete Built-in Functions

  -- Begin REGEXP support (10iR1) --
  PRAGMA interface(c,regexp_like,    "pes_dummy",1);
  PRAGMA interface(c,regexp_instr,   "pes_dummy",1);    -- ICD #300
  PRAGMA interface(c,regexp_substr,  "pes_dummy",1);
  PRAGMA interface(c,regexp_replace, "pes_dummy",1);
  PRAGMA interface(c,regexp_count,   "pes_dummy",1);
  PRAGMA interface(c,regexp_like,    "pes_dummy",2);    -- LOB REGEXP_LIKE
  PRAGMA interface(c,regexp_instr,   "pes_dummy",2);    -- LOB REGEXP_INSTR
  PRAGMA interface(c,regexp_substr,  "pes_dummy",2);    -- LOB REGEXP_SUBSTR
  PRAGMA interface(c,regexp_replace, "pes_dummy",2);    -- LOB REGEXP_REPLACE
  PRAGMA interface(c,regexp_count,   "pes_dummy",2);    -- LOB REGEXP_COUNT
  PRAGMA interface(c,regexp_replace, "pes_dummy",3);    -- LOB REGEXP_REPLACE

  -- End of REGEXP Built-in Functions --


  -- 10i Binary Floating-point Built-in Functions

  PRAGMA interface(c,"IS NAN","pesnanf",2);
  PRAGMA interface(c,"IS NAN","pesnand",3);
  PRAGMA interface(c,"IS INFINITE","pesinf",1);
  PRAGMA interface(c,"IS INFINITE","pesinff",2);
  PRAGMA interface(c,"IS INFINITE","pesinfd",3);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",2);
  PRAGMA interface(c,TO_BINARY_FLOAT,"pesc2flt",3);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",2);
  PRAGMA interface(c,TO_BINARY_DOUBLE,"pesc2dbl",3);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",21);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",22);
  PRAGMA interface(c,TO_CHAR,"pesflt2c",23);
  PRAGMA interface(c,TO_CHAR,"pesdbl2c",24);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",6);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",7);
  PRAGMA interface(c,TO_NCHAR,"pesflt2c",8);
  PRAGMA interface(c,TO_NCHAR,"pesdbl2c",9);
  PRAGMA interface(c,'REMAINDER',"pesrem", 1);
  PRAGMA interface(c,REMAINDER,"pesrem", 2);
  PRAGMA interface(c,'REMAINDER',"pesremf", 3);
  PRAGMA interface(c,REMAINDER,"pesremf", 4);
  PRAGMA interface(c,'REMAINDER',"pesremd", 5);
  PRAGMA interface(c,REMAINDER,"pesremd", 6);
  PRAGMA interface(c,ABS,"pes_dummy",2);
  PRAGMA interface(c,ABS,"pes_dummy",3);
  PRAGMA interface(c,ABS,"pes_dummy",4);
  PRAGMA interface(c,ATAN,"pesatand",2);
  PRAGMA interface(c,'MOD',"pesmodf", 2);
  PRAGMA interface(c,'MOD',"pesmodd", 3);
  PRAGMA interface(c,floor,"pesflof", 2);
  PRAGMA interface(c,floor,"pesflod", 3);
  PRAGMA interface(c,CEIL,"pesceif", 2);
  PRAGMA interface(c,CEIL,"pesceid", 3);
  PRAGMA interface (c, SQRT, "pessqtf", 2);
  PRAGMA interface (c, SQRT, "pessqtd", 3);
  PRAGMA interface(c,SIGN,"pessgnf", 2);
  PRAGMA interface(c,SIGN,"pessgnd", 3);
  PRAGMA interface(c,SIGN,"pessgni", 4);
  PRAGMA interface(c,cos,"pescosd", 2);
  PRAGMA interface(c,sin,"pessind",2);
  PRAGMA interface(c,TAN,"pestand",2);
  PRAGMA interface(c,COSH,"pescshd",2);
  PRAGMA interface(c,SINH,"pessnhd",2);   -- ICD #350
  PRAGMA interface(c,TANH,"pestnhd",2);
  PRAGMA interface(c,EXP,"pesexpd",2);
  PRAGMA interface(c,LN,"peslnd",2);
  PRAGMA interface(c,LOG,"peslogd",2);
  PRAGMA interface(c,TRUNC,"pestruf",4);
  PRAGMA interface(c,TRUNC,"pestrud",5);
  PRAGMA interface(c,TRUNC,"pestrui",6);
  PRAGMA interface(c,ROUND,"pesrndf",4);
  PRAGMA interface(c,ROUND,"pesrndd",5);
  PRAGMA interface(c,ROUND,"pesrndi",6);
  PRAGMA interface(c,POWER,"pespowd",2);

  -- End of 10i Binary Floating-point Built-in Functions

  -- ICDs for MULTISET

  PRAGMA interface(c,CARDINALITY,"pesmcnt");
  PRAGMA interface(c,"IS EMPTY","pesmie");
  PRAGMA interface(c,"IS NOT EMPTY","pes_invert",1);
  -- ICDs which used to be in the body of standard, but which new COG can
  -- handle directly

  -- NOT (some ICD)
  PRAGMA interface(c,NOT_LIKE,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",3);
  PRAGMA interface(c,NOT_LIKE,"pes_invert",4);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE2,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKE4,"pes_invert",2);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",1);
  PRAGMA interface(c,NOT_LIKEC,"pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",2);
  PRAGMA interface(c,"IS NOT NAN","pes_invert",3);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",1);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",2);
  PRAGMA interface(c,"IS NOT INFINITE","pes_invert",3);

  -- datetime is not null
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",14); -- time
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",15); -- time wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",16); -- timestamp
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",17); -- timestamp wtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",18); -- timestamp lwtz
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",19); -- interval ym
  PRAGMA interface(c,"IS NOT NULL","pes_dummy",20); -- interval ds

  -- Misc
  PRAGMA interface(c,"**",   "pespow",1);    -- number
  PRAGMA interface(c,"**",   "pespowd",2);   -- binary double
  PRAGMA interface(c,"ACOS", "pesacosd",2);  -- binary double
  PRAGMA interface(c,"ASIN", "pesasind",2);  -- binary double
  PRAGMA interface(c,"ATAN2","pesatn2d",2);  -- binary double

  -- All the flavors of NVL
  PRAGMA interface(c,nvl,"pes_dummy",1);       -- Boolean -- ICD #400
  PRAGMA interface(c,nvl,"pes_dummy",2);       -- Varchar2
  PRAGMA interface(c,nvl,"pes_dummy",3);       -- Number
  PRAGMA interface(c,nvl,"pes_dummy",4);       -- Date
  PRAGMA interface(c,nvl,"pes_dummy",5);       -- MLSLabel
  PRAGMA interface(c,nvl,"pes_dummy",6);       -- ADT
  PRAGMA interface(c,nvl,"pes_dummy",7);       -- Ref ADT
  PRAGMA interface(c,nvl,"pes_dummy",8);       -- Collection

--  Ref Cursor has problems. The MOVCR instruction needs more information than
--  the other MOV* instructions, including the PVM register of the destination
--  This cannot be easily supplied through the generic NVL instruction, so
--  for now, this flavor will continue to have a real body
--  PRAGMA interface(c,nvl,"pes_dummy",9);       -- Ref Cursor

  PRAGMA interface(c,nvl,"pes_dummy",10);       -- Time
  PRAGMA interface(c,nvl,"pes_dummy",11);       -- Time-tz
  PRAGMA interface(c,nvl,"pes_dummy",12);       -- Timestamp
  PRAGMA interface(c,nvl,"pes_dummy",13);       -- Timestamp-tz
  PRAGMA interface(c,nvl,"pes_dummy",14);       -- Timestamp-ltz
  PRAGMA interface(c,nvl,"pes_dummy",15);       -- Intervalym
  PRAGMA interface(c,nvl,"pes_dummy",16);       -- Intervalds
--  PRAGMA interface(c,nvl,"pes_dummy",17);       -- Clob (Handled above, ICD)
  PRAGMA interface(c,nvl,"pes_dummy",18);       -- Opaque
  PRAGMA interface(c,nvl,"pes_dummy",19);       -- Binaryfloat
  PRAGMA interface(c,nvl,"pes_dummy",20);       -- Binarydouble
  PRAGMA interface(c,nvl,"pes_dummy",21);       -- PLSInteger

  -- The following pragma overrides any other setting of the timestamp,
  -- and is used so that we recognize the client-side and server-side instances
  -- of package STANDARD as being the same.  Package STANDARD is special in
  -- that it is really the root of the PL/SQL dependencies graph; as such it
  -- itself doesn't ever need recompiling due to changes to things below it.
  -- The pragma mechanism used here is currently ignored except for
  -- package STANDARD, but in future may not be.  Do NOT add similar pragmas
  -- to your own code as it may in future interfere with the package
  -- consistency maintenance mechanisms and could have dire results.

  --#### timestamp pragma (please keep this last)
  pragma TIMESTAMP('2006-04-18:00:00:00');
end;

/
--------------------------------------------------------
--  DDL for Package DBMS_STANDARD
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SYS"."DBMS_STANDARD" is
  -- types
   type ora_name_list_t is table of varchar2(64);

  -- Trigger Operations
  procedure raise_application_error(num binary_integer, msg varchar2,
      keeperrorstack boolean default FALSE);
    pragma interface (C, raise_application_error);         -- 1 (see psdicd.c)
    pragma restrict_references (raise_application_error, WNPS, RNPS, WNDS, RNDS);
  function inserting return boolean;
    pragma interface (C, inserting);                       -- 2
    pragma restrict_references (inserting, WNPS, RNPS, WNDS);
  function deleting  return boolean;
    pragma interface (C, deleting);                        -- 3
    pragma restrict_references (deleting, WNPS, RNPS, WNDS);
  function updating  return boolean;
    pragma interface (C, updating);                        -- 4
    pragma restrict_references (updating, WNPS, RNPS, WNDS);
  function updating (colnam varchar2) return boolean;
    pragma interface (C, updating);                        -- 5
    pragma restrict_references (updating, WNPS, RNPS, WNDS);

  -- Transaction Commands
  procedure commit;
    pragma interface (C, commit);                          -- 6
  procedure commit_cm(vc varchar2);
    pragma interface (C, commit_cm);                       -- 7
  procedure rollback_nr;
    pragma interface (C, rollback_nr);                     -- 8
  procedure rollback_sv(save_point varchar2);
    pragma interface (C, rollback_sv);                     -- 9
  procedure savepoint(save_point varchar2);
    pragma interface (C, savepoint);                       -- 10
  procedure set_transaction_use(vc varchar2);
    pragma interface (C, set_transaction_use);             -- 11


  -- Functions supported for system events
  -- Null or zero will be returned if called in inappropriate occasions
  -- error functions only search for the top 5 errors in the error stack

  function sysevent return varchar2 ;                      -- 12
    pragma interface (C, sysevent);
    pragma restrict_references (sysevent, WNPS, RNPS, WNDS);
  function dictionary_obj_type return varchar2 ;           -- 13
    pragma interface (C, dictionary_obj_type);
    pragma restrict_references (dictionary_obj_type, WNPS, RNPS, WNDS);
   function dictionary_obj_owner return varchar2 ;           -- 14
    pragma interface (C, dictionary_obj_owner);
    pragma restrict_references (dictionary_obj_owner, WNPS, RNPS, WNDS);
  function dictionary_obj_name return varchar2 ;           -- 15
    pragma interface (C, dictionary_obj_name);
    pragma restrict_references (dictionary_obj_name, WNPS, RNPS, WNDS);
  function database_name return varchar2 ;                 -- 16
    pragma interface (C, database_name);
    pragma restrict_references (database_name, WNPS, RNPS, WNDS);
  function instance_num return binary_integer ;            -- 17
    pragma interface (C, instance_num);
    pragma restrict_references (instance_num, WNPS, RNPS, WNDS);
  function login_user return varchar2 ;                    -- 18
    pragma interface (C, login_user);
    pragma restrict_references (login_user, WNPS, RNPS, WNDS);
  function is_servererror (errno binary_integer)
		return boolean ; 	                   -- 19
    pragma interface (C, is_servererror);
    pragma restrict_references (is_servererror, WNPS, RNPS, WNDS);

  function server_error(position binary_integer)
			return binary_integer ;           -- 20
    pragma interface (C, server_error);
    pragma restrict_references (server_error, WNPS, RNPS, WNDS);
  function des_encrypted_password(user varchar2 default null) return varchar2; -- 21
    pragma interface (C, des_encrypted_password);
    pragma restrict_references (des_encrypted_password, WNPS, RNPS, WNDS);
  function is_alter_column (column_name varchar2)
		return boolean ; 	                   -- 22
    pragma interface (C, is_alter_column);
    pragma restrict_references (is_alter_column, WNPS, RNPS, WNDS);
  function is_drop_column (column_name varchar2)
		return boolean ; 	                   -- 23
    pragma interface (C, is_drop_column);
    pragma restrict_references (is_drop_column, WNPS, RNPS, WNDS);
  function grantee (user_list out ora_name_list_t) return binary_integer ;   -- 24
    pragma interface (C, grantee);
    pragma restrict_references (grantee, WNPS, RNPS, WNDS);
  function revokee (user_list out ora_name_list_t) return binary_integer ;   -- 25
    pragma interface (C, revokee);
    pragma restrict_references (revokee, WNPS, RNPS, WNDS);
  function privilege_list (priv_list out ora_name_list_t)
                return binary_integer ;                    -- 26
    pragma interface (C, privilege_list);
    pragma restrict_references (privilege_list, WNPS, RNPS, WNDS);
  function with_grant_option return boolean ;                    -- 27
    pragma interface (C, with_grant_option);
    pragma restrict_references (with_grant_option, WNPS, RNPS, WNDS);
  function dictionary_obj_owner_list (owner_list out ora_name_list_t)
                return binary_integer;                           -- 28
    pragma interface (C, dictionary_obj_owner_list);
    pragma restrict_references (dictionary_obj_owner_list, WNPS, RNPS, WNDS);
  function dictionary_obj_name_list (object_list out ora_name_list_t)
                return binary_integer;                           -- 29
    pragma interface (C, dictionary_obj_name_list);
    pragma restrict_references (dictionary_obj_name_list, WNPS, RNPS, WNDS);
  function is_creating_nested_table return boolean; 	         -- 30
    pragma interface (C, is_creating_nested_table);
    pragma restrict_references (is_creating_nested_table, WNPS, RNPS, WNDS);
  function client_ip_address return varchar2; 	                 -- 31
    pragma interface (C, client_ip_address);
    pragma restrict_references (client_ip_address, WNPS, RNPS, WNDS);
  function sql_txt (sql_text out ora_name_list_t) return binary_integer; -- 32
    pragma interface (C, sql_txt);
    pragma restrict_references (sql_txt, WNPS, RNPS, WNDS);
  function server_error_msg (position binary_integer) return varchar2; -- 33
    pragma interface (C, server_error_msg);
    pragma restrict_references (server_error_msg, WNPS, RNPS, WNDS);
  function server_error_depth return binary_integer;              -- 34
    pragma interface (C, server_error_depth);
    pragma restrict_references (server_error_depth, WNPS, RNPS, WNDS);
  function server_error_num_params (position binary_integer)
                                   return binary_integer;         -- 35
    pragma interface (C, server_error_num_params);
    pragma restrict_references (server_error_num_params, WNPS, RNPS, WNDS);
  function server_error_param(position binary_integer, param binary_integer)
                              return varchar2;                    -- 36
    pragma interface (C, server_error_param);
    pragma restrict_references (server_error_param, WNPS, RNPS, WNDS);
  function partition_pos return binary_integer;                  -- 37
    pragma interface (C, partition_pos);
    pragma restrict_references (partition_pos, WNPS, RNPS, WNDS);

  function sys_GetTriggerState  return pls_integer;
    pragma interface (C, Sys_GetTriggerState);                        -- 38
    pragma restrict_references (Sys_GetTriggerState,  wnds, RNDS);
  function applying_crossedition_trigger return boolean;
    pragma interface (C, applying_crossedition_trigger);              -- 39
    pragma restrict_references (applying_crossedition_trigger, WNPS,RNPS,WNDS);
end;

/
--------------------------------------------------------
--  DDL for Procedure FM_UPDATE_FOLDER_FULL_NAME
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "FMAPP"."FM_UPDATE_FOLDER_FULL_NAME" 
as
  v_folder_full_name nvarchar2(1000);
  cursor folder_ids is
    select folder_id
    from fm_folder;

begin
  for folder_rec in folder_ids
  loop
    select fm_get_folder_full_name(folder_rec.folder_id) into v_folder_full_name
    from dual;

    update fm_folder set folder_full_name = v_folder_full_name
    where folder_id = folder_rec.folder_id;
  end loop;
end;

/
--------------------------------------------------------
--  DDL for Procedure CZ_END_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_END_AUDIT" 
(
  jobID NUMBER, 
  jobStatus VARCHAR2
)
AS

  endDate timestamp;

BEGIN
  
  endDate := systimestamp;
  
	update cz_job_master
		set 
			active='N',
			end_date = endDate,
      time_elapsed_secs = 
      EXTRACT (DAY    FROM (endDate - START_DATE))*24*60*60 + 
      EXTRACT (HOUR   FROM (endDate - START_DATE))*60*60 + 
      EXTRACT (MINUTE FROM (endDate - START_DATE))*60 + 
      EXTRACT (SECOND FROM (endDate - START_DATE)),
			job_status = jobStatus		
		where active='Y' 
		and job_id=jobID;

END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_END_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_END_AUDIT" 
(
  jobID NUMBER, 
  jobStatus VARCHAR2
)
AS

  endDate timestamp;

BEGIN
  
  endDate := systimestamp;
  
	update cz_job_master
		set 
			active='N',
			end_date = endDate,
      time_elapsed_secs = 
      EXTRACT (DAY    FROM (endDate - START_DATE))*24*60*60 + 
      EXTRACT (HOUR   FROM (endDate - START_DATE))*60*60 + 
      EXTRACT (MINUTE FROM (endDate - START_DATE))*60 + 
      EXTRACT (SECOND FROM (endDate - START_DATE)),
			job_status = jobStatus		
		where active='Y' 
		and job_id=jobID;

END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_FILL_IN_TREE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_FILL_IN_TREE" 
(
  trial_id VARCHAR2
 ,path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  TrialID varchar2(100);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  auditText varchar2(4000);
  
  ----------------------------------------------
  --Goal: To fill out an I2B2 Tree node
  --Steps. Walk backwards through an i2b2 tree and fill in all missing nodes.
  --\1\2\3\4\5\6\
  --Will check that \1\, \1\2\, etc..all exist.
  ----------------------------------------------
  
  -- JEA@20100107 - Added auditing
  
  --Get the nodes
  CURSOR cNodes is
    --Trimming off the last node as it would never need to be added.
    select distinct substr(c_fullname, 1,instr(c_fullname,'\',-2,1)) as c_fullname
    --select c_fullname
    from i2b2 
    where c_fullname like path || '%';
--      and c_hlevel > = 2;
  
  root_node varchar2(1000);
  node_name varchar(1000);
  v_count NUMBER;
  
BEGIN
  TrialID := upper(trial_id);
  
    stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  --start node with the first slash
 
  --Iterate through each node
  FOR r_cNodes in cNodes Loop
    root_node := '\';
    --Determine how many nodes there are
    --Iterate through, Start with 2 as one will be null from the parser
    
    for loop_counter in 2 .. (length(r_cNodes.c_fullname) - nvl(length(replace(r_cNodes.c_fullname, '\')),0)) / length('\')
    LOOP
      --Determine Node:
      node_name := parse_nth_value(r_cNodes.c_fullname, loop_counter, '\');
      root_node :=  root_node || node_name || '\';
    
      --Dont run for first 2 nodes
    --  if loop_counter > 3 then 
        --Check if node exists. If it does not, add it.
        select count(*)
          into v_count 
        from i2b2
        where c_fullname = root_node;

        --If it doesn't exist, add it
        if v_count = 0 then
			auditText := 'Inserting ' || root_node;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,auditText,0,stepCt,'Done');
            i2b2_add_node(trial_id, root_node, node_name, jobId);
        end if;
    --  end if;
      
    END LOOP;

    --RESET VARIABLES
    root_node := '';
    node_name := '';
  END LOOP;
  
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_FILL_IN_TREE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_FILL_IN_TREE" 
(
  trial_id VARCHAR2
 ,path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  TrialID varchar2(100);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  auditText varchar2(4000);
  
  ----------------------------------------------
  --Goal: To fill out an I2B2 Tree node
  --Steps. Walk backwards through an i2b2 tree and fill in all missing nodes.
  --\1\2\3\4\5\6\
  --Will check that \1\, \1\2\, etc..all exist.
  ----------------------------------------------
  
  -- JEA@20100107 - Added auditing
  
  --Get the nodes
  CURSOR cNodes is
    --Trimming off the last node as it would never need to be added.
    select distinct substr(c_fullname, 1,instr(c_fullname,'\',-2,1)) as c_fullname
    --select c_fullname
    from i2b2 
    where c_fullname like path || '%';
--      and c_hlevel > = 2;
  
  root_node varchar2(1000);
  node_name varchar(1000);
  v_count NUMBER;
  
BEGIN
  TrialID := upper(trial_id);
  
    stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  --start node with the first slash
 
  --Iterate through each node
  FOR r_cNodes in cNodes Loop
    root_node := '\';
    --Determine how many nodes there are
    --Iterate through, Start with 2 as one will be null from the parser
    
    for loop_counter in 2 .. (length(r_cNodes.c_fullname) - nvl(length(replace(r_cNodes.c_fullname, '\')),0)) / length('\')
    LOOP
      --Determine Node:
      node_name := parse_nth_value(r_cNodes.c_fullname, loop_counter, '\');
      root_node :=  root_node || node_name || '\';
    
      --Dont run for first 2 nodes
    --  if loop_counter > 3 then 
        --Check if node exists. If it does not, add it.
        select count(*)
          into v_count 
        from i2b2
        where c_fullname = root_node;

        --If it doesn't exist, add it
        if v_count = 0 then
			auditText := 'Inserting ' || root_node;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,auditText,0,stepCt,'Done');
            i2b2_add_node(trial_id, root_node, node_name, jobId);
        end if;
    --  end if;
      
    END LOOP;

    --RESET VARIABLES
    root_node := '';
    node_name := '';
  END LOOP;
  
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_ERROR_HANDLER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_ERROR_HANDLER" 
(
  jobID NUMBER,
  procedureName NVARCHAR2
)
AS
  databaseName NVARCHAR2(100);
	errorNumber NUMBER(18,0);
	errorMessage NVARCHAR2(1000);
  errorStack NVARCHAR2(4000);
  errorBackTrace NVARCHAR2(4000);
	stepNo NUMBER(18,0);

BEGIN
  --Get DB Name
	select database_name INTO databaseName
		from cz_job_master 
		where job_id=jobID;
  --Get Latest Step
	select max(step_number) into stepNo from cz_job_audit where job_id = jobID;
  
  --Get all error info
  errorNumber := SQLCODE;
  errorMessage := SQLERRM;
  errorStack := dbms_utility.format_error_stack;
  errorBackTrace := dbms_utility.format_error_backtrace;

  --Update the audit step for the error
  cz_write_audit(jobID, databaseName,procedureName, 'Job Failed: See error log for details',SQL%ROWCOUNT, stepNo, 'FAIL');

  
  --write out the error info
  cz_write_error(jobID, errorNumber, errorMessage, errorStack, errorBackTrace);

END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_ERROR_HANDLER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_ERROR_HANDLER" 
(
  jobID NUMBER,
  procedureName NVARCHAR2
)
AS
  databaseName NVARCHAR2(100);
	errorNumber NUMBER(18,0);
	errorMessage NVARCHAR2(1000);
  errorStack NVARCHAR2(4000);
  errorBackTrace NVARCHAR2(4000);
	stepNo NUMBER(18,0);

BEGIN
  --Get DB Name
	select database_name INTO databaseName
		from cz_job_master 
		where job_id=jobID;
  --Get Latest Step
	select max(step_number) into stepNo from cz_job_audit where job_id = jobID;
  
  --Get all error info
  errorNumber := SQLCODE;
  errorMessage := SQLERRM;
  errorStack := dbms_utility.format_error_stack;
  errorBackTrace := dbms_utility.format_error_backtrace;

  --Update the audit step for the error
  cz_write_audit(jobID, databaseName,procedureName, 'Job Failed: See error log for details',SQL%ROWCOUNT, stepNo, 'FAIL');

  
  --write out the error info
  cz_write_error(jobID, errorNumber, errorMessage, errorStack, errorBackTrace);

END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_FILL_IN_TREE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_FILL_IN_TREE" 
(
  trial_id VARCHAR2
 ,path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  TrialID varchar2(100);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  auditText varchar2(4000);
  
  ----------------------------------------------
  --Goal: To fill out an I2B2 Tree node
  --Steps. Walk backwards through an i2b2 tree and fill in all missing nodes.
  --\1\2\3\4\5\6\
  --Will check that \1\, \1\2\, etc..all exist.
  ----------------------------------------------
  
  -- JEA@20100107 - Added auditing
  
  --Get the nodes
  CURSOR cNodes is
    --Trimming off the last node as it would never need to be added.
    select distinct substr(c_fullname, 1,instr(c_fullname,'\',-2,1)) as c_fullname
    --select c_fullname
    from i2b2 
    where c_fullname like path || '%';
--      and c_hlevel > = 2;
  
  root_node varchar2(1000);
  node_name varchar(1000);
  v_count NUMBER;
  
BEGIN
  TrialID := upper(trial_id);
  
    stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  --start node with the first slash
 
  --Iterate through each node
  FOR r_cNodes in cNodes Loop
    root_node := '\';
    --Determine how many nodes there are
    --Iterate through, Start with 2 as one will be null from the parser
    
    for loop_counter in 2 .. (length(r_cNodes.c_fullname) - nvl(length(replace(r_cNodes.c_fullname, '\')),0)) / length('\')
    LOOP
      --Determine Node:
      node_name := parse_nth_value(r_cNodes.c_fullname, loop_counter, '\');
      root_node :=  root_node || node_name || '\';
    
      --Dont run for first 2 nodes
    --  if loop_counter > 3 then 
        --Check if node exists. If it does not, add it.
        select count(*)
          into v_count 
        from i2b2
        where c_fullname = root_node;

        --If it doesn't exist, add it
        if v_count = 0 then
			auditText := 'Inserting ' || root_node;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,auditText,0,stepCt,'Done');
            i2b2_add_node(trial_id, root_node, node_name, jobId);
        end if;
    --  end if;
      
    END LOOP;

    --RESET VARIABLES
    root_node := '';
    node_name := '';
  END LOOP;
  
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_START_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_START_AUDIT" 
(
  jobName IN VARCHAR2,
  databaseName IN VARCHAR2,
  jobID OUT NUMBER
)
AS
BEGIN

	insert into cz_job_master
		(start_date, 
		active, 
		--username,
		--session_id, 
		database_name,
		job_name,
		job_status) 
	VALUES(
		SYSTIMESTAMP,
		'Y', 
		--suser_name(),
		--@@SPID, 
		databaseName,
		jobName,
		'Running')
  RETURNING job_id INTO jobID;

  COMMIT;

END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_START_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_START_AUDIT" 
(
  jobName IN VARCHAR2,
  databaseName IN VARCHAR2,
  jobID OUT NUMBER
)
AS
BEGIN

	insert into cz_job_master
		(start_date, 
		active, 
		--username,
		--session_id, 
		database_name,
		job_name,
		job_status) 
	VALUES(
		SYSTIMESTAMP,
		'Y', 
		--suser_name(),
		--@@SPID, 
		databaseName,
		jobName,
		'Running')
  RETURNING job_id INTO jobID;

  COMMIT;

END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_DELETE_ALL_NODES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_DELETE_ALL_NODES" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
      
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

Begin

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  -------------------------------------------------------------
  -- Delete a tree node in I2b2
  -- Not handling Observation Fact. It will take too long. 
  -- KCR@20090404 - First Rev
  -- JEA@20100106 - Added auditing
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME LIKE PATH || '%');
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
	

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH LIKE path || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  END IF;
  
  --i2b2_secure
      DELETE
        FROM i2b2_secure
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

  --concept_counts
      DELETE
        FROM concept_counts
      WHERE 
        concept_path LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_FILL_IN_TREE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_FILL_IN_TREE" 
(
  trial_id VARCHAR2
 ,path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  TrialID varchar2(100);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  auditText varchar2(4000);
  
  ----------------------------------------------
  --Goal: To fill out an I2B2 Tree node
  --Steps. Walk backwards through an i2b2 tree and fill in all missing nodes.
  --\1\2\3\4\5\6\
  --Will check that \1\, \1\2\, etc..all exist.
  ----------------------------------------------
  
  -- JEA@20100107 - Added auditing
  
  --Get the nodes
  CURSOR cNodes is
    --Trimming off the last node as it would never need to be added.
    select distinct substr(c_fullname, 1,instr(c_fullname,'\',-2,1)) as c_fullname
    --select c_fullname
    from i2b2 
    where c_fullname like path || '%';
--      and c_hlevel > = 2;
  
  root_node varchar2(1000);
  node_name varchar(1000);
  v_count NUMBER;
  
BEGIN
  TrialID := upper(trial_id);
  
    stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  --start node with the first slash
 
  --Iterate through each node
  FOR r_cNodes in cNodes Loop
    root_node := '\';
    --Determine how many nodes there are
    --Iterate through, Start with 2 as one will be null from the parser
    
    for loop_counter in 2 .. (length(r_cNodes.c_fullname) - nvl(length(replace(r_cNodes.c_fullname, '\')),0)) / length('\')
    LOOP
      --Determine Node:
      node_name := parse_nth_value(r_cNodes.c_fullname, loop_counter, '\');
      root_node :=  root_node || node_name || '\';
    
      --Dont run for first 2 nodes
    --  if loop_counter > 3 then 
        --Check if node exists. If it does not, add it.
        select count(*)
          into v_count 
        from i2b2
        where c_fullname = root_node;

        --If it doesn't exist, add it
        if v_count = 0 then
			auditText := 'Inserting ' || root_node;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,auditText,0,stepCt,'Done');
            i2b2_add_node(trial_id, root_node, node_name, jobId);
        end if;
    --  end if;
      
    END LOOP;

    --RESET VARIABLES
    root_node := '';
    node_name := '';
  END LOOP;
  
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_WRITE_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_WRITE_AUDIT" 
(
	jobId IN NUMBER,
	databaseName IN VARCHAR2 , 
	procedureName IN VARCHAR2 , 
	stepDesc IN VARCHAR2 , 
	recordsManipulated IN NUMBER,
	stepNumber IN NUMBER,
	stepStatus IN VARCHAR2
)
AS
  lastTime timestamp;
BEGIN
  select max(job_date)
    into lastTime
    from cz_job_audit
    where job_id = jobID;

	insert 	into cz_job_audit(
		job_id, 
		database_name,
 		procedure_name, 
 		step_desc, 
		records_manipulated,
		step_number,
		step_status,
    job_date,
    time_elapsed_secs
	)
	select
 		jobId,
		databaseName,
		procedureName,
		stepDesc,
		recordsManipulated,
		stepNumber,
		stepStatus,
    SYSTIMESTAMP,
      COALESCE(
      EXTRACT (DAY    FROM (SYSTIMESTAMP - lastTime))*24*60*60 + 
      EXTRACT (HOUR   FROM (SYSTIMESTAMP - lastTime))*60*60 + 
      EXTRACT (MINUTE FROM (SYSTIMESTAMP - lastTime))*60 + 
      EXTRACT (SECOND FROM (SYSTIMESTAMP - lastTime))
      ,0)
  from dual;
  
  COMMIT;

END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_WRITE_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_WRITE_AUDIT" 
(
	jobId IN NUMBER,
	databaseName IN VARCHAR2 , 
	procedureName IN VARCHAR2 , 
	stepDesc IN VARCHAR2 , 
	recordsManipulated IN NUMBER,
	stepNumber IN NUMBER,
	stepStatus IN VARCHAR2
)
AS
  lastTime timestamp;
BEGIN
  select max(job_date)
    into lastTime
    from cz_job_audit
    where job_id = jobID;

	insert 	into cz_job_audit(
		job_id, 
		database_name,
 		procedure_name, 
 		step_desc, 
		records_manipulated,
		step_number,
		step_status,
    job_date,
    time_elapsed_secs
	)
	select
 		jobId,
		databaseName,
		procedureName,
		stepDesc,
		recordsManipulated,
		stepNumber,
		stepStatus,
    SYSTIMESTAMP,
      COALESCE(
      EXTRACT (DAY    FROM (SYSTIMESTAMP - lastTime))*24*60*60 + 
      EXTRACT (HOUR   FROM (SYSTIMESTAMP - lastTime))*60*60 + 
      EXTRACT (MINUTE FROM (SYSTIMESTAMP - lastTime))*60 + 
      EXTRACT (SECOND FROM (SYSTIMESTAMP - lastTime))
      ,0)
  from dual;
  
  COMMIT;

END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_ERROR_HANDLER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_ERROR_HANDLER" 
(
  jobID NUMBER,
  procedureName NVARCHAR2
)
AS
  databaseName NVARCHAR2(100);
	errorNumber NUMBER(18,0);
	errorMessage NVARCHAR2(1000);
  errorStack NVARCHAR2(4000);
  errorBackTrace NVARCHAR2(4000);
	stepNo NUMBER(18,0);

BEGIN
  --Get DB Name
	select database_name INTO databaseName
		from cz_job_master 
		where job_id=jobID;
  --Get Latest Step
	select max(step_number) into stepNo from cz_job_audit where job_id = jobID;
  
  --Get all error info
  errorNumber := SQLCODE;
  errorMessage := SQLERRM;
  errorStack := dbms_utility.format_error_stack;
  errorBackTrace := dbms_utility.format_error_backtrace;

  --Update the audit step for the error
  cz_write_audit(jobID, databaseName,procedureName, 'Job Failed: See error log for details',SQL%ROWCOUNT, stepNo, 'FAIL');

  
  --write out the error info
  cz_write_error(jobID, errorNumber, errorMessage, errorStack, errorBackTrace);

END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_DELETE_ALL_NODES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_DELETE_ALL_NODES" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
      
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

Begin

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  -------------------------------------------------------------
  -- Delete a tree node in I2b2
  -- Not handling Observation Fact. It will take too long. 
  -- KCR@20090404 - First Rev
  -- JEA@20100106 - Added auditing
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME LIKE PATH || '%');
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
	

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH LIKE path || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  END IF;
  
  --i2b2_secure
      DELETE
        FROM i2b2_secure
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

  --concept_counts
      DELETE
        FROM concept_counts
      WHERE 
        concept_path LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_DELETE_ALL_NODES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_DELETE_ALL_NODES" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
      
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

Begin

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  -------------------------------------------------------------
  -- Delete a tree node in I2b2
  -- Not handling Observation Fact. It will take too long. 
  -- KCR@20090404 - First Rev
  -- JEA@20100106 - Added auditing
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME LIKE PATH || '%');
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
	

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH LIKE path || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  END IF;
  
  --i2b2_secure
      DELETE
        FROM i2b2_secure
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

  --concept_counts
      DELETE
        FROM concept_counts
      WHERE 
        concept_path LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_DELETE_ALL_NODES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_DELETE_ALL_NODES" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
      
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

Begin

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  -------------------------------------------------------------
  -- Delete a tree node in I2b2
  -- Not handling Observation Fact. It will take too long. 
  -- KCR@20090404 - First Rev
  -- JEA@20100106 - Added auditing
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME LIKE PATH || '%');
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
	

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH LIKE path || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  END IF;
  
  --i2b2_secure
      DELETE
        FROM i2b2_secure
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

  --concept_counts
      DELETE
        FROM concept_counts
      WHERE 
        concept_path LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_DELETE_ALL_NODES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_DELETE_ALL_NODES" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
      
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

Begin

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  -------------------------------------------------------------
  -- Delete a tree node in I2b2
  -- Not handling Observation Fact. It will take too long. 
  -- KCR@20090404 - First Rev
  -- JEA@20100106 - Added auditing
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME LIKE PATH || '%');
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
	

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH LIKE path || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  END IF;
  
  --i2b2_secure
      DELETE
        FROM i2b2_secure
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

  --concept_counts
      DELETE
        FROM concept_counts
      WHERE 
        concept_path LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_DELETE_ALL_NODES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_DELETE_ALL_NODES" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
      
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

Begin

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  -------------------------------------------------------------
  -- Delete a tree node in I2b2
  -- Not handling Observation Fact. It will take too long. 
  -- KCR@20090404 - First Rev
  -- JEA@20100106 - Added auditing
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME LIKE PATH || '%');
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
	

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH LIKE path || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  END IF;
  
  --i2b2_secure
      DELETE
        FROM i2b2_secure
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

  --concept_counts
      DELETE
        FROM concept_counts
      WHERE 
        concept_path LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_FILL_IN_TREE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_FILL_IN_TREE" 
(
  trial_id VARCHAR2
 ,path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  TrialID varchar2(100);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  auditText varchar2(4000);
  
  ----------------------------------------------
  --Goal: To fill out an I2B2 Tree node
  --Steps. Walk backwards through an i2b2 tree and fill in all missing nodes.
  --\1\2\3\4\5\6\
  --Will check that \1\, \1\2\, etc..all exist.
  ----------------------------------------------
  
  -- JEA@20100107 - Added auditing
  
  --Get the nodes
  CURSOR cNodes is
    --Trimming off the last node as it would never need to be added.
    select distinct substr(c_fullname, 1,instr(c_fullname,'\',-2,1)) as c_fullname
    --select c_fullname
    from i2b2 
    where c_fullname like path || '%';
--      and c_hlevel > = 2;
  
  root_node varchar2(1000);
  node_name varchar(1000);
  v_count NUMBER;
  
BEGIN
  TrialID := upper(trial_id);
  
    stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  --start node with the first slash
 
  --Iterate through each node
  FOR r_cNodes in cNodes Loop
    root_node := '\';
    --Determine how many nodes there are
    --Iterate through, Start with 2 as one will be null from the parser
    
    for loop_counter in 2 .. (length(r_cNodes.c_fullname) - nvl(length(replace(r_cNodes.c_fullname, '\')),0)) / length('\')
    LOOP
      --Determine Node:
      node_name := parse_nth_value(r_cNodes.c_fullname, loop_counter, '\');
      root_node :=  root_node || node_name || '\';
    
      --Dont run for first 2 nodes
    --  if loop_counter > 3 then 
        --Check if node exists. If it does not, add it.
        select count(*)
          into v_count 
        from i2b2
        where c_fullname = root_node;

        --If it doesn't exist, add it
        if v_count = 0 then
			auditText := 'Inserting ' || root_node;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,auditText,0,stepCt,'Done');
            i2b2_add_node(trial_id, root_node, node_name, jobId);
        end if;
    --  end if;
      
    END LOOP;

    --RESET VARIABLES
    root_node := '';
    node_name := '';
  END LOOP;
  
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_WRITE_ERROR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_WRITE_ERROR" (JOBID IN NUMBER,
	ERRORNUMBER IN NUMBER , 
	ERRORMESSAGE IN VARCHAR2 , 
	ERRORSTACK IN VARCHAR2,
  ERRORBACKTRACE IN VARCHAR2)
  AUTHID CURRENT_USER
AS
 PRAGMA AUTONOMOUS_TRANSACTION;
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
BEGIN

	INSERT INTO CZ_JOB_ERROR(
		JOB_ID,
		ERROR_NUMBER,
		ERROR_MESSAGE,
		ERROR_STACK,
    ERROR_BACKTRACE,
		SEQ_ID)
	SELECT
		JOBID,
		ERRORNUMBER,
		ERRORMESSAGE,
		ERRORSTACK,
    ERRORBACKTRACE,
		MAX(SEQ_ID) 
  FROM 
    CZ_JOB_AUDIT 
  WHERE 
    JOB_ID=JOBID;
  
  COMMIT;
 
EXCEPTION
    WHEN OTHERS THEN ROLLBACK;
END;
 

/
--------------------------------------------------------
--  DDL for Procedure CZ_WRITE_ERROR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_WRITE_ERROR" (JOBID IN NUMBER,
	ERRORNUMBER IN NUMBER , 
	ERRORMESSAGE IN VARCHAR2 , 
	ERRORSTACK IN VARCHAR2,
  ERRORBACKTRACE IN VARCHAR2)
  AUTHID CURRENT_USER
AS
 PRAGMA AUTONOMOUS_TRANSACTION;
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
BEGIN

	INSERT INTO CZ_JOB_ERROR(
		JOB_ID,
		ERROR_NUMBER,
		ERROR_MESSAGE,
		ERROR_STACK,
    ERROR_BACKTRACE,
		SEQ_ID)
	SELECT
		JOBID,
		ERRORNUMBER,
		ERRORMESSAGE,
		ERRORSTACK,
    ERRORBACKTRACE,
		MAX(SEQ_ID) 
  FROM 
    CZ_JOB_AUDIT 
  WHERE 
    JOB_ID=JOBID;
  
  COMMIT;
 
EXCEPTION
    WHEN OTHERS THEN ROLLBACK;
END;
 

/
--------------------------------------------------------
--  DDL for Procedure CZ_ERROR_HANDLER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_ERROR_HANDLER" 
(
  jobID NUMBER,
  procedureName NVARCHAR2
)
AS
  databaseName NVARCHAR2(100);
	errorNumber NUMBER(18,0);
	errorMessage NVARCHAR2(1000);
  errorStack NVARCHAR2(4000);
  errorBackTrace NVARCHAR2(4000);
	stepNo NUMBER(18,0);

BEGIN
  --Get DB Name
	select database_name INTO databaseName
		from cz_job_master 
		where job_id=jobID;
  --Get Latest Step
	select max(step_number) into stepNo from cz_job_audit where job_id = jobID;
  
  --Get all error info
  errorNumber := SQLCODE;
  errorMessage := SQLERRM;
  errorStack := dbms_utility.format_error_stack;
  errorBackTrace := dbms_utility.format_error_backtrace;

  --Update the audit step for the error
  cz_write_audit(jobID, databaseName,procedureName, 'Job Failed: See error log for details',SQL%ROWCOUNT, stepNo, 'FAIL');

  
  --write out the error info
  cz_write_error(jobID, errorNumber, errorMessage, errorStack, errorBackTrace);

END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_DELETE_ALL_NODES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_DELETE_ALL_NODES" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
      
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

Begin

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  -------------------------------------------------------------
  -- Delete a tree node in I2b2
  -- Not handling Observation Fact. It will take too long. 
  -- KCR@20090404 - First Rev
  -- JEA@20100106 - Added auditing
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME LIKE PATH || '%');
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
	

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH LIKE path || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  END IF;
  
  --i2b2_secure
      DELETE
        FROM i2b2_secure
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

  --concept_counts
      DELETE
        FROM concept_counts
      WHERE 
        concept_path LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_DELETE_ALL_NODES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_DELETE_ALL_NODES" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
      
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

Begin

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  -------------------------------------------------------------
  -- Delete a tree node in I2b2
  -- Not handling Observation Fact. It will take too long. 
  -- KCR@20090404 - First Rev
  -- JEA@20100106 - Added auditing
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME LIKE PATH || '%');
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
	

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH LIKE path || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  END IF;
  
  --i2b2_secure
      DELETE
        FROM i2b2_secure
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

  --concept_counts
      DELETE
        FROM concept_counts
      WHERE 
        concept_path LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_FILL_IN_TREE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_FILL_IN_TREE" 
(
  trial_id VARCHAR2
 ,path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  TrialID varchar2(100);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  auditText varchar2(4000);
  
  ----------------------------------------------
  --Goal: To fill out an I2B2 Tree node
  --Steps. Walk backwards through an i2b2 tree and fill in all missing nodes.
  --\1\2\3\4\5\6\
  --Will check that \1\, \1\2\, etc..all exist.
  ----------------------------------------------
  
  -- JEA@20100107 - Added auditing
  
  --Get the nodes
  CURSOR cNodes is
    --Trimming off the last node as it would never need to be added.
    select distinct substr(c_fullname, 1,instr(c_fullname,'\',-2,1)) as c_fullname
    --select c_fullname
    from i2b2 
    where c_fullname like path || '%';
--      and c_hlevel > = 2;
  
  root_node varchar2(1000);
  node_name varchar(1000);
  v_count NUMBER;
  
BEGIN
  TrialID := upper(trial_id);
  
    stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  --start node with the first slash
 
  --Iterate through each node
  FOR r_cNodes in cNodes Loop
    root_node := '\';
    --Determine how many nodes there are
    --Iterate through, Start with 2 as one will be null from the parser
    
    for loop_counter in 2 .. (length(r_cNodes.c_fullname) - nvl(length(replace(r_cNodes.c_fullname, '\')),0)) / length('\')
    LOOP
      --Determine Node:
      node_name := parse_nth_value(r_cNodes.c_fullname, loop_counter, '\');
      root_node :=  root_node || node_name || '\';
    
      --Dont run for first 2 nodes
    --  if loop_counter > 3 then 
        --Check if node exists. If it does not, add it.
        select count(*)
          into v_count 
        from i2b2
        where c_fullname = root_node;

        --If it doesn't exist, add it
        if v_count = 0 then
			auditText := 'Inserting ' || root_node;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,auditText,0,stepCt,'Done');
            i2b2_add_node(trial_id, root_node, node_name, jobId);
        end if;
    --  end if;
      
    END LOOP;

    --RESET VARIABLES
    root_node := '';
    node_name := '';
  END LOOP;
  
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_FILL_IN_TREE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_FILL_IN_TREE" 
(
  trial_id VARCHAR2
 ,path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  TrialID varchar2(100);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  auditText varchar2(4000);
  
  ----------------------------------------------
  --Goal: To fill out an I2B2 Tree node
  --Steps. Walk backwards through an i2b2 tree and fill in all missing nodes.
  --\1\2\3\4\5\6\
  --Will check that \1\, \1\2\, etc..all exist.
  ----------------------------------------------
  
  -- JEA@20100107 - Added auditing
  
  --Get the nodes
  CURSOR cNodes is
    --Trimming off the last node as it would never need to be added.
    select distinct substr(c_fullname, 1,instr(c_fullname,'\',-2,1)) as c_fullname
    --select c_fullname
    from i2b2 
    where c_fullname like path || '%';
--      and c_hlevel > = 2;
  
  root_node varchar2(1000);
  node_name varchar(1000);
  v_count NUMBER;
  
BEGIN
  TrialID := upper(trial_id);
  
    stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  --start node with the first slash
 
  --Iterate through each node
  FOR r_cNodes in cNodes Loop
    root_node := '\';
    --Determine how many nodes there are
    --Iterate through, Start with 2 as one will be null from the parser
    
    for loop_counter in 2 .. (length(r_cNodes.c_fullname) - nvl(length(replace(r_cNodes.c_fullname, '\')),0)) / length('\')
    LOOP
      --Determine Node:
      node_name := parse_nth_value(r_cNodes.c_fullname, loop_counter, '\');
      root_node :=  root_node || node_name || '\';
    
      --Dont run for first 2 nodes
    --  if loop_counter > 3 then 
        --Check if node exists. If it does not, add it.
        select count(*)
          into v_count 
        from i2b2
        where c_fullname = root_node;

        --If it doesn't exist, add it
        if v_count = 0 then
			auditText := 'Inserting ' || root_node;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,auditText,0,stepCt,'Done');
            i2b2_add_node(trial_id, root_node, node_name, jobId);
        end if;
    --  end if;
      
    END LOOP;

    --RESET VARIABLES
    root_node := '';
    node_name := '';
  END LOOP;
  
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_SHOW_NODE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_SHOW_NODE" 
(
  path VARCHAR2
)
AS
BEGIN
  
  -------------------------------------------------------------
  -- Shows a tree node in I2b2
  -- KCR@20090519 - First Rev
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 

      --I2B2
    UPDATE i2b2
      SET c_visualattributes = 'FA'
    WHERE c_visualattributes LIKE 'F%'
      AND C_FULLNAME LIKE PATH || '%';

     UPDATE i2b2
      SET c_visualattributes = 'LA'
    WHERE c_visualattributes LIKE 'L%'
      AND C_FULLNAME LIKE PATH || '%';
    COMMIT;
  END IF;
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_SHOW_NODE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_SHOW_NODE" 
(
  path VARCHAR2
)
AS
BEGIN
  
  -------------------------------------------------------------
  -- Shows a tree node in I2b2
  -- KCR@20090519 - First Rev
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 

      --I2B2
    UPDATE i2b2
      SET c_visualattributes = 'FA'
    WHERE c_visualattributes LIKE 'F%'
      AND C_FULLNAME LIKE PATH || '%';

     UPDATE i2b2
      SET c_visualattributes = 'LA'
    WHERE c_visualattributes LIKE 'L%'
      AND C_FULLNAME LIKE PATH || '%';
    COMMIT;
  END IF;
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_TABLE_BKP
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_TABLE_BKP" 
AS
BEGIN
  
  -------------------------------------------------------------
  -- Backup the I2B2 tables.
  -- KCR@20090518 - First Rev
  -------------------------------------------------------------
  --Drop existing backups
  
  execute immediate('drop table i2b2metadata.i2b2_bkp');
  execute immediate('drop table i2b2demodata.concept_counts_bkp');
  execute immediate('drop table i2b2demodata.concept_dimension_bkp');
  execute immediate('drop table i2b2demodata.observation_fact_bkp');
  execute immediate('drop table i2b2demodata.patient_dimension_bkp');

  --Backup tables
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2METADATA.I2B2_BKP AS SELECT * FROM I2B2METADATA.I2B2';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.CONCEPT_COUNTS_BKP AS SELECT * FROM I2B2DEMODATA.CONCEPT_COUNTS';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.CONCEPT_DIMENSION_BKP AS SELECT * FROM I2B2DEMODATA.CONCEPT_DIMENSION';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.OBSERVATION_FACT_BKP AS SELECT * FROM I2B2DEMODATA.OBSERVATION_FACT';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.PATIENT_DIMENSION_BKP AS SELECT * FROM I2B2DEMODATA.PATIENT_DIMENSION';
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_TABLE_BKP
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_TABLE_BKP" 
AS
BEGIN
  
  -------------------------------------------------------------
  -- Backup the I2B2 tables.
  -- KCR@20090518 - First Rev
  -------------------------------------------------------------
  --Drop existing backups
  
  execute immediate('drop table i2b2metadata.i2b2_bkp');
  execute immediate('drop table i2b2demodata.concept_counts_bkp');
  execute immediate('drop table i2b2demodata.concept_dimension_bkp');
  execute immediate('drop table i2b2demodata.observation_fact_bkp');
  execute immediate('drop table i2b2demodata.patient_dimension_bkp');

  --Backup tables
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2METADATA.I2B2_BKP AS SELECT * FROM I2B2METADATA.I2B2';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.CONCEPT_COUNTS_BKP AS SELECT * FROM I2B2DEMODATA.CONCEPT_COUNTS';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.CONCEPT_DIMENSION_BKP AS SELECT * FROM I2B2DEMODATA.CONCEPT_DIMENSION';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.OBSERVATION_FACT_BKP AS SELECT * FROM I2B2DEMODATA.OBSERVATION_FACT';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.PATIENT_DIMENSION_BKP AS SELECT * FROM I2B2DEMODATA.PATIENT_DIMENSION';
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure TM_CZ.CZ_WRITE_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."TM_CZ.CZ_WRITE_AUDIT" 
(
	jobId IN NUMBER,
	databaseName IN VARCHAR2 , 
	procedureName IN VARCHAR2 , 
	stepDesc IN VARCHAR2 , 
	recordsManipulated IN NUMBER,
	stepNumber IN NUMBER,
	stepStatus IN VARCHAR2
)
AS
  lastTime timestamp;
BEGIN
  select max(job_date)
    into lastTime
    from cz_job_audit
    where job_id = jobID;

	insert 	into cz_job_audit(
		job_id, 
		database_name,
 		procedure_name, 
 		step_desc, 
		records_manipulated,
		step_number,
		step_status,
    job_date,
    time_elapsed_secs
	)
	select
 		jobId,
		databaseName,
		procedureName,
		stepDesc,
		recordsManipulated,
		stepNumber,
		stepStatus,
    SYSTIMESTAMP,
      COALESCE(
      EXTRACT (DAY    FROM (SYSTIMESTAMP - lastTime))*24*60*60 + 
      EXTRACT (HOUR   FROM (SYSTIMESTAMP - lastTime))*60*60 + 
      EXTRACT (MINUTE FROM (SYSTIMESTAMP - lastTime))*60 + 
      EXTRACT (SECOND FROM (SYSTIMESTAMP - lastTime))
      ,0)
  from dual;
  
  COMMIT;

END;

/
--------------------------------------------------------
--  DDL for Procedure TM_CZ.CZ_WRITE_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."TM_CZ.CZ_WRITE_AUDIT" 
(
	jobId IN NUMBER,
	databaseName IN VARCHAR2 , 
	procedureName IN VARCHAR2 , 
	stepDesc IN VARCHAR2 , 
	recordsManipulated IN NUMBER,
	stepNumber IN NUMBER,
	stepStatus IN VARCHAR2
)
AS
  lastTime timestamp;
BEGIN
  select max(job_date)
    into lastTime
    from cz_job_audit
    where job_id = jobID;

	insert 	into cz_job_audit(
		job_id, 
		database_name,
 		procedure_name, 
 		step_desc, 
		records_manipulated,
		step_number,
		step_status,
    job_date,
    time_elapsed_secs
	)
	select
 		jobId,
		databaseName,
		procedureName,
		stepDesc,
		recordsManipulated,
		stepNumber,
		stepStatus,
    SYSTIMESTAMP,
      COALESCE(
      EXTRACT (DAY    FROM (SYSTIMESTAMP - lastTime))*24*60*60 + 
      EXTRACT (HOUR   FROM (SYSTIMESTAMP - lastTime))*60*60 + 
      EXTRACT (MINUTE FROM (SYSTIMESTAMP - lastTime))*60 + 
      EXTRACT (SECOND FROM (SYSTIMESTAMP - lastTime))
      ,0)
  from dual;
  
  COMMIT;

END;

/
--------------------------------------------------------
--  DDL for Procedure UTIL_CREATE_SYNONYM_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "BIOMART"."UTIL_CREATE_SYNONYM_ALL" 
(
	V_FROMZONE IN VARCHAR2 DEFAULT NULL ,
	V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,SEQUENCE'
)
AUTHID CURRENT_USER
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
	--The name of the table, proc, function or view.
	V_OBJNAME VARCHAR2(50);

	--Dynamic SQL line
	V_CMDLINE VARCHAR2(200);

	--Table list
	CURSOR L_TABLE IS
		SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = UPPER(V_FROMZONE);
	--View List
	CURSOR L_VIEW IS
		SELECT VIEW_NAME FROM ALL_VIEWS WHERE OWNER = UPPER(V_FROMZONE);
	--Procedure and function list (OBJTYPE are PROCEDURE, FUNCTION, TRIGGER)
	CURSOR L_PROCEDURE (OBJTYPE VARCHAR2) IS
		SELECT DISTINCT OBJECT_NAME FROM ALL_PROCEDURES
			WHERE OWNER = UPPER(V_FROMZONE) AND OBJECT_TYPE = OBJTYPE
      AND UPPER(OBJECT_NAME) NOT LIKE 'UTIL%';
	--	Sequences
		--Procedure and function list (OBJTYPE are PROCEDURE, FUNCTION, TRIGGER)
	CURSOR L_SEQUENCE IS
		SELECT DISTINCT SEQUENCE_NAME FROM ALL_SEQUENCES
			WHERE SEQUENCE_OWNER = UPPER(V_FROMZONE);

BEGIN

	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN

		OPEN L_TABLE;
			FETCH L_TABLE INTO V_OBJNAME;
		WHILE L_TABLE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
	
				FETCH L_TABLE  INTO V_OBJNAME;

			EXCEPTION 
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
       END LOOP;
       CLOSE L_TABLE;
   end if;

	--CREATE SYNONYMS FOR VIEWS
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN

		OPEN L_VIEW;
			FETCH L_VIEW INTO V_OBJNAME;
		WHILE L_VIEW%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_VIEW INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE L_VIEW;
   END IF;

-- CREATE SYNONYMS FOR PROCEDURES
	IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' THEN

		OPEN L_PROCEDURE('PROCEDURE');
			FETCH L_PROCEDURE INTO V_OBJNAME;
		WHILE L_PROCEDURE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH l_procedure INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE l_procedure;
   end if;

-- CREATE SYNONYMS FOR FUNCTIONS
	IF UPPER(V_WHATTYPE) LIKE '%FUNCTION%' THEN
		
		OPEN l_procedure('FUNCTION');
			FETCH l_procedure INTO V_OBJNAME;
		WHILE l_procedure%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_PROCEDURE INTO V_OBJNAME;
		
			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE L_PROCEDURE;
   END IF;
   
	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%' THEN

		OPEN L_SEQUENCE;
			FETCH L_SEQUENCE INTO V_OBJNAME;
		WHILE L_SEQUENCE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
			  DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
	
				FETCH L_TABLE  INTO V_OBJNAME;

			EXCEPTION 
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
       END LOOP;
       CLOSE L_SEQUENCE;
   end if;
END;

/
--------------------------------------------------------
--  DDL for Procedure UTIL_CREATE_SYNONYM_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "BIOMART_USER"."UTIL_CREATE_SYNONYM_ALL" 
(
	V_FROMZONE IN VARCHAR2 DEFAULT NULL ,
	V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,SEQUENCE'
)
AUTHID CURRENT_USER
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
	--The name of the table, proc, function or view.
	V_OBJNAME VARCHAR2(50);

	--Dynamic SQL line
	V_CMDLINE VARCHAR2(200);

	--Table list
	CURSOR L_TABLE IS
		SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = UPPER(V_FROMZONE);
	--View List
	CURSOR L_VIEW IS
		SELECT VIEW_NAME FROM ALL_VIEWS WHERE OWNER = UPPER(V_FROMZONE);
	--Procedure and function list (OBJTYPE are PROCEDURE, FUNCTION, TRIGGER)
	CURSOR L_PROCEDURE (OBJTYPE VARCHAR2) IS
		SELECT DISTINCT OBJECT_NAME FROM ALL_PROCEDURES
			WHERE OWNER = UPPER(V_FROMZONE) AND OBJECT_TYPE = OBJTYPE
      AND UPPER(OBJECT_NAME) NOT LIKE 'UTIL%';
	--	Sequences
		--Procedure and function list (OBJTYPE are PROCEDURE, FUNCTION, TRIGGER)
	CURSOR L_SEQUENCE IS
		SELECT DISTINCT SEQUENCE_NAME FROM ALL_SEQUENCES
			WHERE SEQUENCE_OWNER = UPPER(V_FROMZONE);

BEGIN

	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN

		OPEN L_TABLE;
			FETCH L_TABLE INTO V_OBJNAME;
		WHILE L_TABLE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
	
				FETCH L_TABLE  INTO V_OBJNAME;

			EXCEPTION 
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
       END LOOP;
       CLOSE L_TABLE;
   end if;

	--CREATE SYNONYMS FOR VIEWS
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN

		OPEN L_VIEW;
			FETCH L_VIEW INTO V_OBJNAME;
		WHILE L_VIEW%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_VIEW INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE L_VIEW;
   END IF;

-- CREATE SYNONYMS FOR PROCEDURES
	IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' THEN

		OPEN L_PROCEDURE('PROCEDURE');
			FETCH L_PROCEDURE INTO V_OBJNAME;
		WHILE L_PROCEDURE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH l_procedure INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE l_procedure;
   end if;

-- CREATE SYNONYMS FOR FUNCTIONS
	IF UPPER(V_WHATTYPE) LIKE '%FUNCTION%' THEN
		
		OPEN l_procedure('FUNCTION');
			FETCH l_procedure INTO V_OBJNAME;
		WHILE l_procedure%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_PROCEDURE INTO V_OBJNAME;
		
			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE L_PROCEDURE;
   END IF;
   
	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%' THEN

		OPEN L_SEQUENCE;
			FETCH L_SEQUENCE INTO V_OBJNAME;
		WHILE L_SEQUENCE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
	
				FETCH L_TABLE  INTO V_OBJNAME;

			EXCEPTION 
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
       END LOOP;
       CLOSE L_SEQUENCE;
   end if;
END;

/
--------------------------------------------------------
--  DDL for Procedure UTIL_CREATE_SYNONYM_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "BIOMART"."UTIL_CREATE_SYNONYM_ALL" 
(
	V_FROMZONE IN VARCHAR2 DEFAULT NULL ,
	V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,SEQUENCE'
)
AUTHID CURRENT_USER
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
	--The name of the table, proc, function or view.
	V_OBJNAME VARCHAR2(50);

	--Dynamic SQL line
	V_CMDLINE VARCHAR2(200);

	--Table list
	CURSOR L_TABLE IS
		SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = UPPER(V_FROMZONE);
	--View List
	CURSOR L_VIEW IS
		SELECT VIEW_NAME FROM ALL_VIEWS WHERE OWNER = UPPER(V_FROMZONE);
	--Procedure and function list (OBJTYPE are PROCEDURE, FUNCTION, TRIGGER)
	CURSOR L_PROCEDURE (OBJTYPE VARCHAR2) IS
		SELECT DISTINCT OBJECT_NAME FROM ALL_PROCEDURES
			WHERE OWNER = UPPER(V_FROMZONE) AND OBJECT_TYPE = OBJTYPE
      AND UPPER(OBJECT_NAME) NOT LIKE 'UTIL%';
	--	Sequences
		--Procedure and function list (OBJTYPE are PROCEDURE, FUNCTION, TRIGGER)
	CURSOR L_SEQUENCE IS
		SELECT DISTINCT SEQUENCE_NAME FROM ALL_SEQUENCES
			WHERE SEQUENCE_OWNER = UPPER(V_FROMZONE);

BEGIN

	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN

		OPEN L_TABLE;
			FETCH L_TABLE INTO V_OBJNAME;
		WHILE L_TABLE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
	
				FETCH L_TABLE  INTO V_OBJNAME;

			EXCEPTION 
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
       END LOOP;
       CLOSE L_TABLE;
   end if;

	--CREATE SYNONYMS FOR VIEWS
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN

		OPEN L_VIEW;
			FETCH L_VIEW INTO V_OBJNAME;
		WHILE L_VIEW%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_VIEW INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE L_VIEW;
   END IF;

-- CREATE SYNONYMS FOR PROCEDURES
	IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' THEN

		OPEN L_PROCEDURE('PROCEDURE');
			FETCH L_PROCEDURE INTO V_OBJNAME;
		WHILE L_PROCEDURE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH l_procedure INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE l_procedure;
   end if;

-- CREATE SYNONYMS FOR FUNCTIONS
	IF UPPER(V_WHATTYPE) LIKE '%FUNCTION%' THEN
		
		OPEN l_procedure('FUNCTION');
			FETCH l_procedure INTO V_OBJNAME;
		WHILE l_procedure%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_PROCEDURE INTO V_OBJNAME;
		
			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE L_PROCEDURE;
   END IF;
   
	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%' THEN

		OPEN L_SEQUENCE;
			FETCH L_SEQUENCE INTO V_OBJNAME;
		WHILE L_SEQUENCE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
			  DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
	
				FETCH L_TABLE  INTO V_OBJNAME;

			EXCEPTION 
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
       END LOOP;
       CLOSE L_SEQUENCE;
   end if;
END;

/
--------------------------------------------------------
--  DDL for Procedure UTIL_CREATE_SYNONYM_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "BIOMART_USER"."UTIL_CREATE_SYNONYM_ALL" 
(
	V_FROMZONE IN VARCHAR2 DEFAULT NULL ,
	V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,SEQUENCE'
)
AUTHID CURRENT_USER
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
	--The name of the table, proc, function or view.
	V_OBJNAME VARCHAR2(50);

	--Dynamic SQL line
	V_CMDLINE VARCHAR2(200);

	--Table list
	CURSOR L_TABLE IS
		SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = UPPER(V_FROMZONE);
	--View List
	CURSOR L_VIEW IS
		SELECT VIEW_NAME FROM ALL_VIEWS WHERE OWNER = UPPER(V_FROMZONE);
	--Procedure and function list (OBJTYPE are PROCEDURE, FUNCTION, TRIGGER)
	CURSOR L_PROCEDURE (OBJTYPE VARCHAR2) IS
		SELECT DISTINCT OBJECT_NAME FROM ALL_PROCEDURES
			WHERE OWNER = UPPER(V_FROMZONE) AND OBJECT_TYPE = OBJTYPE
      AND UPPER(OBJECT_NAME) NOT LIKE 'UTIL%';
	--	Sequences
		--Procedure and function list (OBJTYPE are PROCEDURE, FUNCTION, TRIGGER)
	CURSOR L_SEQUENCE IS
		SELECT DISTINCT SEQUENCE_NAME FROM ALL_SEQUENCES
			WHERE SEQUENCE_OWNER = UPPER(V_FROMZONE);

BEGIN

	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN

		OPEN L_TABLE;
			FETCH L_TABLE INTO V_OBJNAME;
		WHILE L_TABLE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
	
				FETCH L_TABLE  INTO V_OBJNAME;

			EXCEPTION 
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
       END LOOP;
       CLOSE L_TABLE;
   end if;

	--CREATE SYNONYMS FOR VIEWS
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN

		OPEN L_VIEW;
			FETCH L_VIEW INTO V_OBJNAME;
		WHILE L_VIEW%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_VIEW INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE L_VIEW;
   END IF;

-- CREATE SYNONYMS FOR PROCEDURES
	IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' THEN

		OPEN L_PROCEDURE('PROCEDURE');
			FETCH L_PROCEDURE INTO V_OBJNAME;
		WHILE L_PROCEDURE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH l_procedure INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE l_procedure;
   end if;

-- CREATE SYNONYMS FOR FUNCTIONS
	IF UPPER(V_WHATTYPE) LIKE '%FUNCTION%' THEN
		
		OPEN l_procedure('FUNCTION');
			FETCH l_procedure INTO V_OBJNAME;
		WHILE l_procedure%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_PROCEDURE INTO V_OBJNAME;
		
			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE L_PROCEDURE;
   END IF;
   
	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%' THEN

		OPEN L_SEQUENCE;
			FETCH L_SEQUENCE INTO V_OBJNAME;
		WHILE L_SEQUENCE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
	
				FETCH L_TABLE  INTO V_OBJNAME;

			EXCEPTION 
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
       END LOOP;
       CLOSE L_SEQUENCE;
   end if;
END;

/
--------------------------------------------------------
--  DDL for Procedure UTIL_CREATE_SYNONYM_ALL_V2
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "BIOMART_USER"."UTIL_CREATE_SYNONYM_ALL_V2" 
(
	V_FROMZONE IN VARCHAR2 DEFAULT NULL ,
	V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,SEQUENCE'
)
AUTHID CURRENT_USER
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
	--The name of the table, proc, function or view.
	V_OBJNAME VARCHAR2(50);

	--Dynamic SQL line
	V_CMDLINE VARCHAR2(200);

BEGIN

	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
		for v_tab_rec in (select table_name from all_tables where owner = upper(v_fromzone) )
		loop
			V_CMDLINE := 'create or replace synonym ' || v_tab_rec.table_name || ' for ' || UPPER(V_FROMZONE) || '.' || v_tab_rec.table_name ;
      dbms_output.put_line(v_cmdline);
			EXECUTE IMMEDIATE V_CMDLINE;
			DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
		   END LOOP;
   end if;

	--CREATE SYNONYMS FOR VIEWS
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
	for v_view_rec in (select view_name from all_views where owner = upper(v_fromzone) )
	LOOP
		V_CMDLINE := 'create or replace synonym ' || v_view_rec.view_name || ' for ' || UPPER(V_FROMZONE) || '.' || v_view_rec.view_name ;
		EXECUTE IMMEDIATE V_CMDLINE;
		DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
		END LOOP;
   END IF;

-- CREATE SYNONYMS FOR PROCEDURES
	IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' THEN
	for v_proc_rec in (SELECT DISTINCT OBJECT_NAME FROM ALL_PROCEDURES
						WHERE OWNER = UPPER(V_FROMZONE) AND OBJECT_TYPE = 'PROCEDURE'
						AND UPPER(OBJECT_NAME) NOT LIKE 'UTIL%')
	LOOP
		V_CMDLINE := 'create or replace synonym ' || v_proc_rec.object_name || ' for ' || UPPER(V_FROMZONE) || '.' || v_proc_rec.object_name ;
		EXECUTE IMMEDIATE V_CMDLINE;
		DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
		END LOOP;
   end if;

-- CREATE SYNONYMS FOR Functions
	IF UPPER(V_WHATTYPE) LIKE '%FUNCTION%' THEN
	for v_func_rec in (SELECT DISTINCT OBJECT_NAME FROM ALL_PROCEDURES
						WHERE OWNER = UPPER(V_FROMZONE) AND OBJECT_TYPE = 'FUNCTION'
						AND UPPER(OBJECT_NAME) NOT LIKE 'UTIL%')
	LOOP
		V_CMDLINE := 'create or replace synonym ' || v_func_rec.object_name || ' for ' || UPPER(V_FROMZONE) || '.' || v_func_rec.object_name ;
		EXECUTE IMMEDIATE V_CMDLINE;
		DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
		END LOOP;
   end if;
   
	-- Create synonyms for Sequence
	IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%' THEN
	for v_seq_rec in (select sequence_name from all_sequences where sequence_owner = upper(v_fromzone) )
	LOOP
		V_CMDLINE := 'create or replace synonym ' || v_seq_rec.sequence_name || ' for ' || UPPER(V_FROMZONE) || '.' || v_seq_rec.sequence_name ;
		EXECUTE IMMEDIATE V_CMDLINE;
		DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
       END LOOP;
   end if;
END;

/
--------------------------------------------------------
--  DDL for Procedure UTIL_CREATE_SYNONYM_ALL_V2
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "BIOMART_USER"."UTIL_CREATE_SYNONYM_ALL_V2" 
(
	V_FROMZONE IN VARCHAR2 DEFAULT NULL ,
	V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,SEQUENCE'
)
AUTHID CURRENT_USER
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
	--The name of the table, proc, function or view.
	V_OBJNAME VARCHAR2(50);

	--Dynamic SQL line
	V_CMDLINE VARCHAR2(200);

BEGIN

	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
		for v_tab_rec in (select table_name from all_tables where owner = upper(v_fromzone) )
		loop
			V_CMDLINE := 'create or replace synonym ' || v_tab_rec.table_name || ' for ' || UPPER(V_FROMZONE) || '.' || v_tab_rec.table_name ;
      dbms_output.put_line(v_cmdline);
			EXECUTE IMMEDIATE V_CMDLINE;
			DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
		   END LOOP;
   end if;

	--CREATE SYNONYMS FOR VIEWS
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
	for v_view_rec in (select view_name from all_views where owner = upper(v_fromzone) )
	LOOP
		V_CMDLINE := 'create or replace synonym ' || v_view_rec.view_name || ' for ' || UPPER(V_FROMZONE) || '.' || v_view_rec.view_name ;
		EXECUTE IMMEDIATE V_CMDLINE;
		DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
		END LOOP;
   END IF;

-- CREATE SYNONYMS FOR PROCEDURES
	IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' THEN
	for v_proc_rec in (SELECT DISTINCT OBJECT_NAME FROM ALL_PROCEDURES
						WHERE OWNER = UPPER(V_FROMZONE) AND OBJECT_TYPE = 'PROCEDURE'
						AND UPPER(OBJECT_NAME) NOT LIKE 'UTIL%')
	LOOP
		V_CMDLINE := 'create or replace synonym ' || v_proc_rec.object_name || ' for ' || UPPER(V_FROMZONE) || '.' || v_proc_rec.object_name ;
		EXECUTE IMMEDIATE V_CMDLINE;
		DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
		END LOOP;
   end if;

-- CREATE SYNONYMS FOR Functions
	IF UPPER(V_WHATTYPE) LIKE '%FUNCTION%' THEN
	for v_func_rec in (SELECT DISTINCT OBJECT_NAME FROM ALL_PROCEDURES
						WHERE OWNER = UPPER(V_FROMZONE) AND OBJECT_TYPE = 'FUNCTION'
						AND UPPER(OBJECT_NAME) NOT LIKE 'UTIL%')
	LOOP
		V_CMDLINE := 'create or replace synonym ' || v_func_rec.object_name || ' for ' || UPPER(V_FROMZONE) || '.' || v_func_rec.object_name ;
		EXECUTE IMMEDIATE V_CMDLINE;
		DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
		END LOOP;
   end if;
   
	-- Create synonyms for Sequence
	IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%' THEN
	for v_seq_rec in (select sequence_name from all_sequences where sequence_owner = upper(v_fromzone) )
	LOOP
		V_CMDLINE := 'create or replace synonym ' || v_seq_rec.sequence_name || ' for ' || UPPER(V_FROMZONE) || '.' || v_seq_rec.sequence_name ;
		EXECUTE IMMEDIATE V_CMDLINE;
		DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
       END LOOP;
   end if;
END;

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "BIOMART"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "BIOMART_STAGE"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "DEAPP"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "I2B2DEMODATA"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "I2B2METADATA"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "SEARCHAPP"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_LZ"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_WZ"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "BIOMART"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "BIOMART_STAGE"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "DEAPP"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "I2B2DEMODATA"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "I2B2METADATA"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "SEARCHAPP"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_LZ"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_WZ"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES,SEQUENCE')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names
	--	JEA@20120223	Added grant drop any table, grant analyze any to TABLES routine
	--	JEA@20120226	Added additional grants to TABLES routine

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
	 
	 execute immediate 'grant create any table to ' || username;
	 execute immediate 'grant drop any table to ' || username;
	 execute immediate 'grant alter any table to ' || username;
	 execute immediate 'grant create any index to ' || username;
	 execute immediate 'grant drop any index to ' || username;
	 execute immediate 'grant analyze any to ' || username;
	 
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;
  
 IF UPPER(V_WHATTYPE) LIKE '%SEQUENCE%'  THEN
    dbms_output.put_line(chr(10) || 'Sequence');

    for L_PROCEDURE in (select object_name from user_objects where object_type = 'SEQUENCE' )
     LOOP

       execute immediate 'grant select on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure CREATE_SYNONYMS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CREATE_SYNONYMS" (
  fromDB IN VARCHAR2,
  toDB IN VARCHAR2
)
AS 
  CURSOR cTableList is
    select 
      UPPER(owner) AS OWNER,
      UPPER(table_name) AS TABLE_NAME
    from
      all_tables 
    order by owner, table_name;
  
  dbCount NUMBER;  
  sourceDB varchar2(200);
  targetDB VARCHAR2(200);

  dynamicSQL varchar2(2000);
    
BEGIN
  -------------------------------------------------------------------------------
    --Create or replace Synonyms Point to DB A (TO) From DB B (FROM)
    --Input: From DB, TO DB
    --Output: Nothing
   -- KCR@20090310 - First rev. 
   -------------------------------------------------------------------------------

/* CANT READ FROM DBA_TABLESPACES
    --Check that DB's exist
    select count(*) into dbCount from dba_tablespaces where tablespace_name = upper(fromDB);
    if dbCOunt > 1 
      then
      dbms_output.put_line('From DB is invalid!: ' || fromDB);
   end if;
   
    if dbCount > 1 
      then
      dbms_output.put_line('TO DB is invalid!: ' || toDB);
   end if;
*/

  sourceDB := UPPER(fromDB);
  targetDB := UPPER(toDB);



    --Loop through full list of results (All table for all schemas)
    for r_cTableList in cTableList
    loop
      --if The current owner(DB) matched the toDB then begin creating Synonyms.
      if r_cTableList.owner = targetDB
        then
        dynamicSQL := 'CREATE OR REPLACE SYNONYM "' || sourceDB || '"."' || r_cTableList.table_name || '" FOR "' || targetDB || '"."' || r_cTableList.table_name || '"';
        dbms_output.put_line(dynamicSQL);
        EXECUTE IMMEDIATE dynamicSQL;
     end if;
    commit;  
    end loop; --Loops through full resultset
    
END;

 
 
 
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZX_END_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZX_END_AUDIT" (V_JOB_ID IN NUMBER DEFAULT NULL ,
  V_JOB_STATUS IN VARCHAR2 DEFAULT 'Success')
  AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: CZX_END_AUDIT
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------	
 PRAGMA AUTONOMOUS_TRANSACTION;
 
  ENDDATE TIMESTAMP;

BEGIN
  DBMS_OUTPUT.PUT_LINE('Job ID = ' || V_JOB_ID || ',' || V_JOB_STATUS);
  
  ENDDATE := SYSTIMESTAMP;
  
	UPDATE CZ_JOB_MASTER
		SET 
			ACTIVE='N',
			END_DATE = ENDDATE,
      TIME_ELAPSED_SECS = 
      EXTRACT (DAY    FROM (ENDDATE - START_DATE))*24*60*60 + 
      EXTRACT (HOUR   FROM (ENDDATE - START_DATE))*60*60 + 
      EXTRACT (MINUTE FROM (ENDDATE - START_DATE))*60 + 
      EXTRACT (SECOND FROM (ENDDATE - START_DATE)),
			JOB_STATUS = V_JOB_STATUS
		WHERE ACTIVE='Y' 
		AND JOB_ID=V_JOB_ID;

COMMIT;

	IF V_JOB_STATUS = 'FAIL'
	THEN
		DBMS_OUTPUT.PUT_LINE('Job Failed - See cz_job_error for details');
	END IF;
  
--EXCEPTION
--	WHEN OTHERS THEN 
--	DBMS_OUTPUT.PUT_LINE('ERROR HERE!');
--    ROLLBACK;  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZX_ERROR_HANDLER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZX_ERROR_HANDLER" (JOBID NUMBER,
	PROCEDURENAME NVARCHAR2)
  AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: CZX_ERROR_HANDLER
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------	
	DATABASENAME NVARCHAR2(100);
	ERRORNUMBER NUMBER(18,0);
	ERRORMESSAGE NVARCHAR2(1000);
	ERRORSTACK NVARCHAR2(4000);
	ERRORBACKTRACE NVARCHAR2(4000);
	STEPNO NUMBER(18,0);

BEGIN
	 --GET DB NAME
	SELECT DATABASE_NAME 
		INTO DATABASENAME
	FROM CZ_JOB_MASTER 
		WHERE JOB_ID=JOBID;
  
	--GET LATEST STEP
	SELECT MAX(STEP_NUMBER) 
		INTO STEPNO 
	FROM CZ_JOB_AUDIT 
		WHERE JOB_ID = JOBID;
  
	--GET ALL ERROR INFO
	ERRORNUMBER := SQLCODE;
	ERRORMESSAGE := SQLERRM;
	ERRORSTACK := DBMS_UTILITY.FORMAT_ERROR_STACK;
	ERRORBACKTRACE := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;

	--UPDATE THE AUDIT STEP FOR THE ERROR
	CZX_WRITE_AUDIT(JOBID, DATABASENAME,PROCEDURENAME, 'Job Failed: See error log for details',SQL%ROWCOUNT, STEPNO, 'FAIL');

	--WRITE OUT THE ERROR INFO
	CZX_WRITE_ERROR(JOBID, ERRORNUMBER, ERRORMESSAGE, ERRORSTACK, ERRORBACKTRACE);

	--COMPLETE THE JOB WITH FAILURE
	CZX_END_AUDIT (JOBID, 'FAIL');

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZX_INFO_HANDLER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZX_INFO_HANDLER" 
(
  jobId IN NUMBER,
  messageID IN NUMBER ,
  messageLine IN NUMBER,
  messageProcedure IN VARCHAR2 ,
  infoMessage IN VARCHAR2,
  stepNumber IN VARCHAR2
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: CZX_INFO_HANDLER
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------	
  databaseName VARCHAR2(100);
BEGIN

  select
    database_name INTO databasename
  from
    cz_job_master
  where
    job_id=jobID;

  czx_write_audit( jobID, databaseName, messageProcedure, 'Step contains more details', 0, stepNumber, 'Information' );

  czx_write_info(jobID, messageID, messageLine, messageProcedure, infoMessage );

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZX_RUN_ONE_TEST
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZX_RUN_ONE_TEST" 
(
  v_test_category_id	number
 ,v_test_id				number
 ,currentRunID 			NUMBER := null
)
AS
	--	Procedure to run one test in CZ_TEST
	
	--	JEA@20111019	New

	--	Define the abstract result set record
	
	TYPE r_type IS RECORD (
		rtn_text          VARCHAR2 (2000),
		rtn_nbr           integer
	);
	
	--	Define the abstract result set table
	TYPE tr_type IS TABLE OF r_type;

	--	Define the result set
	
	rtn_array tr_type;

	--	Variables
	
	testTable		varchar2(2000);
	testSQL   		varchar2(2000);
	tableType		varchar2(2000);
	extrnlLocation	varchar2(2000);
	runID			number(18,0);
	runDate			date;
	
	BEGIN	
	
		--	Initialize runDate
		
		select sysdate into runDate from dual;
		
		--	Initialize runId if not passed as parameter
		
		runId := currentRunId;
		
		if (runId is null or runId < 0) then
			select seq_cz.nextval into runId from dual;
		end if;
		
		--	Get information on test from CZ_TEST
		
		select test_table
			  ,test_sql
			  ,nvl(table_type,'REGULAR') as table_type
		into testTable
			,testSQL
			,tableType
		from cz_test
		where test_id = v_test_id;
		
		if upper(tableType) = 'EXTERNAL' then
			select location into extrnlLocation 
			from all_external_locations
			where table_name = testTable;
		else
			extrnlLocation := '';
		end if;

	--	testSQL := 'Select  ' || '''' || 'x' || '''' || ' as rtn_value, count(distinct site_id || subject_id) from clinical_data_extrnl';

		execute immediate(testSQL) BULK COLLECT INTO rtn_array;
      
		for i in rtn_array.first .. rtn_array.last
		loop
		--	dbms_output.put_line(rtn_array(i).rtn_text || ' ' || to_char(rtn_array(i).rtn_nbr));
			
			if (rtn_array(i).rtn_text is not null) then
				insert into cz_test_result
				(test_id, test_result_text, test_result_nbr, test_run_id, external_location, run_date)
				select v_test_id
					  ,nullif(upper(rtn_array(i).rtn_text),'X')
					  ,rtn_array(i).rtn_nbr
					  ,runId
					  ,extrnlLocation
					  ,runDate
				from dual;
			end if;
			
		end loop;
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZX_RUN_TEST_CATEGORY
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZX_RUN_TEST_CATEGORY" 
(
  V_TEST_CATEGORY_ID	number
  ,study_id varchar2
)
AS
	--	Procedure to run one test in CZ_TEST	
	--	JEA@20111019	New
	--	Define the abstract result set record
	
	runID			number(18,0);
	RUNDATE			date;
  V_NAMEID    number(18,0);
  currentRunID 			NUMBER;  
	

  CURSOR C_TEST IS 
  select distinct 
         TEST_ID
   from  CZ_TEST a
   where TEST_CATEGORY_ID = V_TEST_CATEGORY_ID;
   
BEGIN   
     select sysdate into runDate from dual;
		
		--	Initialize runId if not passed as parameter
		
		runId := currentRunId;
		
		if (runId is null or runId < 0) then
			select seq_cz.nextval into runId from dual;
		end if;
    
    
    OPEN C_TEST;
    FETCH C_TEST INTO V_NameID;
    
    WHILE C_TEST%FOUND
			LOOP
        begin
        CZX_RUN_ONE_TEST(V_TEST_CATEGORY_ID,V_NameID,Runid);
        END;
       
       --DBMS_OUTPUT.PUT_LINE(;
       FETCH C_TEST INTO V_NAMEID;
       END LOOP;
       CLOSE C_TEST;
   
  
		
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZX_START_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZX_START_AUDIT" 
(V_JOB_NAME IN VARCHAR2 DEFAULT NULL ,
  V_DATABASE_NAME IN VARCHAR2 DEFAULT NULL ,
  V_JOB_ID OUT NUMBER)
  AUTHID CURRENT_USER  
IS 
  PRAGMA AUTONOMOUS_TRANSACTION;
-------------------------------------------------------------------------------------
-- NAME: CZX_START_AUDIT
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

BEGIN
   INSERT INTO CZ_JOB_MASTER
     ( START_DATE, 
		ACTIVE, 
		USERNAME,
		SESSION_ID, 
		DATABASE_NAME, 
		JOB_NAME, 
		JOB_STATUS )
     VALUES (
		SYSDATE, 
		'Y', 
		USER, 
		UID, 
		V_DATABASE_NAME, 
		V_JOB_NAME, 
		'Running' )

	RETURNING JOB_ID INTO V_JOB_ID;
	
	COMMIT;
  
EXCEPTION
    WHEN OTHERS THEN ROLLBACK;
END;
 

/
--------------------------------------------------------
--  DDL for Procedure CZX_TABLE_PROFILER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZX_TABLE_PROFILER" 
(
  V_TABLE in varchar2 default null ,
  NBRROWS IN NUMBER DEFAULT 100
)
AS
   /*
   	file: czx_table_profiler.sql
   	desc: Profiles the data and structure of a specific table.
   	KCR@20100614 - Created Script
   	Copyright Ac 2010 Recombinant Data Corp
   	*/
   v_columnName VARCHAR2(250);
   v_dataType VARCHAR2(250);
   v_maxLength VARCHAR2(250);
   v_precision VARCHAR2(250);
   v_scale VARCHAR2(250);
   v_dynamicSQL VARCHAR2(8000);
   v_dynamicCursor VARCHAR2(8000);
   V_VIEWNAME varchar2(250);
   RCOUNT integer ;
  
   
   
   -- Converting data to varchar for dynamic scripts
   v_v_record_sample_percent VARCHAR2(3);
   
   cursor ProfileTable is
      select COLUMN_NAME, DATA_TYPE, DATA_LENGTH, DATA_PRECISION, DATA_SCALE
      from user_tab_columns 
      where table_name = v_table and column_name not in 
            (select column_name from cz_data_profile_column_exclusi where table_name = v_table )
      order by column_name;

-- Can be 1 to 100% (Default is 100)
begin
   
  v_viewName := 'xxx_' || v_table || '_view' ;
   
   --Building a View to use a sample of data
   v_dynamicSQL := 'create or replace view ' || v_viewName || ' as' ||
                  ' select  *   from ' || V_TABLE || ' WHERE ROWNUM < ' || NBRROWS ;
   dbms_output.put_line(v_dynamicSQL);
   EXECUTE IMMEDIATE(v_dynamicSQL);
   
   
   --Delete the existing stats on the tables
   DELETE CZ_DATA_PROFILE_STATS WHERE table_name = v_table;
    
   --Delete the existing stats for this table
   DELETE CZ_DATA_PROFILE_COLUMN_SAMPLE  WHERE table_name = v_table;
   
   OPEN ProfileTable;
   FETCH ProfileTable INTO v_columnName,v_dataType,v_maxLength,v_precision,v_scale;
   WHILE ProfileTable%FOUND
   LOOP

      BEGIN
         --Get a count of Null values or blank values
         v_dynamicSQL := 'INSERT INTO CZ_DATA_PROFILE_STATS' || ' (table_name, column_name, data_type, column_length, column_precision, column_scale, null_count)' || ' select ''' || v_table || ''', ''' || v_columnName || ''', ''' || v_dataType || ''', ' || v_maxLength || ', ' || v_precision || ', ' || v_scale || ', count(*)' || ' from ' || v_viewName || ' where ' || v_columnName || ' is null or ltrim(rtrim(' || v_columnName || ')) = ''''' ;
         DBMS_OUTPUT.PUT_LINE(V_DYNAMICSQL);
          EXECUTE IMMEDIATE (v_dynamicSQL);
         
         --Get a count of Non Null values
         v_dynamicSQL := 'UPDATE CZ_DATA_PROFILE_STATS' || ' set non_null_count = (' || ' select count(*)' || ' from ' || v_viewName || ' where ' || v_columnName || ' is not null AND ltrim(rtrim(' || v_columnName || ')) != '''')' || ' where table_name = ''' || v_table || '''' || ' and column_name = ''' || v_columnName || '''' ;
         DBMS_OUTPUT.PUT_LINE(V_DYNAMICSQL);
 
         EXECUTE IMMEDIATE (v_dynamicSQL);
         
         --get a count of Distinct Values
         v_dynamicSQL := 'UPDATE CZ_DATA_PROFILE_STATS' || ' set distinct_count = (' || ' select count(distinct ' || v_columnName || ')' || ' from ' || v_viewName || ' where ' || v_columnName || ' is not null and ltrim(rtrim(' || v_columnName || ')) != '''')' || ' where table_name = ''' || v_table || '''' || ' and column_name = ''' || v_columnName || '''' ;
          DBMS_OUTPUT.PUT_LINE(V_DYNAMICSQL);
          EXECUTE IMMEDIATE (v_dynamicSQL);
         
         --get max length
         v_dynamicSQL := 'UPDATE CZ_DATA_PROFILE_STATS' || ' set max_length = (' || ' select max(len(ltrim(rtrim(' || v_columnName || '))))' || ' from ' || v_viewName || ' where ' || v_columnName || ' is not null and ltrim(rtrim(' || v_columnName || ')) != '''')' || ' where table_name = ''' || v_table || '''' || ' and column_name = ''' || v_columnName || '''' ;
         EXECUTE IMMEDIATE (v_dynamicSQL);
         
         --get min length
         v_dynamicSQL := 'UPDATE CZ_DATA_PROFILE_STATS' || ' set min_length = (' || ' select min(len(ltrim(rtrim(' || v_columnName || '))))' || ' from ' || v_viewName || ' where ' || v_columnName || ' is not null and ltrim(rtrim(' || v_columnName || ')) != '''')' || ' where table_name = ''' || v_table || '''' || ' and column_name = ''' || v_columnName || '''' ;
         DBMS_OUTPUT.PUT_LINE(V_DYNAMICSQL);
          EXECUTE IMMEDIATE (v_dynamicSQL);
         
         --get max length value
         v_dynamicSQL := 'UPDATE CZ_DATA_PROFILE_STATS' || ' set max_length_value = (' || ' select top 1 ltrim(rtrim(' || v_columnName || '))' || ' from ' || v_viewName || ' where ' || v_columnName || ' is not null and ltrim(rtrim(' || v_columnName || ')) != ''''' || ' and len(ltrim(rtrim(' || v_columnName || '))) = CZ_DATA_PROFILE_STATS.max_length)' || ' where table_name = ''' || v_table || '''' || ' and column_name = ''' || v_columnName || '''' ;
         DBMS_OUTPUT.PUT_LINE(V_DYNAMICSQL);
          EXECUTE IMMEDIATE (v_dynamicSQL);
         
         --get min length value
         v_dynamicSQL := 'UPDATE CZ_DATA_PROFILE_STATS' || ' set min_length_value = (' || ' select top 1 ltrim(rtrim(' || v_columnName || '))' || ' from ' || v_viewName || ' where ' || v_columnName || ' is not null and ltrim(rtrim(' || v_columnName || ')) != ''''' || ' and len(ltrim(rtrim(' || v_columnName || '))) = CZ_DATA_PROFILE_STATS.min_length)' || ' where table_name = ''' || v_table || '''' || ' and column_name = ''' || v_columnName || '''' ;
          DBMS_OUTPUT.PUT_LINE(V_DYNAMICSQL);
          EXECUTE IMMEDIATE (v_dynamicSQL);
         
         --get First value when sorted
         v_dynamicSQL := 'UPDATE CZ_DATA_PROFILE_STATS' || ' set first_value = (' || ' select top 1 ltrim(rtrim(' || v_columnName || '))' || ' from ' || v_viewName || ' where ' || v_columnName || ' is not null and ltrim(rtrim(' || v_columnName || ')) != ''''' || ' order by ltrim(rtrim(' || v_columnName || ')))' || ' where table_name = ''' || v_table || '''' || ' and column_name = ''' || v_columnName || '''' ;
          DBMS_OUTPUT.PUT_LINE(V_DYNAMICSQL);
          EXECUTE IMMEDIATE (v_dynamicSQL);
         
         --get last values when sorted
         v_dynamicSQL := 'UPDATE CZ_DATA_PROFILE_STATS' || ' set last_value = (' || ' select top 1 ltrim(rtrim(' || v_columnName || '))' || ' from ' || v_viewName || ' where ' || v_columnName || ' is not null and ltrim(rtrim(' || v_columnName || ')) != ''''' || ' order by ltrim(rtrim(' || v_columnName || '))' || ' desc)' || ' where table_name = ''' || v_table || '''' || ' and column_name = ''' || v_columnName || '''' ;
          DBMS_OUTPUT.PUT_LINE(V_DYNAMICSQL);
          EXECUTE IMMEDIATE (v_dynamicSQL);
         
         -- Get the top 250 values and the count for each column
         v_dynamicSQL := 'INSERT INTO CZ_DATA_PROFILE_COLUMN_SAMPLE' || ' (table_name, column_name, value, count)' || ' select * ''' || v_table || ''', ''' || v_columnName || ''', ltrim(rtrim(' || v_columnName || ')),  count(*)' || ' from ' || v_viewName || ' where ' || v_columnName || ' is not null and ltrim(rtrim(' || v_columnName || ')) != ''''' || ' and ' || v_columnName || ' not like ''%timestamp%''' || ' and ' || v_columnName || ' not like ''%_by%''' || ' group by ltrim(rtrim(' || v_columnName || '))' ;
          DBMS_OUTPUT.PUT_LINE(V_DYNAMICSQL);
          EXECUTE IMMEDIATE (v_dynamicSQL);
         
         FETCH ProfileTable INTO v_columnName,v_dataType,v_maxLength,v_precision,v_scale;
      END;
   END LOOP;
   CLOSE ProfileTable;
   
   --drop temporary view
   v_dynamicSQL := 'drop view ' || v_viewName ;
   EXECUTE IMMEDIATE (v_dynamicSQL);
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZX_WRITE_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZX_WRITE_AUDIT" (JOBID IN NUMBER,
	DATABASENAME IN VARCHAR2 ,
	PROCEDURENAME IN VARCHAR2 ,
	STEPDESC IN VARCHAR2 ,
	RECORDSMANIPULATED IN NUMBER,
	STEPNUMBER IN NUMBER,
	STEPSTATUS IN VARCHAR2)
  AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: CZX_WRITE_AUDIT
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
 PRAGMA AUTONOMOUS_TRANSACTION;

  LASTTIME TIMESTAMP;
  v_version_id NUMBER;

BEGIN
  SELECT MAX(JOB_DATE)
    INTO LASTTIME
    FROM CZ_JOB_AUDIT
    WHERE JOB_ID = JOBID;

	INSERT 	INTO CZ_JOB_AUDIT(
		JOB_ID,
		DATABASE_NAME,
 		PROCEDURE_NAME,
 		STEP_DESC,
		RECORDS_MANIPULATED,
		STEP_NUMBER,
		STEP_STATUS,
    JOB_DATE,
    TIME_ELAPSED_SECS
	)
	SELECT
 		JOBID,
		DATABASENAME,
		PROCEDURENAME,
		STEPDESC,
		RECORDSMANIPULATED,
		STEPNUMBER,
		STEPSTATUS,
    SYSTIMESTAMP,
      COALESCE(
      EXTRACT (DAY    FROM (SYSTIMESTAMP - LASTTIME))*24*60*60 +
      EXTRACT (HOUR   FROM (SYSTIMESTAMP - LASTTIME))*60*60 +
      EXTRACT (MINUTE FROM (SYSTIMESTAMP - LASTTIME))*60 +
      EXTRACT (SECOND FROM (SYSTIMESTAMP - LASTTIME))
      ,0)
  FROM DUAL;

  COMMIT;

EXCEPTION
    WHEN OTHERS THEN ROLLBACK;
END;
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZX_WRITE_ERROR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZX_WRITE_ERROR" (JOBID IN NUMBER,
	ERRORNUMBER IN NUMBER , 
	ERRORMESSAGE IN VARCHAR2 , 
	ERRORSTACK IN VARCHAR2,
  ERRORBACKTRACE IN VARCHAR2)
  AUTHID CURRENT_USER
AS
 PRAGMA AUTONOMOUS_TRANSACTION;
-------------------------------------------------------------------------------------
-- NAME: CZX_WRITE_ERROR
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
BEGIN

	INSERT INTO CZ_JOB_ERROR(
		JOB_ID,
		ERROR_NUMBER,
		ERROR_MESSAGE,
		ERROR_STACK,
    ERROR_BACKTRACE,
		SEQ_ID)
	SELECT
		JOBID,
		ERRORNUMBER,
		ERRORMESSAGE,
		ERRORSTACK,
    ERRORBACKTRACE,
		MAX(SEQ_ID) 
  FROM 
    CZ_JOB_AUDIT 
  WHERE 
    JOB_ID=JOBID;
  
  COMMIT;
 
EXCEPTION
    WHEN OTHERS THEN ROLLBACK;
END;
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZX_WRITE_INFO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZX_WRITE_INFO" 
(
  v_job_id IN NUMBER DEFAULT NULL ,
  v_message_id IN NUMBER DEFAULT NULL ,
  v_message_line IN NUMBER DEFAULT NULL ,
  v_message_procedure IN VARCHAR2 DEFAULT NULL ,
  v_info_message IN VARCHAR2 DEFAULT NULL
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: CZX_WRITE_INFO
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
BEGIN

   INSERT INTO cz_job_message
     ( job_id, message_id, message_line, message_procedure, info_message )
     VALUES ( v_job_id, v_message_id, v_message_line, v_message_procedure, v_info_message );
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZ_AUDIT_EXAMPLE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_AUDIT_EXAMPLE" 
(
  currentJobID NUMBER
)
AS
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
BEGIN
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    dbms_output.put_line('Here' || to_char(jobID));
    cz_start_audit (procedureName, databaseName, jobID);
    dbms_output.put_line('Here2' || to_char(jobID));
  END IF;

  --Step Audit
  cz_write_audit (jobID, databaseName, procedureName, 'Start loading some data', SQL%ROWCOUNT, 1, 'PASS');

  update cz_job_master set job_name = job_name; 

  --Step Audit
  cz_write_audit (jobID, databaseName, procedureName, '# of rows on the cz_job_master table', SQL%ROWCOUNT, 2, 'PASS');

  
  cz_write_info (jobID, 1, 39, procedureName, 'Writing a message');



  --invalid statement
  insert into az_test_run(dw_version_id)
    values('a');


  --Step Audit
  cz_write_audit (jobID, databaseName, procedureName, 'Should have caused an error!', SQL%ROWCOUNT, 3, 'PASS');


  ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

END;


 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZ_END_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_END_AUDIT" 
(
  jobID NUMBER, 
  jobStatus VARCHAR2
)
AS

  endDate timestamp;

BEGIN
  
  endDate := systimestamp;
  
	update cz_job_master
		set 
			active='N',
			end_date = endDate,
      time_elapsed_secs = 
      EXTRACT (DAY    FROM (endDate - START_DATE))*24*60*60 + 
      EXTRACT (HOUR   FROM (endDate - START_DATE))*60*60 + 
      EXTRACT (MINUTE FROM (endDate - START_DATE))*60 + 
      EXTRACT (SECOND FROM (endDate - START_DATE)),
			job_status = jobStatus		
		where active='Y' 
		and job_id=jobID;

END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_ERROR_HANDLER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_ERROR_HANDLER" 
(
  jobID NUMBER,
  procedureName NVARCHAR2
)
AS
  databaseName NVARCHAR2(100);
	errorNumber NUMBER(18,0);
	errorMessage NVARCHAR2(1000);
  errorStack NVARCHAR2(4000);
  errorBackTrace NVARCHAR2(4000);
	stepNo NUMBER(18,0);

BEGIN
  --Get DB Name
	select database_name INTO databaseName
		from cz_job_master 
		where job_id=jobID;
  --Get Latest Step
	select max(step_number) into stepNo from cz_job_audit where job_id = jobID;
  
  --Get all error info
  errorNumber := SQLCODE;
  errorMessage := SQLERRM;
  errorStack := dbms_utility.format_error_stack;
  errorBackTrace := dbms_utility.format_error_backtrace;

  --Update the audit step for the error
  cz_write_audit(jobID, databaseName,procedureName, 'Job Failed: See error log for details',SQL%ROWCOUNT, stepNo, 'FAIL');

  
  --write out the error info
  cz_write_error(jobID, errorNumber, errorMessage, errorStack, errorBackTrace);

END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_INFO_HANDLER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_INFO_HANDLER" 
(
	jobId IN NUMBER,
	messageID IN NUMBER , 
	messageLine IN NUMBER, 
	messageProcedure IN VARCHAR2 , 
	infoMessage IN VARCHAR2,
  stepNumber IN VARCHAR2
)
AS
  databaseName VARCHAR2(100);
BEGIN

	select 
    database_name INTO databasename
  from 
    cz_job_master 
	where 
    job_id=jobID;
    
  cz_write_audit( jobID, databaseName, messageProcedure, 'Step contains more details', 0, stepNumber, 'Information' );

  cz_write_info(jobID, messageID, messageLine, messageProcedure, infoMessage );
  
END;
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure CZ_START_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_START_AUDIT" 
(
  jobName IN VARCHAR2,
  databaseName IN VARCHAR2,
  jobID OUT NUMBER
)
AS
BEGIN

	insert into cz_job_master
		(start_date, 
		active, 
		--username,
		--session_id, 
		database_name,
		job_name,
		job_status) 
	VALUES(
		SYSTIMESTAMP,
		'Y', 
		--suser_name(),
		--@@SPID, 
		databaseName,
		jobName,
		'Running')
  RETURNING job_id INTO jobID;

  COMMIT;

END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_WRITE_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_WRITE_AUDIT" 
(
	jobId IN NUMBER,
	databaseName IN VARCHAR2 , 
	procedureName IN VARCHAR2 , 
	stepDesc IN VARCHAR2 , 
	recordsManipulated IN NUMBER,
	stepNumber IN NUMBER,
	stepStatus IN VARCHAR2
)
AS
  lastTime timestamp;
BEGIN
  select max(job_date)
    into lastTime
    from cz_job_audit
    where job_id = jobID;

	insert 	into cz_job_audit(
		job_id, 
		database_name,
 		procedure_name, 
 		step_desc, 
		records_manipulated,
		step_number,
		step_status,
    job_date,
    time_elapsed_secs
	)
	select
 		jobId,
		databaseName,
		procedureName,
		stepDesc,
		recordsManipulated,
		stepNumber,
		stepStatus,
    SYSTIMESTAMP,
      COALESCE(
      EXTRACT (DAY    FROM (SYSTIMESTAMP - lastTime))*24*60*60 + 
      EXTRACT (HOUR   FROM (SYSTIMESTAMP - lastTime))*60*60 + 
      EXTRACT (MINUTE FROM (SYSTIMESTAMP - lastTime))*60 + 
      EXTRACT (SECOND FROM (SYSTIMESTAMP - lastTime))
      ,0)
  from dual;
  
  COMMIT;

END;

/
--------------------------------------------------------
--  DDL for Procedure CZ_WRITE_ERROR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_WRITE_ERROR" (JOBID IN NUMBER,
	ERRORNUMBER IN NUMBER , 
	ERRORMESSAGE IN VARCHAR2 , 
	ERRORSTACK IN VARCHAR2,
  ERRORBACKTRACE IN VARCHAR2)
  AUTHID CURRENT_USER
AS
 PRAGMA AUTONOMOUS_TRANSACTION;
/*************************************************************************
* Copyright 2008-2012 Janssen Research & Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
BEGIN

	INSERT INTO CZ_JOB_ERROR(
		JOB_ID,
		ERROR_NUMBER,
		ERROR_MESSAGE,
		ERROR_STACK,
    ERROR_BACKTRACE,
		SEQ_ID)
	SELECT
		JOBID,
		ERRORNUMBER,
		ERRORMESSAGE,
		ERRORSTACK,
    ERRORBACKTRACE,
		MAX(SEQ_ID) 
  FROM 
    CZ_JOB_AUDIT 
  WHERE 
    JOB_ID=JOBID;
  
  COMMIT;
 
EXCEPTION
    WHEN OTHERS THEN ROLLBACK;
END;
 

/
--------------------------------------------------------
--  DDL for Procedure CZ_WRITE_INFO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."CZ_WRITE_INFO" 
(
	jobId IN NUMBER,
	messageID IN NUMBER , 
	messageLine IN NUMBER, 
	messageProcedure IN VARCHAR2 , 
	infoMessage IN VARCHAR2
)
AS

BEGIN

	insert into cz_job_message
    (
      job_id,
      message_id,
      message_line,
      message_procedure,
      info_message,
      seq_id
    )
	select
      jobID,
      messageID,
      messageLine,
      messageProcedure,
      infoMessage,
      max(seq_id)
  from
    cz_job_audit
  where
    job_id = jobID;
  
  COMMIT;

END;

 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure DATA_EXPORT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."DATA_EXPORT" 
AS
--Iterate through a cursor of all patient IDs
--Dynamically build a sql statement
--Run the statement returning the results

CURSOR cPatients is
  select distinct a.patient_num
    FROM observation_fact a
  join i2b2 b
    on a.concept_cd = b.c_basecode
  where c_fullname like '%BRC Depression Study%'
    and c_visualattributes not like '%H%'
  order by patient_num;

  dynamicSQL varchar2(32767);
  dynamicSQL2 varchar2(32767);

BEGIN
  dynamicSQL := 'select c_name ,c_fullname ';
  dynamicSQL2 := 'select c_name ,c_fullname ';

  FOR r_cPatients in cPatients Loop

    dynamicSQL  := dynamicSQL  || ',max(decode(patient_num,' || cast(r_cPatients.patient_num as varchar2) || ',tval_char,null)) "' || cast(r_cPatients.patient_num as varchar2) || '"';
    dynamicSQL2 := dynamicSQL2 || ',max(decode(patient_num,' || cast(r_cPatients.patient_num as varchar2) || ',cast(nval_num as varchar2(20)),null)) "' || cast(r_cPatients.patient_num as varchar2) || '"';

  END LOOP;
  
  dynamicSQL := dynamicSQL || ' from observation_fact a join i2b2 b on a.concept_cd = b.c_basecode where c_fullname like ''%BRC Depression Study%'' and c_columndatatype = ''T'' and c_visualattributes not like ''%H%'' group by c_name, c_fullname';
  dynamicSQL2 := dynamicSQL2 || ' from observation_fact a join i2b2 b on a.concept_cd = b.c_basecode where c_fullname like ''%BRC Depression Study%'' and c_columndatatype = ''N'' and c_visualattributes not like ''%H%'' group by c_name, c_fullname order by c_fullname';

  execute immediate(dynamicSQL || ' UNION ALL ' || dynamicsql2);
  
  dbms_output.put_line(dynamicSQL);-- || ' UNION ALL ' || dynamicsql2);
  dbms_output.put_line('UNION ALL');
  dbms_output.put_line(dynamicsql2);
END;

 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure DROPSYN
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."DROPSYN" IS
 CURSOR s_cur IS
 SELECT synonym_name
 FROM user_synonyms;

 RetVal  NUMBER;
 sqlstr  VARCHAR2(200); 
BEGIN
  FOR s_rec IN s_cur LOOP
    sqlstr := 'DROP SYNONYM ' || s_rec.synonym_name;

    EXECUTE IMMEDIATE sqlstr;
    COMMIT;
  END LOOP; 
END dropsyn;

 
 
 
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure DROP_TABLE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."DROP_TABLE" (
  TabOwner in VARCHAR2,
  TabName in VARCHAR2
  ) 
  IS
    temp number:=0;
    drp_stmt VARCHAR2 (200):=null;

    BEGIN
      select 
        count(*) 
      into 
        temp 
      from 
        all_tables 
      where 
        upper(TABLE_NAME) = upper(TabName)
      and
        upper(OWNER) = upper(TabOwner);
  
      if temp = 1 then
        drp_stmt := 'Drop Table ' || TabOwner || '.' || TabName;
        EXECUTE IMMEDIATE drp_stmt;
        commit;        
      end if;

    EXCEPTION
      WHEN OTHERS THEN
      raise_application_error(-20001,'An error was encountered - '||SQLCODE||' -ERROR- '||SQLERRM);

END DROP_TABLE;

 

 

 
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure EXEC_TEST
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."EXEC_TEST" (
  v_test_run_id NUMBER, -- From AZ_TEST_RUN
  v_test_id NUMBER,     -- From CZ_TEST
  v_param1 VARCHAR2      -- used if parameter is passed.
)
AS 

  --initiate variables for Job run and step ID's
  testRunID  CONTROL.AZ_TEST_RUN.TEST_RUN_ID%TYPE;
  testStepRunID CONTROL.AZ_TEST_STEP_RUN.TEST_STEP_RUN_ID%TYPE;

  --Other variables
  sqlTestCode VARCHAR2(4000);
  startDate DATE;
  returnCount NUMBER;
  minValue NUMBER;
  maxValue NUMBER;
  err_code VARCHAR2(4000);
  err_msg VARCHAR2(4000);
  testStatus VARCHAR2(100);
  testType VARCHAR2(100);
  testSeverity varchar2(20);
  dwVersionID NUMBER;
  comparisonExists NUMBER;

BEGIN
  --Set start Date (Need to set so the correct record can be retrieved)
  startDate := sysdate;
  
  --Check for test run id. If null, create one.
  if v_test_run_id is null or v_test_run_id = 0 then 
    INSERT
    INTO AZ_TEST_RUN
    (
      DW_VERSION_ID,
      START_DATE,
      STATUS
    )
    select max(dw_version_id), startDate, 'RUNNING'
      FROM cz_dw_version;
    commit;    

    --Get the new Test Run ID
    select      
      max(test_run_id) into testRunID
    from az_test_run
      WHERE start_date = startDate;
  else
    testRunID := v_test_run_id;
  end if;
  
  --Create a new test step record
  INSERT INTO 
    AZ_TEST_STEP_RUN (
      TEST_RUN_ID, 
      START_DATE, 
      TEST_ID, 
      STATUS,
      PARAM1) 
  VALUES(
    testRunID, 
    sysdate, 
    v_test_id, 
    'RUNNING',
    v_param1);
  COMMIT;    
  
  --Get the new Test Step ID
  select      
    max(test_step_run_id) into testStepRunID
    from az_test_step_run
      WHERE start_date = startDate;
      
 BEGIN
    --Get SQL for test
    SELECT 
      TEST_SQL, TEST_TYPE, TEST_MIN_VALUE, TEST_MAX_VALUE, TEST_SEVERITY_CD
    INTO 
      sqlTestCode, testType, minValue, maxValue, testSeverity
    FROM CZ_TEST
    WHERE TEST_ID = v_test_id;

  --Replace 'PARAM1' with passed variable
  sqlTestCode := replace(sqlTestCode,'PARAM1', v_Param1);

    --Execute Test
    EXECUTE immediate sqlTestCode into returnCount;
  
    INSERT INTO 
        AZ_TEST_STEP_ACT_RESULT 
        (TEST_STEP_RUN_ID, 
        ACT_RECORD_CNT) 
    SELECT 
      testStepRunID,
      returnCount
    FROM
      CONTROL.AZ_TEST_STEP_RUN a
    WHERE 
      a.TEST_STEP_RUN_ID = testStepRunId;
    commit;

    --ADDING LOGIC FOR COMPARISON TESTS
    IF testType = 'COMPARISON' THEN
      --get current dw version
      select max(dw_version_id) into dwVersionID 
        from cz_dw_version;

      --Add or update current data to comparison table
      select count(*) 
        into comparisonExists
        from az_test_comparison_info 
      where param1 = v_param1 
      and test_id = v_test_id;
      
      
      if (comparisonExists) = 1 then
        update az_test_comparison_info
          set curr_act_record_cnt = returncount,
          curr_dw_version_id = dwversionid,
          curr_test_step_run_id = teststeprunid,
          curr_run_date = sysdate
        where param1 = v_param1
        and test_id = v_test_id;
        commit;        
      end if;
      
      if (comparisonExists) = 0 then
        INSERT INTO CONTROL.AZ_TEST_COMPARISON_INFO
        (TEST_ID,
        PARAM1,
        CURR_DW_VERSION_ID,
        CURR_TEST_STEP_RUN_ID,
        CURR_ACT_RECORD_CNT,
        curr_run_date
        )
        VALUES
        (
          v_test_id,
          v_param1,
          dwVersionID,
          teststeprunid,
          returncount,
          sysdate
        );
        commit;
      end if;
        
        
    --GET THE RESULTS FOR THIS TEST FROM THE PREVIOUS BUILD
    -- put it in both min and max for comparison
      SELECT PREV_ACT_RECORD_CNT, PREV_ACT_RECORD_CNT 
      into minValue, maxValue
        from az_test_comparison_info
      where
        v_test_id = test_id -- get correct test
      and v_param1 = param1; -- correct parameter
    
    end if;
    

    --Determine Pass/Fail  
    if returnCount BETWEEN minValue AND maxValue then
      testStatus := 'PASS';
    elsif testSeverity =  'INFO' then  --Informational Test
      testStatus := 'WARNING';
    else --Required test
      testStatus := 'FAIL';
    end if;

    --update step info      
    update az_test_Step_run
      set end_date = sysdate,
      status = testStatus
    where 
      test_step_run_id = testStepRunID;
    commit;
  END;
  
  commit;
  
  EXCEPTION
  WHEN OTHERS THEN
    
    err_code := SQLCODE;
    err_msg := substr(SQLERRM, 1, 4000);

    --Update Actual Results    
    INSERT INTO AZ_TEST_STEP_ACT_RESULT
    (
      TEST_STEP_RUN_ID,
      RETURN_CODE,
      RETURN_MESSAGE,
      RETURN_ERROR_STACK,
      RETURN_ERROR_BACK_TRACE
    )
    VALUES
    (
      testStepRunID,
      err_code, 
      err_msg, 
      DBMS_UTILITY.FORMAT_ERROR_STACK, 
      DBMS_UTILITY.FORMAT_ERROR_BACKTRACE
    );
    
    update az_test_Step_run
      set end_date = sysdate,
      status = 'ERROR'
    where 
      test_step_run_id = testStepRunID;
    commit;
END;

 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure EXEC_TEST_RUN
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."EXEC_TEST_RUN" (
  v_test_category_id integer,
  v_param1 VARCHAR2,
  v_test_name VARCHAR2 --optional test name for searching
)
AS 
 --BASIC TEST HARNESS FOR SQL TESTS
 --KCR: 2009-08-24
 --TAKES IN 3 CATEGORY PARAMETERS. These are used to filter the tests to run
 --Uses 1 "PARAM1" value to pass to the individual tests to use in the test.
 
 
  --initiate variables for Job run and step ID's
  testRunID  CONTROL.AZ_TEST_RUN.TEST_RUN_ID%TYPE;
  testStepRunID CONTROL.AZ_TEST_STEP_RUN.TEST_STEP_RUN_ID%TYPE;

  startDate DATE;
  testStatus VARCHAR2(100);
  err_code VARCHAR2(4000);
  err_msg VARCHAR2(4000);
  testName VARCHAR2(200);
  testNameExists INTEGER;

  --Create a cursor of tests
  CURSOR testList is
  select test_id
    from CZ_TEST
  WHERE
    test_category_id = v_test_category_id;
    
BEGIN
  startDate := sysdate;

  testName := v_test_name;

  --validate test name
  IF testName = '' then
  select to_char(max(dw_version_id)) || '-' || v_test_category_id  || '-' || v_param1 || '-' || to_char(sysdate,'YYYYMMDD-HH24:MI:SS')
    into testName
    from cz_dw_version;
  ELSE 
    --add date/time to make distinct
    testName := testName || '-' || to_char(startDate,'YYYYMMDD-HH24:MI:SS');
  end if;

  --CREATE A NEW TEST RUN
  INSERT
  INTO AZ_TEST_RUN
  (
    TEST_RUN_NAME,
    DW_VERSION_ID,
    START_DATE,
    STATUS,
    TEST_CATEGORY_ID,
    PARAM1
  )
  select 
    testName,
    max(dw_version_id), 
    startDate, 
    'RUNNING',
    v_test_category_id,
    v_param1
      FROM cz_dw_version;
  commit;    

    --Get the new Test Run ID
    select      
      max(test_run_id) into testRunID
    from az_test_run
      WHERE start_date = startDate;
  

  --ITERATE THROUGH TESTS AND EXECUTE THEM
  FOR r_testList in testList Loop
    exec_test(testRunID, r_testList.test_id, v_param1);
  END LOOP;  

    --determine minimum testRunStatus' for this Test.
    --They will appear as ERROR, FAIL, PASS, WARNING
    select min(status)
    into testStatus
    from az_test_step_run
      where test_run_id = testRunID;

    --update run info      
    update az_test_run
      set end_date = sysdate,
      status = testStatus
    where 
      test_run_id = testRunID;
    commit;
  
  EXCEPTION
  WHEN OTHERS THEN

    err_code := SQLCODE;
    err_msg := substr(SQLERRM, 1, 4000);

    --Update Actual Results    
    UPDATE AZ_TEST_RUN
    SET END_DATE = SYSDATE,
    STATUS = 'RUNERROR',
    RETURN_CODE = err_code, 
    RETURN_MESSAGE = err_msg
    where
      test_run_id = testRunID;
    
    commit;
END;

 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_ADD_NODE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_ADD_NODE" 
(
  TrialID VARCHAR2,
  path VARCHAR2,
  path_name VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  
  root_node		varchar2(2000);
  root_level	int;
  
  
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
BEGIN
  
  -------------------------------------------------------------
  -- Add a tree node in I2b2
  -- KCR@20090519 - First Rev
  -- JEA@20100107 - Added auditing
  -- JEA@20111212	Added i2b2_id sequence
  -- JEA@20120529	Updated for i2b2 1.6
  
  -------------------------------------------------------------
    
  stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;
  
	select parse_nth_value(path, 2, '\') into root_node from dual;
	
	select c_hlevel into root_level
	from table_access
	where c_name = root_node;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  if path != ''  or path != '%' or path_name != ''
  then 
    --Delete existing node.
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME = PATH);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted any concepts for path from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH = path;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted any concepts for path from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME = PATH;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted path from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --CONCEPT DIMENSION
    INSERT INTO CONCEPT_DIMENSION
      (CONCEPT_CD, CONCEPT_PATH, NAME_CHAR,  UPDATE_DATE,  DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, TABLE_NAME)
    VALUES
      (concept_id.nextval,
      path,
      to_char(path_name),
      sysdate,
      sysdate,
      sysdate,
      TrialID,
      'CONCEPT_DIMENSION');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted concept for path into I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
    --I2B2
    INSERT
     INTO I2B2
      (c_hlevel, C_FULLNAME, C_NAME, C_VISUALATTRIBUTES, c_synonym_cd, C_FACTTABLECOLUMN, C_TABLENAME, C_COLUMNNAME,
      C_DIMCODE, C_TOOLTIP, UPDATE_DATE, DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, c_basecode, C_OPERATOR, c_columndatatype, c_comment,
	  i2b2_id, m_applied_path)
    SELECT 
      (length(concept_path) - nvl(length(replace(concept_path, '\')),0)) / length('\') - 2 + root_level,
      CONCEPT_PATH,
      NAME_CHAR,
      'FA',
      'N',
      'CONCEPT_CD',
      'CONCEPT_DIMENSION',
      'CONCEPT_PATH',
      CONCEPT_PATH,
      CONCEPT_PATH,
      sysdate,
      sysdate,
      sysdate,
      SOURCESYSTEM_CD,
      CONCEPT_CD,
      'LIKE',
      'T',
      decode(TrialID,null,null,'trial:' || TrialID),
	  i2b2_id_seq.nextval,
	  '@'
    FROM
      CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH = path;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted path into I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
	  END IF;
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_ADD_NODE_TR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_ADD_NODE_TR" 
(
  TrialID VARCHAR2,
  path VARCHAR2,
  path_name VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  
  root_node        varchar2(2000);
  root_level    int;
  
  
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
BEGIN
  
  -------------------------------------------------------------
  -- Add a tree node in I2b2
  -- KCR@20090519 - First Rev
  -- JEA@20100107 - Added auditing
  -- JEA@20111212    Added i2b2_id sequence
  -- JEA@20120529    Updated for i2b2 1.6
  
  -------------------------------------------------------------
    
  stepCt := 0;
    
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;
  
    select parse_nth_value(path, 2, '\') into root_node from dual;
    
    select c_hlevel into root_level
    from table_access
    where c_name = root_node;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  if path != ''  or path != '%' or path_name != ''
  then 
    --Delete existing node.
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME = PATH);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Deleted any concepts for path from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH = path;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Deleted any concepts for path from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME = PATH;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Deleted path from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --CONCEPT DIMENSION
    INSERT /*+ APPEND */ INTO CONCEPT_DIMENSION nologging
      (CONCEPT_CD, CONCEPT_PATH, NAME_CHAR,  UPDATE_DATE,  DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, TABLE_NAME)
    VALUES
      (concept_id.nextval,
      path,
      to_char(path_name),
      sysdate,
      sysdate,
      sysdate,
      TrialID,
      'CONCEPT_DIMENSION');
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted concept for path into I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
   COMMIT;
    
    --I2B2
    INSERT /*+ APPEND */
     INTO I2B2 nologging
      (c_hlevel, C_FULLNAME, C_NAME, C_VISUALATTRIBUTES, c_synonym_cd, C_FACTTABLECOLUMN, C_TABLENAME, C_COLUMNNAME,
      C_DIMCODE, C_TOOLTIP, UPDATE_DATE, DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, c_basecode, C_OPERATOR, c_columndatatype, c_comment,
      i2b2_id, m_applied_path)
    SELECT 
      (length(concept_path) - nvl(length(replace(concept_path, '\')),0)) / length('\') - 2 + root_level,
      CONCEPT_PATH,
      NAME_CHAR,
      'FA',
      'N',
      'CONCEPT_CD',
      'CONCEPT_DIMENSION',
      'CONCEPT_PATH',
      CONCEPT_PATH,
      CONCEPT_PATH,
      sysdate,
      sysdate,
      sysdate,
      SOURCESYSTEM_CD,
      CONCEPT_CD,
      'LIKE',
      'T',
      decode(TrialID,null,null,'trial:' || TrialID),
      i2b2_id_seq.nextval,
      '@'
    FROM
      CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH = path;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted path into I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
      END IF;
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

  
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_ADD_ROOT_NODE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_ADD_ROOT_NODE" 
(root_node		varchar2
,currentJobID	NUMBER := null
)
AS
	--	JEA@20120510	New
	--	JEA@20120529	Updated for i2b2 1.6
	
	--Audit variables
	newJobFlag 	INTEGER(1);
	databaseName 	VARCHAR(100);
	procedureName VARCHAR(100);
	jobID 		number(18,0);
	stepCt 		number(18,0);

	rootNode	varchar2(200);
	rootPath	varchar2(200);
	
Begin
	rootNode := root_node;
	rootPath := '\' || rootNode || '\';

    stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start ' || procedureName,0,stepCt,'Done');
	
	insert into table_access
	select rootNode as c_table_cd
		  ,'i2b2' as c_table_name
		  ,'N' as protected_access
		  ,0 as c_hlevel
		  ,rootPath as c_fullname
		  ,rootNode as c_name
		  ,'N' as c_synonym_cd
		  ,'CA' as c_visualattributes
		  ,null as c_totalnum
		  ,null as c_basecode
		  ,null as c_metadataxml
		  ,'concept_cd' as c_facttablecolumn
		  ,'concept_dimension' as c_dimtablename
		  ,'concept_path' as c_columnname
		  ,'T' as c_columndatatype
		  ,'LIKE' as c_operator
		  ,rootPath as c_dimcode
		  ,null as c_comment
		  ,rootPath as c_tooltip
		  ,sysdate as c_entry_date
		  ,null as c_change_date
		  ,null as c_status_cd
		  ,null as valuetype_cd
	from dual
	where not exists
		(select 1 from table_access x
		 where x.c_table_cd = rootNode);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert to table_access',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;	

	--	insert root_node into i2b2
	
	insert into i2b2
	(c_hlevel
	,c_fullname
	,c_name
	,c_synonym_cd
	,c_visualattributes
	,c_totalnum
	,c_basecode
	,c_metadataxml
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_columndatatype
	,c_operator
	,c_dimcode
	,c_comment
	,c_tooltip
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,valuetype_cd
	,i2b2_id
	)
	select 0 as c_hlevel
		  ,rootPath as c_fullname
		  ,rootNode as c_name
		  ,'N' as c_synonym_cd
		  ,'CA' as c_visualattributes
		  ,null as c_totalnum
		  ,null as c_basecode
		  ,null as c_metadataxml
		  ,'concept_cd' as c_facttablecolumn
		  ,'concept_dimension' as c_tablename
		  ,'concept_path' as c_columnname
		  ,'T' as c_columndatatype
		  ,'LIKE' as c_operator
		  ,rootPath as c_dimcode
		  ,null as c_comment
		  ,rootPath as c_tooltip
		  ,sysdate as update_date
		  ,null as download_date
		  ,sysdate as import_date
		  ,null as sourcesystem_cd
		  ,null as valuetype_cd
		  ,I2B2_ID_SEQ.nextval as i2b2_id
	from dual
	where not exists
		 (select 1 from i2b2 x
		  where x.c_name = rootNode);
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert root_node ' || rootNode || ' to i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;	
			
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
	
    COMMIT;
	--Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;

	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		--End Proc
		cz_end_audit (jobID, 'FAIL');
	
END;
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_ADD_ROOT_NODE_TR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_ADD_ROOT_NODE_TR" 
(root_node        varchar2
,currentJobID    NUMBER := null
)
AS
    --    JEA@20120510    New
    --    JEA@20120529    Updated for i2b2 1.6
    
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);

    rootNode    varchar2(200);
    rootPath    varchar2(200);
    
Begin
    rootNode := root_node;
    rootPath := '\' || rootNode || '\';

    stepCt := 0;
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := currentJobID;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Start ' || procedureName,0,stepCt,'Done');
    
    insert into table_access
    select rootNode as c_table_cd
          ,'i2b2' as c_table_name
          ,'N' as protected_access
          ,0 as c_hlevel
          ,rootPath as c_fullname
          ,rootNode as c_name
          ,'N' as c_synonym_cd
          ,'CA' as c_visualattributes
          ,null as c_totalnum
          ,null as c_basecode
          ,null as c_metadataxml
          ,'concept_cd' as c_facttablecolumn
          ,'concept_dimension' as c_dimtablename
          ,'concept_path' as c_columnname
          ,'T' as c_columndatatype
          ,'LIKE' as c_operator
          ,rootPath as c_dimcode
          ,null as c_comment
          ,rootPath as c_tooltip
          ,sysdate as c_entry_date
          ,null as c_change_date
          ,null as c_status_cd
          ,null as valuetype_cd
    from dual
    where not exists
        (select 1 from table_access x
         where x.c_table_cd = rootNode);
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert to table_access',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;    

    --    insert root_node into i2b2
    
    insert into i2b2
    (c_hlevel
    ,c_fullname
    ,c_name
    ,c_synonym_cd
    ,c_visualattributes
    ,c_totalnum
    ,c_basecode
    ,c_metadataxml
    ,c_facttablecolumn
    ,c_tablename
    ,c_columnname
    ,c_columndatatype
    ,c_operator
    ,c_dimcode
    ,c_comment
    ,c_tooltip
    ,update_date
    ,download_date
    ,import_date
    ,sourcesystem_cd
    ,valuetype_cd
    ,i2b2_id
    )
    select 0 as c_hlevel
          ,rootPath as c_fullname
          ,rootNode as c_name
          ,'N' as c_synonym_cd
          ,'CA' as c_visualattributes
          ,null as c_totalnum
          ,null as c_basecode
          ,null as c_metadataxml
          ,'concept_cd' as c_facttablecolumn
          ,'concept_dimension' as c_tablename
          ,'concept_path' as c_columnname
          ,'T' as c_columndatatype
          ,'LIKE' as c_operator
          ,rootPath as c_dimcode
          ,null as c_comment
          ,rootPath as c_tooltip
          ,sysdate as update_date
          ,null as download_date
          ,sysdate as import_date
          ,null as sourcesystem_cd
          ,null as valuetype_cd
          ,I2B2_ID_SEQ.nextval as i2b2_id
    from dual
    where not exists
         (select 1 from i2b2 x
          where x.c_name = rootNode);
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert root_node ' || rootNode || ' to i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;    
            
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    
    COMMIT;
    --Cleanup OVERALL JOB if this proc is being run standalone
    IF newJobFlag = 1
    THEN
        cz_end_audit (jobID, 'SUCCESS');
    END IF;

    EXCEPTION
    WHEN OTHERS THEN
        --Handle errors.
        cz_error_handler (jobID, procedureName);
        --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_ADD_SNP_BIOMARKER_NODES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_ADD_SNP_BIOMARKER_NODES" 
(
  trial_id 		VARCHAR2
  ,ont_path		varchar2
 ,currentJobID 	NUMBER := null
)
AS
	--	Adds SNP platform and sample type nodes into Biomarker Data ontology and adds rows into observation_fact for
	--	each subject/concept combination
	
	--	JEA@20110120	New
	--	JEA@@0111218	Remove hard-coded "Biomarker Data" node, use what's supplied in ont_path

	TrialID	varchar2(100);
	ontPath		varchar2(500);
  
	RootNode	VARCHAR2(300);
	pExists 	number;
	platformTitle	varchar2(200);
	tText		varchar2(1000);
	ontLevel	integer;
	nodeName	varchar2(200);
    
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);
	
	--	raise exception if platform not in de_gpl_info
	
	missing_GPL exception;
	
--	cursor to add platform-level nodes, need to be inserted before de_subject_sample_mapping

	cursor addPlatform is
	select distinct REGEXP_REPLACE(ont_path || '\' || g.title || '\' ,
                  '(\\){2,}', '\') as path
		   ,g.title
	from de_subject_snp_dataset s
		,de_gpl_info g
	where s.trial_name = TrialId
	  and nvl(s.platform_name,'GPL570') = g.platform
	  and upper(g.organism) = 'HOMO SAPIENS';
	
--	cursor to add sample-level nodes

	cursor addSample is
	select distinct REGEXP_REPLACE(ont_path || '\' || g.title || '\' ||
                    s.sample_type || '\',	'(\\){2,}', '\') as sample_path
		   ,s.sample_type as sample_name
	from de_subject_snp_dataset s
		,de_gpl_info g
	where s.trial_name = TrialId
	  and nvl(s.platform_name,'GPL570') = g.platform
	  and upper(g.organism) = 'HOMO SAPIENS'
	  and s.sample_type is not null;
	  
BEGIN
	TrialID := upper(trial_id); 
	ontPath := ont_path;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
    	
	stepCt := 0;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_add_snp_node',0,stepCt,'Done');
	stepCt := stepCt + 1;

	--	determine last node in ontPath
	
	select length(ontPath)-length(replace(ontPath,'\','')) into ontLevel from dual;
	select parse_nth_value(ontPath,ontLevel,'\') into nodeName from dual;
	
	--	add the high level \ node if it doesn't exist (first time loading data)
  
	select count(*)
	into pExists
	from i2b2
	where c_fullname = REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\');
  
	if pExists = 0 then 
		i2b2_add_node(TrialId, REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\'), nodeName, jobID);
        stepCt := stepCt + 1;
	    cz_write_audit(jobId,databaseName,procedureName,'Add node for ontPath',0,stepCt,'Done');
	end if;

    --	check if a node exists for the platform, if yes, then delete existing data, make sure all platforms in de_subject_snp_dataset have an
	--	entry in de_gpl_info, if not, raise exception
	
	select count(*) into pExists
	from de_subject_snp_dataset s
		,de_gpl_info g
	where s.trial_name = TrialId
	  and nvl(s.platform_name,'GPL570') = g.platform(+)
	  and  'HOMO SAPIENS' = upper(g.organism(+))
	  and g.platform is null;
	  
	if pExists > 0
		then raise missing_GPL;
	end if;

	--	add SNP platform nodes
	
	for r_addPlatform in addPlatform Loop
	
		i2b2_delete_all_nodes(REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\') || r_addPlatform.title || '\', jobID);
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete existing SNP Platform for trial in I2B2METADATA i2b2',0,stepCt,'Done');
		
		i2b2_add_node(TrialId, r_addPlatform.path, r_addPlatform.title, jobId);
		tText := 'Added Platform: ' || r_addPlatform.path || '  Name: ' || r_addPlatform.title;
		stepCt := stepCt + 1;
	    cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');
	end loop;

	cz_write_audit(jobId,databaseName,procedureName,'Added SNP Platform nodes',0,stepCt,'Done');
	stepCt := stepCt + 1;
	commit;
	       
	--	Insert the sample-level nodes
	
	for r_addSample in addSample Loop
	
		i2b2_add_node(TrialId, r_addSample.sample_path, r_addSample.sample_name, jobId);
		tText := 'Added Sample: ' || r_addSample.sample_path || '  Name: ' || r_addSample.sample_name;
	    cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');
		stepCt := stepCt + 1;

	end loop;		  
	
--	Insert records for patients into observation_fact

	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select p.patient_num
		  ,t.concept_cd
		  ,t.sourcesystem_cd
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null	--	not numeric for Proteomics
		  ,t.sourcesystem_cd
		  ,sysdate
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  concept_dimension t
		 ,de_subject_snp_dataset p
		 ,de_gpl_info g
    where p.trial_name =  TrialId
	  and nvl(p.platform_name,'GPL570') = g.platform
	  and upper(g.organism) = 'HOMO SAPIENS'
	  and t.concept_path = REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\') || g.title || '\' || p.sample_type || '\'
    group by p.patient_num
			,t.concept_cd
			,t.sourcesystem_cd;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	stepCt := stepCt + 1;
    commit;
	
	--	update concept_cd in de_subject_snp_dataset
	
	update de_subject_snp_dataset d
	set concept_cd = (select t.concept_cd
					  from de_subject_snp_dataset p
						  ,de_gpl_info g
						  ,concept_dimension t
					  where d.subject_snp_dataset_id = p.subject_snp_dataset_id
						and nvl(p.platform_name,'GPL570') = g.platform
						and upper(g.organism) = 'HOMO SAPIENS'
						and t.concept_path = REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\') || g.title || '\' || p.sample_type || '\'
					  )
	where d.trial_name = TrialId;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update concept_cd in DEAPP de_subject_snp_dataset',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
--	Update visual attributes for leaf active (default is folder)

	update i2b2 a
    set c_visualattributes = 'LA'
    where 1 = (select count(*)
			   from i2b2 b
			   where b.c_fullname like (a.c_fullname || '%'))
      and a.c_fullname like REGEXP_REPLACE(ont_path || '\','(\\){2,}', '\') || '%';
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update leaf active attribute for trial in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    commit;
	
--	fill in tree

	--	get top level for study, this will be used for fill-in and create_concept_counts
	--	if this fails, check to make sure the trialId is not a sourcesystem_cd at an higher level than the study
	
	select b.c_fullname into nodeName
	from i2b2 b
	where b.c_hlevel =
		 (select min(x.c_hlevel) from i2b2 x
		  where b.sourcesystem_cd = x.sourcesystem_cd)
	  and ontPath like b.c_fullname || '%'
	  and b.sourcesystem_cd = TrialId;

	i2b2_fill_in_tree(TrialID,REGEXP_REPLACE(nodeName || '\','(\\){2,}', '\'), jobID);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Fill in tree for Biomarker Data for trial',SQL%ROWCOUNT,stepCt,'Done');
  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Biomarker level because there may be multiple platforms and patient count can vary
  
    i2b2_create_concept_counts(REGEXP_REPLACE(nodeName || '\','(\\){2,}', '\'),jobID );
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');

  --Reload Security: Inserts one record for every I2B2 record into the security table

    i2b2_load_security_data(jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_protein_data',0,stepCt,'Done');
		
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION

  WHEN missing_GPL  then
	--	put message in log
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'One or more GPL platforms in de_subject_snp_dataset is not in de_gpl_info',0,stepCt,'Done');

    --End Proc
    cz_end_audit (jobID, 'FAIL');

  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL'); 

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_BACKOUT_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_BACKOUT_TRIAL" 
(
  trial_id VARCHAR2
 ,path_string varchar2
 ,currentJobID NUMBER := null
)
AS

--	JEA@20100106	New
--	JEA@20100112	Added removal of SECURITY records from observation_fact
--	JEA@20120313	Added colon to study on patient_dimension delete
--	JEA@20120416	Only delete omic data if omic_source_study is null or same as TrialId

  TrialID	varchar2(100);
  TrialType VARCHAR2(250);
  pExists	number;
  sqlText	varchar2(1000);
  
  
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN
  --TrialID := upper(trial_id);
  TrialId := trial_id;
  
  stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  if path_string != ''  or path_string != '%'
  then 
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_backout_trial',0,stepCt,'Done');

	--	delete all i2b2 nodes
	
	i2b2_delete_all_nodes(path_string,jobId);
	
	--	delete any i2b2_tag data
	
	delete from i2b2_tags
	where path like path_string || '%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	delete clinical data
	
	delete from lz_src_clinical_data
	where study_id = trialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from lz_src_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		
	--	delete observation_fact SECURITY data, do before patient_dimension delete
	
	delete from observation_fact f
	where f.concept_cd = 'SECURITY'
	  and f.patient_num in
	     (select distinct p.patient_num from patient_dimension p
		  where p.sourcesystem_cd like trialId || ':%');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete SECURITY data for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	delete patient data
	
	delete from patient_dimension
	where sourcesystem_cd like trialId || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	delete from patient_trial
	where trial=  trialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	delete gene expression data
	
	select count(*) into pExists
	from de_subject_sample_mapping
	where trial_name = TrialId
	  and platform = 'MRNA_AFFYMETRIX'
	  and trial_name = TrialId
	  --and coalesce(omic_source_study,trial_name) = TrialId
	  ;
	  
	if pExists > 1 then
		select count(*) into pExists
		from all_tables
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and partitioned = 'YES';
		  
		if pExists = 0 then
			--	table not partitioned, do delete
			delete from de_subject_microarray_data
			where trial_name = TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');
			commit;			
		else
			select count(*) into pExists
			from all_tab_partitions
			where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
			  and partition_name = TrialId;
			  
			if pExists > 0 then			
				sqlText := 'alter table deapp.de_subject_microarray_data drop PARTITION "' || TrialID || '"';
				execute immediate(sqlText);
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Dropped partition from de_subject_microarray_data',0,stepCt,'Done');
			end if;
		end if;
	else
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'No gene expression data to be deleted',0,stepCt,'Done');
	end if;
		
	--	check for SNP data	
	
	select count(*) into pExists
	from de_subject_sample_mapping
	where trial_name = TrialId
	  and platform = 'SNP'
	  and trial_name = TrialId;
	  
	if pexists > 0 then
		--	delete SNP data
		
		delete from de_snp_data_dataset_loc
		where trial_name = TrialId;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_snp_data_dataset_loc',SQL%ROWCOUNT,stepCt,'Done');
		commit;
		
		delete from de_snp_data_by_patient
		where trial_name = TrialId;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_snp_data_by_patient',SQL%ROWCOUNT,stepCt,'Done');
		commit;
		
		delete from deapp.de_snp_calls_by_gsm s
		where s.patient_num in 
			 (select distinct x.patient_id
			  from de_subject_sample_mapping x
			  where x.trial_name = TrialId
			    and x.platform = 'SNP');
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_snp_calls_by_gsm',SQL%ROWCOUNT,stepCt,'Done');
		commit;
		
		delete from deapp.de_snp_copy_number s
		where s.patient_num in 
			 (select distinct x.patient_id
			  from de_subject_sample_mapping x
			  where x.trial_name = TrialId
			    and x.platform = 'SNP');
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_snp_copy_number',SQL%ROWCOUNT,stepCt,'Done');
		commit;
		
		delete from deapp.de_snp_subject_sorted_def s
		where s.trial_name = TrialId;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_snp_subject_sorted_def',SQL%ROWCOUNT,stepCt,'Done');
		commit;

		select count(*) into pExists
		from all_tables
		where table_name = 'DE_SNP_DATA_BY_PROBE'
		  and partitioned = 'YES';
		  
		if pExists = 0 then
			--	table not partitioned, so just do delete
			delete from de_snp_data_by_probe
			where trial_name = TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_snp_data_by_probe',SQL%ROWCOUNT,stepCt,'Done');
			commit;	
		else
			sqlText := 'alter table deapp.de_snp_data_by_probe drop PARTITION "' || TrialID || '"';
			execute immediate(sqlText);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Dropped partition from de_snp_data_by_probe',0,stepCt,'Done');			
		end if;
		
		delete from de_subject_snp_dataset
		where trial_name = TrialId;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from de_subject_snp_dataset',SQL%ROWCOUNT,stepCt,'Done');
		commit;		

	else
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'No SNP data to be deleted',0,stepCt,'Done');
	end if;		
	
	--	delete trial from de_subject_sample_mapping
	
	delete from de_subject_sample_mapping
	where trial_name = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete trial from de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');
	commit;
			
	--	delete data in biomart
	
	delete from bio_data_uid
	where unique_id = 'EXP:' || TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete trial from bio_data_uid',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	delete from bio_data_compound
	where bio_data_id in 
		 (select x.bio_experiment_id from bio_experiment x
		  where x.accession = TrialId
		    and x.etl_id = 'METADATA:' || TrialId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete trial from bio_data_compound',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	delete from bio_data_disease
	where bio_data_id in 
		 (select x.bio_experiment_id from bio_experiment x
		  where x.accession = TrialId
		    and x.etl_id = 'METADATA:' || TrialId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete trial from bio_data_disease',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	delete from bio_data_taxonomy
	where bio_data_id in 
		 (select x.bio_experiment_id from bio_experiment x
		  where x.accession = TrialId
		    and x.etl_id = 'METADATA:' || TrialId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete trial from bio_data_taxonomy',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	remove study from FMAPP
	
	delete from fmapp.fm_file ff
	where ff.file_id in
		 (select ffa.file_id
		  from fmapp.fm_folder f
			  ,fmapp.fm_folder_file_association ffa
		  where f.folder_name = TrialId
		    and f.folder_id = ffa.folder_id);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete files from fm_file',SQL%ROWCOUNT,stepCt,'Done');
	
	delete from fmapp.fm_data_uid ff
	where ff.unique_id in
		 (select 'FIL:' || to_char(ffa.file_id)
		  from fmapp.fm_folder f
			  ,fmapp.fm_folder_file_association ffa
		  where f.folder_name = TrialId
		    and f.folder_id = ffa.folder_id);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete files from fm_data_uid',SQL%ROWCOUNT,stepCt,'Done');
	
	delete from fmapp.fm_folder_association
	where object_uid = 'EXP:' || TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete trial from fm_folder_association',SQL%ROWCOUNT,stepCt,'Done');
	
	delete from fmapp.fm_data_uid ff
	where ff.unique_id in
		 (select 'FOL:' || to_char(f.folder_id)
		  from fmapp.fm_folder f
		  where f.folder_name = TrialId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete folders from fm_data_uid',SQL%ROWCOUNT,stepCt,'Done');
	
	delete from fmapp.fm_folder
	where folder_name = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete trial from fm_folder',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	reload i2b2_secure
	
	i2b2_load_security_data;
	
  end if;
  
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
  
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CLINICAL_DATA_EXTRNL_LT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CLINICAL_DATA_EXTRNL_LT" 
(
  trial_id 		IN	VARCHAR2
 ,currentJobID	IN	NUMBER := null
)
AS

	--	JEA@20111028	New, loads clinical data from external table to landing zone temporary table
  
  topNode		VARCHAR2(2000);
  topLevel		number(10,0);
  root_node		varchar2(2000);
  root_level	int;
  study_name	varchar2(2000);
  TrialID		varchar2(100);
  secureStudy	varchar2(200);
  etlDate		date;
  tPath			varchar2(2000);
  pCount		int;
  rtnCode		int;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  

BEGIN
  
	TrialID := upper(trial_id);
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;
	
	select sysdate into etlDate from dual;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
    	
	stepCt := 0;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_clinical_data_extrnl_lt',0,stepCt,'Done');
	
	--	truncate landing zone work table
	
	execute immediate('truncate table tm_lz.lt_src_clinical_data');
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate table lt_src_clinical_data',0,stepCt,'Done');
		
	--	Insert data to lt_src_clinical_data
	
	insert into lt_src_clinical_data
	(study_id
	,site_id
	,subject_id
	,visit_name
	,data_label
	,data_value
	,category_cd)
	select study_id
		  ,site_id
		  ,subject_id
		  ,visit_name
		  ,data_label
		  ,data_value
		  ,category_cd
	from clinical_data_extrnl;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data into lt_src_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_clinical_data_extrnl_lt',0,stepCt,'Done');
	
    ---Cleanup OVERALL JOB if this proc is being run standalone
	if newJobFlag = 1
	then
		cz_end_audit (jobID, 'SUCCESS');
	end if;

	rtnCode := 0;
  
	exception
	when others then
    --Handle errors.
		cz_error_handler (jobID, procedureName);
    --End Proc
		cz_end_audit (jobID, 'FAIL');
		rtnCode := 16;
	
end;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_COPY_TO_RELEASE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_COPY_TO_RELEASE" 
(
  trial_id IN VARCHAR2
 ,ont_Path IN VARCHAR2	--	Use this parameter if TrialID is not contained in the i2b2/concept_dimension paths.  This will specify the string to use in filters
 ,currentJobID NUMBER := null
 )
AS

	TrialId varchar2(200);
	ontPath varchar2(200);
	msgText	varchar2(2000);

	sql_txt varchar2(2000);
	tExists number;
  vSNP number;

	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);
  

	--	JEA@20100624	Removed gene_symbol, renamed probeset to probeset_id in de_subject_mrna_data_release
	--					added de_mrna_annotation_release
	--	JEA@20100903	Added haploview_data_release
	--	JEA@2010099		Added trial/path logging to audit log
	--	JEA@20101013	Added de_gpl_info_release table
	--	JEA@20110125	Added deapp SNP tables
	
BEGIN

	TrialID := upper(trial_id);
	ontPath := ont_path;
	
	stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_promote_to_stg',0,stepCt,'Done');
	
	stepCt := stepCt + 1;
	msgText := 'Extracting trial: ' || TrialId || ' path: ' || ontPath;
	cz_write_audit(jobId,databaseName,procedureName, msgText,0,stepCt,'Done');

	if TrialId = null then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'TrialID missing',0,stepCt,'Done');
		Return;
	end if;

	if ontPath = null or ontPath = '' or ontPath = '%'then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'ontPath invalid',0,stepCt,'Done');
		Return;
	End if;

	--	Delete existing data for trial
	
	delete i2b2_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  i2b2_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete observation_fact_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  observation_fact_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete patient_dimension_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  patient_dimension_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete concept_dimension_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  concept_dimension_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete de_subj_sample_map_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  de_subj_sample_map_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete de_subject_mrna_data_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  de_subject_mrna_data_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete de_subject_rbm_data_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  de_subject_rbm_data_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete de_subj_protein_data_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  de_subj_protein_data_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete haploview_data_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  haploview_data_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete i2b2_tags_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  i2b2_tags_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete bio_experiment_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  bio_experiment_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete bio_clinical_trial_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  bio_clinical_trial_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	delete bio_data_uid_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  bio_data_uid_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	delete bio_data_compound_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  bio_data_compound_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	delete search_secure_object_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  search_secure_object_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--delete de_subject_snp_dataset_release
	--where release_study = TrialID;
	--stepCt := stepCt + 1;
	--cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  de_subject_snp_dataset_release',SQL%ROWCOUNT,stepCt,'Done');
	--commit;	
	
	delete de_snp_data_by_patient_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  de_snp_data_by_patient_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
		
	delete de_snp_data_ds_loc_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  de_snp_data_ds_loc_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	delete de_snp_data_by_probe_release
	where release_study = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from  de_snp_data_by_probe_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	delete sample_categories_release
	where release_study = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from sample_categories_release',SQL%ROWCOUNT,stepCt,'Done');
	
	execute immediate('truncate table de_mrna_annotation_release');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncated table  de_mrna_annotation_release',SQL%ROWCOUNT,stepCt,'Done');
	
	execute immediate('truncate table de_gpl_info_release');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncated table  de_gpl_info_release',SQL%ROWCOUNT,stepCt,'Done');

		
	--	insert i2b2 records into release table

	insert into i2b2_release
	select mf.*, TrialId as release_study 
	from i2b2 mf
	where mf.c_fullname like '%' || ontPath || '%'
    and mf.c_fullname not like '%Across Trials%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  i2b2_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	insert into observation_fact_release
	select mf.*, mf.modifier_cd as release_study
	from observation_fact mf
	where mf.modifier_cd = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  observation_fact_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	insert into patient_dimension_release
	select mf.*, TrialId as release_study
	from patient_dimension mf
	where mf.sourcesystem_cd like TrialId || '%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  patient_dimension_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	insert into concept_dimension_release
	select mf.*, mf.sourcesystem_cd as release_study
	from concept_dimension mf
	where mf.sourcesystem_cd = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  concept_dimension_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	insert into de_subj_sample_map_release 
	select mf.*, mf.trial_name as release_study
	from deapp.de_subject_sample_mapping mf
	where mf.trial_name = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  de_subj_sample_map_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	insert into de_subject_mrna_data_release
	select mf.*, mf.trial_name as release_study
	from deapp.de_subject_microarray_data mf
	where mf.trial_name = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  de_subject_mrna_data_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;



/*
	insert into de_subject_rbm_data_release
	select mf.*, mf.trial_name as release_study
	from deapp.de_subject_rbm_data mf
	where mf.trial_name = TrialId;
	*/
  
  insert into de_subject_rbm_data_release 
        (ANTIGEN_NAME, ASSAY_ID, CONCEPT_CD, DATA_UID, GENE_ID, GENE_SYMBOL, LOG_INTENSITY, MEAN_INTENSITY, MEDIAN_INTENSITY, N_VALUE, NORMALIZED_VALUE, PATIENT_ID, RBM_PANEL, STDDEV_INTENSITY, TIMEPOINT, TRIAL_NAME, VALUE, ZSCORE, release_study)
	select ANTIGEN_NAME, ASSAY_ID, CONCEPT_CD, DATA_UID, GENE_ID, GENE_SYMBOL, LOG_INTENSITY, MEAN_INTENSITY, MEDIAN_INTENSITY, N_VALUE, NORMALIZED_VALUE, PATIENT_ID, RBM_PANEL, STDDEV_INTENSITY, TIMEPOINT, TRIAL_NAME, VALUE, ZSCORE, TrialId
	from deapp.de_subject_rbm_data mf
	where mf.trial_name = TrialId;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  de_subject_rbm_data_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	insert into de_subj_protein_data_release
	select mf.*, mf.trial_name as release_study
	from deapp.de_subject_protein_data mf
	where mf.trial_name = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  de_subj_protein_data_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	insert into haploview_data_release
	select mf.*, mf.trial_name as release_study
	from deapp.haploview_data mf
	where mf.trial_name = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  haploview_data_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
		
	insert into i2b2_tags_release
	select mf.*, TrialId as release_study
	from i2b2_tags mf
	where mf.path like '%' || ontPath || '%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  i2b2_tags_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	insert into bio_experiment_release
	select mf.*, mf.accession as release_study
	from biomart.bio_experiment mf
	where mf.accession = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  bio_experiment_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	insert into bio_clinical_trial_release
	select mf.*, TrialId as release_study
	from biomart.bio_clinical_trial mf
	where mf.trial_number = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  bio_clinical_trial_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	insert into bio_data_uid_release
	select mf.*, TrialId as release_study
	from biomart.bio_data_uid mf
	    ,biomart.bio_experiment mx
	where mx.accession = Trialid
	  and mx.bio_experiment_id = mf.bio_data_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  bio_data_uid_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	insert into bio_data_compound_release
	select mf.*, TrialId as release_study
	from biomart.bio_data_compound mf
	    ,biomart.bio_experiment mx
	where mx.accession = Trialid
	  and mx.bio_experiment_id = mf.bio_data_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  bio_data_compound_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	insert into search_secure_object_release
	select mf.*, TrialId as release_study
	from searchapp.search_secure_object mf
	    ,biomart.bio_experiment mx
	where mx.accession = Trialid
	  and mx.bio_experiment_id = mf.bio_data_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  search_secure_object_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--insert into de_subject_snp_dataset_release
	--select snp.*, TrialId as release_study
	--from deapp.de_subject_snp_dataset snp
	--where snp.trial_name = Trialid;
	--stepCt := stepCt + 1;
	--cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  de_subject_snp_dataset_release',SQL%ROWCOUNT,stepCt,'Done');
		

	insert into de_snp_data_by_patient_release
	select snp.*, TrialId as release_study
	from deapp.de_snp_data_by_patient snp
	where snp.trial_name = Trialid;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  de_snp_data_by_patient_release',SQL%ROWCOUNT,stepCt,'Done');



	insert into de_snp_data_ds_loc_release
	select snp.*, TrialId as release_study
	from deapp.de_snp_data_dataset_loc snp
	where snp.trial_name = Trialid;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  de_snp_data_ds_loc_release',SQL%ROWCOUNT,stepCt,'Done');
	
	insert into de_snp_data_by_probe_release
	select snp.*, TrialId as release_study
	from deapp.de_snp_data_by_probe snp
	where snp.trial_name = Trialid;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into  de_snp_data_by_probe_release',SQL%ROWCOUNT,stepCt,'Done');


	insert into de_mrna_annotation_release
	select * from deapp.de_mrna_annotation;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted data into  de_mrna_annotation_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;
  
	insert into de_gpl_info_release
	select * from deapp.de_gpl_info;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted data into  de_gpl_info_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;
    
  /* JDC: Check if the study contains SNP data and only load the following snp tables if needed */
  
  vSNP:=0;  
  select count(*)
	into vSNP
	from de_snp_data_by_probe_release
	where release_study = TrialId;
  
  
	IF vSNP > 0 THEN     
      

    execute immediate('truncate table de_snp_info_release');
	
    insert into de_snp_info_release
    select * from deapp.de_snp_info;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted data into  de_snp_info_release',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
	execute immediate('truncate table de_snp_probe_release');
	   
    insert into de_snp_probe_release
    select * from deapp.de_snp_probe;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted data into  de_snp_probe_release',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
	execute immediate('truncate table de_snp_gene_map_release');
	    
    insert into de_snp_gene_map_release
    select * from deapp.de_snp_gene_map;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted data into  de_snp_gene_map_release',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
	execute immediate('truncate table de_snp_probe_sort_def_release');
	    
    insert into de_snp_probe_sort_def_release
    select * from deapp.de_snp_probe_sorted_def;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted data into  de_snp_probe_sort_def_release',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
  end if;
  
  
  
	insert into sample_categories_release
	select sc.*, TrialId as release_study
    from lz_src_sample_categories sc
	where trial_cd = TrialId;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted data into  sample_categories_release',SQL%ROWCOUNT,stepCt,'Done');
	commit;
   
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_promote_to_stg',0,stepCt,'Done');

       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

END;

/*	Create release tables

	create table i2b2_release as
	select x.*, x.sourcesystem_cd as release_study
	from i2b2 x
	where 1=2'

	create table observation_fact_release as
	select x.*, x.modifier_cd as release_study
	from observation_fact x
	where 1=2	

	create table patient_dimension_release as
	select x.*, x.sourcesystem_cd as release_study 
	from patient_dimension x
	where 1=2

	create table concept_dimension_release as
	select x.*, x.sourcesystem_cd as release_study 
	from concept_dimension x
	where 1=2
	
	create table de_subj_sample_map_release as
	select x.*, x.trial_name as release_study
	from deapp.de_subject_sample_mapping x
	where 1=2
	
	create table de_subject_mrna_data_release as
	select x.*, x.trial_name as release_study 
	from deapp.de_subject_microarray_data x
	where 1=2
	
	create table de_subject_rbm_data_release as
	select x.*, x.trial_name as release_study 
	from deapp.de_subject_rbm_data x
	where 1=2
	
	create table de_subj_protein_data_release as
	select x.*, x.trial_name as release_study
	from deapp.de_subject_protein_data x
	where 1=2
	
	create table i2b2_tags_release as
	select x.*, x.path as release_study 
	from i2b2_tags x
	where 1=2
	
	create table bio_experiment_release as
	select x.*, x.accession as release_study 
	from biomart.bio_experiment x
	where 1=2
	
	create table bio_clinical_trial_release as
	select x.*, x.trial_number as release_study 
	from biomart.bio_clinical_trial x
	where 1=2
	
	create table bio_data_uid_release as
	select x.*, x.unique_id as release_study 
	from biomart.bio_data_uid x
	where 1=2
	
	create table bio_data_compound_release as
	select c.*, b.accession as release_study 
	from biomart.bio_data_compound c
		,biomart.bio_experiment b
	where 1=2
	
	create table search_secure_object_release as
	select c.*, b.accession as release_study
	from searchapp.search_secure_object c
	    ,biomart.bio_experiment b
	where 1=2
	
*/
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_CONCEPT_COUNTS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_CONCEPT_COUNTS" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  -------------------------------------------------------------
  -- Insert records into the Concept Counts table for new nodes
  -- KCR@20090404 - First Rev
  -- KCR@20090709 - NEXT Rev
  -- JEA@20090817 - Changed processing to eliminate need for cursor
  -- JEA@20091118 - Added auditing
  -- JEA@20100507 - Changed to account for Biomarker mRNA nodes that may have different patient counts from
  --				the Samples & Timepoints concept
  -- JEA220100702 - Remove separate pass for Biomarker mRNA nodes, they now have unique concept codes
  -- JEA@20111025	Exclude samples from being counted as subjects
  -- JEA@20120113	Allow for third character in c_visualattributes
  
  --1. BUILD A TEMP TABLE OF ALL CONCEPT CODES WITH THEIR PATIENTS.
  -- NEED TO INCLUDE ROLLUPS OF INDIRECT RELATIONSHIPS (FOLDERS TO THEIR CHILDREN)
  --Build a cursor of Paths by level
  --iterate through the paths in reverse, so determine max level and go backwards, 
  --this way each folder will have the data needed when you get to it already rolled up

  -------------------------------------------------------------
    
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
BEGIN
     
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  
  delete 
    from concept_counts
  where 
    concept_path like path || '%';
  stepCt := stepCt + 1;
  cz_write_audit(jobId,databaseName,procedureName,'Delete counts for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
	
  commit;

/*	Removed because mRNA nodes have unique concept_cds (20100702)
  
	execute immediate('truncate table tmp_concept_counts');
	
	--	insert data for leaf nodes, do Biomarker mRNA nodes first so that the correct patients are joined to de_subject_sample_mapping
	--	this is done because mRNA nodes can share concept_cds with Samples & Timepoints nodes
	
	insert into tmp_concept_counts
	(leaf_path
	,patient_num
	)
	select distinct la.c_fullname
		  ,tpm.patient_num
	from i2b2 la
		,observation_fact tpm
		,deapp.de_subject_sample_mapping sm
		,reference.gpl_info gi
	where la.c_fullname like path || '%'
	  and la.c_visualattributes like 'L%'
	  and la.c_basecode = tpm.concept_cd(+)
	  and tpm.patient_num = sm.patient_id
	  and tpm.modifier_cd = sm.trial_name
	  and sm.platform = 'MRNA_AFFYMETRIX'
	  and sm.gpl_id = gi.platform
	  and la.c_fullname like path || '%' || gi.title || '%';
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert mRNA leaf counts for trial into I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	insert data for remaining leaf nodes and exclude Biomarker mRNA leaf nodes
	
	insert into tmp_concept_counts
	(leaf_path
	,patient_num
	)
	select distinct la.c_fullname
		  ,tpm.patient_num
	from i2b2 la
		,observation_fact tpm
	where la.c_fullname like path || '%'
	  and la.c_visualattributes like 'L%'
	  and la.c_basecode = tpm.concept_cd(+)
	  and not exists
	     (select 1 from tmp_concept_counts cx
		  where la.c_fullname = cx.leaf_path);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert all remaining leaf counts for trial into I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
*/
	
	--	Join each node (folder or leaf) in the path to it's leaf in the work table to count patient numbers

	insert into concept_counts
	(concept_path
	,parent_concept_path
	,patient_count
	)
	select /*+INDEX (I2B2 I2B2_IDX1) */
    fa.c_fullname
		  ,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)))
		  ,count(distinct tpm.patient_num)
	from i2b2 fa
	    ,i2b2 la
		,observation_fact tpm
		,patient_dimension p
	where fa.c_fullname like path || '%'
	  and substr(fa.c_visualattributes,2,1) != 'H'
	  and la.c_fullname like fa.c_fullname || '%'
	  and la.c_visualattributes like 'L%'
	  and tpm.patient_num = p.patient_num
	  and p.sourcesystem_cd not like '%:S:%'
	  and la.c_basecode = tpm.concept_cd(+)
	group by fa.c_fullname
			,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)));
			
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert counts for trial into I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
		
	commit;

	--execute immediate('truncate table tmp_concept_counts');
	
    execute immediate('create index cc_path_count_idx on CONCEPT_COUNTS(CONCEPT_PATH, PATIENT_COUNT) tablespace "INDX"');
    execute immediate('create index cc_path_idx on CONCEPT_COUNTS(CONCEPT_PATH) tablespace "INDX"');

	--SET ANY NODE WITH MISSING OR ZERO COUNTS TO HIDDEN

	update i2b2
	set c_visualattributes = substr(c_visualattributes,1,1) || 'H' || substr(c_visualattributes,3,1)
	where c_fullname like path || '%'
	  and (not exists
			 (select 1 from concept_counts nc
				  where c_fullname = nc.concept_path)
				 or
			 exists
				 (select 1 from concept_counts zc
				  where c_fullname = zc.concept_path
					and zc.patient_count = 0)
			  )
		and c_name != 'SECURITY';
		
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Nodes hidden with missing/zero counts for trial into I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
		
    execute immediate('drop index cc_path_count_idx');
    execute immediate('drop index cc_path_idx');
	  commit;
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/*	needed for i2b2 1.4

update i2b2 i
set c_totalnum=(select count(distinct tpm.patient_num)
				 from i2b2 la
				     ,observation_fact tpm
				 where la.c_fullname like i.c_fullname || '%'
                   and la.c_visualattributes like 'L%'
                   and la.c_basecode = tpm.concept_cd(+)
				)
where exists
     (select 1 from i2b2 lax
				   ,observation_fact tpmx
	  where lax.c_fullname like i.c_fullname || '%'
        and lax.c_visualattributes like 'L%'
        and lax.c_basecode = tpmx.concept_cd(+)
       )
and i.c_visualattributes not like '%H%'
and i.c_fullname like '%BEERLUNG%'

*/

/* old CODE

--	Cursor

  maxLevel NUMBER := 0;
  currentLevel number := 0;

  CURSOR cPath is
  select a.concept_cd, a.concept_path
    FROM concept_dimension a
    join i2b2 b
      on a.concept_path = b.c_fullname
    where b.c_hlevel = currentLevel
      and b.c_visualattributes not like '%H%' --do not consider Hidden values
      and b.c_fullname like path || '%';

  insert 
    into concept_counts(
      patient_count, 
      concept_path)  
  select 
    count(distinct c.patient_num) patient_count, 
    e.c_fullname as concept_path 
  from 
    i2b2 e
  join
    concept_dimension d
  on 
    d.concept_path like e.c_fullname ||'%'
  left outer join 
    observation_fact c
  on 
    d.concept_cd = c.concept_cd
  where
    e.c_fullname like path || '%'  
  group by (e.c_fullname);  
  commit;

  --determine the parent_path
  update concept_counts
  set parent_concept_path = ltrim(SUBSTR(concept_path, 1,instr(Concept_Path, '\',-1,2))) 
  where concept_path like path || '%';
  commit;
  
    update i2b2
    set c_visualattributes = 'FH'
  where c_fullname like path || '%'
    and c_visualattributes like 'F%'
    and c_fullname in (select concept_path from concept_counts where patient_count = 0 and concept_path like path || '%')
    and c_name != 'SECURITY';
  commit;
  
  
    update i2b2
    set c_visualattributes = 'LH'
  where c_fullname like path || '%'
    and c_visualattributes like 'L%'
    and c_fullname in (select concept_path from concept_counts where patient_count = 0 and concept_path like path || '%')
    and c_name != 'SECURITY';
  
*/

/*	The following code was never implemented in production

  --Truncate temp table
  EXECUTE IMMEDIATE('TRUNCATE TABLE I2B2_PATIENT_ROLLUP');

  --REMOVE RECORDS FROM CONCEPT COUNTS FOR THIS PATH

  --get max level
  SELECT max(c_hlevel) into maxLevel 
    FROM i2b2
      WHERE c_visualattributes not like '%H%' --do not consider Hidden values
      and c_fullname like path || '%';

  --iterate through all paths by level in reverse
  FOR Lpath IN REVERSE 0..maxLevel
  LOOP
    --inner loop through cursor for the particular level
    currentLevel := Lpath;
    FOR r_cPath in cPath Loop
      insert into i2b2_patient_rollup
        SELECT distinct r_cPath.concept_cd, r_cPath.concept_path, b.patient_num, currentLevel
          from concept_dimension a
          join observation_fact b
            on a.concept_cd = b.concept_cd
            and a.concept_cd = r_cPath.concept_cd
        union
        select distinct r_cPath.concept_cd, r_cPath.concept_path, a.patient_num, currentLevel
          from i2b2_patient_rollup a
            where a.concept_path like r_cPath.concept_path || '%'
              and a.c_hlevel = (currentLevel + 1);
    COMMIT;
    END LOOP;  
  END LOOP;
  
  --aggregate the temp table and load into concept_counts  
  INSERT
  INTO CONCEPT_COUNTS
  (
    CONCEPT_PATH,
    PATIENT_COUNT
  )
  SELECT CONCEPT_PATH, COUNT(DISTINCT PATIENT_NUM)
  FROM i2b2_patient_rollup
  GROUP BY CONCEPT_PATH;
  COMMIT;
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_CONCEPT_COUNTS_TR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_CONCEPT_COUNTS_TR" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
 ,buildTree VARCHAR2 := 'Y'
)
AS
  -------------------------------------------------------------
  -- Insert records into the Concept Counts table for new nodes
  -- KCR@20090404 - First Rev
  -- KCR@20090709 - NEXT Rev
  -- JEA@20090817 - Changed processing to eliminate need for cursor
  -- JEA@20091118 - Added auditing
  -- JEA@20100507 - Changed to account for Biomarker mRNA nodes that may have different patient counts from
  --                the Samples & Timepoints concept
  -- JEA220100702 - Remove separate pass for Biomarker mRNA nodes, they now have unique concept codes
  -- JEA@20111025    Exclude samples from being counted as subjects
  -- JEA@20120113    Allow for third character in c_visualattributes
  
  --1. BUILD A TEMP TABLE OF ALL CONCEPT CODES WITH THEIR PATIENTS.
  -- NEED TO INCLUDE ROLLUPS OF INDIRECT RELATIONSHIPS (FOLDERS TO THEIR CHILDREN)
  --Build a cursor of Paths by level
  --iterate through the paths in reverse, so determine max level and go backwards, 
  --this way each folder will have the data needed when you get to it already rolled up

  -------------------------------------------------------------
    
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
BEGIN
     
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
        
  stepCt := 0;
  
  delete 
    from concept_counts
  where 
    concept_path like path || '%';
  stepCt := stepCt + 1;
  cz_write_audit(jobId,databaseName,procedureName,'Delete counts for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    
  commit;

/*    Removed because mRNA nodes have unique concept_cds (20100702)
  
    execute immediate('truncate table tmp_concept_counts');
    
    --    insert data for leaf nodes, do Biomarker mRNA nodes first so that the correct patients are joined to de_subject_sample_mapping
    --    this is done because mRNA nodes can share concept_cds with Samples & Timepoints nodes
    
    insert into tmp_concept_counts
    (leaf_path
    ,patient_num
    )
    select distinct la.c_fullname
          ,tpm.patient_num
    from i2b2 la
        ,observation_fact tpm
        ,deapp.de_subject_sample_mapping sm
        ,reference.gpl_info gi
    where la.c_fullname like path || '%'
      and la.c_visualattributes like 'L%'
      and la.c_basecode = tpm.concept_cd(+)
      and tpm.patient_num = sm.patient_id
      and tpm.modifier_cd = sm.trial_name
      and sm.platform = 'MRNA_AFFYMETRIX'
      and sm.gpl_id = gi.platform
      and la.c_fullname like path || '%' || gi.title || '%';
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert mRNA leaf counts for trial into I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    commit;    
    
    --    insert data for remaining leaf nodes and exclude Biomarker mRNA leaf nodes
    
    insert into tmp_concept_counts
    (leaf_path
    ,patient_num
    )
    select distinct la.c_fullname
          ,tpm.patient_num
    from i2b2 la
        ,observation_fact tpm
    where la.c_fullname like path || '%'
      and la.c_visualattributes like 'L%'
      and la.c_basecode = tpm.concept_cd(+)
      and not exists
         (select 1 from tmp_concept_counts cx
          where la.c_fullname = cx.leaf_path);
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert all remaining leaf counts for trial into I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    commit;    
*/
    
    
    
    

----------July 2013. Performance fix by TR. Join tree pre compute
IF(buildTree = 'Y')
THEN
    I2B2_CREATE_FULL_TREE(path, currentJobID);
END IF;

----------------------
    
    
    --    Join each node (folder or leaf) in the path to it's leaf in the work table to count patient numbers
-----July 2013. Performance fix by TR. Join by pre compute tree

    insert into concept_counts
    (concept_path
    ,parent_concept_path
    ,patient_count
    )
    select fa.c_fullname
          ,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)))
          ,count(distinct tpm.patient_num)
    from i2b2 fa
        ,i2b2 la
        ,observation_fact tpm
        ,patient_dimension p
        ,TM_WZ.I2B2_LOAD_TREE_FULL tree
    where fa.c_fullname like path || '%'
      and substr(fa.c_visualattributes,2,1) != 'H'
      --and la.c_fullname like fa.c_fullname || '%'
        and fa.rowid = tree.IDROOT 
        and la.rowid = tree.IDCHILD
      and la.c_visualattributes like 'L%'
      and tpm.patient_num = p.patient_num
      and p.sourcesystem_cd not like '%:S:%'
      and la.c_basecode = tpm.concept_cd(+)
    group by fa.c_fullname
            ,ltrim(SUBSTR(fa.c_fullname, 1,instr(fa.c_fullname, '\',-1,2)));
            
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert counts for trial into I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;

    --execute immediate('truncate table tmp_concept_counts');
    
    --SET ANY NODE WITH MISSING OR ZERO COUNTS TO HIDDEN

    update i2b2
    set c_visualattributes = substr(c_visualattributes,1,1) || 'H' || substr(c_visualattributes,3,1)
    where c_fullname like path || '%'
      and (not exists
             (select 1 from concept_counts nc
                  where c_fullname = nc.concept_path)
                 or
             exists
                 (select 1 from concept_counts zc
                  where c_fullname = zc.concept_path
                    and zc.patient_count = 0)
              )
        and c_name != 'SECURITY';
        
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Nodes hidden with missing/zero counts for trial into I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
        
      commit;
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
    
END;

/*    needed for i2b2 1.4

update i2b2 i
set c_totalnum=(select count(distinct tpm.patient_num)
                 from i2b2 la
                     ,observation_fact tpm
                 where la.c_fullname like i.c_fullname || '%'
                   and la.c_visualattributes like 'L%'
                   and la.c_basecode = tpm.concept_cd(+)
                )
where exists
     (select 1 from i2b2 lax
                   ,observation_fact tpmx
      where lax.c_fullname like i.c_fullname || '%'
        and lax.c_visualattributes like 'L%'
        and lax.c_basecode = tpmx.concept_cd(+)
       )
and i.c_visualattributes not like '%H%'
and i.c_fullname like '%BEERLUNG%'

*/

/* old CODE

--    Cursor

  maxLevel NUMBER := 0;
  currentLevel number := 0;

  CURSOR cPath is
  select a.concept_cd, a.concept_path
    FROM concept_dimension a
    join i2b2 b
      on a.concept_path = b.c_fullname
    where b.c_hlevel = currentLevel
      and b.c_visualattributes not like '%H%' --do not consider Hidden values
      and b.c_fullname like path || '%';

  insert 
    into concept_counts(
      patient_count, 
      concept_path)  
  select 
    count(distinct c.patient_num) patient_count, 
    e.c_fullname as concept_path 
  from 
    i2b2 e
  join
    concept_dimension d
  on 
    d.concept_path like e.c_fullname ||'%'
  left outer join 
    observation_fact c
  on 
    d.concept_cd = c.concept_cd
  where
    e.c_fullname like path || '%'  
  group by (e.c_fullname);  
  commit;

  --determine the parent_path
  update concept_counts
  set parent_concept_path = ltrim(SUBSTR(concept_path, 1,instr(Concept_Path, '\',-1,2))) 
  where concept_path like path || '%';
  commit;
  
    update i2b2
    set c_visualattributes = 'FH'
  where c_fullname like path || '%'
    and c_visualattributes like 'F%'
    and c_fullname in (select concept_path from concept_counts where patient_count = 0 and concept_path like path || '%')
    and c_name != 'SECURITY';
  commit;
  
  
    update i2b2
    set c_visualattributes = 'LH'
  where c_fullname like path || '%'
    and c_visualattributes like 'L%'
    and c_fullname in (select concept_path from concept_counts where patient_count = 0 and concept_path like path || '%')
    and c_name != 'SECURITY';
  
*/

/*    The following code was never implemented in production

  --Truncate temp table
  EXECUTE IMMEDIATE('TRUNCATE TABLE I2B2_PATIENT_ROLLUP');

  --REMOVE RECORDS FROM CONCEPT COUNTS FOR THIS PATH

  --get max level
  SELECT max(c_hlevel) into maxLevel 
    FROM i2b2
      WHERE c_visualattributes not like '%H%' --do not consider Hidden values
      and c_fullname like path || '%';

  --iterate through all paths by level in reverse
  FOR Lpath IN REVERSE 0..maxLevel
  LOOP
    --inner loop through cursor for the particular level
    currentLevel := Lpath;
    FOR r_cPath in cPath Loop
      insert into i2b2_patient_rollup
        SELECT distinct r_cPath.concept_cd, r_cPath.concept_path, b.patient_num, currentLevel
          from concept_dimension a
          join observation_fact b
            on a.concept_cd = b.concept_cd
            and a.concept_cd = r_cPath.concept_cd
        union
        select distinct r_cPath.concept_cd, r_cPath.concept_path, a.patient_num, currentLevel
          from i2b2_patient_rollup a
            where a.concept_path like r_cPath.concept_path || '%'
              and a.c_hlevel = (currentLevel + 1);
    COMMIT;
    END LOOP;  
  END LOOP;
  
  --aggregate the temp table and load into concept_counts  
  INSERT
  INTO CONCEPT_COUNTS
  (
    CONCEPT_PATH,
    PATIENT_COUNT
  )
  SELECT CONCEPT_PATH, COUNT(DISTINCT PATIENT_NUM)
  FROM i2b2_patient_rollup
  GROUP BY CONCEPT_PATH;
  COMMIT;
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_EXTERNAL_TABLES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_EXTERNAL_TABLES" 
(
  TPMExtFn VARCHAR2,
  CATGExtFn VARCHAR2
)
AS

sqltxt varchar2(5000);

BEGIN

--  recreate CATEGORY_EXTRNL tabls with CATGExtFN parameter (filename in external file system)

sqltxt:='drop table i2b2_lz.category_extrnl';

  execute immediate sqltxt;
  
sqltxt:='CREATE TABLE "I2B2_LZ"."CATEGORY_EXTRNL" 
   ( "STUDY_ID" VARCHAR2(100 BYTE),  
	"CATEGORY_CD" VARCHAR2(100 BYTE), 
	"CATEGORY_PATH" VARCHAR2(250 BYTE)
   ) 
   ORGANIZATION EXTERNAL 
    ( TYPE ORACLE_LOADER
      DEFAULT DIRECTORY "BIOMART_LZ"
      ACCESS PARAMETERS
      ( records delimited by newline nologfile skip 1
        fields terminated by 0X"09"
        MISSING FIELD VALUES ARE NULL 
            )
      LOCATION
       ( ' || '''' || CATGExtFn || '''' || '))';
  
   execute immediate sqltxt;
  
--  recreate TIME_POINT_MEASUREMENT_EXTRNL tabls with TPMExtFN parameter (filename in external file system)

sqltxt:='drop table i2b2_lz.time_point_measurement_extrnl';

  execute immediate sqltxt;
  
sqltxt:='    CREATE TABLE "I2B2_LZ"."TIME_POINT_MEASUREMENT_EXTRNL" 
   ("STUDY_ID" VARCHAR2(25 BYTE), 
	"USUBJID" VARCHAR2(50 BYTE), 
	"SITE_ID" VARCHAR2(10 BYTE), 
	"SUBJECT_ID" VARCHAR2(10 BYTE), 
	"VISIT_NAME" VARCHAR2(100 BYTE), 
	"DATASET_NAME" VARCHAR2(500 BYTE), 
	"SAMPLE_TYPE" VARCHAR2(100 BYTE), 
	"DATA_LABEL" VARCHAR2(500 BYTE), 
	"DATA_VALUE" VARCHAR2(500 BYTE), 
	"CATEGORY_CD" VARCHAR2(100 BYTE), 
	"PERIOD" VARCHAR2(100 BYTE)
   ) 
   ORGANIZATION EXTERNAL 
    ( TYPE ORACLE_LOADER
      DEFAULT DIRECTORY "BIOMART_LZ"
      ACCESS PARAMETERS
      ( records delimited by newline nologfile skip 1
        fields terminated by 0X"09" 
        MISSING FIELD VALUES ARE NULL 
            )
      LOCATION ( ' || '''' || TPMExtFn || '''' ||  ') )';
       
    execute immediate sqltxt;

END;

 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_FULL_TREE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_FULL_TREE" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS

BEGIN
    
--     execute immediate('truncate table I2B2METADATA.I2B2_LOAD_TREE');

--           INSERT INTO "I2B2METADATA"."I2B2_LOAD_TREE"
--             SELECT /*+ parallel(8) */ ROW_NUMBER()  OVER (ORDER BY c_fullname),  C_HLEVEL, NULL, chk.rowid as r FROM i2b2 chk
--             WHERE chk.c_fullname like path || '%'
            --REMOVE ITEMS WITHOUT PARENT
--             AND (C_HLEVEL = 1 OR EXISTS (SELECT 1 FROM i2b2 par WHERE par.c_fullname = (SUBSTR(chk.c_fullname, 1, INSTR(chk.c_fullname, '\', -2)))))
--             ;
          
--     execute immediate('analyze table I2B2METADATA.I2B2_LOAD_TREE compute statistics');


--         UPDATE /*+ parallel(4) */ I2B2METADATA.I2B2_LOAD_TREE t
--         SET t.lvl_last_id = (
--                 WITH LastLVL as (
--                   SELECT tt.ID, (SELECT MIN(e.ID) FROM I2B2METADATA.I2B2_LOAD_TREE e
--                   WHERE e.LVL <= tt.LVL AND e.id > tt.ID) v FROM I2B2METADATA.I2B2_LOAD_TREE tt        
--                 )          
--               SELECT v FROM LastLVL WHERE LastLVL.ID = t.ID
--             ) - 1;      
            
--         commit;
        
--           UPDATE /*+ parallel(4) */ I2B2METADATA.I2B2_LOAD_TREE t
--           SET t.lvl_last_id = (
--               SELECT MAX(e.ID) FROM I2B2METADATA.I2B2_LOAD_TREE e
--             )
--           WHERE t.lvl_last_id IS NULL;
          
--     execute immediate('analyze table I2B2METADATA.I2B2_LOAD_TREE compute statistics');

-- commit; 

--     execute immediate('truncate table I2B2METADATA.I2B2_LOAD_TREE_FULL');

--       INSERT INTO "I2B2METADATA"."I2B2_LOAD_TREE_FULL"
--       select /*+ parallel(8) */ treefa.RECORD_ID, treela.RECORD_ID
--         from "I2B2METADATA"."I2B2_LOAD_TREE" treefa
--       INNER JOIN "I2B2METADATA"."I2B2_LOAD_TREE" treela ON treela.id BETWEEN treefa.id AND treefa.lvl_last_id;
      
--     execute immediate('analyze table I2B2METADATA.I2B2_LOAD_TREE_FULL compute statistics');
    
 
 -- The slow way of loading tree into I2B2_LOAD_TREE_FULL
 
    execute immediate('truncate table TM_WZ.I2B2_LOAD_PATH');
    INSERT INTO "TM_WZ"."I2B2_LOAD_PATH"(PATH, RECORD_ID)
    SELECT  SUBSTR(p.c_fullname, LENGTH(path), LENGTH(p.c_fullname) - LENGTH(path) + 1), p.rowid
    from i2b2 p 
    where p.c_fullname like path || '%';
    
    commit; 
    
    execute immediate('analyze table TM_WZ.I2B2_LOAD_PATH compute statistics');
    execute immediate('truncate table TM_WZ.I2B2_LOAD_TREE_FULL');

    INSERT INTO "TM_WZ"."I2B2_LOAD_TREE_FULL" 
    SELECT /*+ parallel(8) */ p.RECORD_ID, c.RECORD_ID
    from "TM_WZ"."I2B2_LOAD_PATH" p ,"TM_WZ"."I2B2_LOAD_PATH" c
    where c.PATH like p.PATH || '%';
      
    commit; 
    
    execute immediate('analyze table TM_WZ.I2B2_LOAD_TREE_FULL compute statistics');


END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_PATIENT_DIM
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_PATIENT_DIM" 
(
  trial_id VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  TrialID varchar2(100);
    
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN
  -------------------------------------------------------------
  -- Load the Patient Dimension Table
  -- KCR@20090404 - First Rev
  -- JEA@20091117 - Added auditing
  -------------------------------------------------------------
  TrialID := upper(trial_id);

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;

  stepCt := 0;
  
  --delete existing data if it exists
  DELETE 
    FROM PATIENT_DIMENSION
  WHERE 
    sourcesystem_cd like TrialID || '%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete existing data for trial in I2B2DEMODATA patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
  commit;
  --insert patient data
  INSERT
    INTO PATIENT_DIMENSION
    (
      PATIENT_NUM,
      SEX_CD,
      AGE_IN_YEARS_NUM,
      RACE_CD,
      UPDATE_DATE,
      DOWNLOAD_DATE,
      IMPORT_DATE,
      SOURCESYSTEM_CD
    )
    SELECT
      SEQ_PATIENT_NUM.nextval,
      CASE 
        WHEN UPPER(SEX_CD) = 'MALE' THEN 'M'
        WHEN UPPER(SEX_CD) = 'FEMALE' THEN 'F'
        WHEN UPPER(SEX_CD) = 'UNKNOWN' THEN 'U'
        ELSE sex_cd
      END,
      AGE_IN_YEARS_NUM,
      RACE_CD,
      SYSDATE,
      SYSDATE,
      SYSDATE,
      USUBJID
    FROM
      PATIENT_INFO
      where UPPER(study_id) = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in I2B2DEMODATA patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
  COMMIT;

/*
  --Update temp table for UI
  DELETE 
    FROM PATIENT_TRIAL
    WHERE trial = TrialID;
  COMMIT;
  

  INSERT INTO PATIENT_TRIAL (
    PATIENT_NUM, 
    TRIAL) 
  select 
    patient_num,
    TrialID
  from
    patient_dimension
  where
    sourcesystem_cd like TrialID || '%';
  COMMIT;
*/    

  
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_PATIENT_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_PATIENT_TRIAL" 
(
  TrialID 		IN	VARCHAR2
 ,study_type 	IN	VARCHAR2 := NULL
 ,currentJobID 	IN	NUMBER := null
 ,rtnCode		OUT	int
)
AS
		
  -------------------------------------------------------------
  -- Insert records into the Patient Trial table for new Trials
  -- KCR@20090518 - First Rev
  -- JEA@20091013 - Added new column secure_obj_token and logic for Public Study
  -- JEA@20091118 - Added auditing
  -- JEA@20100112 - Set secure_obj_token to EXP:PUBLIC for \Internal Studies\ and \Experimental Medicine Study\Normals\
  -- JEA@20100505 - Added return code
  -------------------------------------------------------------
  
	StudyType varchar2(100);
	  
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

    StudyType := study_type;
  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  	
	if StudyType is null then
		StudyType := 'Secured';
	end if;

  
  --Remove existing records
  delete 
    from patient_trial
  where 
     trial  = TrialID;
  stepCt := stepCt + 1;
  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
  commit;
  
  insert into i2b2demodata.patient_trial
  (patient_num
  ,trial
  ,secure_obj_token
  )
  select 
    patient_num, 
    TrialID,
	decode(studyType,'Public Studies','EXP:PUBLIC'
	                ,'Internal Studies','EXP:PUBLIC'
					,'Experimental Medicine Study',decode(TrialId,'NORMALS','EXP:PUBLIC','EXP:' || TrialID)
					,'EXP:' || TrialID)
  from 
    patient_dimension
  where
    sourcesystem_cd like TrialID || '%';
  stepCt := stepCt + 1;
 cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
  commit;
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  rtnCode := 0;
  
  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	rtnCode := 16;
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_CREATE_SECURITY_FOR_TRIAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_CREATE_SECURITY_FOR_TRIAL" 
(
  trial_id VARCHAR2
 ,secured_study varchar2 := 'N'
 ,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	TrialID 			varchar2(100);
	securedStudy 		varchar2(5);
	pExists				int;
	v_bio_experiment_id	number(18,0);
	v_study_name		varchar2(500);
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
	TrialID := trial_id;
	securedStudy := secured_study;
  
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	  
	delete from i2b2demodata.observation_fact
	where case when modifier_cd = '@'
			   then sourcesystem_cd
			   else modifier_cd end = TrialId
	  and concept_cd = 'SECURITY';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,instance_num
	)
	select distinct patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'@'
		  ,'T'
		  ,decode(securedStudy,'N','EXP:PUBLIC','EXP:' || trialID)
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,TrialId
		  ,1
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert security records for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	insert patients to patient_trial table
	
	delete from patient_trial
	where trial  = TrialID;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	insert into i2b2demodata.patient_trial
	(patient_num
	,trial
	,secure_obj_token
	)
	select patient_num, 
		   TrialID,
		   decode(securedStudy,'Y','EXP:' || TrialID,'EXP:PUBLIC')
	from patient_dimension
	where sourcesystem_cd like TrialID || ':%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA patient_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	if secure study, then create bio_experiment record if needed and insert to search_secured_object
	
	select count(*) into pExists
	from searchapp.search_secure_object sso
	where bio_data_unique_id = 'EXP:' || TrialId;
	
	if pExists = 0 then
		--	if securedStudy = Y, add trial to searchapp.search_secured_object
		if securedStudy = 'Y' then
			select count(*) into pExists
			from biomart.bio_experiment
			where accession = TrialId;
			
			if pExists = 0 then
			
				select c_name into v_study_name
				from i2b2metadata.i2b2
				where c_fullname = (select min(c_fullname) from i2b2metadata.i2b2
				                    where sourcesystem_cd = Trialid);
				
				insert into biomart.bio_experiment
				(title, accession, etl_id, bio_experiment_type)
				select v_study_name
					  ,TrialId
					  ,'METADATA:' || TrialId
					  ,'i2b2'
				from dual;
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
				commit;
			end if;
			
			select bio_experiment_id into v_bio_experiment_id
			from biomart.bio_experiment
			where accession = TrialId;
			
			insert into searchapp.search_secure_object
			(bio_data_id
			,display_name
			,data_type
			,bio_data_unique_id
			)
			select v_bio_experiment_id
				  ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
				  ,'BIO_CLINICAL_TRIAL' as data_type
				  ,'EXP:' || TrialId as bio_data_unique_id
			from i2b2metadata.i2b2 md
			where md.sourcesystem_cd = TrialId
			  and md.c_hlevel = 
				 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
				  where x.sourcesystem_cd = TrialId)
			  and not exists
				 (select 1 from searchapp.search_secure_object so
				  where v_bio_experiment_id = so.bio_data_id);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;
	else
		--	if securedStudy = N, delete entry from searchapp.search_secure_object
		if securedStudy = 'N' then
			delete from searchapp.search_secure_object
			where bio_data_unique_id = 'EXP:' || TrialId;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Deleted trial/study from SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
			commit;
		end if;		
	end if;
     
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_DELETE_1_NODE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_DELETE_1_NODE" 
(
  path VARCHAR2
)
AS
BEGIN
  
  -------------------------------------------------------------
  -- Delete a tree node in I2b2
  -- Not handling Observation Fact. It will take too long. 
  -- KCR@20090404 - First Rev
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME = PATH);
   -- COMMIT;

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH = path;
    --COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME = PATH;
    --COMMIT;

  --i2b2_secure
      DELETE
        FROM i2b2_secure
      WHERE 
        C_FULLNAME = PATH;
    --COMMIT;

  --i2b2_secure
      DELETE
        FROM concept_counts
      WHERE 
        concept_path = PATH;
    COMMIT;

  END IF;
  
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_DELETE_ALL_NODES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_DELETE_ALL_NODES" 
(
  path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
      
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

Begin

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  -------------------------------------------------------------
  -- Delete a tree node in I2b2
  -- Not handling Observation Fact. It will take too long. 
  -- KCR@20090404 - First Rev
  -- JEA@20100106 - Added auditing
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
    --I2B2
    DELETE 
      FROM OBSERVATION_FACT 
    WHERE 
      concept_cd IN (SELECT C_BASECODE FROM I2B2 WHERE C_FULLNAME LIKE PATH || '%');
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
	

      --CONCEPT DIMENSION
    DELETE 
      FROM CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH LIKE path || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
    
      --I2B2
      DELETE
        FROM i2b2
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  END IF;
  
  --i2b2_secure
      DELETE
        FROM i2b2_secure
      WHERE 
        C_FULLNAME LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

  --concept_counts
      DELETE
        FROM concept_counts
      WHERE 
        concept_path LIKE PATH || '%';
	  stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from I2B2DEMODATA concept_counts',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;
  
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_FILL_IN_TREE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_FILL_IN_TREE" 
(
  trial_id VARCHAR2
 ,path VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  TrialID varchar2(100);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  auditText varchar2(4000);
  
  ----------------------------------------------
  --Goal: To fill out an I2B2 Tree node
  --Steps. Walk backwards through an i2b2 tree and fill in all missing nodes.
  --\1\2\3\4\5\6\
  --Will check that \1\, \1\2\, etc..all exist.
  ----------------------------------------------
  
  -- JEA@20100107 - Added auditing
  
  --Get the nodes
  CURSOR cNodes is
    --Trimming off the last node as it would never need to be added.
    select distinct substr(c_fullname, 1,instr(c_fullname,'\',-2,1)) as c_fullname
    --select c_fullname
    from i2b2 
    where c_fullname like path || '%';
--      and c_hlevel > = 2;
  
  root_node varchar2(1000);
  node_name varchar(1000);
  v_count NUMBER;
  
BEGIN
  TrialID := upper(trial_id);
  
    stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
  --start node with the first slash
 
  --Iterate through each node
  FOR r_cNodes in cNodes Loop
    root_node := '\';
    --Determine how many nodes there are
    --Iterate through, Start with 2 as one will be null from the parser
    
    for loop_counter in 2 .. (length(r_cNodes.c_fullname) - nvl(length(replace(r_cNodes.c_fullname, '\')),0)) / length('\')
    LOOP
      --Determine Node:
      node_name := parse_nth_value(r_cNodes.c_fullname, loop_counter, '\');
      root_node :=  root_node || node_name || '\';
    
      --Dont run for first 2 nodes
    --  if loop_counter > 3 then 
        --Check if node exists. If it does not, add it.
        select count(*)
          into v_count 
        from i2b2
        where c_fullname = root_node;

        --If it doesn't exist, add it
        if v_count = 0 then
			auditText := 'Inserting ' || root_node;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,auditText,0,stepCt,'Done');
            i2b2_add_node(trial_id, root_node, node_name, jobId);
        end if;
    --  end if;
      
    END LOOP;

    --RESET VARIABLES
    root_node := '';
    node_name := '';
  END LOOP;
  
      ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_HIDE_NODE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_HIDE_NODE" 
(
  path VARCHAR2
)
AS
BEGIN
  
  -------------------------------------------------------------
  -- hIDES a tree node in I2b2
  -- KCR@20090519 - First Rev
  -- JEA@20120404	Only update second character of c_visualattributes
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
  
	update i2b2 b
	set c_visualattributes=substr(b.c_visualattributes,1,1) || 'H' || substr(b.c_visualattributes,3,1)
	where c_fullname like path || '%';
	
	delete from concept_counts
	where concept_path like path || '%';
	
	commit;
	
	
/*
      --I2B2
     UPDATE i2b2
      SET c_visualattributes = 'FH'
    WHERE c_visualattributes like 'F%'
      AND C_FULLNAME LIKE PATH || '%';

     UPDATE i2b2
      SET c_visualattributes = 'LH'
    WHERE c_visualattributes like 'L%'
      AND C_FULLNAME LIKE PATH || '%';
    COMMIT;
*/
  END IF;
  
END;
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_ACROSS_TRIALS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_ACROSS_TRIALS" 
(
 currentJobID NUMBER := null
)
AS
  
    --Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);
  
	pCount		number;
  
	mixed_datatypes	exception;
	no_table_access	exception;
	
  
  -- JEA@20111104	New
  
  
  root_node 	varchar2(1000);
  root_level	number;
  node_name 	varchar(1000);
  
BEGIN
  
    stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_load_across_trials',0,stepCt,'Done');
	
	--	Get level for \Across Trials\  could be 0 or -1
	
	select count(*)
	into root_level
	from table_access
	where c_fullname = '\Across Trials\';
	
	if root_level = 0 then
		raise no_table_access;
	end if;

	select c_hlevel
	into root_level
	from table_access
	where c_fullname = '\Across Trials\';
	
	--	truncate work table
	
	execute immediate('truncate table tm_wz.wt_xtrial_nodes');
 
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate tm_wz.wt_xtrial_nodes',0,stepCt,'Done');
		
	--	Insert folder-level data
	
	insert into wt_xtrial_nodes
	(xtrial_cd
	,trial_name
	,leaf_name
	,data_type
	,concept_cd
	,leaf_node
	)
	select distinct t.xtrial_cd
		  ,base.c_name as trial_name
		  ,la.c_name as leaf_name
		  ,la.c_columndatatype
		  ,la.c_basecode
		  ,REGEXP_REPLACE('\Across Trials\' || replace(replace(t.xtrial_category_cd,'+','\'),'_',' ')  || '\' || t.xtrial_name || '\' || 
		   decode(la.c_columndatatype,'T',la.c_name,'') || '\' || base.c_name || '\','(\\){2,}', '\')
	from cz_xtrial_codes t
		,i2b2 fa
		,i2b2 la
		,i2b2 base
	where t.xtrial_name = fa.c_name
	  and fa.c_fullname not like '%Across Trials%'
	  and fa.c_visualattributes like 'FA%'
	  and la.c_fullname like fa.c_fullname || '%'
	  and la.c_visualattributes like 'LA%'
	  and to_char(fa.c_comment) = to_char(base.c_comment)
	  and base.c_hlevel = 1
	  and not exists
	      (select 1 from cz_xtrial_exclusion xx
		   where to_char(fa.c_comment) = 'trial:' || trial_id);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert folder data into wt_xtrial_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	Insert leaf level data, check for dups
	
	insert into wt_xtrial_nodes
	(xtrial_cd
	,trial_name
	,leaf_name
	,data_type
	,concept_cd
	,leaf_node
	)
	select distinct t.xtrial_cd
		  ,base.c_name as trial_name
		  ,la.c_name as leaf_name
		  ,la.c_columndatatype
		  ,la.c_basecode
		  ,REGEXP_REPLACE('\Across Trials\' || replace(replace(t.xtrial_category_cd,'+','\'),'_',' ')  || '\' || t.xtrial_name || '\' || 
			'\' || base.c_name || '\' ,'(\\){2,}', '\')
	from cz_xtrial_codes t
		,i2b2 la
		,i2b2 base
	where t.xtrial_name = la.c_name
	  and la.c_fullname not like '%Across Trials%'
	  and la.c_visualattributes like 'LA%'
	  and to_char(la.c_comment) = to_char(base.c_comment)
	  and base.c_hlevel = 1
	  and not exists
		 (select 1 from wt_xtrial_nodes x
		  where t.xtrial_cd = x.xtrial_cd
		    and base.c_name = x.trial_name
			and la.c_name = x.leaf_name
			and la.c_basecode = x.concept_cd)
	  and not exists
	      (select 1 from cz_xtrial_exclusion xx
		   where to_char(la.c_comment) = 'trial:' || trial_id);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert leaf data into wt_xtrial_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	Determine if any xtrial_cds have more than one datatype (mix of numeric and text).  If yes, raise exception
	
	select count(*)
	into pCount
	from (select xtrial_cd
		  from wt_xtrial_nodes
		  group by xtrial_cd
		  having count(distinct data_type) > 1);
		 
	if pCount > 0 then
		raise mixed_datatypes;
	end if;

	--	delete Across Trials nodes in i2b2
	--	can't use i2b2_delete_all_nodes because the observation_fact data should not be deleted.  It belongs to the trial
	
	--concept dimension
	delete from concept_dimension
	where concept_path like '\Across Trials\%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete Across Trials from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
	commit;
    
	--i2b2
	delete from i2b2
	where c_fullname like '\Across Trials\%';
	stepCt := stepCt + 1;
	  cz_write_audit(jobId,databaseName,procedureName,'Delete Across Trials from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
	commit;
 
	--	delete patient SECURITY nodes for Across Trials
	
	delete from observation_fact
	where modifier_cd = 'Across Trials'
	  and concept_cd = 'SECURITY';
	stepct := stepct + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete Across Trials SECURITY from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	add top-level Across Trial nodes
	
	i2b2_add_node('Across Trials','\Across Trials\','Across Trials',jobid);
	
	--	create Across Trials i2b2 nodes
	
	insert into i2b2
    (c_hlevel
	,c_fullname
	,c_name
	,c_visualattributes
	,c_synonym_cd
	,c_facttablecolumn
	,c_tablename
	,c_columnname
    ,c_dimcode
	,c_tooltip
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,c_basecode
	,c_operator
	,c_columndatatype
	,c_metadataxml
	,c_comment)
    SELECT (length(leaf_node) - nvl(length(replace(leaf_node, '\')),0)) / length('\') - 2 + root_level 
		  ,leaf_node
		  ,trial_name
		  ,'LA'		--	set to folder for initial insert, will be changed to LA for leaf nodes in later update
		  ,'N'
		  ,'CONCEPT_CD'
		  ,'CONCEPT_DIMENSION'
		  ,'CONCEPT_PATH'
		  ,leaf_node
		  ,leaf_node
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,'Across_Trials'
		  ,concept_cd
		  ,'LIKE'
		  ,data_type
		  ,case when data_type = 'N' 
		        then '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
				else null end
		  ,'trial:Across_Trials'
	from wt_xtrial_nodes;
	
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Add leaf nodes for Across Trials to I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');

	--	Add concept_dimension paths for Across Trials leaf nodes
	
	insert into concept_dimension
    (concept_cd
	,concept_path
	,name_char
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,table_name)
    SELECT distinct concept_cd
		  ,leaf_node
		  ,leaf_name
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,'Across_Trials'
		  ,'CONCEPT_DIMENSION'
    from wt_xtrial_nodes;
	
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Add leaf nodes to I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	add patient SECURITY data to observation fact
	
    insert into i2b2demodata.observation_fact
    (patient_num
	,concept_cd
	,provider_id
	,modifier_cd
	,valtype_cd
	,tval_char
	,valueflag_cd
	,location_cd
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	)
	SELECT distinct pd.patient_num
		  ,'SECURITY'
		  ,'@'
		  ,'Across Trials'
		  ,'T'
		  ,'EXP:PUBLIC'
		  ,'@'
		  ,'@'
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,pd.sourcesystem_cd
	from wt_xtrial_nodes c
		,observation_fact f
		,patient_dimension pd
	WHERE c.concept_cd = f.concept_cd
	  and f.patient_num = pd.patient_num;
	
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Add SECURITY records to I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		  
	--	fill in tree
	
	i2b2_fill_in_tree('Across Trials','\Across Trials\', jobID);
  
	--	create concept counts
	
    i2b2_create_concept_counts('\Across Trials\',jobID );
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create concept counts for Clinical Data',0,stepCt,'Done');

  --Reload Security: Inserts one record for every I2B2 record into the security table

    i2b2_load_security_data(jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');
		
	---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;

	EXCEPTION
	when mixed_datatypes then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Check wt_xtrial_nodes for mixed data_types',0,stepCt,'Done');
		cz_error_handler (jobID, procedureName);
		cz_end_audit (jobID, 'FAIL');
	when no_table_access then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'No record for \Across Trials\ in table_access',0,stepCt,'Done');
		cz_error_handler (jobID, procedureName);
		cz_end_audit (jobID, 'FAIL');	
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		--End Proc
		cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_ANNOTATION_DEAPP
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_ANNOTATION_DEAPP" 
(
currentJobID NUMBER := null
 )
AS

	--	Loads annotation_deapp from external table 
	
	--	JEA@20100322	(JNJ-1789) New
	--	JEA@20100601	Added code to insert to probeset_deapp and update annotation_deapp with probeset_id
	--	JEA@20100624	Added step to refresh deapp.de_mrna_annotation
	--	JEA@20100805	Added distinct to remove dups
	--	JEA@20100901	Use gene_id from biomart.bio_marker to update de_mrna_annotation if gene_id is null
	--	JEA@20100914	Use bio_marker_name from biomart.bio_marker to update de_mrna_annotation if gene_symbol is null
	--	JEA@20110210	Convert gene_id to number when inserting into de_mrna_annotation
	--	JEA@20111103	Only load data if gene_is is not null or gene_symbol is not null
	--	JEA@20111229	Change probeset_deapp to load only new probesets and allow null gene_id and gene_symbol,
	--					added organism
	--	JEA@20120208	Added coalesce to force organism to Homo sapiens if none specified, added to_char to gene_id
	--					when querying bio_marker table
	--	JEA@@0120523	Update organism in probeset_deapp if changed

	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);
	gplId	varchar2(100);

BEGIN

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_annotation_deapp',0,stepCt,'Done');

	--	get GPL id from external table
	
	select distinct gpl_id into gplId from lt_src_deapp_annot;
	
/*	
	--	delete any existing data from probeset_deapp
	
	delete from probeset_deapp
	where platform = gplId;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from REFERENCE probeset_deapp',SQL%ROWCOUNT,stepCt,'Done');
*/
		
	--	delete any existing data from annotation_deapp
	
	delete from annotation_deapp
	where gpl_id = gplId;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from annotation_deapp',SQL%ROWCOUNT,stepCt,'Done');

	--	delete any existing data from deapp.de_mrna_annotation
	
	delete from deapp.de_mrna_annotation
	where gpl_id = gplId;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from de_mrna_annotation',SQL%ROWCOUNT,stepCt,'Done');

	--	update organism for existing probesets in probeset_deapp
	
	update probeset_deapp p
	set organism=(select distinct t.organism from lt_src_deapp_annot t
				  where p.platform = t.gpl_id
				    and p.probeset = t.probe_id)
	where exists
		 (select 1 from lt_src_deapp_annot x
		  where p.platform = x.gpl_id
		    and p.probeset = x.probe_id);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update organism in probeset_deapp',SQL%ROWCOUNT,stepCt,'Done');
			
	--	insert any new probesets into probeset_deapp
	
	insert into probeset_deapp
	(probeset
	,organism
	,platform)
	select distinct probe_id
		  ,coalesce(organism,'Homo sapiens')
	      ,gpl_id
	from lt_src_deapp_annot t
	where not exists
		 (select 1 from probeset_deapp x
		  where t.gpl_id = x.platform
		    and t.probe_id = x.probeset
			and coalesce(t.organism,'Homo sapiens') = coalesce(x.organism,'Homo sapiens'))
	;
	--where gene_id is not null 
	--   or gene_symbol is not null;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert new probesets into probeset_deapp',SQL%ROWCOUNT,stepCt,'Done');
		
	--	insert data into annotation_deapp
	
	insert into annotation_deapp
	(gpl_id
	,probe_id
	,gene_symbol
	,gene_id
	,probeset_id
	,organism)
	select distinct d.gpl_id
	,d.probe_id
	,d.gene_symbol
	,d.gene_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
	from lt_src_deapp_annot d
	,probeset_deapp p
	where d.probe_id = p.probeset
	  and d.gpl_id = p.platform
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens')
	  --and (d.gene_id is not null or d.gene_symbol is not null)
	  ;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into REFERENCE annotation_deapp',SQL%ROWCOUNT,stepCt,'Done');
		
	--	insert data into deapp.de_mrna_annotation
	
	insert into de_mrna_annotation
	(gpl_id
	,probe_id
	,gene_symbol
	,gene_id
	,probeset_id
	,organism)
	select distinct d.gpl_id
	,d.probe_id
	,d.gene_symbol
	,decode(d.gene_id,null,null,to_number(d.gene_id)) as gene_id
	,p.probeset_id
	,coalesce(d.organism,'Homo sapiens')
	from lt_src_deapp_annot d
	,probeset_deapp p
	where d.probe_id = p.probeset
	  and d.gpl_id = p.platform
	  and coalesce(d.organism,'Homo sapiens') = coalesce(p.organism,'Homo sapiens')
	  --and (d.gene_id is not null or d.gene_symbol is not null)
	  ;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Load annotation data into DEAPP de_mrna_annotation',SQL%ROWCOUNT,stepCt,'Done');
		
	--	update gene_id if null
	
	update de_mrna_annotation t
	set gene_id=(select to_number(min(b.primary_external_id)) as gene_id
				 from biomart.bio_marker b
				 where t.gene_symbol = b.bio_marker_name
				   and upper(b.organism) = upper(t.organism)
				   and upper(b.bio_marker_type) = 'GENE')
	where t.gpl_id = gplId
	  and t.gene_id is null
	  and t.gene_symbol is not null
	  and exists
		 (select 1 from biomart.bio_marker x
		  where t.gene_symbol = x.bio_marker_name
			and upper(x.organism) = upper(t.organism)
			and upper(x.bio_marker_type) = 'GENE');
			
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_mrna_annotation',SQL%ROWCOUNT,stepCt,'Done');
	
	--	update gene_symbol if null
	
	update de_mrna_annotation t
	set gene_symbol=(select min(b.bio_marker_name) as gene_symbol
				 from biomart.bio_marker b
				 where to_char(t.gene_id) = b.primary_external_id
				   and upper(b.organism) = upper(t.organism)
				   and upper(b.bio_marker_type) = 'GENE')
	where t.gpl_id = gplId
	  and t.gene_symbol is null
	  and t.gene_id is not null
	  and exists
		 (select 1 from biomart.bio_marker x
		  where to_char(t.gene_id) = x.primary_external_id
			and upper(x.organism) = upper(t.organism)
			and upper(x.bio_marker_type) = 'GENE');
			
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Updated missing gene_id in de_mrna_annotation',SQL%ROWCOUNT,stepCt,'Done');
		
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_annotation_deapp',0,stepCt,'Done');
	
       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

END;


/*

   CREATE SEQUENCE  "TM_CZ"."SEQ_PROBESET_ID"  MINVALUE 249738 MAXVALUE 99999999 INCREMENT BY 1 START WITH 265364 CACHE 20 NOORDER  NOCYCLE ;
   
   
  CREATE TABLE "TM_CZ"."ANNOTATION_DEAPP" 
   (	"GPL_ID" VARCHAR2(100 BYTE), 
	"PROBE_ID" VARCHAR2(100 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" VARCHAR2(100 BYTE), 
	"PROBESET_ID" NUMBER(38,0)
   ) PCTFREE 10  NOLOGGING
  TABLESPACE "TRANSMART" ;
  
  
  CREATE TABLE "TM_CZ"."PROBESET_DEAPP" 
   (	"PROBESET_ID" NUMBER(38,0) NOT NULL ENABLE, 
	"PROBESET" VARCHAR2(100 BYTE) NOT NULL ENABLE, 
	"PLATFORM" VARCHAR2(100 BYTE) NOT NULL ENABLE
   ) PCTFREE 10 NOLOGGING
  TABLESPACE "TRANSMART" ;
 

  CREATE INDEX "TM_CZ"."PROBESET_DEAPP_I1" ON "TM_CZ"."PROBESET_DEAPP" ("PROBESET_ID") 
  PCTFREE 10 NOLOGGING COMPUTE STATISTICS 
  TABLESPACE "INDX" ;
 
  CREATE INDEX "TM_CZ"."PROBESET_DEAPP_I2" ON "TM_CZ"."PROBESET_DEAPP" ("PROBESET", "PLATFORM") 
  PCTFREE 10 NOLOGGING COMPUTE STATISTICS 
  TABLESPACE "INDX" ;
 

  CREATE OR REPLACE TRIGGER "TM_CZ"."TRG_PROBESET_DEAPP" 
before insert on "PROBESET_DEAPP"    
	for each row begin     
		if inserting then       
			if :NEW."PROBESET_ID" is null then
				select SEQ_PROBESET_ID.nextval into :NEW."PROBESET_ID" from dual;       
			end if;   
		end if; 

ALTER TRIGGER "TM_CZ"."TRG_PROBESET_DEAPP" ENABLE;
 

  CREATE TABLE "TM_LZ"."DEAPP_ANNOT_EXTRNL" 
   (	"GPL_ID" VARCHAR2(100 BYTE), 
	"PROBE_ID" VARCHAR2(100 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" VARCHAR2(250 BYTE)
   ) 
   ORGANIZATION EXTERNAL 
    ( TYPE ORACLE_LOADER
      DEFAULT DIRECTORY "DATA"
      ACCESS PARAMETERS
      ( records delimited BY newline nologfile skip 1 fields terminated BY 0X'09' LRTRIM MISSING FIELD VALUES ARE NULL     )
      LOCATION
       ( 'GPL180_p.txt'
       )
    )
  ;
 
 
  CREATE TABLE "TM_LZ"."LT_SRC_DEAPP_ANNOT" 
   (	"GPL_ID" VARCHAR2(100 BYTE), 
	"PROBE_ID" VARCHAR2(100 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"GENE_ID" VARCHAR2(250 BYTE),
	"ORGANISM" VARCHAR2(200)
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 NOLOGGING
  TABLESPACE "TRANSMART" ;

 
  CREATE TABLE "DEAPP"."DE_GPL_INFO" 
   (	"PLATFORM" VARCHAR2(10 BYTE), 
	"TITLE" VARCHAR2(500 BYTE), 
	"ORGANISM" VARCHAR2(100 BYTE), 
	"ANNOTATION_DATE" TIMESTAMP (6)
   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT)
  TABLESPACE "DEAPP" ;
 

  CREATE TABLE "DEAPP"."DE_MRNA_ANNOTATION" 
   (	"GPL_ID" VARCHAR2(100 BYTE), 
	"PROBE_ID" VARCHAR2(100 BYTE), 
	"GENE_SYMBOL" VARCHAR2(100 BYTE), 
	"PROBESET_ID" NUMBER(38,0), 
	"GENE_ID" NUMBER(18,0)
   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS NOLOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT)
  TABLESPACE "DEAPP" ;
 

  CREATE INDEX "DEAPP"."DE_MRNA_ANNOTATION_I2" ON "DEAPP"."DE_MRNA_ANNOTATION" ("GPL_ID", "PROBE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT)
  TABLESPACE "DEAPP" ;
 


 
*/
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_CLINICAL_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_CLINICAL_DATA" 
(
  trial_id             IN    VARCHAR2
 ,top_node            in  varchar2
 ,secure_study        in varchar2 := 'N'
 ,highlight_study    in    varchar2 := 'N'
 ,currentJobID        IN    NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research m, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
  
  topNode        VARCHAR2(2000);
  topLevel        number(10,0);
  root_node        varchar2(2000);
  root_level    int;
  study_name    varchar2(2000);
  TrialID        varchar2(100);
  secureStudy    varchar2(200);
  etlDate        date;
  tPath            varchar2(2000);
  pCount        int;
  pExists        int;
  rtnCode        int;
  tText            varchar2(2000);
  v_bio_experiment_id    number(18,0);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  duplicate_values    exception;
  invalid_topNode    exception;
  multiple_visit_names    exception;
  
  CURSOR addNodes is
  select DISTINCT 
         leaf_node,
             node_name
  from  wt_trial_nodes a
  ;
   
    --    cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

    CURSOR delNodes is
    select distinct c_fullname 
    from  i2b2
    where c_fullname like topNode || '%'
      and substr(c_visualattributes,2,1) = 'H';
      
    --    cursor to determine if any leaf nodes exist in i2b2 that are not used in this reload (node changes from text to numeric or numeric to text)
      
    cursor delUnusedLeaf is
    select l.c_fullname
    from i2b2 l
    where l.c_visualattributes like 'L%'
      and l.c_fullname like topNode || '%'
      and l.c_fullname not in
         (select t.leaf_node 
          from wt_trial_nodes t
          union
          select m.c_fullname
          from de_subject_sample_mapping sm
              ,i2b2 m
          where sm.trial_name = TrialId
            and sm.concept_code = m.c_basecode
            and m.c_visualattributes like 'L%');
BEGIN
  
    TrialID := upper(trial_id);
    secureStudy := upper(secure_study);
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := currentJobID;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;
    
    select sysdate into etlDate from dual;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 0;

    stepCt := stepCt + 1;
    tText := 'Start i2b2_load_clinical_data for ' || TrialId;
    cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
    
    if (secureStudy not in ('Y','N') ) then
        secureStudy := 'Y';
    end if;
    
    topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\');
    
    --    figure out how many nodes (folders) are at study name and above
    --    \Public Studies\Clinical Studies\Pancreatic_Cancer_Smith_GSE22780\: topLevel = 4, so there are 3 nodes
    --    \Public Studies\GSE12345\: topLevel = 3, so there are 2 nodes
    
    select length(topNode)-length(replace(topNode,'\','')) into topLevel from dual;
    
    if topLevel < 3 then
        raise invalid_topNode;
    end if;    

    --    delete any existing data from lz_src_clinical_data and load new data
    
    delete from lz_src_clinical_data
    where study_id = TrialId;
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from lz_src_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    insert into lz_src_clinical_data
    (study_id
    ,site_id
    ,subject_id
    ,visit_name
    ,data_label
    ,data_value
    ,category_cd
    ,etl_job_id
    ,etl_date
    ,ctrl_vocab_code)
    select study_id
          ,site_id
          ,subject_id
          ,visit_name
          ,data_label
          ,data_value
          ,category_cd
          ,jobId
          ,etlDate
          ,ctrl_vocab_code
    from lt_src_clinical_data;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert data into lz_src_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
    commit;
        
    --    truncate wrk_clinical_data and load data from external file
    
    execute immediate('truncate table tm_wz.wrk_clinical_data');
    
    --    insert data from lt_src_clinical_data to wrk_clinical_data
    
    insert into wrk_clinical_data
    (study_id
    ,site_id
    ,subject_id
    ,visit_name
    ,data_label
    ,data_value
    ,category_cd
    ,ctrl_vocab_code
    )
    select study_id
          ,site_id
          ,subject_id
          ,visit_name
          ,data_label
          ,data_value
          ,category_cd
          ,ctrl_vocab_code
    from lt_src_clinical_data;
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Load lt_src_clinical_data to work table',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;      

    -- Get study name from topNode
  
    select parse_nth_value(topNode, topLevel, '\') into study_name from dual;    
    
    --    Replace all underscores with spaces in topNode except those in study name

    topNode := replace(replace(topNode,'\'||study_name||'\',null),'_',' ') || '\' || study_name || '\';
    
    -- Get root_node from topNode
  
    select parse_nth_value(topNode, 2, '\') into root_node from dual;
    
    select count(*) into pExists
    from table_access
    where c_name = root_node;
    
    select count(*) into pCount
    from i2b2
    where c_name = root_node;
    
    if pExists = 0 or pCount = 0 then
        i2b2_add_root_node(root_node, jobId);
    end if;
    
    select c_hlevel into root_level
    from table_access
    where c_name = root_node;
    
    --    Add any upper level nodes as needed
    
    tPath := REGEXP_REPLACE(replace(top_node,study_name,null),'(\\){2,}', '\');
    select length(tPath) - length(replace(tPath,'\',null)) into pCount from dual;

    if pCount > 2 then
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Adding upper-level nodes',0,stepCt,'Done');
        i2b2_fill_in_tree(null, tPath, jobId);
    end if;
    
/*    Don't delete existing data, concept_cds will be reused
    --    delete any existing data
    
    i2b2_delete_all_nodes(topNode, jobId);
*/

    select count(*) into pExists
    from i2b2
    where c_fullname = topNode;
    
    --    add top node for study
    
    if pExists = 0 then
        i2b2_add_node(TrialId, topNode, study_name, jobId);
    end if;
  
    --    Set data_type, category_path, and usubjid 
  
    update wrk_clinical_data
    set data_type = 'T'
       ,category_path = replace(replace(category_cd,'_',' '),'+','\')
      -- ,usubjid = TrialID || ':' || site_id || ':' || subject_id;
       ,usubjid = REGEXP_REPLACE(TrialID || ':' || site_id || ':' || subject_id,
                   '(::){1,}', ':'); 
     
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set columns in wrk_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;
  
    --    Delete rows where data_value is null
  
    delete from wrk_clinical_data
    where data_value is null;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete null data_values in wrk_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
    
    --Remove Invalid pipes in the data values.
    --RULE: If Pipe is last or first, delete it
    --If it is in the middle replace with a dash

    update wrk_clinical_data
    set data_value = replace(trim('|' from data_value), '|', '-')
    where data_value like '%|%';
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Remove pipes in data_value',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;  
  
    --Remove invalid Parens in the data
    --They have appeared as empty pairs or only single ones.
  
    update wrk_clinical_data
    set data_value = replace(data_value,'(', '')
    where data_value like '%()%'
       or data_value like '%( )%'
       or (data_value like '%(%' and data_value NOT like '%)%');
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 1',SQL%ROWCOUNT,stepCt,'Done');
    
    update wrk_clinical_data
    set data_value = replace(data_value,')', '')
    where data_value like '%()%'
       or data_value like '%( )%'
       or (data_value like '%)%' and data_value NOT like '%(%');
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 2',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

    --Replace the Pipes with Commas in the data_label column
    update wrk_clinical_data
    set data_label = replace (data_label, '|', ',')
    where data_label like '%|%';
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Replace pipes with comma in data_label',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

    --    set visit_name to null when there's only a single visit_name for the catgory
    
    update wrk_clinical_data tpm
    set visit_name=null
    where (tpm.category_cd) in
          (select x.category_cd
           from wrk_clinical_data x
           group by x.category_cd
           having count(distinct upper(x.visit_name)) = 1);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set single visit_name to null',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;
    
    --    set data_label to null when it duplicates the last part of the category_path
    --    Remove data_label from last part of category_path when they are the same
    
    update wrk_clinical_data tpm
    --set data_label = null
    set category_path=substr(tpm.category_path,1,instr(tpm.category_path,'\',-2)-1)
       ,category_cd=substr(tpm.category_cd,1,instr(tpm.category_cd,'+',-2)-1)
    where (tpm.category_cd, tpm.data_label) in
          (select distinct t.category_cd
                 ,t.data_label
           from wrk_clinical_data t
           where upper(substr(t.category_path,instr(t.category_path,'\',-1)+1,length(t.category_path)-instr(t.category_path,'\',-1))) 
                 = upper(t.data_label)
             and t.data_label is not null)
      and tpm.data_label is not null;

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set data_label to null when found in category_path',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;

    --    set visit_name to null if same as data_label
    
    update wrk_clinical_data t
    set visit_name=null
    where (t.category_cd, t.visit_name, t.data_label) in
          (select distinct tpm.category_cd
                 ,tpm.visit_name
                 ,tpm.data_label
          from wrk_clinical_data tpm
          where tpm.visit_name = tpm.data_label);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_label',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;
    
    --    set visit_name to null if same as data_value
    
    update wrk_clinical_data t
    set visit_name=null
    where (t.category_cd, t.visit_name, t.data_value) in
          (select distinct tpm.category_cd
                 ,tpm.visit_name
                 ,tpm.data_value
          from wrk_clinical_data tpm
          where tpm.visit_name = tpm.data_value);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_value',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;
    
    --    set visit_name to null if only DATALABEL in category_cd
    
    update wrk_clinical_data t
    set visit_name=null
    where t.category_cd like '%DATALABEL%'
      and t.category_cd not like '%VISITNAME%';

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when only DATALABE in category_cd',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;

/*    --    Remove sample_type if found in category_path
    
    update wrk_clinical_data t
    set sample_type = null
    where exists
         (select 1 from wrk_clinical_data c
          where instr(c.category_path,t.sample_type) > 0);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Remove sample_type if already in category_path',SQL%ROWCOUNT,stepCt,'Done');
    commit;
*/
    --    comment out may need later
    
    --    change any % to Pct and & and + to ' and ' and _ to space in data_label only
    
    update wrk_clinical_data
    set data_label=replace(replace(replace(replace(data_label,'%',' Pct'),'&',' and '),'+',' and '),'_',' ')
       ,data_value=replace(replace(replace(data_value,'%',' Pct'),'&',' and '),'+',' and ')
       ,category_cd=replace(replace(category_cd,'%',' Pct'),'&',' and ')
       ,category_path=replace(replace(category_path,'%',' Pct'),'&',' and ');

  --Trim trailing and leadling spaces as well as remove any double spaces, remove space from before comma, remove trailing comma

    update wrk_clinical_data
    set data_label  = trim(trailing ',' from trim(replace(replace(data_label,'  ', ' '),' ,',','))),
        data_value  = trim(trailing ',' from trim(replace(replace(data_value,'  ', ' '),' ,',','))),
--        sample_type = trim(trailing ',' from trim(replace(replace(sample_type,'  ', ' '),' ,',','))),
        visit_name  = trim(trailing ',' from trim(replace(replace(visit_name,'  ', ' '),' ,',',')));
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Remove leading, trailing, double spaces',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

-- determine numeric data types

    execute immediate('truncate table tm_wz.wt_num_data_types');
  
    insert into wt_num_data_types
    (category_cd
    ,data_label
    ,visit_name
    )
    select category_cd,
           data_label,
           visit_name
    from wrk_clinical_data
    where data_value is not null
    group by category_cd
            ,data_label
            ,visit_name
      having sum(is_number(data_value)) = 0;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert numeric data into WZ wt_num_data_types',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

    --    Check if any duplicate records of key columns (site_id, subject_id, visit_name, data_label, category_cd) for numeric data
    --    exist.  Raise error if yes
    
    execute immediate('truncate table tm_wz.wt_clinical_data_dups');
    
    insert into wt_clinical_data_dups
    (site_id
    ,subject_id
    ,visit_name
    ,data_label
    ,category_cd)
    select w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
    from wrk_clinical_data w
    where exists
         (select 1 from wt_num_data_types t
         where coalesce(w.category_cd,'@') = coalesce(t.category_cd,'@')
           and coalesce(w.data_label,'@') = coalesce(t.data_label,'@')
           and coalesce(w.visit_name,'@') = coalesce(t.visit_name,'@')
          )
    group by w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
    having count(*) > 1;
          
    pCount := SQL%ROWCOUNT;
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Check for duplicate key columns',pCount,stepCt,'Done');
              
    if pCount > 0 then
        raise duplicate_values;
    end if;
    
    --    check for multiple visit_names for category_cd, data_label, data_value
    
     select max(case when x.null_ct > 0 and x.non_null_ct > 0
                     then 1 else 0 end) into pCount
      from (select category_cd, data_label, data_value
                  ,sum(decode(visit_name,null,1,0)) as null_ct
                  ,sum(decode(visit_name,null,0,1)) as non_null_ct
            from lt_src_clinical_data
            where (category_cd like '%VISITNAME%' or
                   category_cd not like '%DATALABEL%')
            group by category_cd, data_label, data_value) x;
  
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Check for multiple visit_names for category/label/value ',pCount,stepCt,'Done');
              
    if pCount > 0 then
        raise multiple_visit_names;
    end if;
        
    update wrk_clinical_data t
    set data_type='N'
    where exists
         (select 1 from wt_num_data_types x
          where nvl(t.category_cd,'@') = nvl(x.category_cd,'@')
            and nvl(t.data_label,'**NULL**') = nvl(x.data_label,'**NULL**')
            and nvl(t.visit_name,'**NULL**') = nvl(x.visit_name,'**NULL**')
          );
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Updated data_type flag for numeric data_types',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

    -- Build all needed leaf nodes in one pass for both numeric and text nodes
 
    execute immediate('truncate table tm_wz.wt_trial_nodes');
    
    insert into wt_trial_nodes
    (leaf_node
    ,category_cd
    ,visit_name
    ,data_label
    --,node_name
    ,data_value
    ,data_type
    )
    select DISTINCT 
    Case 
    --    Text data_type (default node)
    When a.data_type = 'T'
         then case when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
              then regexp_replace(topNode || replace(replace(a.category_path,'DATALABEL',a.data_label),'VISITNAME',a.visit_name) || '\' || a.data_value || '\','(\\){2,}', '\')
              when a.category_path like '%DATALABEL%'
              then regexp_replace(topNode || replace(a.category_path,'DATALABEL',a.data_label) || '\' || a.data_value || '\','(\\){2,}', '\')
              else REGEXP_REPLACE(topNode || a.category_path || 
                   '\'  || a.data_label || '\'|| a.visit_name || '\' || a.data_value || '\' ,
                   '(\\){2,}', '\') 
              end
    --    else is numeric data_type and default_node
    else case when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
              then regexp_replace(topNode || replace(replace(a.category_path,'DATALABEL',a.data_label),'VISITNAME',a.visit_name) || '\','(\\){2,}', '\')
              when a.category_path like '%DATALABEL%'
              then regexp_replace(topNode || replace(a.category_path,'DATALABEL',a.data_label) || '\','(\\){2,}', '\')
              else REGEXP_REPLACE(topNode || a.category_path || 
                   '\'  || a.data_label || '\' || a.visit_name || '\',
                   '(\\){2,}', '\')
              end
    end as leaf_node,
    a.category_cd,
    a.visit_name,
    a.data_label,
    decode(a.data_type,'T',a.data_value,null) as data_value
    ,a.data_type
    from  wrk_clinical_data a;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes for trial',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    set node_name
    
    update wt_trial_nodes
    set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\',null)),'\');
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Updated node name for leaf nodes',SQL%ROWCOUNT,stepCt,'Done');
    commit;    
    
    -- execute immediate('analyze table tm_wz.wt_trial_nodes compute statistics');
    
    --    insert subjects into patient_dimension if needed
    
    execute immediate('truncate table tmp_subject_info');

    insert into tmp_subject_info
    (usubjid,
     age_in_years_num,
     sex_cd,
     race_cd
    )
    select a.usubjid,
          nvl(max(case when upper(a.data_label) = 'AGE'
                       then case when is_number(a.data_value) = 1 then 0 else to_number(a.data_value) end
                       when upper(a.data_label) like '%(AGE)' 
                       then case when is_number(a.data_value) = 1 then 0 else to_number(a.data_value) end
                       else null end),0) as age,
          --nvl(max(decode(upper(a.data_label),'AGE',data_value,null)),0) as age,
          nvl(max(case when upper(a.data_label) = 'SEX' then a.data_value
                   when upper(a.data_label) like '%(SEX)' then a.data_value
                   when upper(a.data_label) = 'GENDER' then a.data_value
                   else null end),'Unknown') as sex,
          --max(decode(upper(a.data_label),'SEX',data_value,'GENDER',data_value,null)) as sex,
          max(case when upper(a.data_label) = 'RACE' then a.data_value
                   when upper(a.data_label) like '%(RACE)' then a.data_value
                   else null end) as race
          --max(decode(upper(a.data_label),'RACE',data_value,null)) as race
    from wrk_clinical_data a
    --where upper(a.data_label) in ('AGE','RACE','SEX','GENDER')
    group by a.usubjid;
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert subject information into temp table',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;
    
    --    Delete dropped subjects from patient_dimension if they do not exist in de_subject_sample_mapping
    
    delete patient_dimension
    where sourcesystem_cd in
         (select distinct pd.sourcesystem_cd from patient_dimension pd
          where pd.sourcesystem_cd like TrialId || ':%'
          minus 
          select distinct cd.usubjid from wrk_clinical_data cd)
      and patient_num not in
          (select distinct sm.patient_id from de_subject_sample_mapping sm);
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete dropped subjects from patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;    
    
    --    update patients with changed information
    
    update patient_dimension pd
    set (sex_cd, age_in_years_num, race_cd, update_date) = 
        (select nvl(t.sex_cd,pd.sex_cd), t.age_in_years_num, nvl(t.race_cd,pd.race_cd), sysdate
         from tmp_subject_info t
         where t.usubjid = pd.sourcesystem_cd
           and (coalesce(pd.sex_cd,'@') != t.sex_cd or
                pd.age_in_years_num != t.age_in_years_num or
                coalesce(pd.race_cd,'@') != t.race_cd)
        )
    where exists
         (select 1 from tmp_subject_info x
          where pd.sourcesystem_cd = x.usubjid
            and (coalesce(pd.sex_cd,'@') != x.sex_cd or
                 pd.age_in_years_num != x.age_in_years_num or
                 coalesce(pd.race_cd,'@') != x.race_cd)
         );
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Update subjects with changed demographics in patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;    

    --    insert new subjects into patient_dimension
    
    insert into patient_dimension
    (patient_num,
     sex_cd,
     age_in_years_num,
     race_cd,
     update_date,
     download_date,
     import_date,
     sourcesystem_cd
    )
    select seq_patient_num.nextval,
           t.sex_cd,
           t.age_in_years_num,
           t.race_cd,
           sysdate,
           sysdate,
           sysdate,
           t.usubjid
    from tmp_subject_info t
    where t.usubjid in 
         (select distinct cd.usubjid from tmp_subject_info cd
          minus
          select distinct pd.sourcesystem_cd from patient_dimension pd
          where pd.sourcesystem_cd like TrialId || '%');
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert new subjects into patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;
        
    --    delete leaf nodes that will not be reused, if any
    
     FOR r_delUnusedLeaf in delUnusedLeaf Loop

    --    deletes unused leaf nodes for a trial one at a time

        i2b2_delete_1_node(r_delUnusedLeaf.c_fullname);
        stepCt := stepCt + 1;    
        cz_write_audit(jobId,databaseName,procedureName,'Deleted unused node: ' || r_delUnusedLeaf.c_fullname,SQL%ROWCOUNT,stepCt,'Done');

    END LOOP;    
    
    --    bulk insert leaf nodes
    
    update concept_dimension cd
    set name_char=(select t.node_name from wt_trial_nodes t
                   where cd.concept_path = t.leaf_node
                     and cd.name_char != t.node_name)
    where exists (select 1 from wt_trial_nodes x
                  where cd.concept_path = x.leaf_node
                    and cd.name_char != x.node_name);
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Update name_char in concept_dimension for changed names',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;
                            
    
    insert into concept_dimension
    (concept_cd
    ,concept_path
    ,name_char
    ,update_date
    ,download_date
    ,import_date
    ,sourcesystem_cd
    ,table_name
    )
    select concept_id.nextval
         ,x.leaf_node
         ,x.node_name
         ,sysdate
         ,sysdate
         ,sysdate
         ,TrialId
         ,'CONCEPT_DIMENSION'
    from (select distinct c.leaf_node
                ,to_char(c.node_name) as node_name
          from wt_trial_nodes c
          where not exists
            (select 1 from concept_dimension x
            where c.leaf_node = x.concept_path)
         ) x;
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted new leaf nodes into I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    update i2b2 to pick up change in name, data_type for leaf nodes
    
    update i2b2 b
    set (c_name, c_columndatatype, c_metadataxml)=
        (select t.node_name, t.data_type
         ,case when t.data_type = 'T'
               then null
               else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
          end
         from wt_trial_nodes t
         where b.c_fullname = t.leaf_node
           and (b.c_name != t.node_name or b.c_columndatatype != t.data_type))
    where exists
        (select 1 from wt_trial_nodes x
         where b.c_fullname = x.leaf_node
           and (b.c_name != x.node_name or b.c_columndatatype != x.data_type));
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Updated name and data type in i2b2 if changed',SQL%ROWCOUNT,stepCt,'Done');
    commit;
               
    insert into i2b2
    (c_hlevel
    ,c_fullname
    ,c_name
    ,c_visualattributes
    ,c_synonym_cd
    ,c_facttablecolumn
    ,c_tablename
    ,c_columnname
    ,c_dimcode
    ,c_tooltip
    ,update_date
    ,download_date
    ,import_date
    ,sourcesystem_cd
    ,c_basecode
    ,c_operator
    ,c_columndatatype
    ,c_comment
    ,i2b2_id
    ,c_metadataxml
    )
    select (length(c.concept_path) - nvl(length(replace(c.concept_path, '\')),0)) / length('\') - 2 + root_level
          ,c.concept_path
          ,c.name_char
          ,'LA'
          ,'N'
          ,'CONCEPT_CD'
          ,'CONCEPT_DIMENSION'
          ,'CONCEPT_PATH'
          ,c.concept_path
          ,c.concept_path
          ,sysdate
          ,sysdate
          ,sysdate
          ,c.sourcesystem_cd
          ,c.concept_cd
          ,'LIKE'
          ,'T'        -- if i2b2 gets fixed to respect c_columndatatype then change to t.data_type
          ,'trial:' || TrialID 
          ,i2b2_id_seq.nextval
          ,case when t.data_type = 'T' then null
           else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
           end
    from concept_dimension c
        ,wt_trial_nodes t
    where c.concept_path = t.leaf_node
      and not exists
         (select 1 from i2b2 x
          where c.concept_path = x.c_fullname);
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted leaf nodes into I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

    --    delete from observation_fact all concept_cds for trial that are clinical data, exclude concept_cds from biomarker data
    
    delete from observation_fact f
    where (f.modifier_cd = TrialId or f.sourcesystem_cd = TrialId)
      and f.concept_cd not in
         (select distinct concept_code as concept_cd from de_subject_sample_mapping
          where trial_name = TrialId
            and concept_code is not null
          union
          select distinct platform_cd as concept_cd from de_subject_sample_mapping
          where trial_name = TrialId
            and platform_cd is not null
          union
          select distinct sample_type_cd as concept_cd from de_subject_sample_mapping
          where trial_name = TrialId
            and sample_type_cd is not null
          union
          select distinct tissue_type_cd as concept_cd from de_subject_sample_mapping
          where trial_name = TrialId
            and tissue_type_cd is not null
          union
          select distinct timepoint_cd as concept_cd from de_subject_sample_mapping
          where trial_name = TrialId
            and timepoint_cd is not null
          union
          select distinct concept_cd as concept_cd from de_subject_snp_dataset
          where trial_name = TrialId
            and concept_cd is not null);
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete clinical data for study from observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;          
    
    --Insert into observation_fact
    
    insert into observation_fact
    (patient_num,
     concept_cd,
     modifier_cd,
     valtype_cd,
     tval_char,
     nval_num,
     sourcesystem_cd,
     import_date,
     valueflag_cd,
     provider_id,
     location_cd
    )
    select distinct c.patient_num,
           i.c_basecode,
           '@',
           a.data_type,
           case when a.data_type = 'T' then a.data_value
                else 'E'  --Stands for Equals for numeric types
                end,
           case when a.data_type = 'N' then a.data_value
                else null --Null for text types
                end,
           TrialId, 
          sysdate, 
           '@',
           '@',
           '@'
    from wrk_clinical_data a
        ,patient_dimension c
        ,wt_trial_nodes t
        ,i2b2 i
    where a.usubjid = c.sourcesystem_cd
      and nvl(a.category_cd,'@') = nvl(t.category_cd,'@')
      and nvl(a.data_label,'**NULL**') = nvl(t.data_label,'**NULL**')
      and nvl(a.visit_name,'**NULL**') = nvl(t.visit_name,'**NULL**')
      and decode(a.data_type,'T',a.data_value,'**NULL**') = nvl(t.data_value,'**NULL**')
      and t.leaf_node = i.c_fullname
      and not exists        -- don't insert if lower level node exists
         (select 1 from wt_trial_nodes x
          where x.leaf_node like t.leaf_node || '%_')
      and a.data_value is not null;  
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

    --    update c_visualattributes for all nodes in study, done to pick up node that changed from leaf/numeric to folder/text
    
    update i2b2 a
    set c_visualattributes=(
        with upd as (select p.c_fullname, count(*) as nbr_children 
                 from i2b2 p
                     ,i2b2 c
                 where p.c_fullname like topNode || '%'
                   and c.c_fullname like p.c_fullname || '%'
                 group by p.c_fullname)
        select case when u.nbr_children = 1 
                    then 'L' || substr(a.c_visualattributes,2,2)
                    else 'F' || substr(a.c_visualattributes,2,1) ||
                         case when u.c_fullname = topNode -- and highlight_study = 'Y'
							  then 'S' else substr(a.c_visualattributes,3,1) end
               end
        from upd u
        where a.c_fullname = u.c_fullname)
    where a.c_fullname in
        (select x.c_fullname from i2b2 x
         where x.c_fullname like topNode || '%');

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Update c_visualattributes for study',SQL%ROWCOUNT,stepCt,'Done');

    commit;
    
    -- final procs
  
    i2b2_fill_in_tree(TrialId, topNode, jobID);
    
    --    set sourcesystem_cd, c_comment to null if any added upper-level nodes
        
    update i2b2 b
    set sourcesystem_cd=null,c_comment=null
    where b.sourcesystem_cd = TrialId
      and length(b.c_fullname) < length(topNode);
      
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper-level nodes',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    i2b2_create_concept_counts(topNode, jobID);
    
    --    delete each node that is hidden after create concept counts
    
     FOR r_delNodes in delNodes Loop

    --    deletes hidden nodes for a trial one at a time

        i2b2_delete_1_node(r_delNodes.c_fullname);
        stepCt := stepCt + 1;
        tText := 'Deleted node: ' || r_delNodes.c_fullname;
        
        cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');

    END LOOP; 

	--	create entries to support FMAPP
	
	select count(*) into pExists
	from biomart.bio_experiment
	where accession = TrialId;
	
	if pExists = 0 then
		--	insert placeholder for study in bio_experiment
		insert into biomart.bio_experiment
		(title, accession, etl_id, bio_experiment_type)
		select study_name
			  ,TrialId
			  ,'METADATA:' || TrialId
			  ,'i2b2'
		from dual;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
		commit;
	end if;
	
	select bio_experiment_id into v_bio_experiment_id
	from biomart.bio_experiment
	where accession = TrialId;
	
	--	insert study into biomart.bio_data_uid
	
	insert into biomart.bio_data_uid
	(bio_data_id
	,unique_id 
	,bio_data_type
	)
	select v_bio_experiment_id
		  ,'EXP:' || TrialId
		  ,'Experiment'
	from dual
	where not exists
		 (select 1 from biomart.bio_data_uid x
		  where x.bio_data_id = v_bio_experiment_id);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_data_uid',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	insert study into fmapp.fm_folder
	
	insert into fmapp.fm_folder
	(folder_name 
	,folder_level      
	,folder_type
	,active_ind
	)
	select TrialId
		  ,1
		  ,'STUDY'
		  ,'1'
	from dual
	where not exists
		  (select 1 from fmapp.fm_folder x
		   where x.folder_name = TrialId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into fmapp.fm_folder',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert fm_folder_association
	
	insert into fmapp.fm_folder_association
	(folder_id
	,object_uid
	,object_type
	)
	select ff.folder_id
		  ,'EXP:' || TrialId
		  ,'bio.Experiment'
	from fmapp.fm_folder ff
	where folder_name = TrialId
	  and not exists
	     (select 1 from fmapp.fm_folder_association x
		  where ff.folder_id = x.folder_id);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into fmapp.fm_folder_asociation',SQL%ROWCOUNT,stepCt,'Done');
	commit;	  	
    
    i2b2_create_security_for_trial(TrialId, secureStudy, jobID);
    i2b2_load_security_data(jobID);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_clinical_data',0,stepCt,'Done');
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
    if newJobFlag = 1
    then
        cz_end_audit (jobID, 'SUCCESS');
    end if;

    rtnCode := 0;
  
    exception
    when duplicate_values then
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Duplicate values found in key columns',0,stepCt,'Done');    
        cz_error_handler (jobID, procedureName);
        cz_end_audit (jobID, 'FAIL');
        rtnCode := 16;        
    when invalid_topNode then
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Path specified in top_node must contain at least 2 nodes',0,stepCt,'Done');    
        cz_error_handler (jobID, procedureName);
        cz_end_audit (jobID, 'FAIL');
        rtnCode := 16;    
    when multiple_visit_names then
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Multiple visit_names exist for category/label/value',0,stepCt,'Done');    
        cz_error_handler (jobID, procedureName);
        cz_end_audit (jobID, 'FAIL');
        rtnCode := 16;
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
        rtnCode := 16;
    
end;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_CLINICAL_DATA_HZ
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_CLINICAL_DATA_HZ" 
(
  trial_id 			IN	VARCHAR2
 ,top_node			in  varchar2
 ,secure_study		in varchar2 := 'N'
 ,highlight_study	in	varchar2 := 'N'
 ,currentJobID		IN	NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research m, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
  
  topNode		VARCHAR2(2000);
  topLevel		number(10,0);
  root_node		varchar2(2000);
  root_level	int;
  study_name	varchar2(2000);
  TrialID		varchar2(100);
  secureStudy	varchar2(200);
  etlDate		date;
  tPath			varchar2(2000);
  pCount		int;
  pExists		int;
  rtnCode		int;
  tText			varchar2(2000);
  v_bio_experiment_id	number(18,0);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  duplicate_values	exception;
  invalid_topNode	exception;
  multiple_visit_names	exception;
  
  CURSOR addNodes is
  select DISTINCT 
         leaf_node,
    		 node_name
  from  wt_trial_nodes a
  ;
   
	--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

	CURSOR delNodes is
	select distinct c_fullname 
	from  i2b2
	where c_fullname like topNode || '%'
      and substr(c_visualattributes,2,1) = 'H';
	  
	--	cursor to determine if any leaf nodes exist in i2b2 that are not used in this reload (node changes from text to numeric or numeric to text)
	  
	cursor delUnusedLeaf is
	select l.c_fullname
	from i2b2 l
	where l.c_visualattributes like 'L%'
	  and l.c_fullname like topNode || '%'
	  and l.c_fullname not in
		 (select t.leaf_node 
		  from wt_trial_nodes t
		  union
		  select m.c_fullname
		  from de_subject_sample_mapping sm
			  ,i2b2 m
		  where sm.trial_name = TrialId
		    and sm.concept_code = m.c_basecode
			and m.c_visualattributes like 'L%');
BEGIN
  
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;
	
	select sysdate into etlDate from dual;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
    	
	stepCt := 0;

	stepCt := stepCt + 1;
	tText := 'Start i2b2_load_clinical_data for ' || TrialId;
	cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\');
	
	--	figure out how many nodes (folders) are at study name and above
	--	\Public Studies\Clinical Studies\Pancreatic_Cancer_Smith_GSE22780\: topLevel = 4, so there are 3 nodes
	--	\Public Studies\GSE12345\: topLevel = 3, so there are 2 nodes
	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel from dual;
	
	if topLevel < 3 then
		raise invalid_topNode;
	end if;	

	--	delete any existing data from lz_src_clinical_data and load new data
	
	delete from lz_src_clinical_data
	where study_id = TrialId;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from lz_src_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	insert into lz_src_clinical_data
	(study_id
	,site_id
	,subject_id
	,visit_name
	,data_label
	,data_value
	,category_cd
	,etl_job_id
	,etl_date
	,ctrl_vocab_code)
	select study_id
		  ,site_id
		  ,subject_id
		  ,visit_name
		  ,data_label
		  ,data_value
		  ,category_cd
		  ,jobId
		  ,etlDate
		  ,ctrl_vocab_code
	from lt_src_clinical_data;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data into lz_src_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		
	--	truncate wrk_clinical_data and load data from external file
	
	execute immediate('truncate table tm_wz.wrk_clinical_data');
	
	--	insert data from lt_src_clinical_data to wrk_clinical_data
	
	insert into wrk_clinical_data
	(study_id
	,site_id
	,subject_id
	,visit_name
	,data_label
	,data_value
	,category_cd
	,ctrl_vocab_code
	)
	select study_id
		  ,site_id
		  ,subject_id
		  ,visit_name
		  ,data_label
		  ,data_value
		  ,category_cd
		  ,ctrl_vocab_code
	from lt_src_clinical_data;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Load lt_src_clinical_data to work table',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;  	

	-- Get study name from topNode
  
	select parse_nth_value(topNode, topLevel, '\') into study_name from dual;	
	
	--	Replace all underscores with spaces in topNode except those in study name

	topNode := replace(replace(topNode,'\'||study_name||'\',null),'_',' ') || '\' || study_name || '\';
	
	-- Get root_node from topNode
  
	select parse_nth_value(topNode, 2, '\') into root_node from dual;
	
	select count(*) into pExists
	from table_access
	where c_name = root_node;
	
	select count(*) into pCount
	from i2b2
	where c_name = root_node;
	
	if pExists = 0 or pCount = 0 then
		i2b2_add_root_node(root_node, jobId);
	end if;
	
	select c_hlevel into root_level
	from table_access
	where c_name = root_node;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,null),'(\\){2,}', '\');
	select length(tPath) - length(replace(tPath,'\',null)) into pCount from dual;

	if pCount > 2 then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Adding upper-level nodes',0,stepCt,'Done');
		i2b2_fill_in_tree(null, tPath, jobId);
	end if;
	
/*	Don't delete existing data, concept_cds will be reused
	--	delete any existing data
	
	i2b2_delete_all_nodes(topNode, jobId);
*/

	select count(*) into pExists
	from i2b2
	where c_fullname = topNode;
	
	--	add top node for study
	
	if pExists = 0 then
		i2b2_add_node(TrialId, topNode, study_name, jobId);
	end if;
  
	--	Set data_type, category_path, and usubjid 
  
	update wrk_clinical_data
	set data_type = 'T'
	   ,category_path = replace(replace(category_cd,'_',' '),'+','\')
	  -- ,usubjid = TrialID || ':' || site_id || ':' || subject_id;
	   ,usubjid = REGEXP_REPLACE(TrialID || ':' || site_id || ':' || subject_id,
                   '(::){1,}', ':'); 
	 
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Set columns in wrk_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
  
	--	Delete rows where data_value is null
  
	delete from wrk_clinical_data
	where data_value is null;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete null data_values in wrk_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
	
	--Remove Invalid pipes in the data values.
	--RULE: If Pipe is last or first, delete it
	--If it is in the middle replace with a dash

	update wrk_clinical_data
	set data_value = replace(trim('|' from data_value), '|', '-')
	where data_value like '%|%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Remove pipes in data_value',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;  
  
	--Remove invalid Parens in the data
	--They have appeared as empty pairs or only single ones.
  
	update wrk_clinical_data
	set data_value = replace(data_value,'(', '')
	where data_value like '%()%'
	   or data_value like '%( )%'
	   or (data_value like '%(%' and data_value NOT like '%)%');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 1',SQL%ROWCOUNT,stepCt,'Done');
	
	update wrk_clinical_data
	set data_value = replace(data_value,')', '')
	where data_value like '%()%'
	   or data_value like '%( )%'
	   or (data_value like '%)%' and data_value NOT like '%(%');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 2',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	--Replace the Pipes with Commas in the data_label column
	update wrk_clinical_data
    set data_label = replace (data_label, '|', ',')
    where data_label like '%|%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Replace pipes with comma in data_label',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	--	set visit_name to null when there's only a single visit_name for the catgory
	
	update wrk_clinical_data tpm
	set visit_name=null
	where (tpm.category_cd) in
		  (select x.category_cd
		   from wrk_clinical_data x
		   group by x.category_cd
		   having count(distinct upper(x.visit_name)) = 1);

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Set single visit_name to null',SQL%ROWCOUNT,stepCt,'Done');
		
	commit;
	
	--	set data_label to null when it duplicates the last part of the category_path
	--	Remove data_label from last part of category_path when they are the same
	
	update wrk_clinical_data tpm
	--set data_label = null
	set category_path=substr(tpm.category_path,1,instr(tpm.category_path,'\',-2)-1)
	   ,category_cd=substr(tpm.category_cd,1,instr(tpm.category_cd,'+',-2)-1)
	where (tpm.category_cd, tpm.data_label) in
		  (select distinct t.category_cd
				 ,t.data_label
		   from wrk_clinical_data t
		   where upper(substr(t.category_path,instr(t.category_path,'\',-1)+1,length(t.category_path)-instr(t.category_path,'\',-1))) 
			     = upper(t.data_label)
		     and t.data_label is not null)
	  and tpm.data_label is not null;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Set data_label to null when found in category_path',SQL%ROWCOUNT,stepCt,'Done');
		
	commit;

	--	set visit_name to null if same as data_label
	
	update wrk_clinical_data t
	set visit_name=null
	where (t.category_cd, t.visit_name, t.data_label) in
	      (select distinct tpm.category_cd
				 ,tpm.visit_name
				 ,tpm.data_label
		  from wrk_clinical_data tpm
		  where tpm.visit_name = tpm.data_label);

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_label',SQL%ROWCOUNT,stepCt,'Done');
		
	commit;
	
	--	set visit_name to null if same as data_value
	
	update wrk_clinical_data t
	set visit_name=null
	where (t.category_cd, t.visit_name, t.data_value) in
	      (select distinct tpm.category_cd
				 ,tpm.visit_name
				 ,tpm.data_value
		  from wrk_clinical_data tpm
		  where tpm.visit_name = tpm.data_value);

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_value',SQL%ROWCOUNT,stepCt,'Done');
		
	commit;
	
	--	set visit_name to null if only DATALABEL in category_cd
	
	update wrk_clinical_data t
	set visit_name=null
	where t.category_cd like '%DATALABEL%'
	  and t.category_cd not like '%VISITNAME%';

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when only DATALABE in category_cd',SQL%ROWCOUNT,stepCt,'Done');
		
	commit;

/*	--	Remove sample_type if found in category_path
	
	update wrk_clinical_data t
	set sample_type = null
	where exists
	     (select 1 from wrk_clinical_data c
		  where instr(c.category_path,t.sample_type) > 0);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Remove sample_type if already in category_path',SQL%ROWCOUNT,stepCt,'Done');
	commit;
*/
	--	comment out may need later
	
	--	change any % to Pct and & and + to ' and ' and _ to space in data_label only
	
	update wrk_clinical_data
	set data_label=replace(replace(replace(replace(data_label,'%',' Pct'),'&',' and '),'+',' and '),'_',' ')
	   ,data_value=replace(replace(replace(data_value,'%',' Pct'),'&',' and '),'+',' and ')
	   ,category_cd=replace(replace(category_cd,'%',' Pct'),'&',' and ')
	   ,category_path=replace(replace(category_path,'%',' Pct'),'&',' and ');

  --Trim trailing and leadling spaces as well as remove any double spaces, remove space from before comma, remove trailing comma

	update wrk_clinical_data
	set data_label  = trim(trailing ',' from trim(replace(replace(data_label,'  ', ' '),' ,',','))),
		data_value  = trim(trailing ',' from trim(replace(replace(data_value,'  ', ' '),' ,',','))),
--		sample_type = trim(trailing ',' from trim(replace(replace(sample_type,'  ', ' '),' ,',','))),
		visit_name  = trim(trailing ',' from trim(replace(replace(visit_name,'  ', ' '),' ,',',')));
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Remove leading, trailing, double spaces',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

-- determine numeric data types

	execute immediate('truncate table tm_wz.wt_num_data_types');
  
	insert into wt_num_data_types
	(category_cd
	,data_label
	,visit_name
	)
    select category_cd,
           data_label,
           visit_name
    from wrk_clinical_data
    where data_value is not null
    group by category_cd
	        ,data_label
            ,visit_name
      having sum(is_number(data_value)) = 0;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert numeric data into WZ wt_num_data_types',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	--	Check if any duplicate records of key columns (site_id, subject_id, visit_name, data_label, category_cd) for numeric data
	--	exist.  Raise error if yes
	
	execute immediate('truncate table tm_wz.wt_clinical_data_dups');
	
	insert into wt_clinical_data_dups
	(site_id
	,subject_id
	,visit_name
	,data_label
	,category_cd)
	select w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
	from wrk_clinical_data w
	where exists
		 (select 1 from wt_num_data_types t
		 where coalesce(w.category_cd,'@') = coalesce(t.category_cd,'@')
		   and coalesce(w.data_label,'@') = coalesce(t.data_label,'@')
		   and coalesce(w.visit_name,'@') = coalesce(t.visit_name,'@')
		  )
	group by w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
	having count(*) > 1;
		  
	pCount := SQL%ROWCOUNT;
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Check for duplicate key columns',pCount,stepCt,'Done');
			  
	if pCount > 0 then
		raise duplicate_values;
	end if;
	
	--	check for multiple visit_names for category_cd, data_label, data_value
	
     select max(case when x.null_ct > 0 and x.non_null_ct > 0
					 then 1 else 0 end) into pCount
      from (select category_cd, data_label, data_value
				  ,sum(decode(visit_name,null,1,0)) as null_ct
				  ,sum(decode(visit_name,null,0,1)) as non_null_ct
			from lt_src_clinical_data
			where (category_cd like '%VISITNAME%' or
				   category_cd not like '%DATALABEL%')
			group by category_cd, data_label, data_value) x;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Check for multiple visit_names for category/label/value ',pCount,stepCt,'Done');
			  
	if pCount > 0 then
		raise multiple_visit_names;
	end if;
		
	update wrk_clinical_data t
	set data_type='N'
	where exists
	     (select 1 from wt_num_data_types x
	      where nvl(t.category_cd,'@') = nvl(x.category_cd,'@')
			and nvl(t.data_label,'**NULL**') = nvl(x.data_label,'**NULL**')
			and nvl(t.visit_name,'**NULL**') = nvl(x.visit_name,'**NULL**')
		  );
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Updated data_type flag for numeric data_types',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	-- Build all needed leaf nodes in one pass for both numeric and text nodes
 
	execute immediate('truncate table tm_wz.wt_trial_nodes');
	
	insert into wt_trial_nodes
	(leaf_node
	,category_cd
	,visit_name
	,data_label
	--,node_name
	,data_value
	,data_type
	)
    select DISTINCT 
    Case 
	--	Text data_type (default node)
	When a.data_type = 'T'
	     then case when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
		      then regexp_replace(topNode || replace(replace(a.category_path,'DATALABEL',a.data_label),'VISITNAME',a.visit_name) || '\' || a.data_value || '\','(\\){2,}', '\')
			  when a.category_path like '%DATALABEL%'
			  then regexp_replace(topNode || replace(a.category_path,'DATALABEL',a.data_label) || '\' || a.data_value || '\','(\\){2,}', '\')
			  else REGEXP_REPLACE(topNode || a.category_path || 
                   '\'  || a.data_label || '\' || a.visit_name || '\' || a.data_value || '\' ,
                   '(\\){2,}', '\') 
			  end
	--	else is numeric data_type and default_node
	else case when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
		      then regexp_replace(topNode || replace(replace(a.category_path,'DATALABEL',a.data_label),'VISITNAME',a.visit_name) || '\','(\\){2,}', '\')
			  when a.category_path like '%DATALABEL%'
			  then regexp_replace(topNode || replace(a.category_path,'DATALABEL',a.data_label) || '\','(\\){2,}', '\')
			  else REGEXP_REPLACE(topNode || a.category_path || 
                   '\'  || a.data_label || '\' || a.visit_name || '\',
                   '(\\){2,}', '\')
			  end
	end as leaf_node,
    a.category_cd,
    a.visit_name,
	a.data_label,
	decode(a.data_type,'T',a.data_value,null) as data_value
    ,a.data_type
	from  wrk_clinical_data a;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes for trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	set node_name
	
	update wt_trial_nodes
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\',null)),'\');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Updated node name for leaf nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	-- execute immediate('analyze table tm_wz.wt_trial_nodes compute statistics');
	
	--	insert subjects into patient_dimension if needed
	
	execute immediate('truncate table tmp_subject_info');

	insert into tmp_subject_info
	(usubjid,
     age_in_years_num,
     sex_cd,
     race_cd
    )
	select a.usubjid,
	      nvl(max(case when upper(a.data_label) = 'AGE'
					   then case when is_number(a.data_value) = 1 then 0 else to_number(a.data_value) end
		               when upper(a.data_label) like '%(AGE)' 
					   then case when is_number(a.data_value) = 1 then 0 else to_number(a.data_value) end
					   else null end),0) as age,
		  --nvl(max(decode(upper(a.data_label),'AGE',data_value,null)),0) as age,
		  nvl(max(case when upper(a.data_label) = 'SEX' then a.data_value
		           when upper(a.data_label) like '%(SEX)' then a.data_value
				   when upper(a.data_label) = 'GENDER' then a.data_value
				   else null end),'Unknown') as sex,
		  --max(decode(upper(a.data_label),'SEX',data_value,'GENDER',data_value,null)) as sex,
		  max(case when upper(a.data_label) = 'RACE' then a.data_value
		           when upper(a.data_label) like '%(RACE)' then a.data_value
				   else null end) as race
		  --max(decode(upper(a.data_label),'RACE',data_value,null)) as race
	from wrk_clinical_data a
	--where upper(a.data_label) in ('AGE','RACE','SEX','GENDER')
	group by a.usubjid;
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert subject information into temp table',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
	
	--	Delete dropped subjects from patient_dimension if they do not exist in de_subject_sample_mapping
	
	delete patient_dimension
	where sourcesystem_cd in
		 (select distinct pd.sourcesystem_cd from patient_dimension pd
		  where pd.sourcesystem_cd like TrialId || ':%'
		  minus 
		  select distinct cd.usubjid from wrk_clinical_data cd)
	  and patient_num not in
		  (select distinct sm.patient_id from de_subject_sample_mapping sm);
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete dropped subjects from patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;	
	
	--	update patients with changed information
	
	update patient_dimension pd
	set (sex_cd, age_in_years_num, race_cd, update_date) = 
		(select nvl(t.sex_cd,pd.sex_cd), t.age_in_years_num, nvl(t.race_cd,pd.race_cd), sysdate
		 from tmp_subject_info t
		 where t.usubjid = pd.sourcesystem_cd
		   and (coalesce(pd.sex_cd,'@') != t.sex_cd or
				pd.age_in_years_num != t.age_in_years_num or
				coalesce(pd.race_cd,'@') != t.race_cd)
		)
	where exists
		 (select 1 from tmp_subject_info x
		  where pd.sourcesystem_cd = x.usubjid
		    and (coalesce(pd.sex_cd,'@') != x.sex_cd or
				 pd.age_in_years_num != x.age_in_years_num or
				 coalesce(pd.race_cd,'@') != x.race_cd)
		 );
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update subjects with changed demographics in patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;	

	--	insert new subjects into patient_dimension
	
	insert into patient_dimension
    (patient_num,
     sex_cd,
     age_in_years_num,
     race_cd,
     update_date,
     download_date,
     import_date,
     sourcesystem_cd
    )
    select seq_patient_num.nextval,
		   t.sex_cd,
		   t.age_in_years_num,
		   t.race_cd,
		   sysdate,
		   sysdate,
		   sysdate,
		   t.usubjid
    from tmp_subject_info t
	where t.usubjid in 
		 (select distinct cd.usubjid from tmp_subject_info cd
		  minus
		  select distinct pd.sourcesystem_cd from patient_dimension pd
		  where pd.sourcesystem_cd like TrialId || '%');
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert new subjects into patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
		
	--	delete leaf nodes that will not be reused, if any
	
	 FOR r_delUnusedLeaf in delUnusedLeaf Loop

    --	deletes unused leaf nodes for a trial one at a time

		i2b2_delete_1_node(r_delUnusedLeaf.c_fullname);
		stepCt := stepCt + 1;	
		cz_write_audit(jobId,databaseName,procedureName,'Deleted unused node: ' || r_delUnusedLeaf.c_fullname,SQL%ROWCOUNT,stepCt,'Done');

	END LOOP;	
	
	--	bulk insert leaf nodes
	
	update concept_dimension cd
	set name_char=(select t.node_name from wt_trial_nodes t
				   where cd.concept_path = t.leaf_node
				     and cd.name_char != t.node_name)
	where exists (select 1 from wt_trial_nodes x
				  where cd.concept_path = x.leaf_node
				    and cd.name_char != x.node_name);
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update name_char in concept_dimension for changed names',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;
							
	
	insert into concept_dimension
    (concept_cd
	,concept_path
	,name_char
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,table_name
	)
    select concept_id.nextval
	     ,x.leaf_node
		 ,x.node_name
		 ,sysdate
		 ,sysdate
		 ,sysdate
		 ,TrialId
		 ,'CONCEPT_DIMENSION'
	from (select distinct c.leaf_node
				,to_char(c.node_name) as node_name
		  from wt_trial_nodes c
		  where not exists
			(select 1 from concept_dimension x
			where c.leaf_node = x.concept_path)
		 ) x;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted new leaf nodes into I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    commit;
	
	--	update i2b2 to pick up change in name, data_type for leaf nodes
	
	update i2b2 b
	set (c_name, c_columndatatype, c_metadataxml)=
		(select t.node_name, t.data_type
		 ,case when t.data_type = 'T'
		       then null
			   else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
		  end
		 from wt_trial_nodes t
		 where b.c_fullname = t.leaf_node
		   and (b.c_name != t.node_name or b.c_columndatatype != t.data_type))
	where exists
		(select 1 from wt_trial_nodes x
		 where b.c_fullname = x.leaf_node
		   and (b.c_name != x.node_name or b.c_columndatatype != x.data_type));
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Updated name and data type in i2b2 if changed',SQL%ROWCOUNT,stepCt,'Done');
    commit;
			   
	insert into i2b2
    (c_hlevel
	,c_fullname
	,c_name
	,c_visualattributes
	,c_synonym_cd
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_dimcode
	,c_tooltip
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,c_basecode
	,c_operator
	,c_columndatatype
	,c_comment
	,i2b2_id
	,c_metadataxml
	)
    select (length(c.concept_path) - nvl(length(replace(c.concept_path, '\')),0)) / length('\') - 2 + root_level
		  ,c.concept_path
		  ,c.name_char
		  ,'LA'
		  ,'N'
		  ,'CONCEPT_CD'
		  ,'CONCEPT_DIMENSION'
		  ,'CONCEPT_PATH'
		  ,c.concept_path
		  ,c.concept_path
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,c.sourcesystem_cd
		  ,c.concept_cd
		  ,'LIKE'
		  ,'T'		-- if i2b2 gets fixed to respect c_columndatatype then change to t.data_type
		  ,'trial:' || TrialID 
		  ,i2b2_id_seq.nextval
		  ,case when t.data_type = 'T' then null
		   else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
		   end
    from concept_dimension c
		,wt_trial_nodes t
    where c.concept_path = t.leaf_node
	  and not exists
		 (select 1 from i2b2 x
		  where c.concept_path = x.c_fullname);
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted leaf nodes into I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;

	--	delete from observation_fact all concept_cds for trial that are clinical data, exclude concept_cds from biomarker data
	
	delete from observation_fact f
	where (f.modifier_cd = TrialId or f.sourcesystem_cd = TrialId)
	  and f.concept_cd not in
		 (select distinct concept_code as concept_cd from de_subject_sample_mapping
		  where trial_name = TrialId
		    and concept_code is not null
		  union
		  select distinct platform_cd as concept_cd from de_subject_sample_mapping
		  where trial_name = TrialId
		    and platform_cd is not null
		  union
		  select distinct sample_type_cd as concept_cd from de_subject_sample_mapping
		  where trial_name = TrialId
		    and sample_type_cd is not null
		  union
		  select distinct tissue_type_cd as concept_cd from de_subject_sample_mapping
		  where trial_name = TrialId
		    and tissue_type_cd is not null
		  union
		  select distinct timepoint_cd as concept_cd from de_subject_sample_mapping
		  where trial_name = TrialId
		    and timepoint_cd is not null
		  union
		  select distinct concept_cd as concept_cd from de_subject_snp_dataset
		  where trial_name = TrialId
		    and concept_cd is not null);
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete clinical data for study from observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;		  
	
    --Insert into observation_fact
	
	insert into observation_fact
	(patient_num,
     concept_cd,
     modifier_cd,
     valtype_cd,
     tval_char,
     nval_num,
     sourcesystem_cd,
     import_date,
     valueflag_cd,
     provider_id,
     location_cd
	)
	select distinct c.patient_num,
		   i.c_basecode,
		   '@',
		   a.data_type,
		   case when a.data_type = 'T' then a.data_value
				else 'E'  --Stands for Equals for numeric types
				end,
		   case when a.data_type = 'N' then a.data_value
				else null --Null for text types
				end,
		   TrialId, 
		  sysdate, 
		   '@',
		   '@',
		   '@'
	from wrk_clinical_data a
		,patient_dimension c
		,wt_trial_nodes t
		,i2b2 i
	where a.usubjid = c.sourcesystem_cd
	  and nvl(a.category_cd,'@') = nvl(t.category_cd,'@')
	  and nvl(a.data_label,'**NULL**') = nvl(t.data_label,'**NULL**')
	  and nvl(a.visit_name,'**NULL**') = nvl(t.visit_name,'**NULL**')
	  and decode(a.data_type,'T',a.data_value,'**NULL**') = nvl(t.data_value,'**NULL**')
	  and t.leaf_node = i.c_fullname
	  and not exists		-- don't insert if lower level node exists
		 (select 1 from wt_trial_nodes x
		  where x.leaf_node like t.leaf_node || '%_')
	  and a.data_value is not null;  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;

	--	update c_visualattributes for all nodes in study, done to pick up node that changed from leaf/numeric to folder/text
	
	update i2b2 a
	set c_visualattributes=(
		with upd as (select p.c_fullname, count(*) as nbr_children 
				 from i2b2 p
					 ,i2b2 c
				 where p.c_fullname like topNode || '%'
				   and c.c_fullname like p.c_fullname || '%'
				 group by p.c_fullname)
		select case when u.nbr_children = 1 
					then 'L' || substr(a.c_visualattributes,2,2)
	                else 'F' || substr(a.c_visualattributes,2,1) ||
						 case when u.c_fullname = topNode and highlight_study = 'Y'
							  then 'J' else substr(a.c_visualattributes,3,1) end
			   end
		from upd u
		where a.c_fullname = u.c_fullname)
	where a.c_fullname in
		(select x.c_fullname from i2b2 x
		 where x.c_fullname like topNode || '%');

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update c_visualattributes for study',SQL%ROWCOUNT,stepCt,'Done');

	commit;
	
	-- final procs
  
	i2b2_fill_in_tree(TrialId, topNode, jobID);
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
		
	update i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper-level nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	i2b2_create_concept_counts(topNode, jobID);
	
	--	delete each node that is hidden after create concept counts
	
	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		i2b2_delete_1_node(r_delNodes.c_fullname);
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		
		cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');

	END LOOP;  	

	i2b2_create_security_for_trial(TrialId, secureStudy, jobID);
	i2b2_load_security_data(jobID);

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_clinical_data',0,stepCt,'Done');
	
    ---Cleanup OVERALL JOB if this proc is being run standalone
	if newJobFlag = 1
	then
		cz_end_audit (jobID, 'SUCCESS');
	end if;

	rtnCode := 0;
  
	exception
	when duplicate_values then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Duplicate values found in key columns',0,stepCt,'Done');	
		cz_error_handler (jobID, procedureName);
		cz_end_audit (jobID, 'FAIL');
		rtnCode := 16;		
	when invalid_topNode then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Path specified in top_node must contain at least 2 nodes',0,stepCt,'Done');	
		cz_error_handler (jobID, procedureName);
		cz_end_audit (jobID, 'FAIL');
		rtnCode := 16;	
	when multiple_visit_names then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Multiple visit_names exist for category/label/value',0,stepCt,'Done');	
		cz_error_handler (jobID, procedureName);
		cz_end_audit (jobID, 'FAIL');
		rtnCode := 16;
	when others then
    --Handle errors.
		cz_error_handler (jobID, procedureName);
    --End Proc
		cz_end_audit (jobID, 'FAIL');
		rtnCode := 16;
	
end;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_CLINICAL_DATA_TR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_CLINICAL_DATA_TR" 
(
  trial_id             IN    VARCHAR2
 ,top_node            in  varchar2
 ,secure_study        in varchar2 := 'N'
 ,highlight_study    in    varchar2 := 'N'
 ,currentJobID        IN    NUMBER := null
)
AS

    --    JEA@20110708    Cloned from i2b2_apply_curation_rules and i2b2_load_tpm_post_curation
    --    JEA@20111028    Changed source table to lt_src_clinical_data, this table will be loaded either through
    --                    i2b2_clinical_data_extrnl_lt sp or through sqlldr where external tables are not feasible
    --    JEA@20111114    Added ctrl_vocab_code
    --    JEA@20111115    Reuse concept_cds, i2b2 and concept_dimension
    --    JEA@20111201    Added join to concept_dimension when setting datatype of N and xml for i2b2
    --    JEA@20111220    Don't delete patients that exist in de_subject_sample_mapping
    --    JEA@20111226    Change all & to ' and ' in category_cd, data_label or data_value
    --    JEA@20120103    Only check for dups for numeric data values, text won't cause problems on insert
    --    JEA@20120103    Remove setting c_basecode to null for folders
    --    JEA@20120104    Don't insert into observation_fact if lower-level leaf node exists
    --    JEA@20120105    Fix node_name in wt_trial_nodes for numeric data types wchere data_label is concatenation
    --    JEA@20120109    Added populate i2b2_id on insert to i2b2
    --    JEA@20120111    Added populate wt_clinical_data_dups table to easily identify duplicate records
    --    JEA@20120113    Change del_nodes to look for H in pos 2 of c_visualattributes
    --    JEA220120119    Don't run i2b2_create_patient_trial, delete/insert done as part of proc
    --    JEA@20120120    Comment out delete/insert to patient_trial, incorporated as part of i2b2_create_security_for_trial
    --    JEA@20120204    Remove data_label from last part of category_path and category_cd when they are the same
    --    JEA@20120215    Add : to where clause in delete patient_dimension
    --    JEA@20120229    Added replace of + with ' and ' to data_label and data_value
    --    JEA@20120318    Correct node_name where visit_name is not null
    --    JEA@20120318    Update node if node_name changed or changed from text to numeric
    --    JEA@20120319    Added third c_visualattributes = J for topNode
    --    JEA@20120402    Fixed update to patient_dimension to add coalesce for null values
    --    JEA@20120409    Add new parameter, highlight_study that will determine if J is set as third position of c_visualattributes for topNode
    --    JEA@20120411    Fix c_visualattribute issue when node changed from numeric leaf to folder
    --    JEA@20120411    Add DATALABEL, VISITNAME override to category_cd, add update of node_name in wt_trial_nodes
    --    JEA@20120421    Default sex_cd in patient_dimenstion to Unknown when null
    --    JEA220120425    Add single DATALABEL in category_cd to force drop of visit_name/VISITNAME
    --    JEA@20120507    Fix missing data_value when DATALABEL, VISITNAME in category_cd
    --    JEA@20120508    Add trial name to start audit text, change patient update to coalesce for sex_cd, race_cd, 
    --                    remove case statement that set sex_cd to M/F/U
    --    JEA@20120510    Add root node using i2b2_add_root_node if missing
    --    JEA@20120511    Only insert unique leaf_nodes to concept_dimension
    --    JEA@20120517    Set visit_name to null if only DATALABEL in category_cd
    --    JEA@20120526    Set sourcesystem_cd, c_comment to null if any upper-level nodes added
    --    JEA@20120601    Change underscore (_) to space in data_label
    --    JEA@20120603    Raise exception if only one node in top_node
    --    JEA@20120604    Raise exception if category_cd, data_label, data_value has multiple visit_name
    --    JEA@20120709    Rework logic for adding/updating leaf nodes, consolidated logic for setting c_visualattributes, c_metadataxml
    --    JEA@20120808    run i2b2_add_root_node if record doesn't exist in either table_access or i2b2
   
  topNode        VARCHAR2(2000);
  topLevel        number(10,0);
  root_node        varchar2(2000);
  root_level    int;
  study_name    varchar2(2000);
  TrialID        varchar2(100);
  secureStudy    varchar2(200);
  etlDate        date;
  tPath            varchar2(2000);
  pCount        int;
  pExists        int;
  rtnCode        int;
  tText            varchar2(2000);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  duplicate_values    exception;
  invalid_topNode    exception;
  multiple_visit_names    exception;
  
  CURSOR addNodes is
  select DISTINCT 
         leaf_node,
             node_name
  from  wt_trial_nodes a
  ;
   
    --    cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

    CURSOR delNodes is
    select distinct c_fullname 
    from  i2b2
    where c_fullname like topNode || '%'
      and substr(c_visualattributes,2,1) = 'H';
      
    --    cursor to determine if any leaf nodes exist in i2b2 that are not used in this reload (node changes from text to numeric or numeric to text)
      
    cursor delUnusedLeaf is
    select l.c_fullname
    from i2b2 l
    where l.c_visualattributes like 'L%'
      and l.c_fullname like topNode || '%'
      --and l.c_fullname not in
      and not exists
         (select t.leaf_node 
          from wt_trial_nodes t WHERE t.leaf_node = l.c_fullname
          union all
          select m.c_fullname
          from de_subject_sample_mapping sm
              ,i2b2 m
          where sm.trial_name = TrialId
            and sm.concept_code = m.c_basecode
            and m.c_visualattributes like 'L%' AND m.c_fullname = l.c_fullname);
BEGIN

    TrialID := upper(trial_id);
    secureStudy := upper(secure_study);
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := currentJobID;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;
    
    select sysdate into etlDate from dual;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 0;

    stepCt := stepCt + 1;
    tText := 'Start i2b2_load_clinical_data for ' || TrialId;
    cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
    
    if (secureStudy not in ('Y','N') ) then
        secureStudy := 'Y';
    end if;
  
  -- added by Eugr: enable parallel queries
  execute immediate 'alter session enable parallel dml';
    
    topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\');
    
    --    figure out how many nodes (folders) are at study name and above
    --    \Public Studies\Clinical Studies\Pancreatic_Cancer_Smith_GSE22780\: topLevel = 4, so there are 3 nodes
    --    \Public Studies\GSE12345\: topLevel = 3, so there are 2 nodes
    
    select length(topNode)-length(replace(topNode,'\','')) into topLevel from dual;
    
    if topLevel < 3 then
        raise invalid_topNode;
    end if;    

    --    delete any existing data from lz_src_clinical_data and load new data
    
    delete from lz_src_clinical_data
    where study_id = TrialId;
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from lz_src_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    insert /*+ APPEND */ into lz_src_clinical_data nologging
    (study_id
    ,site_id
    ,subject_id
    ,visit_name
    ,data_label
    ,data_value
    ,category_cd
    ,etl_job_id
    ,etl_date
    ,ctrl_vocab_code)
    select study_id
          ,site_id
          ,subject_id
          ,visit_name
          ,data_label
          ,data_value
          ,category_cd
          ,jobId
          ,etlDate
          ,ctrl_vocab_code
    from lt_src_clinical_data;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert data into lz_src_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
    commit;
        
    --    truncate wrk_clinical_data and load data from external file
    
    execute immediate('truncate table tm_wz.wrk_clinical_data');
    
    --    insert data from lt_src_clinical_data to wrk_clinical_data
    
    insert /*+ APPEND */ into wrk_clinical_data nologging
    (study_id
    ,site_id
    ,subject_id
    ,visit_name
    ,data_label
    ,data_value
    ,category_cd
    ,ctrl_vocab_code
    )
    select study_id
          ,site_id
          ,subject_id
          ,visit_name
          ,data_label
          ,data_value
          ,category_cd
          ,ctrl_vocab_code
    from lt_src_clinical_data;
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Load lt_src_clinical_data to work table',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;      

    -- Get root_node from topNode
  
    select parse_nth_value(topNode, 2, '\') into root_node from dual;
    
    select count(*) into pExists
    from table_access
    where c_name = root_node;
    
    select count(*) into pCount
    from i2b2
    where c_name = root_node;
    
    if pExists = 0 or pCount = 0 then
        i2b2_add_root_node_tr(root_node, jobId);
    end if;
    
    select c_hlevel into root_level
    from table_access
    where c_name = root_node;
    
    -- Get study name from topNode
  
    select parse_nth_value(topNode, topLevel, '\') into study_name from dual;
    
    --    Add any upper level nodes as needed
    
    tPath := REGEXP_REPLACE(replace(top_node,study_name,null),'(\\){2,}', '\');
    select length(tPath) - length(replace(tPath,'\',null)) into pCount from dual;

    if pCount > 2 then
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Adding upper-level nodes',0,stepCt,'Done');
        i2b2_fill_in_tree(null, tPath, jobId);
    end if;
    
/*    Don't delete existing data, concept_cds will be reused
    --    delete any existing data
    
    i2b2_delete_all_nodes(topNode, jobId);
*/

    select count(*) into pExists
    from i2b2
    where c_fullname = topNode;
    
    --    add top node for study
    
    if pExists = 0 then
        i2b2_add_node_tr(TrialId, topNode, study_name, jobId);
    end if;
  
    --    Set data_type, category_path, and usubjid 
  
    /*update  wrk_clinical_data
    set data_type = 'T'
       ,category_path = replace(replace(category_cd,'_',' '),'+','\')
      -- ,usubjid = TrialID || ':' || site_id || ':' || subject_id;
       ,usubjid = REGEXP_REPLACE(TrialID || ':' || site_id || ':' || subject_id,
                   '(::){1,}', ':'); */
                   
    --21 July 2013. Performace fix by TR. Split into 2 sub queries
        
    update wrk_clinical_data
    set data_type = 'T'
       ,category_path = replace(replace(category_cd,'_',' '),'+','\')
     ,usubjid = TrialID || ':' || subject_id
    WHERE site_id IS NULL;
    
  update wrk_clinical_data
    set data_type = 'T'
       ,category_path = replace(replace(category_cd,'_',' '),'+','\')
     ,usubjid = TrialID || ':' || site_id || ':' || subject_id
  WHERE site_id IS NOT NULL;
  
     
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set columns in wrk_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;
  
    --    Delete rows where data_value is null
  
    delete from wrk_clinical_data
    where data_value is null;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete null data_values in wrk_clinical_data',SQL%ROWCOUNT,stepCt,'Done');
    
    --Remove Invalid pipes in the data values.
    --RULE: If Pipe is last or first, delete it
    --If it is in the middle replace with a dash

    update wrk_clinical_data
    set data_value = replace(trim('|' from data_value), '|', '-')
    where data_value like '%|%';
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Remove pipes in data_value',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;  
  
    --Remove invalid Parens in the data
    --They have appeared as empty pairs or only single ones.
  
    update wrk_clinical_data
    set data_value = replace(data_value,'(', '')
    where data_value like '%()%'
       or data_value like '%( )%'
       or (data_value like '%(%' and data_value NOT like '%)%');
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 1',SQL%ROWCOUNT,stepCt,'Done');
    
    update wrk_clinical_data
    set data_value = replace(data_value,')', '')
    where data_value like '%()%'
       or data_value like '%( )%'
       or (data_value like '%)%' and data_value NOT like '%(%');
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Remove empty parentheses 2',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

    --Replace the Pipes with Commas in the data_label column
    update wrk_clinical_data
    set data_label = replace (data_label, '|', ',')
    where data_label like '%|%';
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Replace pipes with comma in data_label',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

    --    set visit_name to null when there's only a single visit_name for the catgory
    
    update wrk_clinical_data tpm
    set visit_name=null
    where (tpm.category_cd) in
          (select x.category_cd
           from wrk_clinical_data x
           group by x.category_cd
           having count(distinct upper(x.visit_name)) = 1);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set single visit_name to null',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;
    
    --    set data_label to null when it duplicates the last part of the category_path
    --    Remove data_label from last part of category_path when they are the same
    
    update wrk_clinical_data tpm
    --set data_label = null
    set category_path=substr(tpm.category_path,1,instr(tpm.category_path,'\',-2)-1)
       ,category_cd=substr(tpm.category_cd,1,instr(tpm.category_cd,'+',-2)-1)
    where (tpm.category_cd, tpm.data_label) in
          (select distinct t.category_cd
                 ,t.data_label
           from wrk_clinical_data t
           where upper(substr(t.category_path,instr(t.category_path,'\',-1)+1,length(t.category_path)-instr(t.category_path,'\',-1))) 
                 = upper(t.data_label)
             and t.data_label is not null)
      and tpm.data_label is not null;

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set data_label to null when found in category_path',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;

    --    set visit_name to null if same as data_label
    
    update wrk_clinical_data t
    set visit_name=null
    where (t.category_cd, t.visit_name, t.data_label) in
          (select distinct tpm.category_cd
                 ,tpm.visit_name
                 ,tpm.data_label
          from wrk_clinical_data tpm
          where tpm.visit_name = tpm.data_label);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_label',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;
    
    --    set visit_name to null if same as data_value
    
    update wrk_clinical_data t
    set visit_name=null
    where (t.category_cd, t.visit_name, t.data_value) in
          (select distinct tpm.category_cd
                 ,tpm.visit_name
                 ,tpm.data_value
          from wrk_clinical_data tpm
          where tpm.visit_name = tpm.data_value);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when found in data_value',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;
    
    --    set visit_name to null if only DATALABEL in category_cd
  -- EUGR: disabled!!!!!
    
    /*update wrk_clinical_data t
    set visit_name=null
    where t.category_cd like '%DATALABEL%'
      and t.category_cd not like '%VISITNAME%';

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set visit_name to null when only DATALABE in category_cd',SQL%ROWCOUNT,stepCt,'Done');
        
    commit;*/

/*    --    Remove sample_type if found in category_path
    
    update wrk_clinical_data t
    set sample_type = null
    where exists
         (select 1 from wrk_clinical_data c
          where instr(c.category_path,t.sample_type) > 0);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Remove sample_type if already in category_path',SQL%ROWCOUNT,stepCt,'Done');
    commit;
*/
    --    comment out may need later
    
/*    --    change any % to Pct and & and + to ' and ' and _ to space in data_label only
    
    update wrk_clinical_data
    set data_label=replace(replace(replace(replace(data_label,'%',' Pct'),'&',' and '),'+',' and '),'_',' ')
       ,data_value=replace(replace(replace(data_value,'%',' Pct'),'&',' and '),'+',' and ')
       ,category_cd=replace(replace(category_cd,'%',' Pct'),'&',' and ')
       ,category_path=replace(replace(category_path,'%',' Pct'),'&',' and ');

  --Trim trailing and leadling spaces as well as remove any double spaces, remove space from before comma, remove trailing comma

    update wrk_clinical_data
    set data_label  = trim(trailing ',' from trim(replace(replace(data_label,'  ', ' '),' ,',','))),
        data_value  = trim(trailing ',' from trim(replace(replace(data_value,'  ', ' '),' ,',','))),
--        sample_type = trim(trailing ',' from trim(replace(replace(sample_type,'  ', ' '),' ,',','))),
        visit_name  = trim(trailing ',' from trim(replace(replace(visit_name,'  ', ' '),' ,',',')));*/
        
     -- July 2013. Performace fix by TR. Merge into one query
   
    update /*+ parallel(wrk_clinical_data, 4) */ wrk_clinical_data
    set data_label  = trim(trailing ',' from trim(replace(replace(/**/  replace(replace(replace(replace(data_label,'%',' Pct'),'&',' and '),'+',' and '),'_',' ') /**/   ,'  ', ' '),' ,',',')))
         ,data_value  = trim(trailing ',' from trim(replace(replace(/**/  replace(replace(replace(data_value,'%',' Pct'),'&',' and '),'+',' and ') /**/  ,'  ', ' '),' ,',',')))
     ,visit_name  = trim(trailing ',' from trim(replace(replace(visit_name,'  ', ' '),' ,',',')))
     ,category_cd=replace(replace(category_cd,'%',' Pct'),'&',' and ')
       ,category_path=replace(replace(category_path,'%',' Pct'),'&',' and ')
    ;    
        
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Remove leading, trailing, double spaces',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

-- determine numeric data types

    execute immediate('truncate table tm_wz.wt_num_data_types');
  
    insert into wt_num_data_types
    (category_cd
    ,data_label
    ,visit_name
    )
    select category_cd,
           data_label,
           visit_name
    from wrk_clinical_data
    where data_value is not null
    group by category_cd
            ,data_label
            ,visit_name
      having sum(is_number(data_value)) = 0;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert numeric data into WZ wt_num_data_types',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

    --    Check if any duplicate records of key columns (site_id, subject_id, visit_name, data_label, category_cd) for numeric data
    --    exist.  Raise error if yes
    
    execute immediate('truncate table tm_wz.wt_clinical_data_dups');
    
    insert into wt_clinical_data_dups
    (site_id
    ,subject_id
    ,visit_name
    ,data_label
    ,category_cd)
    select w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
    from wrk_clinical_data w
    where exists
         (select 1 from wt_num_data_types t
         where coalesce(w.category_cd,'@') = coalesce(t.category_cd,'@')
           and coalesce(w.data_label,'@') = coalesce(t.data_label,'@')
           and coalesce(w.visit_name,'@') = coalesce(t.visit_name,'@')
          )
    group by w.site_id, w.subject_id, w.visit_name, w.data_label, w.category_cd
    having count(*) > 1;
          
    pCount := SQL%ROWCOUNT;
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Check for duplicate key columns',pCount,stepCt,'Done');
              
    if pCount > 0 then
        raise duplicate_values;
    end if;
    
    --    check for multiple visit_names for category_cd, data_label, data_value
    
     select max(case when x.null_ct > 0 and x.non_null_ct > 0
                     then 1 else 0 end) into pCount
      from (select category_cd, data_label, data_value
                  ,sum(decode(visit_name,null,1,0)) as null_ct
                  ,sum(decode(visit_name,null,0,1)) as non_null_ct
            from lt_src_clinical_data
            where (category_cd like '%VISITNAME%' or
                   category_cd not like '%DATALABEL%')
            group by category_cd, data_label, data_value) x;
  
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Check for multiple visit_names for category/label/value ',pCount,stepCt,'Done');
              
    if pCount > 0 then
        raise multiple_visit_names;
    end if;
        
    update wrk_clinical_data t
    set data_type='N'
    where exists
         (select 1 from wt_num_data_types x
          where nvl(t.category_cd,'@') = nvl(x.category_cd,'@')
            and nvl(t.data_label,'**NULL**') = nvl(x.data_label,'**NULL**')
            and nvl(t.visit_name,'**NULL**') = nvl(x.visit_name,'**NULL**')
          );
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Updated data_type flag for numeric data_types',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

    -- Build all needed leaf nodes in one pass for both numeric and text nodes
 
    execute immediate('truncate table tm_wz.wt_trial_nodes');
    
    insert /*+ APPEND parallel(wt_trial_nodes, 4) */ into wt_trial_nodes nologging
    (leaf_node
    ,category_cd
    ,visit_name
    ,data_label
    --,node_name
    ,data_value
    ,data_type
    )
    select /*+ parallel(a, 4) */  DISTINCT 
    Case 
    --    Text data_type (default node)
    When a.data_type = 'T'
         then case 
            when a.category_path like '%DATALABEL%' and a.category_path like '%DATAVALUE%' and a.category_path like '%VISITNAME%'
                then regexp_replace(topNode || replace(replace(replace(a.category_path,'DATALABEL',a.data_label),'VISITNAME',a.visit_name), 'DATAVALUE',a.data_value)  || '\','(\\){2,}', '\')
             when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
                then regexp_replace(topNode || replace(replace(a.category_path,'DATALABEL',a.data_label),'VISITNAME',a.visit_name) || '\' || a.data_value || '\','(\\){2,}', '\')
            when a.CATEGORY_PATH like '%DATALABEL%'
                then case
                when a.category_path like '%\VISITNFST' -- TR: support visit first
                    then regexp_replace(topNode || replace(replace(a.category_path,'\VISITNFST', ''), 'DATALABEL',a.data_label) || '\' || a.visit_name || '\' || a.data_value || '\', '(\\){2,}', '\') 
                    else regexp_replace(topNode || replace(a.category_path, 'DATALABEL',a.data_label) || '\' || a.data_value || '\' || a.visit_name || '\', '(\\){2,}', '\')
                end
            ELSE case
            when a.category_path like '%\VISITNFST' -- TR: support visit first
                then REGEXP_REPLACE(TOPNODE || replace(a.category_path,'\VISITNFST', '') || '\'  || a.data_label || '\' || a.visit_name || '\' || a.data_value || '\', '(\\){2,}', '\')
                else REGEXP_REPLACE(TOPNODE || a.category_path || '\'  || a.DATA_LABEL || '\' || a.DATA_VALUE || '\' || a.VISIT_NAME || '\', '(\\){2,}', '\')
            end
    end
    --    else is numeric data_type and default_node
    else case when a.category_path like '%DATALABEL%' and a.category_path like '%VISITNAME%'
              then regexp_replace(topNode || replace(replace(replace(a.category_path,'DATALABEL',a.data_label),'VISITNAME',a.visit_name), '\VISITNFST', '') || '\','(\\){2,}', '\')
              when a.CATEGORY_PATH like '%DATALABEL%'
              then regexp_replace(topNode || replace(replace(a.category_path,'DATALABEL',a.data_label), '\VISITNFST', '') || '\' || a.visit_name || '\', '(\\){2,}', '\')
              else REGEXP_REPLACE(topNode || replace(a.category_path, '\VISITNFST', '') || 
                   '\'  || a.data_label || '\' || a.visit_name || '\',
                   '(\\){2,}', '\')
              end
    end as leaf_node,
    a.category_cd,
    a.visit_name,
    a.data_label,
    decode(a.data_type,'T',a.data_value,null) as data_value
    ,a.data_type
    from  wrk_clinical_data a;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes for trial',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    set node_name
    
    update wt_trial_nodes
    set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\',null)),'\');
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Updated node name for leaf nodes',SQL%ROWCOUNT,stepCt,'Done');
    commit;    
    
    -- execute immediate('analyze table tm_wz.wt_trial_nodes compute statistics');
    
    --    insert subjects into patient_dimension if needed
    
    execute immediate('truncate table tmp_subject_info');

    insert into tmp_subject_info
    (usubjid,
     age_in_years_num,
     sex_cd,
     race_cd
    )
    select a.usubjid,
          nvl(max(case when upper(a.data_label) = 'AGE'
                       then case when is_number(a.data_value) = 1 then 0 else to_number(a.data_value) end
                       when upper(a.data_label) like '%(AGE)' 
                       then case when is_number(a.data_value) = 1 then 0 else to_number(a.data_value) end
                       else null end),0) as age,
          --nvl(max(decode(upper(a.data_label),'AGE',data_value,null)),0) as age,
          nvl(max(case when upper(a.data_label) = 'SEX' then a.data_value
                   when upper(a.data_label) like '%(SEX)' then a.data_value
                   when upper(a.data_label) = 'GENDER' then a.data_value
                   else null end),'Unknown') as sex,
          --max(decode(upper(a.data_label),'SEX',data_value,'GENDER',data_value,null)) as sex,
          max(case when upper(a.data_label) = 'RACE' then a.data_value
                   when upper(a.data_label) like '%(RACE)' then a.data_value
                   else null end) as race
          --max(decode(upper(a.data_label),'RACE',data_value,null)) as race
    from wrk_clinical_data a
    --where upper(a.data_label) in ('AGE','RACE','SEX','GENDER')
    group by a.usubjid;
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert subject information into temp table',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;
    
    --    Delete dropped subjects from patient_dimension if they do not exist in de_subject_sample_mapping
    
    delete /*+ parallel(patient_dimension, 8) */ patient_dimension
    where sourcesystem_cd in
         (select distinct pd.sourcesystem_cd from patient_dimension pd
          where pd.sourcesystem_cd like TrialId || ':%'
          minus 
          select distinct cd.usubjid from wrk_clinical_data cd)
      and patient_num not in
          (select distinct sm.patient_id from de_subject_sample_mapping sm);
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete dropped subjects from patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;    
    
    --    update patients with changed information
    
    update /*+ parallel(patient_dimension, 8) */ patient_dimension pd
    set (SEX_CD, AGE_IN_YEARS_NUM, RACE_CD, UPDATE_DATE) = 
        (select /*+ parallel(tmp_subject_info, 8) */ nvl(t.sex_cd,pd.sex_cd), t.age_in_years_num, nvl(t.race_cd,pd.race_cd), sysdate
         from tmp_subject_info t
         where t.usubjid = pd.sourcesystem_cd
           and (coalesce(pd.sex_cd,'@') != t.sex_cd or
                pd.age_in_years_num != t.age_in_years_num or
                coalesce(pd.race_cd,'@') != t.race_cd)
        )
    where exists
         (select /*+ parallel(tmp_subject_info, 8) */ 1 from tmp_subject_info x
          where pd.sourcesystem_cd = x.usubjid
            and (coalesce(pd.sex_cd,'@') != x.sex_cd or
                 pd.age_in_years_num != x.age_in_years_num or
                 coalesce(pd.race_cd,'@') != x.race_cd)
         );
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Update subjects with changed demographics in patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;    

    --    insert new subjects into patient_dimension
    
    insert /*+ parallel(patient_dimension, 8) */ into patient_dimension
    (patient_num,
     sex_cd,
     age_in_years_num,
     race_cd,
     update_date,
     download_date,
     import_date,
     sourcesystem_cd
    )
    select /*+ parallel(tmp_subject_info, 8) */ seq_patient_num.nextval,
           t.sex_cd,
           t.age_in_years_num,
           t.race_cd,
           sysdate,
           sysdate,
           sysdate,
           t.usubjid
    from tmp_subject_info t
    where t.usubjid in 
         (select distinct cd.usubjid from tmp_subject_info cd
          minus
          select distinct pd.sourcesystem_cd from patient_dimension pd
          where pd.sourcesystem_cd like TrialId || '%');
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert new subjects into patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;
        
    --    delete leaf nodes that will not be reused, if any
    
     FOR r_delUnusedLeaf in delUnusedLeaf Loop

    --    deletes unused leaf nodes for a trial one at a time

        i2b2_delete_1_node(r_delUnusedLeaf.c_fullname);
        stepCt := stepCt + 1;    
        cz_write_audit(jobId,databaseName,procedureName,'Deleted unused node: ' || r_delUnusedLeaf.c_fullname,SQL%ROWCOUNT,stepCt,'Done');

    END LOOP;    
    
    --    bulk insert leaf nodes
    
    update /*+ parallel(cd, 4) */ concept_dimension cd
    set name_char=(select /*+ parallel(t, 4) */ t.node_name from wt_trial_nodes t
                   where cd.concept_path = t.leaf_node
                     and cd.name_char != t.node_name)
    where exists (select /*+ parallel(x, 4) */ 1 from wt_trial_nodes x
                  where cd.concept_path = x.leaf_node
                    and cd.name_char != x.node_name);
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Update name_char in concept_dimension for changed names',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;
                            
    
    insert /*+ parallel(concept_dimension, 8) */ into concept_dimension
    (concept_cd
    ,concept_path
    ,name_char
    ,update_date
    ,download_date
    ,import_date
    ,sourcesystem_cd
    ,table_name
    )
    select /*+ parallel(8) */ concept_id.nextval
         ,x.leaf_node
         ,x.node_name
         ,sysdate
         ,sysdate
         ,sysdate
         ,TrialId
         ,'CONCEPT_DIMENSION'
    from (select distinct c.leaf_node
                ,to_char(c.node_name) as node_name
          from wt_trial_nodes c
          where not exists
            (select 1 from concept_dimension x
            where c.leaf_node = x.concept_path)
         ) x;
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted new leaf nodes into I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    update i2b2 to pick up change in name, data_type for leaf nodes
    
    update /*+ parallel(i2b2, 8) */ i2b2 b
    set (c_name, c_columndatatype, c_metadataxml)=
        (select t.node_name, t.data_type
         ,case when t.data_type = 'T'
               then null
               else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
          end
         from wt_trial_nodes t
         where b.c_fullname = t.leaf_node
           and (b.c_name != t.node_name or b.c_columndatatype != t.data_type))
    where exists
        (select 1 from wt_trial_nodes x
         where b.c_fullname = x.leaf_node
           and (b.c_name != x.node_name or b.c_columndatatype != x.data_type));
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Updated name and data type in i2b2 if changed',SQL%ROWCOUNT,stepCt,'Done');
    commit;
               
    insert /*+ parallel(i2b2, 8) */ into I2B2
    (c_hlevel
    ,c_fullname
    ,c_name
    ,c_visualattributes
    ,c_synonym_cd
    ,c_facttablecolumn
    ,c_tablename
    ,c_columnname
    ,c_dimcode
    ,c_tooltip
    ,update_date
    ,download_date
    ,import_date
    ,sourcesystem_cd
    ,c_basecode
    ,c_operator
    ,c_columndatatype
    ,c_comment
    ,i2b2_id
    ,c_metadataxml
    )
    select /*+ parallel(concept_dimension, 8) */  (length(c.concept_path) - nvl(length(replace(c.concept_path, '\')),0)) / length('\') - 2 + root_level
          ,c.concept_path
          ,c.name_char
          ,'LA'
          ,'N'
          ,'CONCEPT_CD'
          ,'CONCEPT_DIMENSION'
          ,'CONCEPT_PATH'
          ,c.concept_path
          ,c.concept_path
          ,sysdate
          ,sysdate
          ,sysdate
          ,c.sourcesystem_cd
          ,c.concept_cd
          ,'LIKE'
          ,'T'        -- if i2b2 gets fixed to respect c_columndatatype then change to t.data_type
          ,'trial:' || TrialID 
          ,i2b2_id_seq.nextval
          ,case when t.data_type = 'T' then null
           else '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
           end
    from concept_dimension c
        ,wt_trial_nodes t
    where c.concept_path = t.leaf_node
      and not exists
         (select 1 from i2b2 x
          where c.concept_path = x.c_fullname);
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted leaf nodes into I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;    
    
      i2b2_fill_in_tree(TrialId, topNode, jobID);
    
    commit;
  
  
    --21 July 2013. Performace fix by TR. Drop complicated index before data manipulation
  --execute immediate('DROP INDEX "I2B2DEMODATA"."OB_FACT_PK"');
  --execute immediate('DROP INDEX "I2B2DEMODATA"."IDX_OB_FACT_1"');
  --execute immediate('DROP INDEX "I2B2DEMODATA"."IDX_OB_FACT_2"');
  --execute immediate('DROP INDEX "I2B2DEMODATA"."OF_CTX_BLOB"'); 
  
    --    delete from observation_fact all concept_cds for trial that are clinical data, exclude concept_cds from biomarker data
    
    delete /*+ parallel(observation_fact, 4) */ from OBSERVATION_FACT F
    where f.modifier_cd = TrialId
      and F.CONCEPT_CD not in
         (select /*+ parallel(de_subject_sample_mapping, 4) */ distinct concept_code as concept_cd from de_subject_sample_mapping
          where trial_name = TrialId
            and concept_code is not null
          union
          select /*+ parallel(de_subject_sample_mapping, 4) */ distinct platform_cd as concept_cd from de_subject_sample_mapping
          where trial_name = TrialId
            and platform_cd is not null
          union
          select /*+ parallel(de_subject_sample_mapping, 4) */ distinct sample_type_cd as concept_cd from de_subject_sample_mapping
          where trial_name = TrialId
            and sample_type_cd is not null
          union
          select /*+ parallel(de_subject_sample_mapping, 4) */ distinct tissue_type_cd as concept_cd from de_subject_sample_mapping
          where trial_name = TrialId
            and tissue_type_cd is not null
          union
          select /*+ parallel(de_subject_sample_mapping, 4) */ distinct timepoint_cd as concept_cd from de_subject_sample_mapping
          where trial_name = TrialId
            and timepoint_cd is not null
          union
          select /*+ parallel(de_subject_sample_mapping, 4) */ distinct concept_cd as concept_cd from de_subject_snp_dataset
          where trial_name = TrialId
            and concept_cd is not null);
          
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete clinical data for study from observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    COMMIT;          
    
    --Insert into observation_fact
    --22 July 2013. Performace fix by TR. Set nologging.
    insert /*+ APPEND */ into observation_fact nologging
    (patient_num,
     concept_cd,
     modifier_cd,
     valtype_cd,
     tval_char,
     nval_num,
     sourcesystem_cd,
     import_date,
     valueflag_cd,
     PROVIDER_ID,
     location_cd,
     instance_num
    )
    select /*+ parallel(wrk_clinical_data, 4) */ distinct c.patient_num,
           i.c_basecode,
           a.study_id,
           a.data_type,
           case when a.data_type = 'T' then a.data_value
                else 'E'  --Stands for Equals for numeric types
                end,
           case when a.data_type = 'N' then a.data_value
                else null --Null for text types
                end,
           c.sourcesystem_cd, 
          sysdate, 
           '@',
           '@',
           '@',
       1
    from wrk_clinical_data a
        ,patient_dimension c
        ,wt_trial_nodes t
        ,i2b2 i
    where a.usubjid = c.sourcesystem_cd
      and nvl(a.category_cd,'@') = nvl(t.category_cd,'@')
      and nvl(a.data_label,'**NULL**') = nvl(t.data_label,'**NULL**')
      and nvl(a.visit_name,'**NULL**') = nvl(t.visit_name,'**NULL**')
      and decode(a.data_type,'T',a.data_value,'**NULL**') = nvl(t.data_value,'**NULL**')
      and t.leaf_node = i.c_fullname
      and not exists        -- don't insert if lower level node exists
         (select 1 from wt_trial_nodes x
          --where x.leaf_node like t.leaf_node || '%_'
          --Jule 2013. Performance fix by TR. Find if any leaf parent node is current
           where (SUBSTR(x.leaf_node, 1, INSTR(x.leaf_node, '\', -2))) = t.leaf_node
          
          )
      and a.data_value is not null;  
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
    
    commit;

    
    
    --July 2013. Performance fix by TR. Prepare precompute tree
    
    I2B2_CREATE_FULL_TREE(topNode, jobId);
    
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Create i2b2 full tree',SQL%ROWCOUNT,stepCt,'Done');
    commit;
  
      --July 2013. Performance fix by TR.
   execute immediate('truncate table TM_WZ.I2B2_LOAD_PATH_WITH_COUNT'); 
   
   insert into TM_WZ.i2b2_load_path_with_count  
   select /*+ parallel(4) */ p.c_fullname, count(*) 
                 from i2b2 p
                    --,i2b2 c
                    ,TM_WZ.I2B2_LOAD_TREE_FULL tree
                 where p.c_fullname like topNode || '%'
                   --and c.c_fullname like p.c_fullname || '%'
                    and p.rowid = tree.IDROOT 
                    --and c.rowid = tree.IDCHILD
                 group by P.C_FULLNAME;
    
    commit;
  execute immediate('analyze table TM_WZ.I2B2_LOAD_PATH_WITH_COUNT compute statistics');
  execute immediate('analyze table I2B2METADATA.I2B2 compute statistics');
  
      stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Create i2b2 load path with count',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    update c_visualattributes for all nodes in study, done to pick up node that changed from leaf/numeric to folder/text
        --July 2013. Performance fix by TR. join by precompute tree
    update /*+ parallel(i2b2, 4) */ i2b2 a
    set C_VISUALATTRIBUTES=( 
        select case when u.nbr_children = 1 
                    then 'L' || substr(a.c_visualattributes,2,2)
                    else 'F' || substr(a.c_visualattributes,2,1) ||
                         case when u.c_fullname = topNode and highlight_study = 'Y'
                              then 'J' else substr(a.c_visualattributes,3,1) end
               end
        from TM_WZ.i2b2_load_path_with_count u
        where a.c_fullname = u.c_fullname)
    where EXISTS
        (select 1 from i2b2 x
         where x.c_fullname like topNode || '%' AND a.c_fullname = x.c_fullname);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Update c_visualattributes for study',SQL%ROWCOUNT,stepCt,'Done');

    commit;
    
    -- final procs
  
--    i2b2_fill_in_tree(TrialId, topNode, jobID);
    
    --    set sourcesystem_cd, c_comment to null if any added upper-level nodes
        
    update i2b2 b
    set sourcesystem_cd=null,c_comment=null
    where b.sourcesystem_cd = TrialId
      and length(b.c_fullname) < length(topNode);
      
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper-level nodes',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    i2b2_create_concept_counts_tr(topNode, jobID, 'N');
    
    --    delete each node that is hidden after create concept counts
    
     FOR r_delNodes in delNodes Loop

    --    deletes hidden nodes for a trial one at a time

        i2b2_delete_1_node(r_delNodes.c_fullname);
        stepCt := stepCt + 1;
        tText := 'Deleted node: ' || r_delNodes.c_fullname;
        
        cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');

    END LOOP;      

    i2b2_create_security_for_trial(TrialId, secureStudy, jobID);
    i2b2_load_security_data_tr(jobID);
 
    -- --21 July 2013. Performace fix by TR. re create dropped index
   --execute immediate('CREATE UNIQUE INDEX "I2B2DEMODATA"."OB_FACT_PK" ON "I2B2DEMODATA"."OBSERVATION_FACT" ("ENCOUNTER_NUM", "PATIENT_NUM", "CONCEPT_CD", "PROVIDER_ID", "START_DATE", "MODIFIER_CD")');
   --execute immediate('CREATE INDEX "I2B2DEMODATA"."IDX_OB_FACT_1" ON "I2B2DEMODATA"."OBSERVATION_FACT" ( "CONCEPT_CD" )');
   --execute immediate('CREATE INDEX "I2B2DEMODATA"."IDX_OB_FACT_2" ON "I2B2DEMODATA"."OBSERVATION_FACT" ("CONCEPT_CD", "PATIENT_NUM", "ENCOUNTER_NUM")');
   --execute immediate('CREATE INDEX "I2B2DEMODATA"."OF_CTX_BLOB" ON "I2B2DEMODATA"."OBSERVATION_FACT"("OBSERVATION_BLOB") INDEXTYPE IS "CTXSYS"."CONTEXT" PARAMETERS (''SYNC (on commit)'')');
   
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_clinical_data',0,stepCt,'Done');
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
    if newJobFlag = 1
    then
        cz_end_audit (jobID, 'SUCCESS');
    end if;

    rtnCode := 0;
  
    exception
    when duplicate_values then
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Duplicate values found in key columns',0,stepCt,'Done');    
        cz_error_handler (jobID, procedureName);
        cz_end_audit (jobID, 'FAIL');
        rtnCode := 16;        
    when invalid_topNode then
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Path specified in top_node must contain at least 2 nodes',0,stepCt,'Done');    
        cz_error_handler (jobID, procedureName);
        cz_end_audit (jobID, 'FAIL');
        rtnCode := 16;    
    when multiple_visit_names then
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Multiple visit_names exist for category/label/value',0,stepCt,'Done');    
        cz_error_handler (jobID, procedureName);
        cz_end_audit (jobID, 'FAIL');
        rtnCode := 16;
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
        rtnCode := 16;
    
end;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_COMPOUND_METADATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_COMPOUND_METADATA" 
(
  currentJobID NUMBER := null
)
AS
	--	NOTE****	The compound.txt file must have the LF's cleaned from data (Run CleanCells macro before exporting to tab-delimited file)
	-- JEA@20110720	New, cloned for tranSMART consortia
  
	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

BEGIN
    
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;

	--	Update existing compound data by generic_names, cnto_number, jnj_number or cas_registry
	
	update biomart.bio_compound b
	set (cas_registry
		,code_name
		,brand_name
		,chemical_name
		,mechanism
		,product_category
		,description
		) = (select trim('"' from c.cas_registry)
				   ,trim('"' from c.code_name)
				   ,trim('"' from c.brand_name)
				   ,trim('"' from c.chemical_name)
				   ,trim('"' from c.mechanism)
				   ,trim('"' from c.product_category)
				   ,trim('"' from c.description)
			 from control.compound_extrnl c
			 where (c.generic_name is not null
					and b.generic_name = c.generic_name)
				or (c.cas_registry is not null
					and b.cas_registry = c.cas_registry)
			)
		where (b.generic_name is not null
			   and exists
			   (select 1 from control.compound_extrnl c
			    where b.generic_name = c.generic_name
			      and c.generic_name is not null
			   ))
		  or (b.cas_registry is not null
			  and exists
			  (select 1 from control.compound_extrnl c
			   where b.cas_registry = c.cas_registry
			     and c.cas_registry is not null
			  ))
	;
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated compound in BIOMART bio_compound',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	Add new compound to bio_compound
	
	insert into biomart.bio_compound b
	(cas_registry
	,code_name
	,generic_name
	,brand_name
	,chemical_name
	,mechanism
	,product_category
	,description
	,etl_id
	)
	select trim('"' from c.cas_registry)
		  ,trim('"' from c.code_name)
		  ,trim('"' from c.generic_name)
		  ,trim('"' from c.brand_name)
		  ,trim('"' from c.chemical_name)
		  ,trim('"' from c.mechanism)
		  ,trim('"' from c.product_category)
		  ,replace(trim('"' from c.description),'""','"')
		  ,to_char(sysdate,'YYYY/MM/DD HH:mm:SS')
	from control.compound_extrnl c
	where (c.generic_name is not null or
		   c.cas_registry is not null)
	  and not exists
		   (select 1 from biomart.bio_compound xb
		    where xb.generic_name = c.generic_name)
	  and not exists
		   (select 1 from biomart.bio_compound wb
		    where wb.cas_registry = c.cas_registry)
	;
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Inserted compound into BIOMART bio_compound',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

    ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;

	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		
		--End Proc
		cz_end_audit (jobID, 'FAIL');
	
END;
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_EQTL_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_EQTL_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_eqtl_top50
        
        delete from biomart.bio_asy_analysis_eqtl_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_eqtls_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for eqtl_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
        loop
                v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_eqtl_top50
        
        insert into biomart.bio_asy_analysis_eqtl_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,a.gene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.gene
                                ,b.cis_trans
                                ,b.distance_from_gene
                                ,b.rnum
                 from (select eqtl.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,eqtl.rs_id as rsid
                                         ,eqtl.p_value as pvalue
                                         ,eqtl.log_p_value as logpvalue
                                         ,eqtl.ext_data as extdata
                                         ,eqtl.gene
                                         ,eqtl.cis_trans
                                         ,eqtl.distance_from_gene
                                         ,row_number () over (order by eqtl.p_value asc, eqtl.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_eqtl eqtl 
                          inner join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = eqtl.bio_assay_analysis_id
                          where eqtl.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        inner join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_eaqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 

/*
        --        rebuild indexes
        
        for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
*/

        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
                
END I2B2_LOAD_eqtl_TOP50;        

/*
execute immediate ('drop table biomart.tmp_analysis_count_eqtl');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_count_eqtl as
select count(*) as total, bio_assay_analysis_id
from biomart.bio_assay_analysis_eqtl
group by bio_assay_analysis_id');


execute immediate ('update biomart.bio_assay_analysis b
set b.data_count = (select a.total from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id)
where exists(
select 1 from biomart.tmp_analysis_count_eqtl  a where a.bio_assay_analysis_id =  b.bio_assay_analysis_id
)');

--select * from bio_assay_analysis_eqtl 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_eqtl_top500
--where bio_assay_analysis_id = 419842521
--order by p_value asc;

BEGIN
execute immediate ('drop table biomart.tmp_analysis_eqtl_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.tmp_analysis_eqtl_top500 
as
select a.* 
from (
select 
bio_asy_analysis_eqtl_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
gene,
cis_trans,
distance_from_gene,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from biomart.bio_assay_analysis_eqtl
) a
where 
a.rnum <=500');

execute immediate ('create index BIOMART.t_a_ge_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(RS_ID) tablespace "INDX"');
execute immediate ('create index BIOMART.t_a_gae_t500_idx on BIOMART.TMP_ANALYSIS_eqtl_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate ('drop table biomart.bio_asy_analysis_eqtl_top50 cascade constraints');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate ('create table biomart.BIO_ASY_ANALYSIS_eqtl_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue, data.gene as gene,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_eqtl_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id');

--execute immediate ('select count(*) from BIO_ASY_ANALYSIS_eqtl_TOP50');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate ('create index BIOMART.B_ASY_eqtl_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_eqtl_TOP50(ANALYSIS) parallel tablespace "INDX"');

END I2B2_LOAD_EQTL_TOP50;

*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_FROM_RELEASE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_FROM_RELEASE" 
(
  trial_id IN VARCHAR2
 ,ont_Path IN VARCHAR2
 ,currentJobID NUMBER := null
 )
AS

	TrialId 	varchar2(200);
	ontPath 	varchar2(200);
	msgText 	varchar2(1000);
	
	sqlText 	varchar2(2000);
	tExists 	number;
	returnCode 	number;
	gotSNP		integer;
	StudyType	varchar2(100);

	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

	--	JEA@20100624	Removed gene_symbol, changed probeset to probeset_id in de_subject_microarray_data,
	--					added de_mrna_annotation load (complete reload, not tied to study)
	--	JEA@20100625	Changed check if partition exists from count of records to entry in all_tab_partitions table
	--	JEA@20100901	Added insert into i2b2_tags
	--	JEA@20100903	Added haploview_data insert
	--	JEA@20100908	Added i2b2_id to i2b2
	--	JEA@20101013	Added de_gpl_info insert
	--	JEA@20101202	Added rbm_panel to de_subj_sample_map_release and de_subject_rbm_data_release
	--	JEA@20110125	Added deapp SNP tables 
	
BEGIN

	TrialID := upper(trial_id);
	ontPath := ont_path;
	
	select parse_nth_value(ontPath,2,'\') into StudyType
	from dual;

	stepCt := 0;

	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_from_release',0,stepCt,'Done');
	stepCt := stepCt + 1;
	msgText := 'Loading trial: ' || TrialId || ' path: ' || ontPath;
	cz_write_audit(jobId,databaseName,procedureName, msgText,0,stepCt,'Done');
	stepCt := stepCt + 1;

	--	Delete trial from target tables

	i2b2_delete_all_nodes(ontPath, jobId);
/*
	delete from i2b2metadata.i2b2
	where c_fullname like ontPath || '%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete from i2b2demodata.concept_dimension
	where concept_path like ontPath || '%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	delete from i2b2demodata.observation_fact
	where modifier_cd = TrialId;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	commit;
*/

	delete from i2b2demodata.observation_fact
	where modifier_cd = TrialId
	  and concept_cd = 'SECURITY';

	cz_write_audit(jobId,databaseName,procedureName,'Deleted SECURITY for trial from I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;
	  
	delete from i2b2demodata.patient_dimension
	where sourcesystem_cd like TrialId || '%';

	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from I2B2DEMODATA patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	delete from deapp.de_subject_sample_mapping
	where trial_name = TrialId;
	
	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	--	create or truncate partition in de_subject_microarray_data

	tExists := 0;
	
	select count(*) 
	into tExists
	from all_tab_partitions
	where table_owner = 'DEAPP'
	  and table_name = 'DE_SUBJECT_MICROARRAY_DATA'
	  and partition_name = TrialId;

	if tExists = 0 then

--	needed to add partition to deapp.de_subject_microarray_data

		sqlText := 'alter table deapp.de_subject_microarray_data add PARTITION "' || TrialID || '"  VALUES (' || '''' || TrialID || '''' || ') ' ||
                   'PCTFREE 0 PCTUSED 40 INITRANS 1 MAXTRANS 255  NOLOGGING ' ||
				   'STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645 ' ||
				   'PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT) ' ||
				   'TABLESPACE "DEAPP" COMPRESS ';
		execute immediate(sqlText);
       
	    cz_write_audit(jobId,databaseName,procedureName,'Adding partition to DEAPP de_subject_microarray_data',0,stepCt,'Done');
		stepCt := stepCt + 1;

	else
		sqlText := 'alter table deapp.de_subject_microarray_data truncate partition ' || TrialID;
		execute immediate(sqlText);
		
	    cz_write_audit(jobId,databaseName,procedureName,'Truncate partition in DEAPP de_subject_microarray_data',0,stepCt,'Done');
		stepCt := stepCt + 1;

	end if;

	delete from deapp.de_subject_rbm_data
	where trial_name = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from DEAPP de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	delete from deapp.de_subject_protein_data
	where trial_name = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from DEAPP de_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	delete from deapp.haploview_data
	where trial_name = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from DEAPP haploview',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	delete from i2b2_tags
	where path like ontPath || '%';

	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	delete from biomart.bio_data_compound t
	where t.bio_data_id =
	     (select distinct x.bio_experiment_id from bio_experiment_release x
		  where x.accession = Trialid);

	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from BIOMART bio_data_compound',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	delete from deapp.de_subject_snp_dataset
	where trial_name = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from DEAPP de_subject_snp_dataset',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	delete from deapp.de_snp_data_by_patient
	where trial_name = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from DEAPP de_snp_data_by_patient',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	delete from deapp.de_snp_data_dataset_loc
	where trial_name = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from DEAPP de_snp_data_dataset_loc',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	delete from deapp.de_snp_data_by_probe
	where trial_name = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from DEAPP de_snp_data_by_probe',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;
  
	select count(*) into gotSNP
	from deapp.de_snp_data_by_patient;
	
	if gotSNP > 0 then 
		-- Remove constraints before truncating data
		execute immediate('alter table DE_SNP_INFO DISABLE constraint U_SNP_INFO_NAME;');
		execute immediate('alter table DE_SNP_PROBE DISABLE constraint U_SNP_PROBE_NAME;');
		execute immediate('alter table DE_SNP_GENE_MAP DISABLE constraint FK_SNP_GENE_MAP_SNP_ID;');
		execute immediate('alter table DE_SNP_DATA_BY_PROBE DISABLE constraint FK_SNP_BY_PROBE_SNP_ID;');
		execute immediate('alter table DE_SNP_PROBE DISABLE constraint FK_SNP_PROBE_SNP_ID;');
		execute immediate('alter table DE_SNP_INFO DISABLE constraint SYS_C0045667;');

		cz_write_audit(jobId,databaseName,procedureName,'Disabled constraints from SNP tables',SQL%ROWCOUNT,stepCt,'Done');
		commit;
		stepCt := stepCt + 1;
		
		execute immediate('truncate table deapp.de_snp_info');

		cz_write_audit(jobId,databaseName,procedureName,'Truncate table DEAPP de_snp_info',SQL%ROWCOUNT,stepCt,'Done');
		stepCt := stepCt + 1;
	
		execute immediate('truncate table deapp.de_snp_probe');

		cz_write_audit(jobId,databaseName,procedureName,'Truncate table DEAPP de_snp_probe',SQL%ROWCOUNT,stepCt,'Done');
		stepCt := stepCt + 1;
	
		execute immediate('truncate table deapp.de_snp_gene_map');

		cz_write_audit(jobId,databaseName,procedureName,'Truncate table DEAPP de_snp_gene_map',SQL%ROWCOUNT,stepCt,'Done');
		stepCt := stepCt + 1;
	
		execute immediate('truncate table deapp.de_snp_probe_sorted_def');

		cz_write_audit(jobId,databaseName,procedureName,'Truncate table DEAPP de_snp_probe_sorted_def',SQL%ROWCOUNT,stepCt,'Done');
		end if;

	execute immediate('truncate table deapp.de_mrna_annotation');

	cz_write_audit(jobId,databaseName,procedureName,'Truncate table DEAPP de_mrna_annotation',SQL%ROWCOUNT,stepCt,'Done');
	stepCt := stepCt + 1;
	
	execute immediate('truncate table deapp.de_gpl_info');

	cz_write_audit(jobId,databaseName,procedureName,'Truncate table DEAPP de_gpl_info',SQL%ROWCOUNT,stepCt,'Done');
	stepCt := stepCt + 1;
	
	execute immediate('truncate table i2b2demodata.sample_categories');

	cz_write_audit(jobId,databaseName,procedureName,'Truncate table I2B2DEMODATA sample_categories',SQL%ROWCOUNT,stepCt,'Done');
	stepCt := stepCt + 1;
		
	--	bio_experiment, bio_clinical_trial: only insert or update columns
	--	bio_data_uid: only insert new
	--	search_secure_object: insert new

	--	Insert release trial into target tables

	insert into i2b2metadata.i2b2
	(c_hlevel
	,c_fullname
	,c_name
	,c_synonym_cd
	,c_visualattributes
	,c_totalnum
	,c_basecode
	,c_metadataxml
	,c_facttablecolumn
	,c_tablename
	,c_columnname
	,c_columndatatype
	,c_operator
	,c_dimcode
	,c_comment
	,c_tooltip
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,valuetype_cd
	,i2b2_id
	)
	select c_hlevel
		  ,c_fullname
		  ,c_name
		  ,c_synonym_cd
		  ,c_visualattributes
		  ,c_totalnum
		  ,c_basecode
		  ,c_metadataxml
		  ,c_facttablecolumn
		  ,c_tablename
		  ,c_columnname
		  ,c_columndatatype
		  ,c_operator
		  ,c_dimcode
		  ,c_comment
		  ,c_tooltip
		  ,update_date
		  ,download_date
		  ,import_date
		  ,sourcesystem_cd
		  ,valuetype_cd
		  ,i2b2_id
	from i2b2_release
	where release_study = TrialId;
	
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into i2b2demodata.concept_dimension
	(concept_cd
	,concept_path
	,name_char
	,concept_blob
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,upload_id
	,table_name
	)
	select concept_cd
		  ,concept_path
		  ,name_char
		  ,concept_blob
		 ,update_date
		  ,download_date
		  ,import_date
		  ,sourcesystem_cd
		  ,upload_id
		  ,table_name
	from concept_dimension_release
	where release_study = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into i2b2demodata.patient_dimension
	(patient_num
	,vital_status_cd
	,birth_date
	,death_date
	,sex_cd
	,age_in_years_num
	,language_cd
	,race_cd
	,marital_status_cd
	,religion_cd
	,zip_cd
	,statecityzip_path
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,upload_id
	,patient_blob
	)
	select patient_num
		  ,vital_status_cd
		  ,birth_date
		  ,death_date
		  ,sex_cd
		  ,age_in_years_num
		  ,language_cd
		  ,race_cd
		  ,marital_status_cd
		  ,religion_cd
		  ,zip_cd
		  ,statecityzip_path
		  ,update_date
		  ,download_date
		  ,import_date
		  ,sourcesystem_cd
		  ,upload_id
		  ,patient_blob
	from patient_dimension_release
	where release_study = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into I2B2DEMODATA patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into i2b2demodata.observation_fact
	(encounter_num
	,patient_num
	,concept_cd
	,provider_id
	,start_date
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,valueflag_cd
	,quantity_num
	,units_cd
	,end_date
	,location_cd
	,confidence_num
	,update_date
	,download_date
	,import_date
	,sourcesystem_cd
	,upload_id
	,observation_blob
	)
	select encounter_num
		  ,patient_num
		  ,concept_cd
		  ,provider_id
		  ,start_date
		  ,modifier_cd
		  ,valtype_cd
		  ,tval_char
		  ,nval_num
		  ,valueflag_cd
		  ,quantity_num
		  ,units_cd
		  ,end_date
		  ,location_cd
		  ,confidence_num
		  ,update_date
		  ,download_date
		  ,import_date
		  ,sourcesystem_cd
		  ,upload_id
		  ,observation_blob
	from observation_fact_release
	where release_study = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into i2b2metadata.i2b2_tags
	(path
	,tag
	,tag_type
	)
	select path
		  ,tag
		  ,tag_type
	from i2b2_tags_release
	where release_study = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;
	
	insert into tm_lz.lz_src_sample_categories
	(trial_cd
	,site_cd
	,subject_cd
	,sample_cd
	,category_cd
	,category_value)
	select trial_cd
		  ,site_cd
		  ,subject_cd
		  ,sample_cd
		  ,category_cd
		  ,category_value
	from sample_categories_release
	where release_study = Trialid;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into I2B2DEMODATA sample_categories',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;
		
	insert into deapp.de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,patient_uid
	,sample_type
	,assay_uid
	,trial_name
	,timepoint
	,timepoint_cd
	,sample_type_cd
	,tissue_type_cd
	,platform
	,platform_cd
	,tissue_type
	,data_uid
	,gpl_id
	,rbm_panel
	)
	select patient_id
		  ,site_id
		  ,subject_id
		  ,subject_type
		  ,concept_code
		  ,assay_id
		  ,patient_uid
		  ,sample_type
		  ,assay_uid
		  ,trial_name
		  ,timepoint
		  ,timepoint_cd
		  ,sample_type_cd
		  ,tissue_type_cd
		  ,platform
		  ,platform_cd
		  ,tissue_type
		  ,data_uid
		  ,gpl_id
		  ,rbm_panel
	from de_subj_sample_map_release
	where release_study = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	select count(*) into tExists
	from de_subject_mrna_data_release
	where release_study = TrialId;

	if tExists > 20000000 then
		i2b2_mrna_index_maint('DROP',jobId);

		cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on DEAPP de_subject_microarray_data',0,stepCt,'Done');
		stepCt := stepCt + 1;
	else
		
		cz_write_audit(jobId,databaseName,procedureName,'Less than 20M records, index drop bypassed',0,stepCt,'Done');
		stepCt := stepCt + 1;
	end if;

	insert into deapp.de_subject_microarray_data
	(trial_name
	,assay_id
	,patient_id
	,probeset_id
	,timepoint
	,pvalue
	,refseq
	,subject_id
	,raw_intensity
	,log_intensity
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	)
	select trial_name
	      ,assay_id
	      ,patient_id
	      ,probeset_id
	      ,timepoint
	      ,pvalue
	      ,refseq
	      ,subject_id
	      ,raw_intensity
	      ,log_intensity
	      ,mean_intensity
	      ,stddev_intensity
	      ,median_intensity
	      ,zscore
	from de_subject_mrna_data_release
	where release_study = TrialID
	order by trial_name
            ,assay_id
            ,probeset_id;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into DEAPP de_subject_microarray_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	if tExists > 20000000 then
		i2b2_mrna_index_maint('Add',jobId);
	
		cz_write_audit(jobId,databaseName,procedureName,'Add indexes on DEAPP de_subject_microarray_data',0,stepCt,'Done');
		stepCt := stepCt + 1;
	end if;

	insert into deapp.de_subject_rbm_data
	(trial_name
	,antigen_name
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,normalized_value
	,concept_cd
	,timepoint
	,data_uid
	,value
	,log_intensity
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,rbm_panel
	)
	select trial_name
		  ,antigen_name
		  ,n_value
		  ,patient_id
		  ,gene_symbol
		  ,gene_id
		  ,assay_id
		  ,normalized_value
		  ,concept_cd
		  ,timepoint
		  ,data_uid
		  ,value
		  ,log_intensity
		  ,mean_intensity
		  ,stddev_intensity
		  ,median_intensity
		  ,zscore
		  ,rbm_panel
	from de_subject_rbm_data_release
	where release_study = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into DEAPP de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into deapp.de_subject_protein_data
	(trial_name
	,component
	,intensity
	,patient_id
	,subject_id
	,gene_symbol
	,gene_id
	,assay_id
	,timepoint
	,n_value
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	)
	select trial_name
		  ,component
		  ,intensity
		  ,patient_id
		  ,subject_id
		  ,gene_symbol
		  ,gene_id
		  ,assay_id
		  ,timepoint
		  ,n_value
		  ,mean_intensity
		  ,stddev_intensity
		  ,median_intensity
		  ,zscore
	from de_subj_protein_data_release
	where release_study = TrialId;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into DEAPP de_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into deapp.haploview_data
	(i2b2_id
	,jnj_id
	,father_id
	,mother_id
	,sex
	,affection_status
	,chromosome
	,gene
	,release
	,release_date
	,trial_name
	,snp_data
	)
	select i2b2_id
	,jnj_id
	,father_id
	,mother_id
	,sex
	,affection_status
	,chromosome
	,gene
	,release
	,release_date
	,trial_name
	,snp_data
	from haploview_data_release
	where release_study = TrialId;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into DEAPP haploview_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into biomart.bio_experiment
	(bio_experiment_id
	,bio_experiment_type
	,title
	,description
	,design
	,start_date
	,completion_date
	,primary_investigator
	,contact_field
	,etl_id
	,status
	,overall_design
	,accession)
	select m.bio_experiment_id
		  ,m.bio_experiment_type
	      ,m.title
		  ,m.description
		  ,m.design
		  ,m.start_date
		  ,m.completion_date
		  ,m.primary_investigator
		  ,m.contact_field
		  ,m.etl_id
		  ,m.status
		  ,m.overall_design
		  ,m.accession
	from bio_experiment_release m
	    ,i2b2metadata.i2b2 md
	where m.release_study = TrialId
	  and not exists
	      (select 1 from biomart.bio_experiment x
		   where x.accession = TrialId)
	  and not exists
	      (select 1 from biomart.bio_experiment x
		   where x.bio_experiment_id = m.bio_experiment_id)
	  and m.accession = md.sourcesystem_cd
	  and md.c_hlevel = 0;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data in BIOMART bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	update biomart.bio_experiment b
	set (bio_experiment_type
	    ,title
	    ,description
		,design
		,start_date
		,completion_date
		,primary_investigator
		,contact_field
		,etl_id
		,status
		,overall_design) =
	    (select distinct m.bio_experiment_type
		       ,m.title
		       ,m.description
			   ,m.design
			   ,m.start_date
			   ,m.completion_date
			   ,m.primary_investigator
			   ,m.contact_field
			   ,m.etl_id
			   ,m.status
			   ,m.overall_design
		 from bio_experiment_release m
			 ,i2b2metadata.i2b2 md
		 where m.release_study = TrialId
		   and b.accession = m.accession
		   and md.sourcesystem_cd = TrialId
		   and md.c_hlevel = 0)
	where b.accession = TrialId
	  and exists
	      (select 1 from bio_experiment_release x
		   where x.release_study = TrialId);

	cz_write_audit(jobId,databaseName,procedureName,'Updated trial data in BIOMART bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into biomart.bio_clinical_trial
	(trial_number
	,study_owner
	,study_phase
	,blinding_procedure
	,studytype
	,duration_of_study_weeks
	,number_of_patients
	,number_of_sites
	,route_of_administration
	,dosing_regimen
	,group_assignment
	,type_of_control
	,completion_date
	,primary_end_points
	,secondary_end_points
	,inclusion_criteria
	,exclusion_criteria
	,subjects
	,gender_restriction_mfb
	,min_age
	,max_age
	,secondary_ids
	,bio_experiment_id
	,development_partner
	,main_findings
	,geo_platform
	,platform_name
	,search_area
	)
	select m.trial_number
          ,m.study_owner
          ,m.study_phase
          ,m.blinding_procedure
          ,m.studytype
		  ,m.duration_of_study_weeks
		  ,m.number_of_patients
		  ,m.number_of_sites
          ,m.route_of_administration
          ,m.dosing_regimen
          ,m.group_assignment
          ,m.type_of_control
          ,m.completion_date
          ,m.primary_end_points
          ,m.secondary_end_points
          ,m.inclusion_criteria
          ,m.exclusion_criteria
          ,m.subjects
          ,m.gender_restriction_mfb
		  ,m.min_age
		  ,m.max_age
          ,m.secondary_ids
          ,m.bio_experiment_id
		  ,m.development_partner
		  ,m.main_findings
		  ,m.geo_platform
		  ,m.platform_name
		  ,m.search_area
	from bio_clinical_trial_release m
		,i2b2metadata.i2b2 md
	where m.release_study = TrialId
	  and not exists
	      (select 1 from biomart.bio_clinical_trial x
		   where x.trial_number = TrialId)
	  and md.sourcesystem_cd = TrialId
	  and md.c_hlevel = 0
	  and (parse_nth_value(md.c_fullname,2,'\') = 'Clinical Trials' or
		   (parse_nth_value(md.c_fullname,2,'\') = 'Experimental Medicine Study' and substr(m.release_study,1,1) = 'C')
          );
	
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data in BIOMART bio_clinical_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	update biomart.bio_clinical_trial b
	set (study_owner
	    ,study_phase
		,blinding_procedure
		,studytype
		,duration_of_study_weeks
		,number_of_patients
		,number_of_sites
		,route_of_administration
		,dosing_regimen
		,group_assignment
		,type_of_control
		,completion_date
		,primary_end_points
		,secondary_end_points
		,inclusion_criteria
		,exclusion_criteria
		,subjects
		,gender_restriction_mfb
		,min_age
		,max_age
		,secondary_ids
		,development_partner
		,main_findings
		,geo_platform
		,platform_name
		,search_area
        ) =
		(select m.study_owner
			   ,m.study_phase
			   ,m.blinding_procedure
			   ,m.studytype
			   ,m.duration_of_study_weeks
			   ,m.number_of_patients
			   ,m.number_of_sites
			   ,m.route_of_administration
			   ,m.dosing_regimen
			   ,m.group_assignment
			   ,m.type_of_control
			   ,m.completion_date
			   ,m.primary_end_points
			   ,m.secondary_end_points
			   ,m.inclusion_criteria
			   ,m.exclusion_criteria
			   ,m.subjects
			   ,m.gender_restriction_mfb
			   ,m.min_age
			   ,m.max_age
			   ,m.secondary_ids
			   ,m.development_partner
			   ,m.main_findings
			   ,m.geo_platform
			   ,m.platform_name
			   ,m.search_area
		 from bio_clinical_trial_release m
		 where m.release_study = TrialId
		)
	where b.trial_number = TrialId
	  and exists
		  (select 1 from bio_clinical_trial_release x
		   where x.release_study = TrialId);

	cz_write_audit(jobId,databaseName,procedureName,'Updated trial data in BIOMART bio_clinical_trial',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into biomart.bio_data_uid
	(bio_data_id
	,unique_id
	,bio_data_type
	)
	select b.bio_data_id
	      ,b.unique_id
		  ,b.bio_data_type
	from bio_data_uid_release b
	where b.release_study = TrialId
	  and not exists
	      (select 1 from biomart.bio_data_uid x
		   where b.bio_data_id = x.bio_data_id);
	
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data into BIOMART bio_data_uid',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into biomart.bio_data_compound
	(bio_data_id
	,bio_compound_id
	,etl_source
	)
	select b.bio_data_id
	      ,b.bio_compound_id
		  ,b.etl_source
	from bio_data_compound_release b
	where b.release_study = TrialId
	  and exists
	      (select 1 from biomart.bio_data_compound x
		   where b.bio_compound_id = x.bio_compound_id);

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data into BIOMART bio_data_compound',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	stepCt := stepCt + 1;

	insert into searchapp.search_secure_object
	(search_secure_object_id
	,bio_data_id
	,display_name
	,data_type
	,bio_data_unique_id
	)
	select b.search_secure_object_id
	      ,b.bio_data_id
		  ,b.display_name
		  ,b.data_type
		  ,b.bio_data_unique_id
	from search_secure_object_release b
	where b.release_study = TrialId
	  and exists
	      (select 1 from biomart.bio_experiment x
		   where b.bio_data_id = x.bio_experiment_id)
	  and not exists
	      (select 1 from searchapp.search_secure_object y
		   where b.search_secure_object_id = y.search_secure_object_id);

	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;
	
	--	check gotSNP and reload tables if > 0
	
	if gotSNP > 0 then

		insert into deapp.de_snp_info
		select * from de_snp_info_release;
		cz_write_audit(jobId,databaseName,procedureName,'Inserted data into DEAPP de_snp_info',SQL%ROWCOUNT,stepCt,'Done');
		commit;
		stepCt := stepCt + 1;
	
		insert into deapp.de_snp_probe
		select * from de_snp_probe_release;
		cz_write_audit(jobId,databaseName,procedureName,'Inserted data into DEAPP de_snp_probe',SQL%ROWCOUNT,stepCt,'Done');
		commit;
		stepCt := stepCt + 1;
		
		insert into deapp.de_snp_gene_map
		select * from de_snp_gene_map_release;
		cz_write_audit(jobId,databaseName,procedureName,'Inserted data into DEAPP de_snp_gene_map',SQL%ROWCOUNT,stepCt,'Done');
		commit;
		stepCt := stepCt + 1;
		
		insert into deapp.de_snp_probe_sorted_def
		select * from de_snp_probe_sort_def_release;
		cz_write_audit(jobId,databaseName,procedureName,'Inserted data into DEAPP de_snp_probe_sorted_def',SQL%ROWCOUNT,stepCt,'Done');
		commit;
		stepCt := stepCt + 1;
		
	end if;

/*	
	insert into deapp.de_subject_snp_dataset
	(subject_snp_dataset_id
	,dataset_name
	,concept_cd
	,platform_name
	,trial_name
	,patient_num
	,timepoint
	,subject_id
	,sample_type
	,paired_dataset_id
	,patient_gender)
	select subject_snp_dataset_id
		  ,dataset_name
		  ,concept_cd
		  ,platform_name
		  ,trial_name
		  ,patient_num
		  ,timepoint
		  ,subject_id
		  ,sample_type
		  ,paired_dataset_id
		  ,patient_gender
	from de_subject_snp_dataset_release
	where trial_name = TrialId;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted data into DEAPP de_subject_snp_dataset',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;
*/	
	insert into deapp.de_snp_data_by_patient
	(snp_data_by_patient_id
	,snp_dataset_id
	,trial_name
	,patient_num
	,chrom
	,data_by_patient_chr
	)
	select snp_data_by_patient_id
		  ,snp_dataset_id
		  ,trial_name
		  ,patient_num
		  ,chrom
		  ,data_by_patient_chr
	from de_snp_data_by_patient_release
	where trial_name = TrialId;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted data into DEAPP de_snp_data_by_patient',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into deapp.de_snp_data_dataset_loc
	(snp_data_dataset_loc_id
	,trial_name
	,snp_dataset_id
	,location)
	select snp_data_dataset_loc_id
		  ,trial_name
		  ,snp_dataset_id
		  ,location
	from de_snp_data_ds_loc_release
	where trial_name = TrialId;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted data into DEAPP de_snp_data_dataset_loc',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	insert into deapp.de_snp_data_by_probe
	(snp_data_by_probe_id
	,probe_id
	,probe_name
	,snp_id
	,snp_name
	,trial_name
	,data_by_probe
	)
	select snp_data_by_probe_id
		  ,probe_id
		  ,probe_name
		  ,snp_id
		  ,snp_name
		  ,trial_name
		  ,data_by_probe
	from de_snp_data_by_probe_release
	where trial_name = TrialId;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted data into DEAPP de_snp_data_by_probe',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;	
	
	--	Load de_mrna_annotation
	
	insert into deapp.de_mrna_annotation
	select * from de_mrna_annotation_release;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted data into DEAPP de_mrna_annotation',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;

	--	Load de_gpl_info
	
	insert into deapp.de_gpl_info
	select * from de_gpl_info_release;

	cz_write_audit(jobId,databaseName,procedureName,'Inserted data into DEAPP de_gpl_info',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	stepCt := stepCt + 1;
	
	if gotSNP > 0 then
		-- Enable the SNP table constraints that were disabled prior to truncate
		execute immediate('alter table DE_SNP_INFO ENABLE constraint U_SNP_INFO_NAME;');
		execute immediate('alter table DE_SNP_PROBE ENABLE constraint U_SNP_PROBE_NAME;');
		execute immediate('alter table DE_SNP_INFO ENABLE constraint SYS_C0045667;  ');
		execute immediate('alter table DE_SNP_PROBE ENABLE constraint FK_SNP_PROBE_SNP_ID;');
		execute immediate('alter table DE_SNP_GENE_MAP ENABLE constraint FK_SNP_GENE_MAP_SNP_ID;');
		execute immediate('alter table DE_SNP_DATA_BY_PROBE ENABLE constraint FK_SNP_BY_PROBE_PROBE_ID;');
	  
		cz_write_audit(jobId,databaseName,procedureName,'Constrants enabled for SNP tables',SQL%ROWCOUNT,stepCt,'Done');
		commit;
		stepCt := stepCt + 1;
	end if;
    
	--	Create patient-trial, concept counts, and load security data

	i2b2_create_patient_trial(TrialId, StudyType, jobId, returnCode);
	i2b2_create_concept_counts(ontPath, jobId);
	i2b2_load_security_data(jobId);
	
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_from_release',0,stepCt,'Done');
	
       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_GWAS_TOP50
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_GWAS_TOP50" 
(i_bio_assay_analysis_id number
,i_job_id        number := null
)
 AS 
        --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
        
        v_sqlText                varchar2(2000);
        
BEGIN
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := i_job_id;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting ' || procedureName,0,stepCt,'Done');
    
        --        delete existing data from bio_asy_analysis_gwas_top50
        
        delete from biomart.bio_asy_analysis_gwas_top50
        where bio_assay_analysis_id = i_bio_assay_analysis_id;
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart.bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
        commit; 
        
/*
        --        disable indexes 

        for gwas_idx in (select index_name
                                                        ,table_name
                                         from all_indexes 
                                         where owner = 'BIOMART' 
                                           and table_name = 'BIO_ASY_ANALYSIS_gwas_TOP50')
        loop
                v_sqlText := 'alter index ' || gwas_idx.index_name || ' unusable';
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                execute immediate(v_sqlText);
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Disabling complete',0,stepCt,'Done');       
        end loop;
*/
        
        --        insert analysis into bio_asy_analysis_gwas_top50
        
        insert into biomart.bio_asy_analysis_gwas_top50
        (bio_assay_analysis_id
        ,analysis
        ,chrom
        ,pos
        ,rsgene
        ,rsid
        ,pvalue
        ,logpvalue
        ,extdata
        ,rnum
        ,intronexon
        ,recombinationrate
        ,regulome
        )
        select a.bio_assay_analysis_id
                  ,a.analysis
                  ,info.chrom
                  ,info.pos
                  ,info.gene_name AS rsgene
                  ,a.rsid
                  ,a.pvalue
                  ,a.logpvalue
                  ,a.extdata
                  ,a.rnum
                  ,info.exon_intron as intronexon
                  ,info.recombination_rate as recombinationrate
                  ,info.regulome_score as regulome
        from (select b.bio_assay_analysis_id
                                ,b.analysis 
                                ,b.rsid
                                ,b.pvalue
                                ,b.logpvalue
                                ,b.extdata
                                ,b.rnum
                 from (select gwas.bio_assay_analysis_id
                                         ,baa.analysis_name as analysis
                                         ,gwas.rs_id as rsid
                                         ,gwas.p_value as pvalue
                                         ,gwas.log_p_value as logpvalue
                                         ,gwas.ext_data as extdata
                                         ,row_number () over (order by gwas.p_value asc, gwas.rs_id asc) as rnum
                          from biomart.bio_assay_analysis_gwas gwas 
                          left join biomart.bio_assay_analysis baa 
                                        on  baa.bio_assay_analysis_id = gwas.bio_assay_analysis_id
                          where gwas.bio_assay_analysis_id = i_bio_assay_analysis_id) b
                 where b.rnum < 500) a          
        left join deapp.de_rc_snp_info info 
                  on  a.rsid = info.rs_id 
                  and hg_version='19';
    stepCt := stepCt + 1;
        cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_asy_analysis_gwas_top50',0,stepCt,'Done');
        commit; 
        
     /*   for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_GWAS_TOP50')
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,0,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        */
        cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');

END I2B2_LOAD_GWAS_TOP50;

/*
--select * from bio_assay_analysis_gwas 
--where bio_assay_analysis_id = 419842521
--order by p_value asc, rs_id asc;

--select * from tmp_analysis_gwas_top500
--where bio_assay_analysis_id = 419842521
-- order by p_value asc;

BEGIN
execute immediate('drop table BIOMART.tmp_analysis_gwas_top500');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.tmp_analysis_gwas_top500 
as
select a.* 
from (
select 
bio_asy_analysis_gwas_id,
bio_assay_analysis_id,
rs_id,
p_value,
log_p_value,
etl_id,
ext_data,
p_value_char,
row_number () over (partition by bio_assay_analysis_id order by p_value asc, rs_id asc) as rnum
from BIOMART.bio_assay_analysis_gwas
) a
where 
a.rnum <=500');

execute immediate('create index t_a_g_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(RS_ID) tablespace "INDX"');
execute immediate('create index t_a_ga_t500_idx on BIOMART.TMP_ANALYSIS_GWAS_TOP500(bio_assay_analysis_id) tablespace "INDX"');

BEGIN
execute immediate('drop table BIOMART.bio_asy_analysis_gwas_top50');
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;

execute immediate('create table BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50
as 
SELECT baa.bio_assay_analysis_id,
baa.analysis_name AS analysis, info.chrom AS chrom, info.pos AS pos,
gmap.gene_name AS rsgene, DATA.rs_id AS rsid,
DATA.p_value AS pvalue, DATA.log_p_value AS logpvalue,
DATA.ext_data AS extdata , DATA.rnum,
info.exon_intron as intronexon, info.recombination_rate as recombinationrate, info.regulome_score as regulome
FROM biomart.tmp_analysis_gwas_top500 DATA 
JOIN biomart.bio_assay_analysis baa 
ON baa.bio_assay_analysis_id = DATA.bio_assay_analysis_id
JOIN deapp.de_rc_snp_info info ON DATA.rs_id = info.rs_id and (hg_version='''||19||''')
LEFT JOIN deapp.de_snp_gene_map gmap ON  gmap.snp_name =info.rs_id') ;

--select count(*) from BIO_ASY_ANALYSIS_GWAS_TOP50;

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX1 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(bio_assay_analysis_id) parallel tablespace "INDX"');

execute immediate('create index BIOMART.B_ASY_GWAS_T50_IDX2 on BIOMART.BIO_ASY_ANALYSIS_GWAS_TOP50(ANALYSIS) parallel tablespace "INDX"');
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_PROTEIN_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_PROTEIN_DATA" 
(
  trial_id VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  
  --	JEA@20100128	New

  TrialID varchar2(100);
  RootNode VARCHAR2(100);
  pExists number;
    
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

	--	cursor for add_nodes
	
  CURSOR addNodes is
  select distinct REGEXP_REPLACE('\' || rootnode || '\' || TrialID || '\Biomarker Data\Protein\Proteomics\' || timepoint || '\' ,
                  '(\\){2,}', '\') as path
         ,timepoint as node_name
  from  deapp.de_subject_protein_data
  where trial_name = TrialId;
	
BEGIN
  TrialID := upper(trial_id);  
  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_protein_data',0,stepCt,'Done');
	
  --Determine if trial exists in i2b2, if not add

  select count(*)
  into pExists
  from i2b2metadata.i2b2
  where c_name = TrialID
    and c_hlevel = 0;

  --if trial does not exist in i2b2, then add a root node as a clinical trial 
  if pExists = 0 then  
    i2b2_add_node(TrialID, '\Clinical Trials\' || TrialID || '\', TrialID, jobID);
    RootNode := 'Clinical Trials';
  end if;

	--Cleanup any existing data from raw table
  
	delete from deapp_wz.stg_subject_protein_data_raw 
    where trial_name = TrialID; 

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from DEAPP_WZ stg_subject_protein_data_raw',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	Insert into raw data table from staging
 
	insert into deapp_wz.stg_subject_protein_data_raw
	(trial_name
	,component
	,intensity_text
	,timepoint
	,assay_id
	,gene_symbol
	,gene_id
	,subject_id
	,site_id
	)
	select trial_name
		  ,component
		  ,intensity_text
		  ,timepoint
		  ,assay_id
		  ,gene_symbol
		  ,gene_id
		  ,subject_id
		  ,site_id
	from deapp_wz.stg_subject_protein_data
    where trial_name = TrialID; 

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into DEAPP_WZ stg_subject_protein_data_raw',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	Perform node-curation on timepoint

	update deapp_wz.stg_subject_protein_data a
    set a.timepoint = 
       (select replace(Upper(a.timepoint), b.node_name, b.display_name)
        from node_curation b
        where b.node_type = 'VISIT_NAME'
          and upper(a.timepoint) = b.node_name  
          and b.active_flag = 'Y'
          and (b.global_flag = 'Y' OR b.study_id = a.trial_name)
		  and b.global_flag =
			 (select min(x.global_flag) from node_curation x
			  where b.node_type = x.node_type
                and b.node_name = x.node_name
                and (x.global_flag = 'Y' or a.trial_name = x.study_id)
             )
      )
    where exists
    (select 1 
      from node_curation b 
      where b.node_type = 'VISIT_NAME'
        and upper(a.timepoint) = b.node_name  
        and b.active_flag = 'Y'
        and (b.global_flag = 'Y' OR b.study_id = a.trial_name)
		and b.global_flag =
			 (select min(x.global_flag) from node_curation x
			  where b.node_type = x.node_type
                and b.node_name = x.node_name
                and (x.global_flag = 'Y' or a.trial_name = x.study_id)
             )
    );
	
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated timepoints in DEAPP_WZ stg_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	--	Update any values that contain < to value-.01 and that contain > to value+.01
	
	update deapp_wz.stg_subject_protein_data t
	set intensity_text=decode(instr(intensity_text,'<'),0,to_char(to_number(replace(intensity_text,'>',''))+.01),to_char(to_number(replace(intensity_text,'<',''))-.01))
	where (intensity_text like '%<%' or intensity_text like '%>%')
	  and control.is_number(replace(replace(intensity_text,'<',''),'>','')) = 0;

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated values with < or > in DEAPP_WZ stg_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	--	Delete any data where component is null and value is null
	
	delete from deapp_wz.stg_subject_protein_data
	where component is null
	  and intensity_text is null;
	  
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete records with null component and intensity_text in DEAPP_WZ stg_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	--	Update numeric values 
	
	update deapp_wz.stg_subject_protein_data
	set intensity=to_number(intensity_text)
	where control.is_number(intensity_text) = 0;
	  
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated numeric values in DEAPP_WZ stg_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;		

	--Cleanup any existing data from data file
  
	delete from deapp_wz.de_subject_protein_data
    where trial_name = TrialID; 

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from DEAPP_WZ de_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	create temporary indexes
	
	select count(*)
	into pExists
	from all_indexes
	where owner = 'DEAPP_WZ'
	  and index_name = 'stg_subject_protein_data_I1';
	  
	if pExists > 0 then
		execute immediate('drop index deapp_wz.stg_subject_protein_data_i1');
	end if;
	execute immediate('create index deapp_wz.stg_subject_protein_data_i1 on deapp_wz.stg_subject_protein_data (component, subject_id) tablespace deapp');

	select count(*)
	into pExists
	from all_indexes
	where owner = 'I2B2_LZ'
	  and index_name = 'PROTEIN_PATIENT_INFO_I1';
	  
	if pExists > 0 then
		execute immediate('drop index i2b2_lz.protein_patient_info_i1');
	end if;
	
	execute immediate('create index i2b2_lz.protein_patient_info_i1 on i2b2_lz.patient_info (study_id, subject_id, usubjid) tablespace i2b2_data');
	
	select count(*)
	into pExists
	from all_indexes
	where owner = 'I2B2DEMODATA'
	  and index_name = 'PROTEIN_PATIENT_DIMENSION_I1';
	  
	if pExists > 0 then
		execute immediate('drop index i2b2demodata.protein_patient_dimension_i1');
	end if;	
			
	execute immediate('create index i2b2demodata.protein_patient_dimension_i1 on i2b2demodata.patient_dimension (sourcesystem_cd) tablespace i2b2_data');
	
    insert into deapp_wz.de_subject_protein_data
	(trial_name
	,component
	,intensity
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,timepoint
	,zscore
	)
	select p.trial_name
		  ,p.component
		  ,avg(p.intensity) as value
		  ,avg(p.intensity) as n_value
		  ,pd.patient_num
		  ,p.gene_symbol
		  ,p.gene_id
		  ,p.assay_id
		  ,p.timepoint
		  ,0 as zscore
	from deapp_wz.stg_subject_protein_data p
		,i2b2_lz.patient_info pi
		,i2b2demodata.patient_dimension pd
	where p.subject_id = pi.subject_id
	  and nvl(p.site_id,'**NULL**') = nvl(pi.site_id,'**NULL**')
	  and pi.study_id = TrialId
	  and pi.usubjid = pd.sourcesystem_cd
	  and p.trial_name = TrialId
	  and p.intensity is not null
	  and p.intensity > 0
	  and p.gene_symbol is not null
	  group by p.trial_name
		  ,p.component
		  ,pd.patient_num
		  ,p.gene_symbol
		  ,p.gene_id
		  ,p.assay_id
		  ,p.timepoint;
	  
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into DEAPP_WZ de_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	execute immediate('drop index deapp_wz.stg_subject_protein_data_i1');
	execute immediate('drop index i2b2_lz.protein_patient_info_i1');
	execute immediate('drop index i2b2demodata.protein_patient_dimension_i1');
	
	--	ZScore calculation which will insert data to deapp.de_subject_protein_data
	
	i2b2_protein_zscore_calc(Trialid, jobid);
	
--	add the high level \Biomarker Data\ node if it doesn't exist (first time loading data)
  
	select count(*)
	into pExists
	from i2b2
	where c_fullname = '\' || RootNode || '\'|| TrialID || '\Biomarker Data\';
  
	if pExists = 0 then 
		i2b2_add_node(trialID, '\' || RootNode || '\' || trialID || '\Biomarker Data\', 'Biomarker Data', jobID);
        stepCt := stepCt + 1;
	    control.cz_write_audit(jobId,databaseName,procedureName,'Add Biomarker Data node for trial',0,stepCt,'Done');
	end if;

    --	check if Proteomics node exists, if yes, then delete existing data
	
	select count(*) into pExists
	from i2b2
	where c_fullname = '\' || RootNode || '\'|| TrialID || '\Biomarker Data\Protein\Proteomics\';
		  
	if pExists != 0 then
		--This deletes all i2b2, concept_dimension, and observation_fact records wher the path starts with the passed paramenter
		i2b2_delete_all_nodes('\' || RootNode || '\'|| TrialID || '\Biomarker Data\Protein\Proteomics\', jobID);
		stepCt := stepCt + 1;
		control.cz_write_audit(jobId,databaseName,procedureName,'Delete existing Proteomics data for trial in I2B2METADATA i2b2',0,stepCt,'Done');
	end if;
	
	--	Cleanup any existing data in de_subject_sample_mapping.  
	
	delete from deapp.DE_SUBJECT_SAMPLE_MAPPING 
	where trial_name = TrialID 
	  and platform = 'Protein'
	  and platform_cd = trialID || ':Protein'; --Making sure only protein data is deleted
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	add \Biomarker\Protein\Proteomics\timepoint nodes
	
	FOR r_addNodes in addNodes Loop
		
		i2b2_add_node(TrialId, r_addNodes.path, r_addNodes.node_name, jobId);

	End loop;
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Added Biomarker\Protein\Proteomics\timepoint nodes',0,stepCt,'Done');
	commit;
	
  --Load the DE_SUBJECT_SAMPLE_MAPPING from deapp_wz.stg_subject_mrna_data

  --CONCEPT_CODE    = generated JNJ concept code 
  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT       = TIMEPOINT
  --ASSAY_ID        = ASSAY_ID
  --PLATFORM        = Protein - this is required by ui code
  --PLATFORM_CD     = trial_name || 'Protein' 
  --TISSUE_TYPE     = NULL
  --SITE_ID         = NULL
  --SUBJECT_ID      = NULL
  --SUBJECT_TYPE    = NULL
  --PATIENT_UID     = NULL
  --SAMPLE_TYPE     = NULL
  --ASSAY_UID       = NULL
  --TIMEPOINT_CD    = same as concept_cd
  --SAMPLE_TYPE_CD  = NULL
  --TISSUE_TYPE_CD  = NULL
  --GPL_ID			= NULL
    
	insert into de_subject_sample_mapping
	(data_uid
	,concept_code
	,patient_id
	,trial_name
	,timepoint
	,assay_id
	,platform
	,platform_cd
	,timepoint_cd
	,sample_type
	,sample_type_cd
	,gpl_id
    )
	select distinct replace(cd.concept_cd || '-' || a.patient_id,' ','') as data_uid
	      ,cd.concept_cd
		  ,a.patient_id
		  ,a.trial_name
		  ,a.timepoint
		  ,a.assay_id
		  ,'Protein'
		  ,a.trial_name || ':Protein'
		  ,cd.concept_cd as timepoint_cd
		  ,null
		  ,null as sample_type_cd
		  ,null
	from deapp.de_subject_protein_data a		
    --Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
	join i2b2demodata.patient_dimension b
	  on a.patient_id = b.patient_num
	join i2b2demodata.concept_dimension cd
	  on cd.concept_path = '\' || rootNode || '\' || TrialId || '\Biomarker Data\Protein\Proteomics\' || a.timepoint || '\'
    where a.trial_name = TrialID; 
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');
	commit;
         
--	Insert records for patients and timepoints into observation_fact

	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select m.patient_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null	--	not numeric for Proteomics
		  ,m.trial_name
		  ,sysdate
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  deapp.de_subject_sample_mapping m
    where trial_name = TrialID 
      and platform = 'Protein'
    group by patient_id
			,concept_code
			,trial_name;
    stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');

    commit;
    
--	Update visual attributes for leaf active (default is folder)

	update i2b2 a
    set c_visualattributes = 'LA'
    where 1 = (select count(*)
			   from i2b2 b
			   where b.c_fullname like (a.c_fullname || '%'))
      and a.c_fullname like '\' || RootNode || '\' || TrialID || '\Biomarker Data\%';
    stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Update leaf active attribute for trial in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    commit;
	
--	fill in tree

	i2b2_fill_in_tree(TrialID,'\' || rootNode || '\' || TrialID || '\Biomarker Data\', jobID);
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Fill in tree for Biomarker Data for trial',SQL%ROWCOUNT,stepCt,'Done');
  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Biomarker level because there may be multiple platforms and patient count can vary
  
    i2b2_create_concept_counts('\' || RootNode || '\' || TrialID || '\Biomarker Data\',jobID );
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');

  --Reload Security: Inserts one record for every I2B2 record into the security table

    i2b2_load_security_data(jobId);
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_protein_data',0,stepCt,'Done');
		
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL'); 

END;


 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_RBM_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_RBM_DATA" 
(
  trial_id VARCHAR2
 ,rbm_type CHAR --Z or O (Z for Zscore, O for Observed value)
 ,currentJobID NUMBER := null
)
AS
--PROCEDURE TO LOAD THE DEAPP SAMPLE MAPPING TABLE AND I2B2 TREE WITH RBM DATA
--KCR: 06-25-2009
--RBM DATA SHOULD HAVE A ZSCORE AND OBSERVER VALUE. THESE SHOULD BOTH APPEAR.
--IN GENERAL THE SAMPLE MAPPING TABLE WILL HAVE 2 RECORDS FOR EACH RECORD ON THE RBM TABLE.
--1 FOR ZSCORE, 1 FOR OBSERVED.
--JOIN IS ON THE DATA_UID (UNIQUE ON RBM DATA, BUT NOT ON THE SAMPLE MAPPING)
--THE FOLLOWING FIELDS SHOULD MAKE THE RBM RECORDS UNIQUE:
  --TRIAL NAME, TIMEPOINT, ANTIGEN NAME, PATIENT ID
--FOR I2B2, DATA IS GROUPED BY CATEOGRY, SO PATIENT ID IS NOT USED WHEN GENERATING THE CONCEPT CODE.
  --Key: TRIAL NAME, TIMEPOINT, ANTIGEN NAME
  --The concept codes will also be differentiated by Zscore or Observed Value
  
  --	JEA@20090908	Changed data_uid to trial_name || '-RBM-' || timepoint || '-' || substr(antigen_name,1, 20) || '-' || patient_id so that it remains the same
  --					regardless of Observed/Z Score, concept_cd still has RBMType as part of string
  --	JEA@20091118	Added auditing
  --	JEA@20100201	Renamed to I2B2_LOAD_RBM_DATA from I2B2_PROCESS_RBM_DATA for consistency amoung mRNA, RBM, and protein load procedures

  TrialID varchar2(100);
  RBMType char(1);
  RootNode VARCHAR2(100);
  pExists number;
  rbmName varchar2(20);
    
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);


BEGIN
  TrialID := upper(trial_id);
  RBMType := upper(rbm_type);
  
 
  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_load_rbm_data',0,stepCt,'Done');
  
    --Quit if no valid type
  if RBMType NOT IN ('Z', 'O') then
    stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Invalid rbmType, must be O or Z',0,stepCt,'Done');
    RETURN;
  end if;  
  
  if RBMType = 'O' then
     rbmName := 'Observed';
  else
	  rbmName := 'Z Score';
  end if;
  
  --Determine root value of I2B2: Could be Clinical or Experimental
  select parse_nth_value(c_fullname, 2, '\') into RootNode
  from i2b2
  where c_name = TrialID;

  --if Root Node is null, then add a root node as a clinical trial as a default.
  if RootNode is null then  
    i2b2_add_node(TrialID, '\Clinical Trials\' || TrialID || '\', TrialID, jobID);
    RootNode := 'Clinical Trials';
  end if;

  --Cleanup any existing data
  delete 
    from DE_SUBJECT_SAMPLE_MAPPING 
    where trial_name = TrialID 
      and concept_code like '%' || TrialID || '%-' || RBMType  || '-%'; --Making sure only The ZScore or Observed gets deleted for RBM Data
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');
	
  commit;

  --	check if RBM node exists, if not add (first time adding RBM data)
  
  select count(*) into pExists
  from i2b2
  where c_fullname = '\' || RootNode || '\'|| TrialID || '\Biomarker Data\Protein\RBM\';
  
  if pexists = 0 then
	 i2b2_add_node(trialID, '\' || RootNode || '\' || trialID || '\Biomarker Data\Protein\RBM\', 'RBM', jobID);
     stepCt := stepCt + 1;
     control.cz_write_audit(jobId,databaseName,procedureName,'Added RBM node for trial in I2B2METADATA i2b2',0,stepCt,'Done');
	 i2b2_fill_in_tree(TrialId, trialID, '\' || RootNode || '\' || trialID || '\Biomarker Data\');
  end if;

    --	check if RBMType node exists, if yes, then delete existing data
	
  select count(*) into pExists
  from i2b2
  where c_fullname = '\' || RootNode || '\'|| TrialID || '\Biomarker Data\Protein\RBM\' || rbmName || '\';
  
  if pExists != 0 then
  --This deletes all i2b2, concept_dimension, and observation_fact records wher the path starts with the passed paramenter
	i2b2_delete_all_nodes('\' || RootNode || '\'|| TrialID || '\Biomarker Data\Protein\RBM\' || rbmName || '\', jobID);
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Delete existing RBMType data for trial in I2B2METADATA i2b2',0,stepCt,'Done');
  end if;

  --Create value for DATA_UID and concept_cd
  --Only taking first 20 Characters for ANTIGEN NAME because I2B2 has a 50 char limit on concept_cd
  --MUST BE Distinct on this table.
  
  update de_subject_rbm_data
    set data_uid = replace(trial_name || '-RBM-' || timepoint || '-' || substr(antigen_name,1, 20) || '-' || patient_id,' ','')
	   ,concept_cd = replace(trial_name || '-' || RBMType || '-' || timepoint || '-' || substr(antigen_name,1, 20),' ','')
    where trial_name = TrialID;
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Update data_uid and concept_cd in de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');

  commit;

/*  combined into single update pass
--Update concept Code with the correct value of data_uid minus the patient info
  update de_subject_rbm_data
    set concept_cd = trial_name || '-' || RBMType || '-' || timepoint || '-' || substr(antigen_name,1, 20)
    where trial_name = TrialID;
  commit;

  --Trim out any spaces
  update de_subject_rbm_data
    set data_uid = replace(data_uid, ' ', ''),
    concept_cd = replace(concept_cd, ' ', '')
    where trial_name = TrialID;
  commit;
*/


  --update RBM SAMPLE MAPPING TABLE FOR TREE NODE ROLLUP
  --NEED TO MAP ALL OF THE CONCEPT CODES INTO THE TABLE
  --HIERARCHY IS:
  --1: --TRIAL\BIOMARKER DATA\PROTEIN\RBM\ = platform_cd
  --3: --TRIAL\BIOMARKER DATA\PROTEIN\RBM\Observered or ZScore\Specific Week\ = timepoint_cd
  --4: --TRIAL\BIOMARKER DATA\PROTEIN\RBM\Observered or ZScore\Specific Week\Antigene\ = concept_code

  --Load the DE_SUBJECT_SAMPLE_MAPPING
  --MAPPING: (1 to 1 relationship for RBM)
  --CONCEPT_CODE    = trial_name || 'ZSc-' || timepoint || '-' || antigen_name  (Group patient for I2B2)
                      --NOTE: ZSc = Z-score. Would be Obs for Observered
  --PATIENT_ID      = RBM.PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --TRIAL_NAME      = RBM.TRIAL_NAME
  --TIMEPOINT       = RBM.TIMEPOINT
  --ASSAY_ID        = RBM.ASSAY_ID
  --PLATFORM        = "RBM"
  --PLATFORM_CD     = trial_name || 'RBM' 
  --TISSUE_TYPE     = "Serum"
  --SITE_ID         = NULL
  --SUBJECT_ID      = NULL
  --SUBJECT_TYPE    = NULL
  --PATIENT_UID     = NULL
  --SAMPLE_TYPE     = NULL
  --ASSAY_UID       = NULL
  --TIMEPOINT_CD    = trial_name || 'RBM' || '-' || RBMType || '-' || timepoint
  --SAMPLE_TYPE_CD  = trial_name || 'RBM' || '-' || RBMType
  --TISSUE_TYPE_CD  = NULL
  
  INSERT
  INTO DE_SUBJECT_SAMPLE_MAPPING
    (
      DATA_UID,  
      CONCEPT_CODE,
      PATIENT_ID,
      TRIAL_NAME,
      TIMEPOINT,
      ASSAY_ID,
      PLATFORM,
      PLATFORM_CD,
      timepoint_cd,
      TISSUE_TYPE
    )
  select distinct 
    a.data_uid,
    a.concept_cd,
    a.patient_id,
    a.trial_name,
    a.timepoint,
    a.assay_id,
    'RBM',  
    a.trial_name || ':RBM',
    a.trial_name || ':RBM:' || RBMType || ':' || a.timepoint,
    'Serum'
  from
    de_subject_rbm_data a
    --Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
  join
    patient_dimension b
  on
    a.patient_id = b.patient_num
    where a.trial_name = TrialID; 
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');

  commit;

  --Build Dataset Explorer Records:
    --need to build out specific levels of the tree individually
    --because the concept_cd must be specifically assigned at each level

/*	RBM node done at start of procedure

    --RBM NODE
    --CONCEPT_DIMENSION
    INSERT INTO CONCEPT_DIMENSION
      (CONCEPT_CD, CONCEPT_PATH, NAME_CHAR,  UPDATE_DATE,  DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, TABLE_NAME)
    select distinct
      a.platform_cd,
      '\' || RootNode || '\' || a.trial_name || '\Biomarker Data\Protein\RBM\',
      'RBM',
      sysdate,
      sysdate,
      sysdate,
      a.Trial_name,
      'CONCEPT_DIMENSION'
    from 
      de_subject_sample_mapping a
    where a.trial_name = TrialID 
      and a.platform = 'RBM';
    Commit;
*/
        
    --TIME POINTS
    --CONCEPT_DIMENSION
    INSERT INTO CONCEPT_DIMENSION
      (CONCEPT_CD, CONCEPT_PATH, NAME_CHAR,  UPDATE_DATE,  DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, TABLE_NAME)
    select distinct
      a.timepoint_cd,
      case 
        when RBMType = 'Z' then
          '\' || RootNode || '\' || a.trial_name || '\Biomarker Data\Protein\RBM\Z Score\' || timepoint || '\'
        when RBMType = 'O' then
          '\' || RootNode || '\' || a.trial_name || '\Biomarker Data\Protein\RBM\Observed\' || timepoint || '\'
      end,
      timepoint,
      sysdate,
      sysdate,
      sysdate,
      a.Trial_name,
      'CONCEPT_DIMENSION'
    from 
      de_subject_sample_mapping a
    where a.trial_name = TrialID 
      and a.platform = 'RBM'
      and a.concept_code like '%-' || RBMType || '-%';
    stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Insert data for RBMType and timepoint into I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');

    Commit;

  --Node Path will be: 
  --Clinical Trial + Trial_name + Biomarker Data + Protein-RBM + timepoint + antigen_name
    INSERT INTO CONCEPT_DIMENSION
      (CONCEPT_CD, CONCEPT_PATH, NAME_CHAR,  UPDATE_DATE,  DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, TABLE_NAME)
    select distinct
      a.concept_cd,
      case 
        when RBMType = 'Z' then
          '\' || RootNode || '\' || a.trial_name || '\Biomarker Data\Protein\RBM\Z Score\' || a.timepoint || '\' || a.antigen_name || '\'
        when RBMType = 'O' then
          '\' || RootNode || '\' || a.trial_name || '\Biomarker Data\Protein\RBM\Observed\' || a.timepoint || '\' || a.antigen_name || '\'
      end,
      a.antigen_name,
      sysdate,
      sysdate,
      sysdate,
      a.Trial_name,
      'CONCEPT_DIMENSION'
    from 
      de_subject_rbm_data a
    where a.trial_name = TrialID 
      and a.concept_cd like '%' || a.trial_name || '%-' || RBMType  || '-%'; --Making sure only The ZScore or Observed gets added for RBM Data
    stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Insert data for RBMType, timepoint and antigen into I2B2DEMODATA concept_dimension',SQL%ROWCOUNT,stepCt,'Done');

    Commit;
         
  --OBSERVATION_FACT
  INSERT
  INTO OBSERVATION_FACT
    (
      PATIENT_NUM,
      CONCEPT_CD,
      MODIFIER_CD,
      VALTYPE_CD,
      TVAL_CHAR,
      NVAL_NUM,
      SOURCESYSTEM_CD,
      IMPORT_DATE,
      VALUEFLAG_CD,
      PROVIDER_ID,
      LOCATION_CD,
      UNITS_CD
    )
/*
    select distinct
      a.patient_id,
      a.concept_cd,
      a.trial_name,
      'N', -- Numeric data type
      'E',  --Stands for Equals for numeric types
      case 
        when RBMType = 'Z' then
          a.zscore
        when RBMType = 'O' then
          a.value
      end,
      a.trial_name, 
      sysdate, 
      '@',
      '@',
      '@',
      '' -- no units available
    from de_subject_rbm_data a
    where a.trial_name = TrialID 
      and a.concept_cd like '%' || TrialID || '%-' || RBMType  || '-%' --Making sure only The ZScore or Observed gets deleted for RBM Data
      and a.value is not null
      and a.zscore is not null;
  */
    --WORKAROUND TO TAKE AVERAGE SCORE
    select
      a.patient_id,
      a.concept_cd,
      a.trial_name,
      'N', -- Numeric data type
      'E',  --Stands for Equals for numeric types
      case 
        when RBMType = 'Z' then
          AVG(a.zscore)
        when RBMType = 'O' then
          AVG(a.value)
      end,
      a.trial_name, 
      sysdate, 
      '@',
      '@',
      '@',
      '' -- no units available
    from deapp.de_subject_rbm_data a
    where a.trial_name = TrialID 
      and a.concept_cd like '%' || TrialID || '%-' || RBMType  || '-%' --Making sure only The ZScore or Observed gets deleted for RBM Data
      and a.value is not null
      and a.zscore is not null
    group by 
      a.patient_id,
      a.concept_cd,
      a.trial_name;
    stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');

    commit;

    --I2B2: Build all paths at once
   INSERT
     INTO I2B2
      (c_hlevel, C_FULLNAME, C_NAME, C_VISUALATTRIBUTES, c_synonym_cd, C_FACTTABLECOLUMN, C_TABLENAME, C_COLUMNNAME,
      C_DIMCODE, C_TOOLTIP, UPDATE_DATE, DOWNLOAD_DATE, IMPORT_DATE, SOURCESYSTEM_CD, c_basecode, C_OPERATOR, c_columndatatype, c_metadataxml, c_comment)
    SELECT 
      (length(concept_path) - nvl(length(replace(concept_path, '\')),0)) / length('\') - 3,
      CONCEPT_PATH,
      NAME_CHAR,
      'LA',
      'N',
      'concept_cd',
      'concept_dimension',
      'concept_path',
      CONCEPT_PATH,
      CONCEPT_PATH,
      sysdate,
      sysdate,
      sysdate,
      SOURCESYSTEM_CD,
      CONCEPT_CD,
      'LIKE',
      'N',
      '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>' ,
      'trial:' ||  TrialID
    FROM
      CONCEPT_DIMENSION
    WHERE 
      CONCEPT_PATH LIKE '\' || RootNode || '\' || TrialID || '\Biomarker Data\Protein\RBM\' || rbmName || '%';
    stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Insert nodes for trial into I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');

    COMMIT;
	
    --Adding rbm type node. dont care about Concept_cd. User cannot drag it.
	
    if RBMType = 'Z' then
      i2b2_add_node(trialID, '\' || RootNode || '\' || trialID || '\Biomarker Data\Protein\RBM\Z Score\', 'Z Score',jobID);
    else
      i2b2_add_node(trialID, '\' || RootNode || '\' || trialID || '\Biomarker Data\Protein\RBM\Observed\', 'Observed',jobID);
    end if;
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Add RBMType node in I2B2METADATA i2b2',0,stepCt,'Done');

    --need to set folders correctly.
    update i2b2
      set c_visualattributes = 'FA',
      c_columndatatype = 'T',
      c_metadataxml = ''
        where c_fullname like '\' || RootNode || '\' || TrialID || '\Biomarker Data\Protein\RBM\' || rbmName || '\%'
          and c_hlevel < 6;
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for folders nodes in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');

    commit;
	
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do this at the RBM level because patient counts may have changed
	i2b2_create_concept_counts('\' || RootNode || '\' || TrialID || '\Biomarker Data\Protein\RBM\',jobID);
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Update patient counts for trial in I2B2DEMODATA concept_counts',0,stepCt,'Done');

  --Reload Security: Inserts one record for every I2B2 record into the security table
	i2b2_load_security_data(jobID);
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Reload security for trial in I2B2METADATA i2b2_secure',0,stepCt,'Done');
    
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_rbm_data',0,stepCt,'Done');
  
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL'); 

END;


 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_SAMPLE_CATEGORIES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_SAMPLE_CATEGORIES" 

(
  currentJobID NUMBER := null
)
AS


	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

	--	JEA@20110916	New
	--	JEA@20120209	Remove insert of sample to patient_dimension

	--
	-- Copyright ? 2011 Recombinant Data Corp.
	--

BEGIN
    
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
  
	--	delete any data for study in sample_categories_extrnl from lz_src_sample_categories
	
	delete from lz_src_sample_categories
	where trial_cd in (select distinct trial_cd from lt_src_sample_categories);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted existing study data in lz_src_sample_categories',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

/*	
	--	create records in patient_dimension for samples if they do not exist
	--	format of sourcesystem_cd:  trial:S:[site:]subject_cd:sample_cd
	--	if no sample_cd specified, then the patient_num of the trial:[site]:subject_cd should have already been created
	
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select seq_patient_num.nextval,
		   null as sex_cd,
		   0 as age_in_years_num,
		   null as race_cd,
		   sysdate,
		   sysdate,
		   sysdate,
		   regexp_replace(s.trial_cd || ':S:' || s.site_cd || ':' || s.subject_cd || ':' || s.sample_cd,
						  '(::){1,}', ':')
	from (select distinct trial_cd
	             ,site_cd
				 ,subject_cd
				 ,sample_cd
		  from sample_categories_extrnl s
		  where s.sample_cd is not null
			and not exists
				(select 1 from patient_dimension x
				 where x.sourcesystem_cd = 
					   regexp_replace(s.trial_cd || ':S:' || s.site_cd || ':' || s.subject_cd || ':' || s.sample_cd,
					 '(::){1,}', ':'))
		  ) s;
			
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Added new sample_cds for study in I2B2DEMODATA patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
	commit;
*/

	--	Load data into lz_src_sample_categories table, joins to make sure study/trial exists and there's an entry in the patient_dimension
	
	insert into lz_src_sample_categories
	(trial_cd
	,site_cd
	,subject_cd
	,sample_cd
	,category_cd
	,category_value
	)
	select distinct s.trial_cd
		  ,s.site_cd
		  ,s.subject_cd
		  ,s.sample_cd
		  ,replace(s.category_cd,'"',null)
		  ,replace(s.category_value,'"',null)
	from lt_src_sample_categories s
	where replace(s.category_cd,'"',null) is not null
	  and replace(s.category_value,'"',null) is not null
	  and s.trial_cd in (select distinct x.sourcesystem_cd from i2b2 x)
	;
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted sample data in lz_src_sample_categories',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	if newjobflag = 1
	then
		cz_end_audit (jobID, 'SUCCESS');
	end if;

	exception
	when others then
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		
		--End Proc
		cz_end_audit (jobID, 'FAIL');
	
END;

 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_SAMPLE_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_SAMPLE_DATA" 

(
  currentJobID NUMBER := null
)
AS


	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);

	--	JEA@20110916	New

	--
	-- Copyright ? 2011 Recombinant Data Corp.
	--

BEGIN
    
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
  
	--	delete any data for study in sample_categories_extrnl from lz_src_sample_categories
	
	delete from lz_src_sample_categories
	where trial_cd in (select distinct trial_cd from sample_categories_extrnl);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Deleted existing study data in tm_lz lz_src_sample_categories',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	create records in patient_dimension for samples if they do not exist
	--	format of sourcesystem_cd:  trial:S:[site:]subject_cd:sample_cd
	--	if no sample_cd specified, then the patient_num of the trial:[site]:subject_cd should have already been created
	
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select seq_patient_num.nextval,
		   null as sex_cd,
		   0 as age_in_years_num,
		   null as race_cd,
		   sysdate,
		   sysdate,
		   sysdate,
		   regexp_replace(s.trial_cd || ':S:' || s.site_cd || ':' || s.subject_cd || ':' || s.sample_cd,
						  '(::){2,}', ':')
	from (select distinct trial_cd
	             ,site_cd
				 ,subject_cd
				 ,sample_cd
		  from sample_categories_extrnl s
		  where s.sample_cd is not null
			and not exists
				(select 1 from patient_dimension x
				 where x.sourcesystem_cd = 
					   regexp_replace(s.trial_cd || ':S:' || s.site_cd || ':' || s.subject_cd || ':' || s.sample_cd,
					 '(::){2,}', ':'))
		  ) s;
			
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Added new sample_cds for study in I2B2DEMODATA patient_dimension',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	Load data into lz_src_sample_categories table, joins to make sure study/trial exists and there's an entry in the patient_dimension
	
	insert into lz_src_sample_categories
	(trial_cd
	,site_cd
	,subject_cd
	,sample_cd
	,category_cd
	,category_value
	)
	select distinct s.trial_cd
		  ,s.site_cd
		  ,s.subject_cd
		  ,s.sample_cd
		  ,replace(s.category_cd,'"',null)
		  ,replace(s.category_value,'"',null)
	from sample_categories_extrnl s
		,patient_dimension p
		,i2b2 f
	where s.category_cd is not null
	  and s.category_value is not null
	  and p.sourcesystem_cd = 
		  case when s.sample_cd is null 
			   then regexp_replace(s.trial_cd || ':' || s.site_cd || ':' || s.subject_cd,'(::){2,}', ':')
			   else regexp_replace(s.trial_cd || ':S:' || s.site_cd || ':' || s.subject_cd || ':' || s.sample_cd,'(::){2,}', ':')
		  end
	  and s.trial_cd = f.sourcesystem_cd
	  and f.c_hlevel = 0
	;
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted sample data in i2b2demodata sample_categories',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	if newjobflag = 1
	then
		cz_end_audit (jobID, 'SUCCESS');
	end if;

	exception
	when others then
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		
		--End Proc
		cz_end_audit (jobID, 'FAIL');
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_SECURITY_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_SECURITY_DATA" 
(
  currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;

  stepCt := 0;

  Execute immediate ('truncate table I2B2METADATA.i2b2_secure');

  stepCt := stepCt + 1;
  cz_write_audit(jobId,databaseName,procedureName,'Truncate I2B2METADATA i2b2_secure',0,stepCt,'Done');

  insert into I2B2METADATA.i2b2_secure(
    C_HLEVEL,
    C_FULLNAME,
    C_NAME,
    C_SYNONYM_CD,
    C_VISUALATTRIBUTES,
    C_TOTALNUM,
    C_BASECODE,
    C_METADATAXML,
    C_FACTTABLECOLUMN,
    C_TABLENAME,
    C_COLUMNNAME,
    C_COLUMNDATATYPE,
    C_OPERATOR,
    C_DIMCODE,
    C_COMMENT,
    C_TOOLTIP,
    UPDATE_DATE,
    DOWNLOAD_DATE,
    IMPORT_DATE,
    SOURCESYSTEM_CD,
    VALUETYPE_CD,
	secure_obj_token)
  select
    b.C_HLEVEL,
    b.C_FULLNAME,
    b.C_NAME,
    b.C_SYNONYM_CD,
    b.C_VISUALATTRIBUTES,
    b.C_TOTALNUM,
    b.C_BASECODE,
    b.C_METADATAXML,
    b.C_FACTTABLECOLUMN,
    b.C_TABLENAME,
    b.C_COLUMNNAME,
    b.C_COLUMNDATATYPE,
    b.C_OPERATOR,
    b.C_DIMCODE,
    b.C_COMMENT,
    b.C_TOOLTIP,
    b.UPDATE_DATE,
    b.DOWNLOAD_DATE,
    b.IMPORT_DATE,
    b.SOURCESYSTEM_CD,
    b.VALUETYPE_CD,
	coalesce(f.tval_char,'EXP:PUBLIC')
    from I2B2METADATA.I2B2 b
		,(select distinct case when sourcesystem_cd like '%:%' then substr(sourcesystem_cd,1,instr(sourcesystem_cd,':')-1)
							   else sourcesystem_cd end as sourcesystem_cd
				,tval_char from observation_fact where concept_cd = 'SECURITY') f
	where b.sourcesystem_cd = f.sourcesystem_cd(+);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert security data into I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');

    commit;

    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

end;
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_SECURITY_DATA_TR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_SECURITY_DATA_TR" 
(
  currentJobID NUMBER := null
)
AS
  -- JEA@20111206    Changed to use security token (tval_char) from SECURITY concept in observation_fact
  -- JEA@20111221    Added distinct to subselect to fix duplicate record issue
  -- JEA@20120214    Added coalesce to EXP:PUBLIC where no SECURITY records found (upper-level nodes)

  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;

  stepCt := 0;

  Execute immediate ('truncate table I2B2METADATA.i2b2_secure');

  stepCt := stepCt + 1;
  cz_write_audit(jobId,databaseName,procedureName,'Truncate I2B2METADATA i2b2_secure',0,stepCt,'Done');

  insert /*+ APPEND */ into I2B2METADATA.i2b2_secure nologging
  (
    C_HLEVEL,
    C_FULLNAME,
    C_NAME,
    C_SYNONYM_CD,
    C_VISUALATTRIBUTES,
    C_TOTALNUM,
    C_BASECODE,
    C_METADATAXML,
    C_FACTTABLECOLUMN,
    C_TABLENAME,
    C_COLUMNNAME,
    C_COLUMNDATATYPE,
    C_OPERATOR,
    C_DIMCODE,
    C_COMMENT,
    C_TOOLTIP,
    UPDATE_DATE,
    DOWNLOAD_DATE,
    IMPORT_DATE,
    SOURCESYSTEM_CD,
    VALUETYPE_CD,
    secure_obj_token)
  select /*+ parallel(b, 4) parallel(f, 4) */
    b.C_HLEVEL,
    b.C_FULLNAME,
    b.C_NAME,
    b.C_SYNONYM_CD,
    b.C_VISUALATTRIBUTES,
    b.C_TOTALNUM,
    b.C_BASECODE,
    b.C_METADATAXML,
    b.C_FACTTABLECOLUMN,
    b.C_TABLENAME,
    b.C_COLUMNNAME,
    b.C_COLUMNDATATYPE,
    b.C_OPERATOR,
    b.C_DIMCODE,
    b.C_COMMENT,
    b.C_TOOLTIP,
    b.UPDATE_DATE,
    b.DOWNLOAD_DATE,
    b.IMPORT_DATE,
    b.SOURCESYSTEM_CD,
    b.VALUETYPE_CD,
    coalesce(f.tval_char,'EXP:PUBLIC')
    from I2B2METADATA.I2B2 b
        ,(select distinct modifier_cd, tval_char from observation_fact where concept_cd = 'SECURITY') f
    where b.sourcesystem_cd = f.modifier_cd(+);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert security data into I2B2METADATA i2b2_secure',SQL%ROWCOUNT,stepCt,'Done');

    commit;

    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

end;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_LOAD_STUDY_METADATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_LOAD_STUDY_METADATA" 
(
  currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research n, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/
  -------------------------------------------------------------
    --HZ 20140130 added folder association
  -------------------------------------------------------------
    --Audit variables
    newJobFlag INTEGER(1);
    databaseName VARCHAR(100);
    procedureName VARCHAR(100);
    jobID number(18,0);
    stepCt number(18,0);
    
    dcount                 int;
    lcount                 int;
    upload_date            timestamp;
    tmp_compound        varchar2(200);
    tmp_disease            varchar2(200);
    tmp_organism        varchar2(200);
    tmp_pubmed            varchar2(200);
    pubmed_id            varchar2(200);
    pubmed_title        varchar2(200);
    
    Type study_compound_rec is record
    (study_id    varchar2(200)
    ,compound    varchar2(500)
    );
  
    Type study_compound_tab is table of study_compound_rec;
  
    study_compound_array study_compound_tab;
  
    Type study_disease_rec is record
    (study_id    varchar2(200)
    ,disease    varchar2(500)
    );
  
    Type study_disease_tab is table of study_disease_rec;
  
    study_disease_array study_disease_tab;
  
    Type study_taxonomy_rec is record
    (study_id    varchar2(200)
    ,organism    varchar2(500)
    );
  
    Type study_taxonomy_tab is table of study_taxonomy_rec;
  
    study_taxonomy_array study_taxonomy_tab;
    
    Type study_pubmed_rec is record
    (study_id    varchar2(200)
    ,pubmed    varchar2(500)
    );
  
    Type study_pubmed_tab is table of study_pubmed_rec;
  
    study_pubmed_array study_pubmed_tab;

BEGIN
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := currentJobID;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
  
    stepCt := 0;
    select sysdate into upload_date from dual;
    
    --    delete existing metadata from lz_src_study_metadata
    
    delete from lz_src_study_metadata
    where study_id in (select distinct study_id from lt_src_study_metadata);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing metadata in lz_src_study_metadata',SQL%ROWCOUNT,stepCt,'Done');
    commit;

    --    insert metadata into lz_src_study_metadata
    
    insert into lz_src_study_metadata
    select x.*, upload_date
    from lt_src_study_metadata x;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing metadata in lz_src_study_metadata',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    delete existing metadata from lz_src_study_metadata_ad_hoc
    
    delete from lz_src_study_metadata_ad_hoc
    where study_id in (select distinct study_id from lt_src_study_metadata);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing metadata in lz_src_study_metadata_ad_hoc',SQL%ROWCOUNT,stepCt,'Done');
    commit;

    --    insert metadata into lz_src_study_metadata_ad_hoc
    
    insert into lz_src_study_metadata_ad_hoc
    select x.*, upload_date
    from lt_src_study_metadata_ad_hoc x;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing metadata in lz_src_study_metadata_ad_hoc',SQL%ROWCOUNT,stepCt,'Done');
    commit;
  
    --    Update existing bio_experiment data
    
    update biomart.bio_experiment b
    set (title
        ,description
        ,design
        ,start_date
        ,completion_date
        ,primary_investigator
        ,overall_design
        ,institution
        ,country) =
        (select m.title
               ,m.description
               ,m.design
               ,decode(is_date(m.start_date,'YYYYMMDD'),1,null,to_date(m.start_date,'YYYYMMDD'))
               ,decode(is_date(m.completion_date,'YYYYMMDD'),1,null,to_date(m.completion_date,'YYYYMMDD'))
               ,coalesce(m.primary_investigator,m.study_owner)
               ,coalesce(substr(decode(m.primary_end_points,null,null,'N/A',null,m.primary_end_points) ||
                        decode(m.inclusion_criteria,null,null,'N/A',null,' Inclusion Criteria: ' || m.inclusion_criteria) ||
                        decode(m.exclusion_criteria,null,null,'N/A',null,' Exclusion Criteria: ' || m.exclusion_criteria),1,2000)
                        ,m.overall_design)
               ,m.institution
               ,m.country
         from lt_src_study_metadata m
         where m.study_id is not null
           and b.accession = m.study_id)
    where exists
        (select 1 from lt_src_study_metadata x
         where b.accession = x.study_id
           and b.etl_id = 'METADATA:' || x.study_id
           and x.study_id is not null)
    ;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Updated trial data in BIOMART bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    Update existing bio_clinical_trial data only for true Clinical Trials or JnJ Experimental Medicine Studies

    update biomart.bio_clinical_trial b
    set (study_owner
        ,study_phase
        ,blinding_procedure
        ,studytype
        ,duration_of_study_weeks
        ,number_of_patients
        ,number_of_sites
        ,route_of_administration
        ,dosing_regimen
        ,group_assignment
        ,type_of_control
        ,completion_date
        ,primary_end_points
        ,secondary_end_points
        ,inclusion_criteria
        ,exclusion_criteria
        ,subjects
        ,gender_restriction_mfb
        ,min_age
        ,max_age
        ,secondary_ids
        ,development_partner
        ,main_findings
        ,geo_platform
        --,platform_name
        ,search_area
        ) =
        (select m.study_owner
               ,m.study_phase
               ,m.blinding_procedure
               ,m.studytype
               ,decode(is_number(m.duration_of_study_weeks),1,null,to_number(m.duration_of_study_weeks))
               ,decode(is_number(m.number_of_patients),1,null,to_number(m.number_of_patients))
               ,decode(is_number(m.number_of_sites),1,null,to_number(m.number_of_sites))
               ,m.route_of_administration
               ,m.dosing_regimen
               ,m.group_assignment
               ,m.type_of_control
               ,decode(is_date(m.completion_date,'YYYYMMDD'),1,null,to_date(m.completion_date,'YYYYMMDD'))
               ,m.primary_end_points
               ,m.secondary_end_points
               ,m.inclusion_criteria
               ,m.exclusion_criteria
               ,m.subjects
               ,m.gender_restriction_mfb
               ,decode(is_number(m.min_age),1,null,to_number(m.min_age))
               ,decode(is_number(m.max_age),1,null,to_number(m.max_age))
               ,m.secondary_ids
               ,m.development_partner
               ,m.main_findings
               ,m.geo_platform
               --,m.platform_name
               ,m.search_area
         from lt_src_study_metadata m
         where m.study_id is not null
           and b.trial_number = m.study_id
        )
    where exists
         (select 1 from lt_src_study_metadata x
          where b.trial_number = x.study_id
            and x.study_id is not null
         )
    ;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Updated trial data in BIOMART bio_clinical_trial',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    Add new trial data to bio_experiment
    
    insert into biomart.bio_experiment
    (bio_experiment_type
    ,title
    ,description
    ,design
    ,start_date
    ,completion_date
    ,primary_investigator
    ,contact_field
    ,etl_id
    ,status
    ,overall_design
    ,accession
    ,country
    ,institution)
    select 'Experiment'
          ,m.title
          ,m.description
          ,m.design
          ,decode(is_date(m.start_date,'YYYYMMDD'),1,null,to_date(m.start_date,'YYYYMMDD'))
          ,decode(is_date(m.completion_date,'YYYYMMDD'),1,null,to_date(m.completion_date,'YYYYMMDD'))
          ,coalesce(m.primary_investigator,m.study_owner)
          ,m.contact_field
          ,'METADATA:' || m.study_id
          ,m.study_id
          ,coalesce(decode(m.primary_end_points,null,null,'N/A',null,replace(m.primary_end_points,'"',null)) ||
                        decode(m.inclusion_criteria,null,null,'N/A',null,' Inclusion Criteria: ' || replace(m.inclusion_criteria,'"',null)) ||
                        decode(m.exclusion_criteria,null,null,'N/A',null,' Exclusion Criteria: ' || replace(m.exclusion_criteria,'"',null))
                        ,m.overall_design)
          ,m.study_id
          ,m.country
          ,m.institution
    from lt_src_study_metadata m
    where m.study_id is not null
      and not exists
          (select 1 from biomart.bio_experiment x
           where m.study_id = x.accession
             and m.study_id is not null);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data in BIOMART bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
    commit;
        
    --    Add new trial data to bio_clinical_trial
    
    insert into biomart.bio_clinical_trial
    (trial_number
    ,study_owner
    ,study_phase
    ,blinding_procedure
    ,studytype
    ,duration_of_study_weeks
    ,number_of_patients
    ,number_of_sites
    ,route_of_administration
    ,dosing_regimen
    ,group_assignment
    ,type_of_control
    ,completion_date
    ,primary_end_points
    ,secondary_end_points
    ,inclusion_criteria
    ,exclusion_criteria
    ,subjects
    ,gender_restriction_mfb
    ,min_age
    ,max_age
    ,secondary_ids
    ,bio_experiment_id
    ,development_partner
    ,main_findings
    ,geo_platform
    --,platform_name
    ,search_area
    )
    select m.study_id
          ,m.study_owner
          ,m.study_phase
          ,m.blinding_procedure
          ,m.studytype
          ,decode(is_number(m.duration_of_study_weeks),1,null,to_number(m.duration_of_study_weeks))
          ,decode(is_number(m.number_of_patients),1,null,to_number(m.number_of_patients))
          ,decode(is_number(m.number_of_sites),1,null,to_number(m.number_of_sites))
          ,m.route_of_administration
          ,m.dosing_regimen
          ,m.group_assignment
          ,m.type_of_control
          ,decode(is_date(m.completion_date,'YYYYMMDD'),1,null,to_date(m.completion_date,'YYYYMMDD'))
          ,m.primary_end_points
          ,m.secondary_end_points
          ,m.inclusion_criteria
          ,m.exclusion_criteria
          ,m.subjects
          ,m.gender_restriction_mfb
          ,decode(is_number(m.min_age),1,null,to_number(m.min_age))
          ,decode(is_number(m.max_age),1,null,to_number(m.max_age))
          ,m.secondary_ids
          ,b.bio_experiment_id
          ,m.development_partner
          ,m.main_findings
          ,m.geo_platform
          --,m.platform_name
          ,m.search_area
    from lt_src_study_metadata m
        ,biomart.bio_experiment b
    where m.study_id is not null
      and m.study_id = b.accession
      and not exists
          (select 1 from biomart.bio_clinical_trial x
           where m.study_id = x.trial_number);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data in BIOMART bio_clinical_trial',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    Insert new trial into bio_data_uid
    
    insert into biomart.bio_data_uid
    (bio_data_id
    ,unique_id
    ,bio_data_type
    )
    select distinct b.bio_experiment_id
          ,'EXP:' || m.study_id
          ,'EXP'
    from biomart.bio_experiment b
        ,lt_src_study_metadata m
    where m.study_id is not null
      and m.study_id = b.accession
      and not exists
          (select 1 from biomart.bio_data_uid x
           where x.unique_id = 'EXP:' || m.study_id)
    ;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data into BIOMART bio_data_uid',SQL%ROWCOUNT,stepCt,'Done');
    commit;

    --    delete existing compound data for study, compound list may change
    
    delete bio_data_compound dc
    where dc.bio_data_id in 
         (select x.bio_experiment_id
          from bio_experiment x
              ,lt_src_study_metadata y
          where x.accession = y.study_id
            and x.etl_id = 'METADATA:' || y.study_id);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from bio_data_compound',SQL%ROWCOUNT,stepCt,'Done');
    commit;

    select distinct study_id, compound
    bulk collect into study_compound_array
    from lt_src_study_metadata
    where compound is not null;
    
    if SQL%ROWCOUNT > 0 then 
        for i in study_compound_array.first .. study_compound_array.last
        loop
        
            select length(study_compound_array(i).compound) -
                   length(replace(study_compound_array(i).compound,';',null))+1
                into dcount
            from dual;
     
            while dcount > 0
            Loop    
        
                select parse_nth_value(study_compound_array(i).compound,dcount,';') into tmp_compound
                from dual;
                   
                --    add new compound
                
                insert into bio_compound bc
                (generic_name)
                select tmp_compound
                from dual
                where not exists
                     (select 1 from bio_compound x
                      where upper(x.generic_name) = upper(tmp_compound))
                  and tmp_compound is not null;
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Added compound to bio_compound',SQL%ROWCOUNT,stepCt,'Done');
                commit;
                            
                --    Insert new trial data into bio_data_compound

                insert into bio_data_compound
                (bio_data_id
                ,bio_compound_id
                ,etl_source
                )
                select b.bio_experiment_id
                      ,c.bio_compound_id
                      ,'METADATA:' || study_compound_array(i).study_id
                from biomart.bio_experiment b
                    ,biomart.bio_compound c
                where upper(tmp_compound) = upper(c.generic_name) 
                  and tmp_compound is not null
                  and b.accession = study_compound_array(i).study_id
                  and not exists
                         (select 1 from biomart.bio_data_compound x
                          where b.bio_experiment_id = x.bio_data_id
                            and c.bio_compound_id = x.bio_compound_id);

                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data in BIOMART bio_data_compound',SQL%ROWCOUNT,stepCt,'Done');
                commit;
                
                dcount := dcount - 1;
            end loop;
        end loop;
    end if;

    --    delete existing disease data for studies
    
    delete bio_data_disease dc
    where dc.bio_data_id in 
         (select x.bio_experiment_id
          from bio_experiment x
              ,lt_src_study_metadata y
          where x.accession = y.study_id
            and x.etl_id = 'METADATA:' || y.study_id);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from bio_data_disease',SQL%ROWCOUNT,stepCt,'Done');
    commit;

    select distinct study_id, disease
    bulk collect into study_disease_array
    from lt_src_study_metadata
    where disease is not null;
    
    if SQL%ROWCOUNT > 0 then 
        for i in study_disease_array.first .. study_disease_array.last
        loop
        
            select length(study_disease_array(i).disease) -
                   length(replace(study_disease_array(i).disease,';',null))+1
                into dcount
            from dual;
     
            while dcount > 0
            Loop    
        
                select parse_nth_value(study_disease_array(i).disease,dcount,';') into tmp_disease
                from dual;
                   
                --    add new disease
                
                insert into bio_disease bc
                (disease
                ,prefered_name)
                select tmp_disease
                      ,tmp_disease
                from dual
                where not exists
                     (select 1 from bio_disease x
                      where upper(x.disease) = upper(tmp_disease))
                  and tmp_disease is not null;
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Added disease to bio_disease',SQL%ROWCOUNT,stepCt,'Done');
                commit;
                            
                --    Insert new trial data into bio_data_disease

                insert into bio_data_disease
                (bio_data_id
                ,bio_disease_id
                ,etl_source
                )
                select b.bio_experiment_id
                      ,c.bio_disease_id
                      ,'METADATA:' || study_disease_array(i).study_id
                from biomart.bio_experiment b
                    ,biomart.bio_disease c
                where upper(tmp_disease) = upper(c.disease) 
                  and tmp_disease is not null
                  and b.accession = study_disease_array(i).study_id
                  and not exists
                         (select 1 from biomart.bio_data_disease x
                          where b.bio_experiment_id = x.bio_data_id
                            and c.bio_disease_id = x.bio_disease_id);

                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data in BIOMART bio_data_disease',SQL%ROWCOUNT,stepCt,'Done');
                commit;
                
                dcount := dcount - 1;
            end loop;
        end loop;
    end if;

    --    delete existing taxonomy data for studies
    
    delete bio_data_taxonomy dc
    where dc.bio_data_id in 
         (select x.bio_experiment_id
          from bio_experiment x
              ,lt_src_study_metadata y
          where x.accession = y.study_id
            and x.etl_id = 'METADATA:' || y.study_id);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data from bio_data_taxonomy',SQL%ROWCOUNT,stepCt,'Done');
    commit;

    select distinct study_id, organism
    bulk collect into study_taxonomy_array
    from lt_src_study_metadata
    where organism is not null;
    
    if SQL%ROWCOUNT > 0 then 
        for i in study_taxonomy_array.first .. study_taxonomy_array.last
        loop
        
            select length(study_taxonomy_array(i).organism) -
                   length(replace(study_taxonomy_array(i).organism,';',null))+1
                into dcount
            from dual;
     
            while dcount > 0
            Loop    
        
                select parse_nth_value(study_taxonomy_array(i).organism,dcount,';') into tmp_organism
                from dual;
                   
                --    add new organism
                
                insert into bio_taxonomy bc
                (taxon_name
                ,taxon_label)
                select tmp_organism
                      ,tmp_organism
                from dual
                where not exists
                     (select 1 from bio_taxonomy x
                      where upper(x.taxon_name) = upper(tmp_organism))
                  and tmp_organism is not null;
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Added organism to bio_taxonomy',SQL%ROWCOUNT,stepCt,'Done');
                commit;
                            
                --    Insert new trial data into bio_data_taxonomy

                insert into bio_data_taxonomy
                (bio_data_id
                ,bio_taxonomy_id
                ,etl_source
                )
                select b.bio_experiment_id
                      ,c.bio_taxonomy_id
                      ,'METADATA:' || study_taxonomy_array(i).study_id
                from biomart.bio_experiment b
                    ,biomart.bio_taxonomy c
                where upper(tmp_organism) = upper(c.taxon_name) 
                  and tmp_organism is not null
                  and b.accession = study_taxonomy_array(i).study_id
                  and not exists
                         (select 1 from biomart.bio_data_taxonomy x
                          where b.bio_experiment_id = x.bio_data_id
                            and c.bio_taxonomy_id = x.bio_taxonomy_id);

                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Inserted trial data in BIOMART bio_data_taxonomy',SQL%ROWCOUNT,stepCt,'Done');
                commit;
                
                dcount := dcount - 1;
            end loop;
        end loop;
    end if;
    
    --    add ncbi/GEO linking
    
    --    check if ncbi exists in bio_content_repository, if not, add
    
    select count(*) into dcount
    from bio_content_repository
    where repository_type = 'NCBI'
      and location_type = 'URL';
    
    if dcount = 0 then
        insert into bio_content_repository
        (location
        ,active_y_n
        ,repository_type
        ,location_type) 
        values ('http://www.ncbi.nlm.nih.gov/','Y','NCBI','URL');
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Inserted NCBI URL in bio_content_repository',SQL%ROWCOUNT,stepCt,'Done');
        commit;
        
    end if;

    --    insert GSE studies into bio_content
    
    insert into bio_content
    (repository_id
    ,location
    ,file_type
    ,etl_id_c
    )
    select bcr.bio_content_repo_id
          ,'geo/query/acc.cgi?acc=' || m.study_id
          ,'Experiment Web Link'
          ,'METADATA:' || m.study_id
    from lt_src_study_metadata m
        ,bio_content_repository bcr
    where m.study_id like 'GSE%'
      and bcr.repository_type = 'NCBI'
      and bcr.location_type = 'URL'
      and not exists
         (select 1 from bio_content x
          where x.etl_id_c like '%' || m.study_id || '%'
            and x.file_type = 'Experiment Web Link'
            and x.location = 'geo/query/acc.cgi?acc=' || m.study_id);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted GEO study into bio_content',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    insert GSE studies into bio_content_reference
    
    insert into bio_content_reference
    (bio_content_id
    ,bio_data_id
    ,content_reference_type
    ,etl_id_c
    )
    select bc.bio_file_content_id
          ,be.bio_experiment_id
          ,'Experiment Web Link'
          ,'METADATA:' || m.study_id
    from lt_src_study_metadata m
        ,bio_experiment be
        ,bio_content bc
    where m.study_id like 'GSE%'
      and m.study_id = be.accession
      and bc.file_type = 'Experiment Web Link'
      and bc.etl_id_c = 'METADATA:' || m.study_id
      and bc.location = 'geo/query/acc.cgi?acc=' || m.study_id
      and not exists
         (select 1 from bio_content_reference x
          where bc.bio_file_content_id = x.bio_content_id
            and be.bio_experiment_id = x.bio_data_id);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted GEO study into bio_content_reference',SQL%ROWCOUNT,stepCt,'Done');
    commit;

    --    add PUBMED linking
    
    --    delete existing pubmed data for studies
    
    delete bio_content_reference dc
    where dc.bio_content_id in 
         (select x.bio_file_content_id
          from bio_content x
              ,lt_src_study_metadata y
          where x.file_type = 'Publication Web Link'
            and x.etl_id_c = 'METADATA:' || y.study_id);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing Pubmed data from bio_content_reference',SQL%ROWCOUNT,stepCt,'Done');
    commit;            
            
    delete bio_content dc
    where dc.bio_file_content_id in 
         (select x.bio_file_content_id
          from bio_content x
              ,lt_src_study_metadata y
          where x.file_type = 'Publication Web Link'
            and x.etl_id_c = 'METADATA:' || y.study_id);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing Pubmed data from bio_content',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    select distinct study_id, pubmed_ids
    bulk collect into study_pubmed_array
    from lt_src_study_metadata
    where pubmed_ids is not null;
    
    if SQL%ROWCOUNT > 0 then
        --    check if PubMed url exists in bio_content_repository, if not, add
        select count(*) into dcount
        from bio_content_repository
        where repository_type = 'PubMed';    
    
        if dcount = 0 then
            insert into bio_content_repository
            (location
            ,active_y_n
            ,repository_type
            ,location_type) 
            values ('http://www.ncbi.nlm.nih.gov/pubmed/','Y','PubMed','URL');
            stepCt := stepCt + 1;
            cz_write_audit(jobId,databaseName,procedureName,'Inserted GEO study into bio_content_reference',SQL%ROWCOUNT,stepCt,'Done');
            commit;
        end if;

        for i in study_pubmed_array.first .. study_pubmed_array.last
        loop
            select length(study_pubmed_array(i).pubmed)-length(replace(study_pubmed_array(i).pubmed,';',null))+1
            into dcount
            from dual;
 
            while dcount > 0
            Loop    
                -- multiple pubmed id can be separated by ;, pubmed id and title are separated by :
                
                select parse_nth_value(study_pubmed_array(i).pubmed,dcount,';') into tmp_pubmed from dual;            
                select instr(tmp_pubmed,':') into lcount from dual;
                
                if lcount = 0 then
                    pubmed_id := tmp_pubmed;
                    pubmed_title := null;
                else
                    pubmed_id := substr(tmp_pubmed,1,instr(tmp_pubmed,':')-1);
                    cz_write_audit(jobId,databaseName,procedureName,'pubmed_id: ' || pubmed_id,1,stepCt,'Done');    
                    pubmed_title := substr(tmp_pubmed,instr(tmp_pubmed,':')+1);
                    cz_write_audit(jobId,databaseName,procedureName,'pubmed_title: ' || pubmed_title,1,stepCt,'Done');
                end if;
    
                insert into bio_content
                (repository_id
                ,location
                ,title
                ,file_type
                ,etl_id_c
                )
                select bcr.bio_content_repo_id
                      ,pubmed_id
                      ,pubmed_title
                      ,'Publication Web Link'
                      ,'METADATA:' || study_pubmed_array(i).study_id
                from bio_content_repository bcr
                where bcr.repository_type = 'PubMed'
                  and not exists
                     (select 1 from bio_content x
                      where x.etl_id_c like '%' || study_pubmed_array(i).study_id || '%'
                        and x.file_type = 'Publication Web Link'
                        and x.location = pubmed_id);

                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Inserted pubmed for study into bio_content',SQL%ROWCOUNT,stepCt,'Done');
                commit;                
        
                insert into bio_content_reference
                (bio_content_id
                ,bio_data_id
                ,content_reference_type
                ,etl_id_c
                )
                select bc.bio_file_content_id
                      ,be.bio_experiment_id
                      ,'Publication Web Link'
                      ,'METADATA:' || study_pubmed_array(i).study_id
                from bio_experiment be
                    ,bio_content bc
                where be.accession = study_pubmed_array(i).study_id
                  and bc.file_type = 'Publication Web Link'
                  and bc.etl_id_c = 'METADATA:' || study_pubmed_array(i).study_id
                  and bc.location = pubmed_id
                  and not exists
                     (select 1 from bio_content_reference x
                      where bc.bio_file_content_id = x.bio_content_id
                        and be.bio_experiment_id = x.bio_data_id);    

                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Inserted pubmed for study into bio_content_reference',SQL%ROWCOUNT,stepCt,'Done');
                commit;                
    
                dcount := dcount - 1;
            end loop;
        end loop;
    end if;
    
        --    Create i2b2_tags

    delete from i2b2_tags
    where tag_type = 'Trial';
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing Trial tags in i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    insert into i2b2_tags
    (path, tag, tag_type, tags_idx)
    select min(b.c_fullname) as path
          ,be.accession as tag
          ,'Trial' as tag_type
          ,0 as tags_idx
    from bio_experiment be
        ,i2b2 b
    where be.accession = b.sourcesystem_cd
    group by be.accession;
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Add Trial tags in i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
    commit;
                     
    --    Insert trial data tags - COMPOUND
    
    delete from i2b2_tags t
    where upper(t.tag_type) = 'COMPOUND';

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing Compound tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
    commit;    
    
    insert into i2b2_tags
    (path, tag, tag_type, tags_idx)
    select distinct min(o.c_fullname) as path
          ,decode(x.rec_num,1,c.generic_name,c.brand_name) as tag
          ,'Compound' as tag_type
          ,1 as tags_idx
    from bio_experiment be
        ,bio_data_compound bc
        ,bio_compound c
        ,i2b2 o
        ,(select rownum as rec_num from table_access where rownum < 3) x
    where be.bio_experiment_id = bc.bio_data_id
       and bc.bio_compound_id = c.bio_compound_id
       and be.accession = o.sourcesystem_cd
       and decode(x.rec_num,1,c.generic_name,c.brand_name) is not null
    group by decode(x.rec_num,1,c.generic_name,c.brand_name);

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert Compound tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
    commit;    
                     
    --    Insert trial data tags - DISEASE
    
    delete from i2b2_tags t
    where upper(t.tag_type) = 'DISEASE';

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing DISEASE tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
    commit;    
        
    insert into i2b2_tags
    (path, tag, tag_type, tags_idx)
    select distinct min(o.c_fullname) as path
           ,c.prefered_name
           ,'Disease' as tag_type
           ,1 as tags_idx
    from bio_experiment be
        ,bio_data_disease bc
        ,bio_disease c
        ,i2b2 o
      --,(select rownum as rec_num from table_access where rownum < 3) x
    where be.bio_experiment_id = bc.bio_data_id
      and bc.bio_disease_id = c.bio_disease_id
      and be.accession = o.sourcesystem_cd
    --and decode(x.rec_num,1,c.generic_name,c.brand_name) is not null
    group by c.prefered_name;

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert Disease tags in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
    commit;    

    --    Load bio_ad_hoc_property
    
    delete from bio_ad_hoc_property
    where bio_data_id in
         (select distinct x.bio_experiment_id 
          from lt_src_study_metadata_ad_hoc t
              ,bio_experiment x
          where t.study_id = x.accession);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing ad_hoc metadata from BIOMART BIO_AD_HOC_PROPERTY',SQL%ROWCOUNT,stepCt,'Done');
    commit;         
    
    insert into bio_ad_hoc_property
    (bio_data_id
    ,property_key
    ,property_value)
    select b.bio_experiment_id
          ,t.ad_hoc_property_key
          ,t.ad_hoc_property_value
    from lt_src_study_metadata_ad_hoc t
        ,bio_experiment b
    where t.study_id = b.accession;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert ad_hoc metadata into BIOMART BIO_AD_HOC_PROPERTY',SQL%ROWCOUNT,stepCt,'Done');
    commit;
        --    insert study into fmapp.fm_folder
    
    insert into fmapp.fm_folder
    (folder_name 
    ,folder_level      
    ,folder_type
    ,active_ind
    )
    select m.study_id
          ,1
          ,'STUDY'
          ,'1'
    from lt_src_study_metadata m
    where not exists
          (select 1 from fmapp.fm_folder x
           where x.folder_name = m.study_id);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into fmapp.fm_folder',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    --    insert fm_folder_association
    
    insert into fmapp.fm_folder_association
    (folder_id
    ,object_uid
    ,object_type
    )
    select ff.folder_id
          ,'EXP:' || m.study_id
          ,'bio.Experiment'
    from fmapp.fm_folder ff,
       lt_src_study_metadata m
    where folder_name = m.study_id
      and not exists
         (select 1 from fmapp.fm_folder_association x
          where ff.folder_id = x.folder_id);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into fmapp.fm_folder_asociation',SQL%ROWCOUNT,stepCt,'Done');
    commit;          

    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'End i2b2_load_study_metadata',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
    IF newJobFlag = 1
    THEN
        cz_end_audit (jobID, 'SUCCESS');
    END IF;

    EXCEPTION
    WHEN OTHERS THEN
        --Handle errors.
        cz_error_handler (jobID, procedureName);
        
        --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;


/*    ignore for now
    --    Add trial/study to search_secure_object
    
    insert into searchapp.search_secure_object
    (bio_data_id
    ,display_name
    ,data_type
    ,bio_data_unique_id
    )
    select b.bio_experiment_id
          ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || b.accession as display_name
          ,'BIO_CLINICAL_TRIAL' as data_type
          ,'EXP:' || b.accession as bio_data_unique_id
    from i2b2metadata.i2b2 md
        ,biomart.bio_experiment b
    where b.accession = md.sourcesystem_cd
      and md.c_hlevel = 0
      and md.c_fullname not like '\Public Studies\%'
      and md.c_fullname not like '\Internal Studies\%'
      and md.c_fullname not like '\Experimental Medicine Study\NORMALS\%'
      and not exists
         (select 1 from searchapp.search_secure_object so
          where b.bio_experiment_id = so.bio_data_id)
    ;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted new trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
    commit;
*/


/*    not used    
    --    Insert WORKFLOW tags
    
    delete from i2b2_tags
    where tag_type = 'WORKFLOW';
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing trial WORKFLOW in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
    commit;    
    
    insert into i2b2_tags
    (path
    ,tag_type
    ,tag
    )
    select distinct b.c_fullname
          ,'WORKFLOW'
          ,decode(d.platform,'MRNA_AFFYMETRIX','Gene Expression','RBM','RBM','Protein','Protein',null) as tag
    from deapp.de_subject_sample_mapping d
        ,i2b2 b
    where d.platform is not null
      and d.trial_name = b.sourcesystem_cd
      and b.c_hlevel = 0
      and b.c_fullname not like '%Across Trials%';
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted heatmap WORKFLOW in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
    commit;    

    insert into i2b2_tags
    (path
    ,tag_type
    ,tag
    )
    select distinct c.c_fullname
          ,'WORKFLOW'
          ,'SNP'
    from deapp.de_snp_data_by_patient snp
    ,i2b2 c
    where snp.trial_name = c.sourcesystem_cd
      and c.c_hlevel = 0;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Inserted SNP WORKFLOW in I2B2METADATA i2b2_tags',SQL%ROWCOUNT,stepCt,'Done');
    commit;        
*/

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD" 
(i_etl_id		number	:= -1
,i_job_id		number	:= null
)
AS
  
    --Audit variables
	newJobFlag 	INTEGER(1);
	databaseName 	VARCHAR(100);
	procedureName VARCHAR(100);
	jobID 		number(18,0);
	stepCt 		number(18,0);
	
	v_etl_id					number(18,0);
	v_bio_assay_analysis_id		number(18,0);
	v_data_type					varchar2(50);
	v_sqlText					varchar2(2000);
	v_exists					int;
	v_GWAS_staged				int;
	v_EQTL_staged				int;
	
	type stage_rec  is record
	(bio_assay_analysis_id		number(18,0)
	,etl_id						number(18,0)
	,study_id					varchar2(500)
	,data_type					varchar2(50)
	,orig_data_type				varchar2(50)
	,analysis_name				varchar2(1000)
	);

	type stage_table is table of stage_rec; 
	stage_array stage_table;
	
	type stage_table_names_rec is record
	(table_name					varchar2(500)
	);
	
	type stage_table_names is table of stage_table_names_rec;
	stage_table_array stage_table_names;
	
	no_staged_data	exception;
	
	BEGIN	
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := -1;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
    	
	stepCt := 1;	
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
	
	--	load staged analysis to array
	
	select baa.bio_assay_analysis_id
		  ,lz.etl_id
		  ,lz.study_id
		  ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
		  ,lz.data_type as orig_data_type
		  ,lz.analysis_name
	bulk collect into stage_array
	from tm_lz.lz_src_analysis_metadata lz
		,biomart.bio_assay_analysis baa
	where lz.status = 'STAGED'
	  and lz.study_id = baa.etl_id
	  and lz.etl_id = baa.etl_id_source
	  and case when i_etl_id = -1 then 1
			   when lz.etl_id = i_etl_id then 1
			   else 0 end = 1;
			   
	v_exists := SQL%ROWCOUNT;
	
	if v_exists = 0 then
		raise no_staged_data;
	end if;

	--	set variables if staged data contains GWAS and/or EQTL data
	
	v_GWAS_staged := 0;
	v_EQTL_staged := 0;
	
	for i in stage_array.first .. stage_array.last
	loop	
		if stage_array(i).data_type = 'GWAS' then
			v_GWAS_staged := 1;
		end if;
		
		if stage_array(i).data_type = 'EQTL' then
			v_EQTL_staged := 1;
		end if;	
		
	end loop;
	
	--	drop indexes if loading GWAS data
	
	if v_GWAS_staged = 1 then
		select count(*) into v_exists
		from all_indexes
		where owner = 'BIOMART'
		  and table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
		  and index_name = 'BIO_ASSAY_ANALYSIS_GWAS_PK';
		  
		if v_exists > 0 then
			execute immediate('drop index biomart.bio_assay_analysis_gwas_pk');
		end if;

		select count(*) into v_exists
		from all_indexes
		where owner = 'BIOMART'
		  and table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
		  and index_name = 'BIO_ASSAY_ANALYSIS_GWAS_IDX2';
		  
		if v_exists > 0 then
			execute immediate('drop index biomart.bio_assay_analysis_gwas_idx2');
		end if;		
	end if;

	--	delete any existing data in bio_assay_analysis_gwas and bio_assay_analysis_eqtl
			   
	if v_GWAS_staged = 1 then
		delete from biomart.bio_assay_analysis_gwas g
		where g.bio_assay_analysis_id in
			 (select x.bio_assay_analysis_id
			  from tm_lz.lz_src_analysis_metadata t
				  ,biomart.bio_assay_analysis x
			  where t.status = 'STAGED'
				and t.data_type in ('GWAS','Metabolic GWAS')
				and t.study_id = x.etl_id
				and t.etl_id = x.etl_id_source
				and case when i_etl_id = -1 then 1
						 when t.etl_id = i_etl_id then 1
						 else 0 end = 1);
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete exising data for staged analyses from BIOMART.BIO_ASSAY_ANALYSIS_GWAS',SQL%ROWCOUNT,stepCt,'Done');
		commit;	
	end if;

	if v_EQTL_staged = 1 then
		delete from biomart.bio_assay_analysis_eqtl g
		where g.bio_assay_analysis_id in
			 (select x.bio_assay_analysis_id
			  from tm_lz.lz_src_analysis_metadata t
				  ,biomart.bio_assay_analysis x
			  where t.status = 'STAGED'
				and t.data_type = 'EQTL'
				and t.study_id = x.etl_id
				and t.etl_id = x.etl_id_source
				and case when i_etl_id = -1 then 1
						 when t.etl_id = i_etl_id then 1
						 else 0 end = 1);
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete exising data for staged analyses from BIOMART.BIO_ASSAY_ANALYSIS_EQTL',SQL%ROWCOUNT,stepCt,'Done');
		commit;	
	end if;
	
	if v_GWAS_staged = 1 then
		select count(*) into v_exists
		from all_indexes
		where owner = 'BIOMART'
		  and table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
		  and index_name = 'BIO_ASSAY_ANALYSIS_GWAS_IDX1';
		  
		if v_exists > 0 then
			execute immediate('drop index biomart.BIO_ASSAY_ANALYSIS_GWAS_IDX1');
		end if;	
	end if;
	
	for i in stage_array.first .. stage_array.last
	loop
		
		cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_array(i).study_id || ' ' || stage_array(i).orig_data_type || ' ' ||
					   stage_array(i).analysis_name,0,stepCt,'Done');
					   
		v_etl_id := stage_array(i).etl_id;
		v_bio_assay_analysis_id := stage_array(i).bio_assay_analysis_id;
		v_data_type := stage_array(i).data_type;
		
		if v_data_type = 'EQTL' then
			insert into biomart.bio_assay_analysis_eqtl
			(bio_asy_analysis_eqtl_id
			,bio_assay_analysis_id
			,rs_id
			,gene
			,p_value
			,p_value_char
			,cis_trans
			,distance_from_gene
			,etl_id
			,ext_data
			,log_p_value)
			select bio_asy_analysis_eqtl_id
				  ,bio_assay_analysis_id
				  ,rs_id
				  ,gene
				  ,to_binary_double(p_value_char)
				  ,p_value_char
				  ,cis_trans
				  ,distance_from_gene
				  ,etl_id
				  ,ext_data
				  ,log(10,to_binary_double(p_value_char))*-1
			from biomart_stage.bio_assay_analysis_eqtl
			where bio_assay_analysis_id = v_bio_assay_analysis_id;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis from BIOMART_STAGE.BIO_ASSAY_ANALYSIS_' || v_data_type,SQL%ROWCOUNT,stepCt,'Done');
			commit;		
		else
			insert into biomart.bio_assay_analysis_gwas
			(bio_asy_analysis_gwas_id
			,bio_assay_analysis_id
			,rs_id
			,p_value
			,p_value_char
			,etl_id
			,ext_data
			,log_p_value)
			select bio_asy_analysis_gwas_id
				  ,bio_assay_analysis_id
				  ,rs_id
				  ,to_binary_double(p_value_char)
				  ,p_value_char
				  ,etl_id
				  ,ext_data
				  ,log(10,to_binary_double(p_value_char))*-1
			from biomart_stage.bio_assay_analysis_gwas
			where bio_assay_analysis_id = v_bio_assay_analysis_id;
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis from BIOMART_STAGE.BIO_ASSAY_ANALYSIS_' || v_data_type,SQL%ROWCOUNT,stepCt,'Done');
			commit;	
		end if;

		if i_etl_id > -1 then

			v_sqlText := 'delete from biomart_stage.bio_assay_analysis_' || v_data_type || 
						 ' where bio_assay_analysis_id = ' || to_char(v_bio_assay_analysis_id);
			--dbms_output.put_line(v_sqlText);
			execute immediate(v_sqlText);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Delete data for analysis from BIOMART_STAGE.BIO_ASSAY_ANALYSIS_' || v_data_type,SQL%ROWCOUNT,stepCt,'Done');
			commit;	
		end if;	
		
		update tm_lz.lz_src_analysis_metadata
		set status='PRODUCTION'
		where etl_id = v_etl_id;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
		commit;				
			
	end loop;
	
	if i_etl_id = -1 then
	
		select table_name
		bulk collect into stage_table_array
		from all_tables
		where owner = 'BIOMART_STAGE'
		  and table_name like 'BIO_ASSAY_ANALYSIS%';
		  
		for i in stage_table_array.first .. stage_table_array.last
		loop
			v_sqlText := 'truncate table biomart_stage.' || stage_table_array(i).table_name;
			--dbms_output.put_line(v_sqlText);
			execute immediate(v_sqlText);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Truncated biomart_stage.' || stage_table_array(i).table_name,0,stepCt,'Done');
		end loop;
	end if;
	
	--	recreate GWAS indexes if needed
	
	if v_GWAS_staged = 1 then
		execute immediate('create index biomart.bio_assay_analysis_gwas_idx1 on biomart.bio_assay_analysis_gwas (bio_assay_analysis_id) tablespace "INDX"');
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Created index bio_assay_analysis_gwas_idx1',0,stepCt,'Done');
		execute immediate('create index biomart.bio_assay_analysis_gwas_idx2 on biomart.bio_assay_analysis_gwas (rs_id) tablespace "INDX"');
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Created index bio_assay_analysis_gwas_idx2',0,stepCt,'Done');
		execute immediate('create unique index biomart.bio_assay_analysis_gwas_pk on biomart.bio_assay_analysis_gwas (bio_asy_analysis_gwas_id) tablespace "INDX"');
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Created index bio_assay_analysis_gwas_pk',0,stepCt,'Done');
    I2B2_LOAD_EQTL_TOP50();
    stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Created top 50 EQTL',0,stepCt,'Done');
    I2B2_LOAD_GWAS_TOP50();
    stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Created top 50 GWAS',0,stepCt,'Done');
	end if;
	
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_move_analysis_to_prod',0,stepCt,'Done');
	stepCt := stepCt + 1;
	
	cz_end_audit(jobId, 'Success');
	
	exception
	when no_staged_data then
		cz_write_audit(jobId, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
		cz_end_audit(jobId, 'Success');
	when others then
    --Handle errors.
		cz_error_handler (jobID, procedureName);
    --End Proc
		cz_end_audit (jobID, 'FAIL');
	
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_DC
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_DC" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    --recreate index using parallel 8
    --generate datacounts
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                    number(18,0);
    v_bio_assay_analysis_id        number(18,0);
    v_data_type                    varchar2(50);
    v_sqlText                    varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                int;
    v_EQTL_staged                int;
    
    type stage_rec  is record
    (bio_assay_analysis_id        number(18,0)
    ,etl_id                        number(18,0)
    ,study_id                    varchar2(500)
    ,data_type                    varchar2(50)
    ,orig_data_type                varchar2(50)
    ,analysis_name                varchar2(1000)
    );

    type stage_table is table of stage_rec; 
    stage_array stage_table;
    
    type stage_table_names_rec is record
    (table_name                    varchar2(500)
    );
    
    type stage_table_names is table of stage_table_names_rec;
    stage_table_array stage_table_names;
    
    no_staged_data    exception;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
    --    load staged analysis to array
    
    select baa.bio_assay_analysis_id
          ,lz.etl_id
          ,lz.study_id
          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
          ,lz.data_type as orig_data_type
          ,lz.analysis_name
    bulk collect into stage_array
    from tm_lz.lz_src_analysis_metadata lz
        ,biomart.bio_assay_analysis baa
    where lz.status = 'STAGED'
      and lz.study_id = baa.etl_id
      and lz.etl_id = baa.etl_id_source
      and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1;
               
    v_exists := SQL%ROWCOUNT;
    
    if v_exists = 0 then
        raise no_staged_data;
    end if;

    --    set variables if staged data contains GWAS and/or EQTL data
    
    v_GWAS_staged := 0;
    v_EQTL_staged := 0;
    
    for i in stage_array.first .. stage_array.last
    loop    
        if stage_array(i).data_type = 'GWAS' then
            v_GWAS_staged := 1;
        end if;
        
        if stage_array(i).data_type = 'EQTL' then
            v_EQTL_staged := 1;
        end if;    
        
    end loop;
    
    --    drop indexes if loading GWAS data
    
    if v_GWAS_staged = 1 then
        select count(*) into v_exists
        from all_indexes
        where owner = 'BIOMART'
          and table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
          and index_name = 'BIO_ASSAY_ANALYSIS_GWAS_PK';
          
        if v_exists > 0 then
            execute immediate('drop index biomart.bio_assay_analysis_gwas_pk');
        end if;

        select count(*) into v_exists
        from all_indexes
        where owner = 'BIOMART'
          and table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
          and index_name = 'BIO_ASSAY_ANALYSIS_GWAS_IDX2';
          
        if v_exists > 0 then
            execute immediate('drop index biomart.bio_assay_analysis_gwas_idx2');
        end if;        
    end if;

    --    delete any existing data in bio_assay_analysis_gwas and bio_assay_analysis_eqtl
               
    if v_GWAS_staged = 1 then
        delete from biomart.bio_assay_analysis_gwas g
        where g.bio_assay_analysis_id in
             (select x.bio_assay_analysis_id
              from tm_lz.lz_src_analysis_metadata t
                  ,biomart.bio_assay_analysis x
              where t.status = 'STAGED'
                and t.data_type in ('GWAS','Metabolic GWAS')
                and t.study_id = x.etl_id
                and t.etl_id = x.etl_id_source
                and case when i_etl_id = -1 then 1
                         when t.etl_id = i_etl_id then 1
                         else 0 end = 1);
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Delete exising data for staged analyses from BIOMART.BIO_ASSAY_ANALYSIS_GWAS',SQL%ROWCOUNT,stepCt,'Done');
        commit;    
    end if;

    if v_EQTL_staged = 1 then
        delete from biomart.bio_assay_analysis_eqtl g
        where g.bio_assay_analysis_id in
             (select x.bio_assay_analysis_id
              from tm_lz.lz_src_analysis_metadata t
                  ,biomart.bio_assay_analysis x
              where t.status = 'STAGED'
                and t.data_type = 'EQTL'
                and t.study_id = x.etl_id
                and t.etl_id = x.etl_id_source
                and case when i_etl_id = -1 then 1
                         when t.etl_id = i_etl_id then 1
                         else 0 end = 1);
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Delete exising data for staged analyses from BIOMART.BIO_ASSAY_ANALYSIS_EQTL',SQL%ROWCOUNT,stepCt,'Done');
        commit;    
    end if;
    
    if v_GWAS_staged = 1 then
        select count(*) into v_exists
        from all_indexes
        where owner = 'BIOMART'
          and table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
          and index_name = 'BIO_ASSAY_ANALYSIS_GWAS_IDX1';
          
        if v_exists > 0 then
            execute immediate('drop index biomart.BIO_ASSAY_ANALYSIS_GWAS_IDX1');
        end if;    
    end if;
    
    for i in stage_array.first .. stage_array.last
    loop
        
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_array(i).study_id || ' ' || stage_array(i).orig_data_type || ' ' ||
                       stage_array(i).analysis_name,0,stepCt,'Done');
                       
        v_etl_id := stage_array(i).etl_id;
        v_bio_assay_analysis_id := stage_array(i).bio_assay_analysis_id;
        v_data_type := stage_array(i).data_type;
        
        if v_data_type = 'EQTL' then
            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,ext_data
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis from BIOMART_STAGE.BIO_ASSAY_ANALYSIS_' || v_data_type,SQL%ROWCOUNT,stepCt,'Done');
           commit;        
        else
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,ext_data
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis from BIOMART_STAGE.BIO_ASSAY_ANALYSIS_' || v_data_type,SQL%ROWCOUNT,stepCt,'Done');
            commit;    
        end if;

        if i_etl_id > -1 then

            v_sqlText := 'delete from biomart_stage.bio_assay_analysis_' || v_data_type || 
                         ' where bio_assay_analysis_id = ' || to_char(v_bio_assay_analysis_id);
            --dbms_output.put_line(v_sqlText);
            execute immediate(v_sqlText);
            stepCt := stepCt + 1;
            cz_write_audit(jobId,databaseName,procedureName,'Delete data for analysis from BIOMART_STAGE.BIO_ASSAY_ANALYSIS_' || v_data_type,SQL%ROWCOUNT,stepCt,'Done');
            commit;    
        end if;    
        
        update tm_lz.lz_src_analysis_metadata
        set status='PRODUCTION'
        where etl_id = v_etl_id;
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
        commit;                
            
    end loop;
    
    if i_etl_id = -1 then
    
        select table_name
        bulk collect into stage_table_array
        from all_tables
        where owner = 'BIOMART_STAGE'
          and table_name like 'BIO_ASSAY_ANALYSIS%';
          
        for i in stage_table_array.first .. stage_table_array.last
        loop
            v_sqlText := 'truncate table biomart_stage.' || stage_table_array(i).table_name;
            --dbms_output.put_line(v_sqlText);
            execute immediate(v_sqlText);
            stepCt := stepCt + 1;
            cz_write_audit(jobId,databaseName,procedureName,'Truncated biomart_stage.' || stage_table_array(i).table_name,0,stepCt,'Done');
        end loop;
    end if;
    
    --    recreate GWAS indexes if needed
    
    if v_GWAS_staged = 1 then
        execute immediate('create index biomart.bio_assay_analysis_gwas_idx1 on biomart.bio_assay_analysis_gwas (bio_assay_analysis_id) tablespace "INDX" parallel 8');
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Created index bio_assay_analysis_gwas_idx1',0,stepCt,'Done');
        execute immediate('create index biomart.bio_assay_analysis_gwas_idx2 on biomart.bio_assay_analysis_gwas (rs_id) tablespace "INDX" parallel 8');
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Created index bio_assay_analysis_gwas_idx2',0,stepCt,'Done');
        execute immediate('create unique index biomart.bio_assay_analysis_gwas_pk on biomart.bio_assay_analysis_gwas (bio_asy_analysis_gwas_id) tablespace "INDX" parallel 8');
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Created index bio_assay_analysis_gwas_pk',0,stepCt,'Done');
        
        
    I2B2_LOAD_EQTL_TOP50();
    stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Created top 50 EQTL',0,stepCt,'Done');
    I2B2_LOAD_GWAS_TOP50();
    stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Created top 50 GWAS',0,stepCt,'Done');

    end if;
    
    --Insert data_count to bio_assay_analysis table. added by Haiyan Zhang 01/22/2013
    for i in stage_array.first .. stage_array.last
    loop
        v_bio_assay_analysis_id := stage_array(i).bio_assay_analysis_id;
        v_data_type := stage_array(i).data_type;
        if v_data_type = 'EQTL' then
          
            update biomart.bio_assay_analysis set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl 
            where bio_assay_analysis_eqtl.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where bio_assay_analysis.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobId,databaseName,procedureName,'Update data_count for analysis ' || v_data_type,SQL%ROWCOUNT,stepCt,'Done');
            commit;
        else
          
            update biomart.bio_assay_analysis set data_count=(select count(*) from biomart.bio_assay_analysis_gwas 
            where bio_assay_analysis_gwas.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where bio_assay_analysis.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobId,databaseName,procedureName,'Update data_count for analysis ' || v_data_type,SQL%ROWCOUNT,stepCt,'Done');
            commit;
        end if;
    end loop; 
    ---end added by Haiyan Zhang
    
    cz_write_audit(jobId,databaseName,procedureName,'End i2b2_move_analysis_to_prod',0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobId, 'Success');
    
    exception
    when no_staged_data then
        cz_write_audit(jobId, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobId, 'Success');
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_ANALYSIS_TO_PROD_NEW
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_ANALYSIS_TO_PROD_NEW" 
(i_etl_id        number    := -1
,i_job_id        number    := null
)
AS
    -- create indexes using parallele 8  -zhanh101 5/10/2013 use ~20-30% original time  
    --Audit variables
    newJobFlag     INTEGER(1);
    databaseName     VARCHAR(100);
    procedureName VARCHAR(100);
    jobID         number(18,0);
    stepCt         number(18,0);
    
    v_etl_id                                        number(18,0);
    v_bio_assay_analysis_id                number(18,0);
    v_data_type                                        varchar2(50);
    v_sqlText                                        varchar2(2000);
    v_exists                    int;
    v_GWAS_staged                                int;
    v_EQTL_staged                                int;
        v_gwas_indx                                        int;
        v_eqtl_indx                                        int;
        v_max_ext_flds                                int;
    
    BEGIN    
    
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := -1;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;
        
    stepCt := 1;    
    cz_write_audit(jobID,databaseName,procedureName,'Starting i2b2_move_analysis_to_prod',0,stepCt,'Done');
    
        v_GWAS_staged := 0;
        v_EQTL_staged := 0;
        v_gwas_indx := 0;
        
    --    load staged analysis to array
    
        for stage_rec in 
                (select baa.bio_assay_analysis_id
                          ,lz.etl_id
                          ,lz.study_id
                          ,case when lz.data_type = 'Metabolic GWAS' then 'GWAS' else lz.data_type end as data_type
                          ,lz.data_type as orig_data_type
                          ,lz.analysis_name
                from tm_lz.lz_src_analysis_metadata lz
                        ,biomart.bio_assay_analysis baa
                where lz.status = 'STAGED'
                  and lz.study_id = baa.etl_id
                  and lz.etl_id = baa.etl_id_source
                  and case when i_etl_id = -1 then 1
               when lz.etl_id = i_etl_id then 1
               else 0 end = 1)
        loop
                stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Loading ' || stage_rec.study_id || ' ' || stage_rec.orig_data_type || ' ' ||
                       stage_rec.analysis_name,0,stepCt,'Done');
                           
                v_bio_assay_analysis_id := stage_rec.bio_assay_analysis_id;
                v_etl_id := stage_rec.etl_id;
                v_data_type := stage_rec.data_type;
                
                --        get max nbr fields in ext_data for original data type
                        
                select max(field_idx) into v_max_ext_flds
                from biomart.bio_asy_analysis_data_idx
                where ext_type = stage_rec.orig_data_type;
                
        if stage_rec.data_type = 'GWAS' then
                        --        GWAS data
            v_GWAS_staged := 1;
                /* comment out for not disabling the indexes   by HZ 1/15/2014
                        if v_gwas_indx = 0 then
                                --        disable indexes if loading GWAS data
                                for gwas_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name in ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') 
                                                                   and partitioned = 'NO' and compression!='DISABLED' )
                                loop
                                        v_sqlText := 'alter index biomart.' || gwas_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_gwas_indx := 1;
                        end if;
              */          
                        --        check if partition exists for bio_assay_analysis_id, if not, add, if yes, truncate
                        select count(*) into v_exists
                        from all_tab_partitions
                        where table_name = 'BIO_ASSAY_ANALYSIS_GWAS'
                          and partition_name = to_char(v_bio_assay_analysis_id);
                
                        if v_exists = 0 then        
                                --        add partition to bio_assay_analysis_gwas
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas add PARTITION "' || to_char(v_bio_assay_analysis_id) || '"  VALUES (' || 
                                                    to_char(v_bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Adding partition to bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        else
                                --        truncate existing partition
                                v_sqlText := 'alter table biomart.bio_assay_analysis_gwas truncate partition "' || to_char(v_bio_assay_analysis_id) || '"';
                                execute immediate(v_sqlText);
                                stepCt := stepCt + 1;
                                cz_write_audit(jobID,databaseName,procedureName,'Truncating partition in bio_assay_analysis_gwas '|| to_char(v_bio_assay_analysis_id),0,stepCt,'Done');
                        end if;
                        
            insert into biomart.bio_assay_analysis_gwas
            (bio_asy_analysis_gwas_id
            ,bio_assay_analysis_id
            ,rs_id
            ,p_value
            ,p_value_char
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_gwas_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_gwas
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis from biomart.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
            commit; 
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_gwas x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_gwas
                        where bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
                        commit; 

                        --        load top50 table
                        i2b2_load_gwas_top50(v_bio_assay_analysis_id, jobID);
                        
                else
                        --        EQTL data
                        v_EQTL_staged := 1;
                      /*  
                        if v_eqtl_indx = 0 then
                                --        disable indexes if loading eqtl data
                                for eqtl_idx in (select index_name
                                                                           ,table_name
                                                                 from all_indexes 
                                                             where owner = 'BIOMART' 
                                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50' )
                                loop
                                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' unusable';
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                                        execute immediate(v_sqlText);
                                        stepCt := stepCt + 1;
                                        cz_write_audit(jobID,databaseName,procedureName,'Disabling complete',SQL%ROWCOUNT,stepCt,'Done');       
                                end loop;
                                v_eqtl_indx := 1;
                        end if;
                        */
                        --        delete existing data from bio_assay_analysis_eqtl
                        delete from biomart.bio_assay_analysis_eqtl g
                        where g.bio_assay_analysis_id = v_bio_assay_analysis_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Delete exising data for staged analyses from biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
                        commit;    

            insert into biomart.bio_assay_analysis_eqtl
            (bio_asy_analysis_eqtl_id
            ,bio_assay_analysis_id
            ,rs_id
            ,gene
            ,p_value
            ,p_value_char
            ,cis_trans
            ,distance_from_gene
            ,etl_id
            ,ext_data
            ,log_p_value)
            select bio_asy_analysis_eqtl_id
                  ,bio_assay_analysis_id
                  ,rs_id
                  ,gene
                  ,to_binary_double(p_value_char)
                  ,p_value_char
                  ,cis_trans
                  ,distance_from_gene
                  ,etl_id
                  ,case when length(ext_data)-length(replace(ext_data,';','')) < v_max_ext_flds
                                                then tm_cz.repeat_char(ext_data,v_max_ext_flds-(length(ext_data)-length(replace(ext_data,';',''))),';')
                                                else ext_data
                                   end
                  ,log(10,to_binary_double(p_value_char))*-1
            from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Insert data for analysis into biomart.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit;        
                        
                        --        update data_count in bio_assay_analysis
                        
            update biomart.bio_assay_analysis baa
                        set data_count=(select count(*) from biomart.bio_assay_analysis_eqtl x
                                                        where x.bio_assay_analysis_id=v_bio_assay_analysis_id) 
            where baa.bio_assay_analysis_id=v_bio_assay_analysis_id;
            stepCt := stepCt +1;
            cz_write_audit(jobID,databaseName,procedureName,'Update data_count for analysis',SQL%ROWCOUNT,stepCt,'Done');
            commit;                        
        
                        --        update status in lz_src_analysis_metadata
                        
                        update tm_lz.lz_src_analysis_metadata
                        set status='PRODUCTION'
                        where etl_id = v_etl_id;
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Set status to PRODUCTION in tm_lz.lz_src_analysis_metadata',SQL%ROWCOUNT,stepCt,'Done');
                        commit;        
                        
                        --        delete data from biomart_stage
                        
                        delete from biomart_stage.bio_assay_analysis_eqtl
            where bio_assay_analysis_id = v_bio_assay_analysis_id;
            stepCt := stepCt + 1;
            cz_write_audit(jobID,databaseName,procedureName,'Delete data for analysis from biomart_stage.bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
            commit; 

                        --        load top50 table
                        i2b2_load_eqtl_top50(v_bio_assay_analysis_id, jobID);
                
                end if;
        end loop;
    
    --    rebuild indexes if loading GWAS data
    /*
    if v_GWAS_staged = 1 then
                for gwas_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name In ('BIO_ASSAY_ANALYSIS_GWAS','BIO_ASY_ANALYSIS_GWAS_TOP50') )
                loop
                        v_sqlText := 'alter index ' || gwas_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || gwas_idx.index_name || ' on ' || gwas_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_gwas_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;

    --    rebuild indexes if loading EQTL data
    /*
    if v_eqtl_staged = 1 then
                for eqtl_idx in (select index_name 
                                                           ,table_name
                                                 from all_indexes 
                                                 where owner = 'BIOMART' 
                                                   and table_name = 'BIO_ASY_ANALYSIS_EQTL_TOP50')
                loop
                        v_sqlText := 'alter index ' || eqtl_idx.index_name || ' rebuild';
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding index ' || eqtl_idx.index_name || ' on ' || eqtl_idx.table_name,SQL%ROWCOUNT,stepCt,'Done');
                        execute immediate(v_sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobID,databaseName,procedureName,'Rebuilding complete',SQL%ROWCOUNT,stepCt,'Done');       
                end loop;
        end if;
        */
        if v_eqtl_staged = 0 and v_eqtl_staged = 0 then
        cz_write_audit(jobID, databaseName, procedureName, 'No staged data - run terminating normally',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;        
        --        check if any data left in staging tables, ususally indicated no bio_assay_analysis record in biomart
        
        select count(*) into v_exists
        from (select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_gwas
                  union 
                  select distinct bio_assay_analysis_id from biomart_stage.bio_assay_analysis_eqtl);
                  
        if v_exists = 0 then
        cz_write_audit(jobID, databaseName, procedureName, '**WARNING ** data remains in stage tables',0,stepCt,'Done');
        cz_end_audit(jobID, 'Success');
        end if;                  
                
    cz_write_audit(jobID,databaseName,procedureName,'End ' || procedureName,0,stepCt,'Done');
    stepCt := stepCt + 1;
    
    cz_end_audit(jobID, 'Success');
    
    exception
    when others then
    --Handle errors.
        cz_error_handler (jobID, procedureName);
    --End Proc
        cz_end_audit (jobID, 'FAIL');
    
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_NODE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_NODE" 
(
  old_path VARCHAR2,
  new_path VARCHAR2,
  topNode	varchar2,
  currentJobID NUMBER := null
)
AS

  root_node		varchar2(2000);
  root_level	int;
 
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
BEGIN

 
  -------------------------------------------------------------
  -- Add a tree node in I2b2
  -- KCR@20090519 - First Rev
  --	JEA@20111212	Added auditing, recreate concept_counts for topNode
  -------------------------------------------------------------
  
	stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;
  
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
	cz_start_audit (procedureName, databaseName, jobID);
	END IF;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_move_node',0,stepCt,'Done');  
	
	select parse_nth_value(topNode, 2, '\') into root_node from dual;
	
	select c_hlevel into root_level
	from table_access
	where c_name = root_node;
	
	if old_path != ''  or old_path != '%' or new_path != ''  or new_path != '%'
	then 
      --CONCEPT DIMENSION
		update concept_dimension
		set CONCEPT_PATH = replace(concept_path, old_path, new_path)
		where concept_path like old_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update concept_dimension with new path',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;
    
		--I2B2
		update i2b2
		set c_fullname = replace(c_fullname, old_path, new_path)
		where c_fullname like old_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new path',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;
  
		--update level data
		UPDATE I2B2
		set c_hlevel = (length(c_fullname) - nvl(length(replace(c_fullname, '\')),0)) / length('\') - 2 + root_level
		where c_fullname like new_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new level',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;
		
		--Update tooltip and dimcode
		update i2b2
		set c_dimcode = c_fullname,
		c_tooltip = c_fullname
		where c_fullname like new_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new dimcode and tooltip',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;

		--if topNode != '' then
		--	i2b2_create_concept_counts(topNode,jobId);
		--end if;
	end if;
	
	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;

	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		--End Proc
		cz_end_audit (jobID, 'FAIL');
		
END;
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MOVE_STUDY
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MOVE_STUDY" 
(
  old_path VARCHAR2,
  new_path VARCHAR2,
 -- topNode	varchar2,
  currentJobID NUMBER := null
)
AS

  root_node		varchar2(2000);
  root_level	int;
 
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
BEGIN

 
  -------------------------------------------------------------
  --	I2B2_MOVE_STUDY is used to move an entire study to a new location in the ontology
  --	
  --	JEA@20120127	New, cloned from i2b2_move_node
  --	JEA@20120328	Fixed parent_concept_path of top-node
 
  -------------------------------------------------------------
  
	stepCt := 0;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;
  
	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
	cz_start_audit (procedureName, databaseName, jobID);
	END IF;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_move_node',0,stepCt,'Done');  
	
	select parse_nth_value(new_path, 2, '\') into root_node from dual;
	
	select c_hlevel into root_level
	from table_access
	where c_name = root_node;
	
	if old_path != ''  or old_path != '%' or new_path != ''  or new_path != '%'
	then 
      --CONCEPT DIMENSION
		update concept_dimension
		set CONCEPT_PATH = replace(concept_path, old_path, new_path)
		where concept_path like old_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update concept_dimension with new path',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;
    
		--I2B2
		update i2b2
		set c_fullname = replace(c_fullname, old_path, new_path)
			,c_dimcode = replace(c_fullname, old_path, new_path)
			,c_tooltip = replace(c_fullname, old_path, new_path)
			,c_hlevel =  (length(replace(c_fullname, old_path, new_path)) - nvl(length(replace(replace(c_fullname, old_path, new_path), '\')),0)) / length('\') - 2 + root_level
		where c_fullname like old_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new path',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;
		
		--	concept_counts
		
		update concept_counts
		set concept_path = replace(concept_path, old_path, new_path)
		   ,parent_concept_path = replace(parent_concept_path, old_path, new_path)
		where concept_path like old_path || '%';
		
		--	update parent_concept_path for new_path (replace doesn't work)
		update concept_counts 
		set parent_concept_path=ltrim(SUBSTR(concept_path, 1,instr(concept_path, '\',-1,2)))
		where concept_path = new_path;
		
		--	fill in any upper levels
		
		i2b2_fill_in_tree(null, new_path, jobID);
		
/*
		--update level data
		UPDATE I2B2
		set c_hlevel = (length(c_fullname) - nvl(length(replace(c_fullname, '\')),0)) / length('\') - 2 + root_level
		where c_fullname like new_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new level',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;
		
		--Update tooltip and dimcode
		update i2b2
		set c_dimcode = c_fullname,
		c_tooltip = c_fullname
		where c_fullname like new_path || '%';
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new dimcode and tooltip',SQL%ROWCOUNT,stepCt,'Done'); 
		COMMIT;

		if topNode != '' then
			i2b2_fill_in_tree
			i2b2_create_concept_counts(topNode,jobId);
		end if;
*/
	end if;
	
	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;

	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		--End Proc
		cz_end_audit (jobID, 'FAIL');
		
END;
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MRNA_DATA_EXTRNL_LT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MRNA_DATA_EXTRNL_LT" 
(
  trial_id 		IN	VARCHAR2
 ,currentJobID	IN	NUMBER := null
)
AS

	--	JEA@20111028	New, loads MRNA data from external table to landing zone temporary table
  
  topNode		VARCHAR2(2000);
  topLevel		number(10,0);
  root_node		varchar2(2000);
  root_level	int;
  study_name	varchar2(2000);
  TrialID		varchar2(100);
  secureStudy	varchar2(200);
  etlDate		date;
  tPath			varchar2(2000);
  pCount		int;
  rtnCode		int;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  

BEGIN
  
	TrialID := upper(trial_id);
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;
	
	select sysdate into etlDate from dual;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
    	
	stepCt := 0;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_clinical_data_extrnl_lt',0,stepCt,'Done');
	
	--	truncate landing zone work table
	
	execute immediate('truncate table tm_lz.lt_src_mrna_data');
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate table lt_src_mrna_data',0,stepCt,'Done');
		
	--	Insert data to lt_src_mrna_data
	
	insert into lt_src_mrna_data
	(trial_name
	,probeset
	,expr_id
	,intensity_value
	)
	select TrialId
		  ,probeset
		  ,expr_id
		  ,intensity_value
	from mrna_data_extrnl;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data into lt_src_mrna_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	truncate landing zone work table for subject_sample mapping
	
	execute immediate('truncate table tm_lz.lt_src_mrna_subj_samp_map');
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate table lt_src_mrna_subj_samp_map',0,stepCt,'Done');
		
	--	insert data to lt_src_mrna_subj_samp_map
	
	insert into lt_src_mrna_subj_samp_map
	(trial_name
	,site_id
	,subject_id
	,sample_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,category_cd
	)
	select Trial_id
		  ,site_id
		  ,subject_id
		  ,sample_cd
		  ,platform
		  ,tissue_type
		  ,attribute_1
		  ,attribute_2
		  ,category_cd
	from mrna_subj_sample_map_extrnl;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data into lt_src_mrna_subj_samp_map',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_clinical_data_extrnl_lt',0,stepCt,'Done');
	
    ---Cleanup OVERALL JOB if this proc is being run standalone
	if newJobFlag = 1
	then
		cz_end_audit (jobID, 'SUCCESS');
	end if;

	rtnCode := 0;
  
	exception
	when others then
    --Handle errors.
		cz_error_handler (jobID, procedureName);
    --End Proc
		cz_end_audit (jobID, 'FAIL');
		rtnCode := 16;
	
end;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MRNA_INDEX_MAINT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MRNA_INDEX_MAINT" 
(
  run_type 			VARCHAR2 := 'DROP'
 ,tablespace_name	varchar2	:= 'INDX'
 ,currentJobID 		NUMBER := null
)
AS
--	Procedure to either drop or create indexes for deapp.de_subject_microarray_data

--	JEA@20111020	New
--	JEA@20111130	Only do local or bitmap index if de_subject_microarray_data is partitioned
--	JEA@20120226	Added tablespace to indx10, added bitmapCompress to compress indexs if not bitmapped
--	JEA@20120301	Removed indx10, subject_id no longer in de_subject_microarray_data
--	JEA@20120406	Added variable for tablespace name
--	JEA@20120423	Removed indx5, app code changed to join on assay_id
--	JEA@20120530	Added indx5 on trial_source if table not partitioned

  runType	varchar2(100);
  idxExists	number;
  pExists	number;
  localVar	varchar2(20);
  bitmapVar	varchar2(20);
  bitmapCompress	varchar2(20);
  tableSpace	varchar2(50);
   
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
BEGIN

	runType := upper(run_type);
	tableSpace := upper(tablespace_name);
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  
	--	Determine if de_subject_microarray_data is partitioned, if yes, set localVar to local
  	select count(*)
	into pExists
	from all_tables
	where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
	  and partitioned = 'YES';
	  
	if pExists = 0 then
		localVar := null;
		bitmapVar := null;
		bitmapCompress := 'compress';
	else 
		localVar := 'local';
		bitmapVar := 'bitmap';
		bitmapCompress := null;
	end if;
   
	if runType = 'DROP' then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Start de_subject_microarray_data index drop',0,stepCt,'Done');
		--	drop the indexes
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX1'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			execute immediate('drop index deapp.de_microarray_data_idx1');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx1',0,stepCt,'Done');
		end if;
		
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX2'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			execute immediate('drop index deapp.de_microarray_data_idx2');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx2',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX3'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			execute immediate('drop index deapp.de_microarray_data_idx3');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx3',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX4'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			execute immediate('drop index deapp.de_microarray_data_idx4');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx4',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX5'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			execute immediate('drop index deapp.de_microarray_data_idx5');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx5',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX10'
		  and owner = 'DEAPP';
		
		if idxExists = 1 then
			execute immediate('drop index deapp.de_microarray_data_idx10');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Drop de_microarray_data_idx10',0,stepCt,'Done');
		end if;
						
	else
		--	add indexes
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Start de_subject_microarray_data index create',0,stepCt,'Done');
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX1'
		  and owner = 'DEAPP';
		  
		if idxExists = 0 then
			execute immediate('create index deapp.de_microarray_data_idx1 on deapp.de_subject_microarray_data(trial_name, assay_id, probeset_id) ' || localVar || ' nologging compress tablespace "' || tableSpace || '"'); 
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx1',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX2'
		  and owner = 'DEAPP';
		  
		if idxExists = 0 then		
			execute immediate('create index deapp.de_microarray_data_idx2 on deapp.de_subject_microarray_data(assay_id, probeset_id) ' || localVar || ' nologging compress tablespace "' || tableSpace || '"');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx2',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX3'
		  and owner = 'DEAPP';
		  
		if idxExists = 0 then		
			execute immediate('create ' || bitmapVar || ' index deapp.de_microarray_data_idx3 on deapp.de_subject_microarray_data(assay_id) ' || localVar || ' nologging ' || bitmapCompress || ' tablespace "' || tableSpace || '"');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx3',0,stepCt,'Done');
		end if;
				
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX4'
		  and owner = 'DEAPP';
		  
		if idxExists = 0 then
			execute immediate('create ' || bitmapVar || ' index deapp.de_microarray_data_idx4 on deapp.de_subject_microarray_data(probeset_id) ' || localVar || ' nologging ' || bitmapCompress || ' tablespace "' || tableSpace || '"');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx4',0,stepCt,'Done');
		end if;

		if pExists = 0 then
			--	only create this index if the table is not partitioned.  This is the column that the table would be partitioned on
			
			select count(*) 
			into idxExists
			from all_indexes
			where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
			  and index_name = 'DE_MICROARRAY_DATA_IDX5'
			  and owner = 'DEAPP';
			  
			if idxExists = 0 then
				execute immediate('create index deapp.de_microarray_data_idx5 on deapp.de_subject_microarray_data(trial_source) ' || localVar || ' nologging ' || bitmapCompress || ' tablespace "' || tableSpace || '"');
				stepCt := stepCt + 1;
				cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx5',0,stepCt,'Done');
			end if;
		end if;

/*		not used
	
		select count(*) 
		into idxExists
		from all_indexes
		where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
		  and index_name = 'DE_MICROARRAY_DATA_IDX10'
		  and owner = 'DEAPP';
		  
		if idxExists = 0 then
			execute immediate('create index deapp.de_microarray_data_idx10 on deapp.de_subject_microarray_data(assay_id, subject_id, probeset_id, zscore) ' || localVar || ' nologging compress tablespace "' || tableSpace || '"');
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Create de_microarray_data_idx10',0,stepCt,'Done');
		end if;
*/							
	end if;

end;
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_MRNA_ZSCORE_CALC
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_MRNA_ZSCORE_CALC" 
(
  trial_id VARCHAR2
 ,run_type varchar2 := 'L'
 ,currentJobID NUMBER := null
 ,data_type varchar2 := 'R'
 ,log_base	number := 2
 ,source_cd	varchar2
)
AS

	--	JEA@20111024	New
	--	JEA@20111116	Remove run_type R (reload) processing
	--	JEA@20111209	Removed index drop/all
	--	JEA@20120214	Round all intensity values on insert to de_subject_microarray_data
	--	JEA@20120314	Custom for Millennium, added trial_source for partitioning, added source_cd parameter 

  TrialID varchar2(50);
  sourceCD	varchar2(50);
  sqlText varchar2(2000);
  runType varchar2(10);
  dataType varchar2(10);
  stgTrial varchar2(50);
  idxExists number;
  pExists	number;
  nbrRecs number;
  logBase number;
   
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  --  exceptions
  invalid_runType exception;
  trial_mismatch exception;
  trial_missing exception;
  
BEGIN

	TrialId := trial_id;
	runType := run_type;
	dataType := data_type;
	logBase := log_base;
	sourceCd := source_cd;
	  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting zscore calc for ' || TrialId || ' RunType: ' || runType || ' dataType: ' || dataType,0,stepCt,'Done');
  
	if runType != 'L' then
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Invalid runType passed - procedure exiting',SQL%ROWCOUNT,stepCt,'Done');
		raise invalid_runType;
	end if;
  
--	For Load, make sure that the TrialId passed as parameter is the same as the trial in stg_subject_mrna_data
--	If not, raise exception

	if runType = 'L' then
		select distinct trial_name into stgTrial
		from wt_subject_mrna_probeset;
		
		if stgTrial != TrialId then
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'TrialId not the same as trial in wt_subject_mrna_probeset - procedure exiting',SQL%ROWCOUNT,stepCt,'Done');
			raise trial_mismatch;
		end if;
	end if;
   
/*	remove Reload processing
--	For Reload, make sure that the TrialId passed as parameter has data in de_subject_microarray_data
--	If not, raise exception

	if runType = 'R' then
		select count(*) into idxExists
		from de_subject_microarray_data
		where trial_name = TrialId;
		
		if idxExists = 0 then
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'No data for TrialId in de_subject_microarray_data - procedure exiting',SQL%ROWCOUNT,stepCt,'Done');
			raise trial_missing;
		end if;
	end if;
*/
   
--	truncate tmp tables

	execute immediate('truncate table tm_wz.wt_subject_microarray_logs');
	execute immediate('truncate table tm_wz.wt_subject_microarray_calcs');
	execute immediate('truncate table tm_wz.wt_subject_microarray_med');
	
	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_MICROARRAY_LOGS'
	  and index_name = 'WT_SUBJECT_MRNA_LOGS_I1'
	  and owner = 'TM_WZ';
		
	if idxExists = 1 then
		execute immediate('drop index tm_wz.wt_subject_mrna_logs_i1');		
	end if;
	
	select count(*) 
	into idxExists
	from all_indexes
	where table_name = 'WT_SUBJECT_MICROARRAY_CALCS'
	  and index_name = 'WT_SUBJECT_MRNA_CALCS_I1'
	  and owner = 'TM_WZ';
		
	if idxExists = 1 then
		execute immediate('drop index tm_wz.wt_subject_mrna_calcs_i1');
	end if;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
	
	--	if dataType = L, use intensity_value as log_intensity
	--	if dataType = R, always use intensity_value


	if dataType = 'L' then
/*	Remove Reload processing
		if runType = 'R' then
			insert into wt_subject_microarray_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			,sample_id
			,subject_id
			)
			select probeset_id
				  ,raw_intensity 
				  ,assay_id
				  ,log_intensity
				  ,patient_id
				  ,sample_id
				  ,subject_id
			from de_subject_microarray_data 
			where trial_name =  TrialID;
		else
*/
			insert into wt_subject_microarray_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
		--	,subject_id
			)
			select probeset_id
				  ,intensity_value  
				  ,assay_id 
				  ,intensity_value
				  ,patient_id
			--	  ,sample_cd
			--	  ,subject_id
			from wt_subject_mrna_probeset
			where trial_name = TrialId;
		--end if;
	else
	/*	remove Reload processing
		if runType = 'R' then
			insert into wt_subject_microarray_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
			,sample_id
			,subject_id
			)
			select probeset_id
				  ,raw_intensity 
				  ,assay_id  
				  ,log(2,raw_intensity)
				  ,patient_id
				  ,sample_id
				  ,subject_id
			from de_subject_microarray_data 
			where trial_name =  TrialID;
		else
*/
			insert into wt_subject_microarray_logs 
			(probeset_id
			,intensity_value
			,assay_id
			,log_intensity
			,patient_id
		--	,sample_cd
		--	,subject_id
			)
			select probeset_id
				  ,intensity_value 
				  ,assay_id 
				  ,log(2,intensity_value)
				  ,patient_id
		--		  ,sample_cd
		--		  ,subject_id
			from wt_subject_mrna_probeset
			where trial_name = TrialId;
--		end if;
	end if;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Loaded data for trial in TM_WZ wt_subject_microarray_logs',SQL%ROWCOUNT,stepCt,'Done');

	commit;
    
	execute immediate('create index tm_wz.wt_subject_mrna_logs_i1 on tm_wz.wt_subject_microarray_logs (trial_name, probeset_id) nologging  tablespace "INDX"');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_microarray_logs',0,stepCt,'Done');
		
--	calculate mean_intensity, median_intensity, and stddev_intensity per experiment, probe

	insert into wt_subject_microarray_calcs
	(trial_name
	,probeset_id
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
	select d.trial_name 
		  ,d.probeset_id
		  ,avg(log_intensity)
		  ,median(log_intensity)
		  ,stddev(log_intensity)
	from wt_subject_microarray_logs d 
	group by d.trial_name 
			,d.probeset_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate intensities for trial in TM_WZ wt_subject_microarray_calcs',SQL%ROWCOUNT,stepCt,'Done');

	commit;

	execute immediate('create index tm_wz.wt_subject_mrna_calcs_i1 on tm_wz.wt_subject_microarray_calcs (trial_name, probeset_id) nologging tablespace "INDX"');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create index on TM_WZ wt_subject_microarray_calcs',0,stepCt,'Done');
		
-- calculate zscore

	insert into wt_subject_microarray_med parallel 
	(probeset_id
	,intensity_value
	,log_intensity
	,assay_id
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	,patient_id
--	,sample_cd
--	,subject_id
	)
	select d.probeset_id
		  ,d.intensity_value 
		  ,d.log_intensity 
		  ,d.assay_id  
		  ,c.mean_intensity 
		  ,c.stddev_intensity 
		  ,c.median_intensity 
		  ,CASE WHEN stddev_intensity=0 THEN 0 ELSE (log_intensity - median_intensity ) / stddev_intensity END
		  ,d.patient_id
	--	  ,d.sample_cd
	--	  ,d.subject_id
    from wt_subject_microarray_logs d 
		,wt_subject_microarray_calcs c 
    where d.probeset_id = c.probeset_id;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score for trial in TM_WZ wt_subject_microarray_med',SQL%ROWCOUNT,stepCt,'Done');

    commit;
  
/*
	select count(*) into nbrRecs
	from wt_subject_microarray_med;
	
	if nbrRecs > 10000000 then
		i2b2_mrna_index_maint('DROP',,jobId);
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Drop indexes on DEAPP de_subject_microarray_data',0,stepCt,'Done');
	else
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Less than 10M records, index drop bypassed',0,stepCt,'Done');
	end if;
*/	


	insert into de_subject_microarray_data
	(trial_source
	,trial_name
	,assay_id
	,probeset_id
	,raw_intensity 
	,log_intensity
	,zscore
	,patient_id
	--,sample_id
	--,subject_id
	)
	select TrialId || ':' || sourceCD
		  ,TrialId
	      ,m.assay_id
	      ,m.probeset_id 
		  ,round(case when dataType = 'R' then m.intensity_value
				when dataType = 'L' 
				then case when logBase = -1 then null else power(logBase, m.log_intensity) end
				else null
				end,4) as raw_intensity
	    --  ,decode(dataType,'R',m.intensity_value,'L',power(logBase, m.log_intensity),null)
		  ,round(m.log_intensity,4)
	      ,round(CASE WHEN m.zscore < -2.5 THEN -2.5 WHEN m.zscore >  2.5 THEN  2.5 ELSE round(m.zscore,5) END,5)
		  ,m.patient_id
	--	  ,m.sample_id
	--	  ,m.subject_id
	from wt_subject_microarray_med m;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial in DEAPP de_subject_microarray_data',SQL%ROWCOUNT,stepCt,'Done');

  	commit;

--	add indexes, if indexes were not dropped, procedure will not try and recreate
/*
	i2b2_mrna_index_maint('ADD',,jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Add indexes on DEAPP de_subject_microarray_data',0,stepCt,'Done');
*/
	
--	cleanup tmp_ files

	execute immediate('truncate table tm_wz.wt_subject_microarray_logs');
	execute immediate('truncate table tm_wz.wt_subject_microarray_calcs');
	execute immediate('truncate table tm_wz.wt_subject_microarray_med');

   	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Truncate work tables in TM_WZ',0,stepCt,'Done');
    
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION

  WHEN invalid_runType or trial_mismatch or trial_missing then
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
  when OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
	
END;


/*	--	Recreate tmp tables used for calculation of mRNA Zscore if necessary

create table wt_subject_microarray_logs parallel nologging compress as 
select probeset_id 
	  ,raw_intensity 
	  ,pvalue 
	  ,refseq 
	  ,assay_id 
	  ,patient_id 
	  ,subject_id 
	  ,trial_name 
	  ,timepoint  
      ,raw_intensity as log_intensity 
       from de_subject_microarray_data
	   where 1=2;
	   
create index tmp_microarray_logs_i1 on wt_subject_microarray_logs (trial_name, probeset_id);

create table wt_subject_microarray_calcs parallel nologging compress as
select d.trial_name 
	  ,d.probeset_id
	  ,log_intensity as mean_intensity
	  ,log_intensity as median_intensity 
	  ,log_intensity as stddev_intensity 
from wt_subject_microarray_logs d 
where 1=2;

create index tmp_microarray_calcs_i1 on wt_subject_microarray_calcs (trial_name, probeset_id);	

create table wt_subject_microarray_med parallel nologging compress as  
select d.probeset_id
	  ,d.raw_intensity  
	  ,d.log_intensity  
	  ,d.assay_id  
	  ,d.patient_id  
	  ,d.subject_id  
	  ,d.trial_name  
	  ,d.timepoint  
	  ,d.pvalue  
	  ,d.refseq 
	  ,c.mean_intensity  
	  ,c.stddev_intensity  
	  ,c.median_intensity  
	  ,d.log_intensity as zscore 
from wt_subject_microarray_logs d 
	 ,wt_subject_microarray_calcs c
where 1=2;
            
create table wt_subject_microarray_mcapped parallel nologging compress as 
select d.probeset_id 
	  ,d.patient_id 
	  ,d.trial_name 
	  ,d.timepoint 
	  ,d.pvalue 
	  ,d.refseq 
	  ,d.subject_id 
	  ,d.raw_intensity 
	  ,d.log_intensity 
	  ,d.assay_id 
	  ,d.mean_intensity 
	  ,d.stddev_intensity 
	  ,d.median_intensity 
	  ,d.zscore 
 from wt_subject_microarray_med d
 where 1=2;
		   
*/
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_PROCESS_MRNA_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_PROCESS_MRNA_DATA" 
(
  trial_id 		VARCHAR2
 ,top_node		varchar2
 ,data_type		varchar2 := 'R'		--	R = raw data, do zscore calc, T = transformed data, load raw values as zscore,
									--	L = log intensity data, skip log step in zscore calc
 ,source_cd		varchar2 := 'STD'	--	default source_cd = 'STD'
 ,log_base		number := 2			--	log base value for conversion back to raw
 ,secure_study	varchar2			--	security setting if new patients added to patient_dimension
 ,currentJobID 	NUMBER := null
 ,rtn_code		OUT	NUMBER
)
AS
--	Procedure to load the DE_SUBJECT_MICROARRAY_DATA and DE_SUBJECT_SAMPLE_MAPPING tables, compute the Z-Score, and create the I2B2 data for mRNA (gene expression) data
--	wt_subject_mrna_data must be pre-loaded with gene expression data.  Because the format/content of gene expression data varies,
--	the loading of wt_subject_mrna_data is not done within this procedure

--	***  NOTE ***
--	The input file columns are mapped to the following table columns.  This is done so that the javascript for the advanced workflows
--	selects the correct data for the dropdowns.

--		tissue_type	=>	sample_type
--		attribute_1	=>	tissue_type
--		atrribute_2	=>	timepoint	


--	JEA@90090904	New, modified version from JnJ
--	JEA@20111017	Remove JnJ-specific ontology, use path derived from category_cd
--	JEA@20111028	Use lt_ tables instead of extrnl to accomodate clients without external tables
--	JEA@20111116	Insert subject_id to patient_dimension if not exists (no clinical data)
--	JEA@20111116	Added source_cd handling to account for multiple transformations for same study
--	JEA@@0111117	Removed code to insert sample into patient_dimension
--	JEA@20111201	Added i2b2 attribute update code
--	JEA@20111207	Added distinct to patient insert
--	JEA@21001209	Added platform to lt_src_mrna_data, lz_src_mrna_data, use probeset_deapp for probe_id
--	JEA@20112121	Remove platform stuff, add exception if sample_cd has multiple platforms
--	JEA@20111214	Throw exception if no rows inserted into wt_subject_mrna_probeset
--	JEA@20120113	Added H to c_visualattributes for high-density biomarker
--	JEA@20120131	Remove check for organism in de_gpl_info.
--	JEA@20120301	Custom for Millennium to support multiple gene expression analysis per study, 
--	JEA@20120314	Pass sourceCD to i2b2_mrna_zscore_calc so correct trial_source set
--	JEA@20120416	Add omic_source_study, omic_patient_id to de_subject_sample_mapping and populate
--	JEA@@0120510	Add root_node using i2b2_add_root_node if missing
--	JEA@20120526	Set sourcesystem_cd, c_comment to null if any upper-level nodes added, set sex_cd to Unknown if adding subjects


  TrialID		varchar2(100);
  RootNode		VARCHAR2(2000);
  root_level	integer;
  topNode		varchar2(2000);
  topLevel		integer;
  tPath			varchar2(2000);
  study_name	varchar2(100);
  sourceCd		varchar2(50);
  secureStudy	varchar2(1);

  dataType		varchar2(10);
  sqlText		varchar2(1000);
  tText			varchar2(1000);
  gplTitle		varchar2(1000);
  pExists		number;
  partTbl   	number;
  partExists 	number;
  sampleCt		number;
  idxExists 	number;
  logBase		number;
  pCount		integer;
  sCount		integer;
  tablespaceName	varchar2(200);
  v_bio_experiment_id	number(18,0);
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
  --unmapped_patients exception;
  missing_platform	exception;
  missing_tissue	EXCEPTION;
  unmapped_platform exception;
  multiple_platform	exception;
  no_probeset_recs	exception;
  

  
	CURSOR addNodes is
	select distinct t.leaf_node
          ,t.node_name
	from  wt_mrna_nodes t
	where not exists
		 (select 1 from i2b2 x
		  where t.leaf_node = x.c_fullname);

 
--	cursor to define the path for delete_one_node  this will delete any nodes that are hidden after i2b2_create_concept_counts

  CURSOR delNodes is
  select distinct c_fullname 
  from  i2b2
  where c_fullname like topNode || '%'
    and substr(c_visualattributes,2,1) = 'H';
    --and c_visualattributes like '_H_';


BEGIN
	TrialID := upper(trial_id);
	secureStudy := upper(secure_study);
	
	if (secureStudy not in ('Y','N') ) then
		secureStudy := 'Y';
	end if;
	
	topNode := REGEXP_REPLACE('\' || top_node || '\','(\\){2,}', '\');	
	select length(topNode)-length(replace(topNode,'\','')) into topLevel from dual;
	
	if data_type is null then
		dataType := 'R';
	else
		if data_type in ('R','T','L') then
			dataType := data_type;
		else
			dataType := 'R';
		end if;
	end if;
	
	logBase := log_base;
	sourceCd := upper(nvl(source_cd,'STD'));

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
	stepCt := 0;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_process_mrna_data',0,stepCt,'Done');
	
	--	Get count of records in lt_src_mrna_subj_samp_map
	
	select count(*) into sCount
	from lt_src_mrna_subj_samp_map;
	
	--	check if all subject_sample map records have a platform, If not, abort run
	
	select count(*) into pCount
	from lt_src_mrna_subj_samp_map
	where platform is null;
	
	if pCount > 0 then
		raise missing_platform;
	end if;
  
  	--	check if platform exists in de_mrna_annotation .  If not, abort run.
	
	select count(*) into pCount
	from DE_MRNA_ANNOTATION
	where GPL_ID in (select distinct m.platform from lt_src_mrna_subj_samp_map m);
	
	if PCOUNT = 0 then
		RAISE UNMAPPED_platform;
	end if;
	
	select count(*) into pCount
	from DE_gpl_info
	where platform in (select distinct m.platform from lt_src_mrna_subj_samp_map m);
	
	if PCOUNT = 0 then
		RAISE UNMAPPED_platform;
	end if;
		
	--	check if all subject_sample map records have a tissue_type, If not, abort run
	
	select count(*) into pCount
	from lt_src_mrna_subj_samp_map
	where tissue_type is null;
	
	if pCount > 0 then
		raise missing_tissue;
	end if;
	
	--	check if there are multiple platforms, if yes, then platform must be supplied in lt_src_mrna_data
	
	select count(*) into pCount
	from (select sample_cd
		  from lt_src_mrna_subj_samp_map
		  group by sample_cd
		  having count(distinct platform) > 1);
	
	if pCount > 0 then
		raise multiple_platform;
	end if;
		
	-- Get root_node from topNode
  
	select parse_nth_value(topNode, 2, '\') into RootNode from dual;
	
	select count(*) into pExists
	from table_access
	where c_name = rootNode;
	
	if pExists = 0 then
		i2b2_add_root_node(rootNode, jobId);
	end if;
	
	select c_hlevel into root_level
	from i2b2
	where c_name = RootNode;
	
	-- Get study name from topNode
  
	select parse_nth_value(topNode, topLevel, '\') into study_name from dual;
	
	--	Add any upper level nodes as needed
	
	tPath := REGEXP_REPLACE(replace(top_node,study_name,null),'(\\){2,}', '\');
	select length(tPath) - length(replace(tPath,'\',null)) into pCount from dual;

	if pCount > 2 then
		i2b2_fill_in_tree(null, tPath, jobId);
	end if;

	--	uppercase study_id in lt_src_mrna_subj_samp_map in case curator forgot
	
	update lt_src_mrna_subj_samp_map
	set trial_name=upper(trial_name);
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Uppercase trial_name in lt_src_mrna_subj_samp_map',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	create records in patient_dimension for subject_ids if they do not exist
	--	format of sourcesystem_cd:  trial:[site:]subject_cd
	
	insert into patient_dimension
    ( patient_num,
      sex_cd,
      age_in_years_num,
      race_cd,
      update_date,
      download_date,
      import_date,
      sourcesystem_cd
    )
    select seq_patient_num.nextval
		  ,x.sex_cd
		  ,x.age_in_years_num
		  ,x.race_cd
		  ,sysdate
		  ,sysdate
		  ,sysdate
		  ,x.sourcesystem_cd
	from (select distinct 'Unknown' as sex_cd,
				 0 as age_in_years_num,
				 null as race_cd,
				 regexp_replace(TrialID || ':' || s.site_id || ':' || s.subject_id,'(::){1,}', ':') as sourcesystem_cd
		 from lt_src_mrna_subj_samp_map s
		     ,de_gpl_info g
		 where s.subject_id is not null
		   and s.trial_name = TrialID
		   and s.source_cd = sourceCD
		   and s.platform = g.platform
		   and upper(g.marker_type) = 'GENE EXPRESSION'
		   and not exists
			  (select 1 from patient_dimension x
			   where x.sourcesystem_cd = 
				 regexp_replace(TrialID || ':' || s.site_id || ':' || s.subject_id,'(::){1,}', ':'))
		) x;
	
	pCount := SQL%ROWCOUNT;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert subjects to patient_dimension',pCount,stepCt,'Done');
	commit;
	
	--	add security for trial if new subjects added to patient_dimension

	if pCount > 0 then
		i2b2_create_security_for_trial(TrialId, secureStudy, jobID);	
	end if;
	
	--	Delete existing observation_fact data, will be repopulated
	
	delete from observation_fact obf
	where obf.concept_cd in
		 (select distinct x.concept_code
		  from de_subject_sample_mapping x
		  where x.trial_name = TrialId
		    and nvl(x.source_cd,'STD') = sourceCD
		    and x.platform = 'MRNA_AFFYMETRIX');

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	select count(*) into pExists
	from all_tables
	where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
	  and partitioned = 'YES';
	  
	if pExists = 0 then
		--	dataset is not partitioned so must delete
		
		delete from de_subject_microarray_data
		where trial_source = TrialId || ':' || sourceCd;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Delete data from observation_fact',SQL%ROWCOUNT,stepCt,'Done');
		commit;
	else
		--	Create partition in de_subject_microarray_data if it doesn't exist else truncate partition
			
		select count(*)
			into pExists
			from all_tab_partitions
			where table_name = 'DE_SUBJECT_MICROARRAY_DATA'
			  and partition_name = TrialId || ':' || sourceCd;
			
		if pExists = 0 then
					
			--	needed to add partition to de_subject_microarray_data

			sqlText := 'alter table deapp.de_subject_microarray_data add PARTITION "' || TrialID || ':' || sourceCd || '"  VALUES (' || '''' || TrialID || ':' || sourceCd || '''' || ') ' ||
						   'NOLOGGING COMPRESS TABLESPACE "DEAPP" ';
			execute immediate(sqlText);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Adding partition to de_subject_microarray_data',0,stepCt,'Done');
				
		else
			sqlText := 'alter table deapp.de_subject_microarray_data truncate partition "' || TrialID || ':' || sourceCd || '"';
			execute immediate(sqlText);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in de_subject_microarray_data',0,stepCt,'Done');
		end if;
		
	end if;
		
	--	Cleanup any existing data in de_subject_sample_mapping.  

	delete from DE_SUBJECT_SAMPLE_MAPPING 
	where trial_name = TrialID 
	  and nvl(source_cd,'STD') = sourceCd
	  and platform = 'MRNA_AFFYMETRIX'; --Making sure only mRNA data is deleted
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');

	commit;

--	truncate tmp node table

	execute immediate('truncate table tm_wz.wt_mrna_nodes');
	
--	load temp table with leaf node path, use temp table with distinct sample_type, ATTR2, platform, and title   this was faster than doing subselect
--	from wt_subject_mrna_data

	execute immediate('truncate table tm_wz.wt_mrna_node_values');
	
	insert into wt_mrna_node_values
	(category_cd
	,platform
	,tissue_type
	,attribute_1
	,attribute_2
	,title
	)
	select distinct a.category_cd
				   ,nvl(a.platform,'GPL570')
				   ,nvl(a.tissue_type,'Unspecified Tissue Type')
	               ,a.attribute_1
				   ,a.attribute_2
				   ,g.title
    from lt_src_mrna_subj_samp_map a
	    ,de_gpl_info g 
	where a.trial_name = TrialID
	  and nvl(a.platform,'GPL570') = g.platform
	  and a.source_cd = sourceCD
	  and a.platform = g.platform
	  and upper(g.marker_type) = 'GENE EXPRESSION'
      -- and upper(g.organism) = 'HOMO SAPIENS'
	  ;
	--  and decode(dataType,'R',sign(a.intensity_value),1) = 1;	--	take all values when dataType T, only >0 for dataType R
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert node values into DEAPP wt_mrna_node_values',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	insert into wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       category_cd,'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\','(\\){2,}', '\') 
		  ,category_cd
		  ,platform as platform
		  ,tissue_type
		  ,attribute_1 as attribute_1
          ,attribute_2 as attribute_2
		  ,'LEAF'
	from  wt_mrna_node_values;
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create leaf nodes in DEAPP tmp_mrna_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for platform node so platform concept can be populated
	
	insert into wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'PLATFORM')+8)
		  ,platform as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'PLATFORM')+8),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'PLATFORM'
	from  wt_mrna_node_values;
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create platform nodes in wt_mrna_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for ATTR1 node so ATTR1 concept can be populated in tissue_type_cd
	
	insert into wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'ATTR1')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
		  ,attribute_1 as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'ATTR1'
	from  wt_mrna_node_values
	where category_cd like '%ATTR1%'
	  and attribute_1 is not null;
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create ATTR1 nodes in wt_mrna_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for ATTR2 node so ATTR2 concept can be populated in timepoint_cd
	
	insert into wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
    ,attribute_1
	,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'ATTR2')+5)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'PLATFORM') > 1 then platform else null end as platform
		  ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then tissue_type else null end as tissue_type
          ,case when instr(substr(category_cd,1,instr(category_cd,'ATTR2')+5),'ATTR1') > 1 then attribute_1 else null end as attribute_1
		  ,attribute_2 as attribute_2
		  ,'ATTR2'
	from  wt_mrna_node_values
	where category_cd like '%ATTR2%'
	  and attribute_2 is not null;
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_mrna_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert for tissue_type node so sample_type_cd can be populated
	
	insert into wt_mrna_nodes
	(leaf_node
	,category_cd
	,platform
	,tissue_type
	,attribute_1
    ,attribute_2
	,node_type
	)
	select distinct topNode || regexp_replace(replace(replace(replace(replace(replace(replace(
	       substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM',title),'ATTR1',attribute_1),'ATTR2',attribute_2),'TISSUETYPE',tissue_type),'+','\'),'_',' ') || '\',
		   '(\\){2,}', '\')
		  ,substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10)
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then platform else null end as platform
		  ,tissue_type as tissue_type
		  ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then attribute_1 else null end as attribute_1
          ,case when instr(substr(category_cd,1,instr(category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then attribute_2 else null end as attribute_2
		  ,'TISSUETYPE'
	from  wt_mrna_node_values
	where category_cd like '%TISSUETYPE%';
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create ATTR2 nodes in wt_mrna_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
				
	update wt_mrna_nodes
	set node_name=parse_nth_value(leaf_node,length(leaf_node)-length(replace(leaf_node,'\',null)),'\');
		   
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Updated node_name in DEAPP tmp_mrna_nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		
--	add leaf nodes for mRNA data  The cursor will only add nodes that do not already exist.

	 FOR r_addNodes in addNodes Loop

    --Add nodes for all types (ALSO DELETES EXISTING NODE)

		i2b2_add_node(TrialID, r_addNodes.leaf_node, r_addNodes.node_name, jobId);
		stepCt := stepCt + 1;
		tText := 'Added Leaf Node: ' || r_addNodes.leaf_node || '  Name: ' || r_addNodes.node_name;
		
		cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');
		
		i2b2_fill_in_tree(TrialId, r_addNodes.leaf_node, jobID);

	END LOOP;  
	
	--	set sourcesystem_cd, c_comment to null if any added upper-level nodes
	
	update i2b2 b
	set sourcesystem_cd=null,c_comment=null
	where b.sourcesystem_cd = TrialId
	  and length(b.c_fullname) < length(topNode);
	  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Set sourcesystem_cd to null for added upper level nodes',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		
--	update concept_cd for nodes, this is done to make the next insert easier

	update wt_mrna_nodes t
	set concept_cd=(select c.concept_cd from concept_dimension c
	                where c.concept_path = t.leaf_node
				   )
    where exists
         (select 1 from concept_dimension x
	                where x.concept_path = t.leaf_node
				   )
	  and t.concept_cd is null;
	  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update wt_mrna_nodes with newly created concept_cds',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	 
		--	create entries to support FMAPP
	
	select count(*) into pExists
	from biomart.bio_experiment
	where accession = TrialId;
	
	if pExists = 0 then
		--	insert placeholder for study in bio_experiment
		insert into biomart.bio_experiment
		(title, accession, etl_id, bio_experiment_type)
		select study_name
			  ,TrialId
			  ,'METADATA:' || TrialId
			  ,'i2b2'
		from dual;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
		commit;
	end if;
	
	select bio_experiment_id into v_bio_experiment_id
	from biomart.bio_experiment
	where accession = TrialId;
	
	--	insert study into biomart.bio_data_uid
	
	insert into biomart.bio_data_uid
	(bio_data_id
	,unique_id 
	,bio_data_type
	)
	select v_bio_experiment_id
		  ,'EXP:' || TrialId
		  ,'Experiment'
	from dual
	where not exists
		 (select 1 from biomart.bio_data_uid x
		  where x.bio_data_id = v_bio_experiment_id);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_data_uid',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	insert study into fmapp.fm_folder
	
	insert into fmapp.fm_folder
	(folder_name 
	,folder_level      
	,folder_type
	,active_ind
	)
	select TrialId
		  ,1
		  ,'STUDY'
		  ,'1'
	from dual
	where not exists
		  (select 1 from fmapp.fm_folder x
		   where x.folder_name = TrialId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into fmapp.fm_folder',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	insert fm_folder_association
	
	insert into fmapp.fm_folder_association
	(folder_id
	,object_uid
	,object_type
	)
	select ff.folder_id
		  ,'EXP:' || TrialId
		  ,'bio.Experiment'
	from fmapp.fm_folder ff
	where folder_name = TrialId
	  and not exists
	     (select 1 from fmapp.fm_folder_association x
		  where ff.folder_id = x.folder_id);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into fmapp.fm_folder_asociation',SQL%ROWCOUNT,stepCt,'Done');
	commit;	  	
	
  --Load the DE_SUBJECT_SAMPLE_MAPPING from wt_subject_mrna_data

  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --SITE_ID         = site_id
  --SUBJECT_ID      = subject_id
  --SUBJECT_TYPE    = NULL
  --CONCEPT_CODE    = from LEAF records in wt_mrna_nodes
  --SAMPLE_TYPE    	= TISSUE_TYPE
  --SAMPLE_TYPE_CD  = concept_cd from TISSUETYPE records in wt_mrna_nodes
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT		= attribute_2
  --TIMEPOINT_CD	= concept_cd from ATTR2 records in wt_mrna_nodes
  --TISSUE_TYPE     = attribute_1
  --TISSUE_TYPE_CD  = concept_cd from ATTR1 records in wt_mrna_nodes
  --PLATFORM        = MRNA_AFFYMETRIX - this is required by ui code
  --PLATFORM_CD     = concept_cd from PLATFORM records in wt_mrna_nodes
  --DATA_UID		= concatenation of concept_cd-patient_num
  --GPL_ID			= platform from wt_subject_mrna_data
  --CATEGORY_CD		= category_cd that generated ontology
  --SAMPLE_ID		= id of sample (trial:S:[site_id]:subject_id:sample_cd) from patient_dimension, may be the same as patient_num
  --SAMPLE_CD		= sample_cd
  --SOURCE_CD		= sourceCd
  
  --ASSAY_ID        = generated by trigger

	insert into de_subject_sample_mapping
	(patient_id
	,site_id
	,subject_id
	,subject_type
	,concept_code
	,assay_id
	,sample_type
	,sample_type_cd
	,trial_name
	,timepoint
	,timepoint_cd
	,tissue_type
	,tissue_type_cd
	,platform
	,platform_cd
	,data_uid
	,gpl_id
	,sample_id
	,sample_cd
	,category_cd
	,source_cd
	,omic_source_study
	,omic_patient_id
    )
	select t.patient_id
		  ,t.site_id
		  ,t.subject_id
		  ,t.subject_type
		  ,t.concept_code
		  ,deapp.seq_assay_id.nextval
		  ,t.sample_type
		  ,t.sample_type_cd
		  ,t.trial_name
		  ,t.timepoint
		  ,t.timepoint_cd
		  ,t.tissue_type
		  ,t.tissue_type_cd
		  ,t.platform
		  ,t.platform_cd
		  ,t.data_uid
		  ,t.gpl_id
		  ,t.sample_id
		  ,t.sample_cd
		  ,t.category_cd
		  ,t.source_cd
		  ,t.omic_source_study
		  ,t.omic_patient_id
	from (select distinct b.patient_num as patient_id
			  ,a.site_id
			  ,a.subject_id
			  ,null as subject_type
			  ,ln.concept_cd as concept_code
			  ,a.tissue_type as sample_type
			  ,ttp.concept_cd as sample_type_cd
			  ,a.trial_name
			  ,a.attribute_2 as timepoint
			  ,a2.concept_cd as timepoint_cd
			  ,a.attribute_1 as tissue_type
			  ,a1.concept_cd as tissue_type_cd
			  ,'MRNA_AFFYMETRIX' as platform
			  ,pn.concept_cd as platform_cd
			  ,ln.concept_cd || '-' || to_char(b.patient_num) as data_uid
			  ,a.platform as gpl_id
			  ,coalesce(sid.patient_num,b.patient_num) as sample_id
			  ,a.sample_cd
			  ,nvl(a.category_cd,'Biomarker_Data+Gene_Expression+PLATFORM+TISSUETYPE+ATTR1+ATTR2') as category_cd
			  ,a.source_cd
			  ,TrialId as omic_source_study
			  ,b.patient_num as omic_patient_id
		from lt_src_mrna_subj_samp_map a		
		--Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
		inner join patient_dimension b
		  on regexp_replace(TrialID || ':' || a.site_id || ':' || a.subject_id,'(::){1,}', ':') = b.sourcesystem_cd
		inner join wt_mrna_nodes ln
			on a.platform = ln.platform
			and a.tissue_type = ln.tissue_type
			and nvl(a.attribute_1,'@') = nvl(ln.attribute_1,'@')
			and nvl(a.attribute_2,'@') = nvl(ln.attribute_2,'@')
			and ln.node_type = 'LEAF'
		inner join wt_mrna_nodes pn
			on a.platform = pn.platform
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'TISSUETYPE') > 1 then a.tissue_type else '@' end = nvl(pn.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR1') > 1 then a.attribute_1 else '@' end = nvl(pn.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'PLATFORM')+8),'ATTR2') > 1 then a.attribute_2 else '@' end = nvl(pn.attribute_2,'@')
			and pn.node_type = 'PLATFORM'	  
		left outer join wt_mrna_nodes ttp
			on a.tissue_type = ttp.tissue_type
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'PLATFORM') > 1 then a.platform else '@' end = nvl(ttp.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR1') > 1 then a.attribute_1 else '@' end = nvl(ttp.attribute_1,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'TISSUETYPE')+10),'ATTR2') > 1 then a.attribute_2 else '@' end = nvl(ttp.attribute_2,'@')
			and ttp.node_type = 'TISSUETYPE'		  
		left outer join wt_mrna_nodes a1
			on a.attribute_1 = a1.attribute_1
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'PLATFORM') > 1 then a.platform else '@' end = nvl(a1.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = nvl(a1.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR1')+5),'ATTR2') > 1 then a.attribute_2 else '@' end = nvl(a1.attribute_2,'@')
			and a1.node_type = 'ATTR1'		  
		left outer join wt_mrna_nodes a2
			on a.attribute_2 = a1.attribute_2
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'PLATFORM') > 1 then a.platform else '@' end = nvl(a2.platform,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'TISSUETYPE') > 1 then a.tissue_type else '@' end = nvl(a2.tissue_type,'@')
			and case when instr(substr(a.category_cd,1,instr(a.category_cd,'ATTR2')+5),'ATTR1') > 1 then a.attribute_1 else '@' end = nvl(a2.attribute_1,'@')
			and a2.node_type = 'ATTR2'			  
		left outer join patient_dimension sid
			on  regexp_replace(TrialId || ':S:' || a.site_id || ':' || a.subject_id || ':' || a.sample_cd,
							  '(::){1,}', ':') = sid.sourcesystem_cd
		where a.trial_name = TrialID
		  and a.source_cd = sourceCD
		  and  ln.concept_cd is not null) t;

	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');

  commit;

--	recreate de_subject_sample_mapping indexes

	--execute immediate('create index de_subject_smpl_mpng_idx1 on de_subject_sample_mapping(timepoint, patient_id, trial_name) parallel nologging'); 
	--execute immediate('create index de_subject_smpl_mpng_idx2 on de_subject_sample_mapping(patient_id, timepoint_cd, platform_cd, assay_id, trial_name) parallel nologging'); 
	--execute immediate('create bitmap index de_subject_smpl_mpng_idx3 on de_subject_sample_mapping(sample_type_cd) parallel nologging');
	--execute immediate('create index de_subject_smpl_mpng_idx4 on de_subject_sample_mapping(gpl_id) parallel nologging');
	--execute immediate('create index de_subject_smpl_mpng_idx4 on de_subject_sample_mapping(platform, gpl_id) parallel nologging');
    --stepCt := stepCt + 1;
	--cz_write_audit(jobId,databaseName,procedureName,'Recreate indexes on DEAPP de_subject_sample_mapping',0,stepCt,'Done');

--	Insert records for patients and samples into observation_fact

	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select distinct m.patient_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null	--	not numeric for mRNA
		  ,m.trial_name
		  ,sysdate
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCD
      and m.platform = 'MRNA_AFFYMETRIX';
	  
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert patient facts into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');

    commit;
    
	--	Insert sample facts 
	
	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select distinct m.sample_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null	--	not numeric for mRNA
		  ,m.trial_name
		  ,sysdate
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  de_subject_sample_mapping m
    where m.trial_name = TrialID 
	  and m.source_cd = sourceCd
      and m.platform = 'MRNA_AFFYMETRIX'
	  and m.patient_id != m.sample_id;
	  
    stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert sample facts into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');

    commit;
    
	--Update I2b2 for correct data type
	
	update i2b2 t
	set c_columndatatype = 'T', c_metadataxml = null, c_visualattributes='FA'
	where t.c_basecode in (select distinct x.concept_cd from wt_mrna_nodes x);
  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Initialize data_type and xml in i2b2',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	update i2b2
	SET c_columndatatype = 'N',
      --Static XML String
		c_metadataxml = '<?xml version="1.0"?><ValueMetadata><Version>3.02</Version><CreationDateTime>08/14/2008 01:22:59</CreationDateTime><TestID></TestID><TestName></TestName><DataType>PosFloat</DataType><CodeType></CodeType><Loinc></Loinc><Flagstouse></Flagstouse><Oktousevalues>Y</Oktousevalues><MaxStringLength></MaxStringLength><LowofLowValue>0</LowofLowValue><HighofLowValue>0</HighofLowValue><LowofHighValue>100</LowofHighValue>100<HighofHighValue>100</HighofHighValue><LowofToxicValue></LowofToxicValue><HighofToxicValue></HighofToxicValue><EnumValues></EnumValues><CommentsDeterminingExclusion><Com></Com></CommentsDeterminingExclusion><UnitValues><NormalUnits>ratio</NormalUnits><EqualUnits></EqualUnits><ExcludingUnits></ExcludingUnits><ConvertingUnits><Units></Units><MultiplyingFactor></MultiplyingFactor></ConvertingUnits></UnitValues><Analysis><Enums /><Counts /><New /></Analysis></ValueMetadata>'
	where c_basecode IN (
		  select xd.concept_cd
		  from wt_mrna_nodes xd
			  ,observation_fact xf
		  where xf.concept_cd = xd.concept_cd
		  group by xd.concept_Cd
		  having Max(xf.valtype_cd) = 'N');
		  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update c_columndatatype and c_metadataxml for numeric data types in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
	commit;
  
/*
	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	update i2b2 a
    set c_visualattributes = 'LA'
    where 1 = (
      select count(*)
      from i2b2 b
      where b.c_fullname like (a.c_fullname || '%'))
      and c_fullname like '%' || topNode || '%';
*/

	--UPDATE VISUAL ATTRIBUTES for Leaf Active (Default is folder)
	update i2b2 a
    set c_visualattributes = 'LAH'
	where a.c_basecode in (select distinct x.concept_code from de_subject_sample_mapping x
						   where x.trial_name = TrialId
						     and x.platform = 'MRNA_AFFYMETRIX'
							 and x.concept_code is not null);
	  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update visual attributes for leaf nodes in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
  
	COMMIT;
    
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Trial level because there may be multiple platform and there is no longer
  -- a unique top-level node for mRNA data
  
    i2b2_create_concept_counts(topNode ,jobID );
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');
	
	--	delete each node that is hidden
	
	 FOR r_delNodes in delNodes Loop

    --	deletes hidden nodes for a trial one at a time

		i2b2_delete_1_node(r_delNodes.c_fullname);
		stepCt := stepCt + 1;
		tText := 'Deleted node: ' || r_delNodes.c_fullname;
		
		cz_write_audit(jobId,databaseName,procedureName,tText,SQL%ROWCOUNT,stepCt,'Done');

	END LOOP;  	


  --Reload Security: Inserts one record for every I2B2 record into the security table

    i2b2_load_security_data(jobId);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

--	tag data with probeset_id from reference.probeset_deapp
  
	execute immediate ('truncate table tm_wz.wt_subject_mrna_probeset');
	
	--	note: assay_id represents a unique subject/site/sample
	
	insert into wt_subject_mrna_probeset
	(probeset_id
--	,expr_id
	,intensity_value
	,patient_id
--	,sample_cd
--	,subject_id
	,trial_name
	,assay_id
	)
	select gs.probeset_id
--		  ,sd.sample_cd
		  ,avg(md.intensity_value)
		  ,sd.patient_id
--		  ,sd.sample_cd
--		  ,sd.subject_id
		  ,TrialId
		  ,sd.assay_id
	from de_subject_sample_mapping sd
		,lt_src_mrna_data md   
		,probeset_deapp gs
	where sd.sample_cd = md.expr_id
	  and sd.platform = 'MRNA_AFFYMETRIX'
	  and sd.trial_name = TrialId
	  and sd.source_cd = sourceCd
	  and sd.gpl_id = gs.platform
	  and md.probeset = gs.probeset
	  and decode(dataType,'R',sign(md.intensity_value),1) = 1  --	take only >0 for dataType R
	group by gs.probeset_id
		--  ,sd.sample_cd
		  ,sd.patient_id
		--  ,sd.sample_cd
		--  ,sd.subject_id
		  ,sd.assay_id;
		  
	pExists := SQL%ROWCOUNT;
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Insert into DEAPP wt_subject_mrna_probeset',SQL%ROWCOUNT,stepCt,'Done');
	
	commit;		
	
	if pExists = 0 then
		raise no_probeset_recs;
	end if;

	--	insert into de_subject_microarray_data when dataType is T (transformed)

	if dataType = 'T' then
		insert into de_subject_microarray_data
		(trial_source
		,probeset_id
		,assay_id
		,patient_id
		--,sample_id
		--,subject_id
		,trial_name
		,zscore
		)
		select TrialId || ':' || sourceCd
			  ,probeset_id
			  ,assay_id
			  ,patient_id
			  --,sample_id
			  --,subject_id
			  ,trial_name
			  ,case when intensity_value < -2.5
			        then -2.5
					when intensity_value > 2.5
					then 2.5
					else intensity_value
			   end as zscore
		from wt_subject_mrna_probeset
		where trial_name = TrialID;
		stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Insert transformed into DEAPP de_subject_microarray_data',SQL%ROWCOUNT,stepCt,'Done');

		commit;	
	else
		
	--	Calculate ZScores and insert data into de_subject_microarray_data.  The 'L' parameter indicates that the gene expression data will be selected from
	--	wt_subject_mrna_probeset as part of a Load.  

		if dataType = 'R' or dataType = 'L' then
			i2b2_mrna_zscore_calc(TrialID,'L',jobId,dataType,logBase,sourceCD);
			stepCt := stepCt + 1;
			cz_write_audit(jobId,databaseName,procedureName,'Calculate Z-Score',0,stepCt,'Done');
			commit;
		end if;
	
	end if;
	
    ---Cleanup OVERALL JOB if this proc is being run standalone
	
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_mrna_data',0,stepCt,'Done');

	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;
	
	select 0 into rtn_code from dual;

	EXCEPTION
	--when unmapped_patients then
	--	cz_write_audit(jobId,databasename,procedurename,'No site_id/subject_id mapped to patient_dimension',1,stepCt,'ERROR');
	--	cz_error_handler(jobid,procedurename);
	--	cz_end_audit (jobId,'FAIL');
	when missing_platform then
		cz_write_audit(jobId,databasename,procedurename,'Platform data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		cz_error_handler(jobid,procedurename);
		cz_end_audit (jobId,'FAIL');
		select 16 into rtn_code from dual;
	when missing_tissue then
		cz_write_audit(jobId,databasename,procedurename,'Tissue Type data missing from one or more subject_sample mapping records',1,stepCt,'ERROR');
		cz_error_handler(jobid,procedurename);
		CZ_END_AUDIT (JOBID,'FAIL');
		select 16 into rtn_code from dual;
	when unmapped_platform then
		cz_write_audit(jobId,databasename,procedurename,'Platform not found in de_mrna_annotation',1,stepCt,'ERROR');
		CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		cz_end_audit (jobId,'FAIL');
		select 16 into rtn_code from dual;
	when multiple_platform then
		cz_write_audit(jobId,databasename,procedurename,'Multiple platforms for sample_cd in lt_src_mrna_subj_samp_map',1,stepCt,'ERROR');
		CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		cz_end_audit (jobId,'FAIL');
		select 16 into rtn_code from dual;
	when no_probeset_recs then
		cz_write_audit(jobId,databasename,procedurename,'Unable to match probesets to platform in probeset_deapp',1,stepCt,'ERROR');
		CZ_ERROR_HANDLER(JOBID,PROCEDURENAME);
		cz_end_audit (jobId,'FAIL');
		select 16 into rtn_code from dual;
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		--End Proc
		cz_end_audit (jobID, 'FAIL');
		select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_PROCESS_PROTEIN_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_PROCESS_PROTEIN_DATA" 
(
  trial_id VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  
  --	JEA@20100128	New

  TrialID varchar2(100);
  RootNode VARCHAR2(100);
  pExists number;
    
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

	--	cursor for add_nodes
	
  CURSOR addNodes is
  select distinct REGEXP_REPLACE('\' || rootnode || '\' || TrialID || '\Biomarker Data\Protein\Proteomics\' || timepoint || '\' ,
                  '(\\){2,}', '\') as path
         ,timepoint as node_name
  from  deapp.de_subject_protein_data
  where trial_name = TrialId;
	
BEGIN
  TrialID := upper(trial_id);  
  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_load_protein_data',0,stepCt,'Done');
	
  --Determine root value of I2B2: Could be Clinical or Experimental
  select parse_nth_value(c_fullname, 2, '\') into RootNode
  from i2b2
  where c_name = TrialID;

  --if Root Node is null, then add a root node as a clinical trial as a default.
  if RootNode is null then  
    i2b2_add_node(TrialID, '\Clinical Trials\' || TrialID || '\', TrialID, jobID);
    RootNode := 'Clinical Trials';
  end if;

	--Cleanup any existing data from raw table
  
	delete from deapp_wz.stg_subject_protein_data_raw 
    where trial_name = TrialID; 

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from DEAPP_WZ stg_subject_protein_data_raw',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	Insert into raw data table from staging
 
	insert into deapp_wz.stg_subject_protein_data_raw
	(trial_name
	,component
	,intensity_text
	,timepoint
	,assay_id
	,gene_symbol
	,gene_id
	,subject_id
	,site_id
	)
	select trial_name
		  ,component
		  ,intensity_text
		  ,timepoint
		  ,assay_id
		  ,gene_symbol
		  ,gene_id
		  ,subject_id
		  ,site_id
	from deapp_wz.stg_subject_protein_data
    where trial_name = TrialID; 

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into DEAPP_WZ stg_subject_protein_data_raw',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	Perform node-curation on timepoint

	update deapp_wz.stg_subject_protein_data a
    set a.timepoint = 
       (select replace(Upper(a.timepoint), b.node_name, b.display_name)
        from node_curation b
        where b.node_type = 'VISIT_NAME'
          and upper(a.timepoint) = b.node_name  
          and b.active_flag = 'Y'
          and (b.global_flag = 'Y' OR b.study_id = a.trial_name)
		  and b.global_flag =
			 (select min(x.global_flag) from node_curation x
			  where b.node_type = x.node_type
                and b.node_name = x.node_name
                and (x.global_flag = 'Y' or a.trial_name = x.study_id)
             )
      )
    where exists
    (select 1 
      from node_curation b 
      where b.node_type = 'VISIT_NAME'
        and upper(a.timepoint) = b.node_name  
        and b.active_flag = 'Y'
        and (b.global_flag = 'Y' OR b.study_id = a.trial_name)
		and b.global_flag =
			 (select min(x.global_flag) from node_curation x
			  where b.node_type = x.node_type
                and b.node_name = x.node_name
                and (x.global_flag = 'Y' or a.trial_name = x.study_id)
             )
    );
	
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated timepoints in DEAPP_WZ stg_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	--	Update any values that contain < to value-.01 and that contain > to value+.01
	
	update deapp_wz.stg_subject_protein_data t
	set intensity_text=decode(instr(intensity_text,'<'),0,to_char(to_number(replace(intensity_text,'>',''))+.01),to_char(to_number(replace(intensity_text,'<',''))-.01))
	where (intensity_text like '%<%' or intensity_text like '%>%')
	  and control.is_number(replace(replace(intensity_text,'<',''),'>','')) = 0;

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated values with < or > in DEAPP_WZ stg_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	--	Delete any data where component is null and value is null
	
	delete from deapp_wz.stg_subject_protein_data
	where component is null
	  and intensity_text is null;
	  
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete records with null antigen_name and intensity_text in DEAPP_WZ stg_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	--	Update numeric values 
	
	update deapp_wz.stg_subject_protein_data
	set intensity=to_number(intensity_text)
	where control.is_number(intensity_text) = 0;
	  
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated numeric values in DEAPP_WZ stg_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;		

	--Cleanup any existing data from data file
  
	delete from deapp_wz.de_subject_protein_data
    where trial_name = TrialID; 

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from DEAPP_WZ de_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	create temporary indexes
	
	select count(*)
	into pExists
	from all_indexes
	where owner = 'DEAPP_WZ'
	  and index_name = 'stg_subject_protein_data_I1';
	  
	if pExists > 0 then
		execute immediate('drop index deapp_wz.stg_subject_protein_data_i1');
	end if;
	execute immediate('create index deapp_wz.stg_subject_protein_data_i1 on deapp_wz.stg_subject_protein_data (component, subject_id) tablespace deapp');

	select count(*)
	into pExists
	from all_indexes
	where owner = 'I2B2_LZ'
	  and index_name = 'PROTEIN_PATIENT_INFO_I1';
	  
	if pExists > 0 then
		execute immediate('drop index i2b2_lz.protein_patient_info_i1');
	end if;
	
	execute immediate('create index i2b2_lz.protein_patient_info_i1 on i2b2_lz.patient_info (study_id, subject_id, usubjid) tablespace i2b2_data');
	
	select count(*)
	into pExists
	from all_indexes
	where owner = 'I2B2DEMODATA'
	  and index_name = 'PROTEIN_PATIENT_DIMENSION_I1';
	  
	if pExists > 0 then
		execute immediate('drop index i2b2demodata.protein_patient_dimension_i1');
	end if;	
			
	execute immediate('create index i2b2demodata.protein_patient_dimension_i1 on i2b2demodata.patient_dimension (sourcesystem_cd) tablespace i2b2_data');
	
    insert into deapp_wz.de_subject_protein_data
	(trial_name
	,component
	,intensity
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,timepoint
	,zscore
	)
	select p.trial_name
		  ,p.component
		  ,avg(p.intensity) as value
		  ,avg(p.intensity) as n_value
		  ,pd.patient_num
		  ,p.gene_symbol
		  ,p.gene_id
		  ,p.assay_id
		  ,p.timepoint
		  ,0 as zscore
	from deapp_wz.stg_subject_protein_data p
		,i2b2_lz.patient_info pi
		,i2b2demodata.patient_dimension pd
	where p.subject_id = pi.subject_id
	  and nvl(p.site_id,'**NULL**') = nvl(pi.site_id,'**NULL**')
	  and pi.study_id = TrialId
	  and pi.usubjid = pd.sourcesystem_cd
	  and p.trial_name = TrialId
	  and p.intensity is not null
	  and p.intensity > 0
	  and p.gene_symbol is not null
	  group by p.trial_name
		  ,p.component
		  ,pd.patient_num
		  ,p.gene_symbol
		  ,p.gene_id
		  ,p.assay_id
		  ,p.timepoint;
	  
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into DEAPP_WZ de_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	execute immediate('drop index deapp_wz.stg_subject_protein_data_i1');
	execute immediate('drop index i2b2_lz.protein_patient_info_i1');
	execute immediate('drop index i2b2demodata.protein_patient_dimension_i1');
	
	--	ZScore calculation which will insert data to deapp.de_subject_protein_data
	
	i2b2_protein_zscore_calc(Trialid, jobid);
	
--	add the high level \Biomarker Data\ node if it doesn't exist (first time loading data)
  
	select count(*)
	into pExists
	from i2b2
	where c_fullname = '\' || RootNode || '\'|| TrialID || '\Biomarker Data\';
  
	if pExists = 0 then 
		i2b2_add_node(trialID, '\' || RootNode || '\' || trialID || '\Biomarker Data\', 'Biomarker Data', jobID);
        stepCt := stepCt + 1;
	    control.cz_write_audit(jobId,databaseName,procedureName,'Add Biomarker Data node for trial',0,stepCt,'Done');
	end if;

    --	check if Proteomics node exists, if yes, then delete existing data
	
	select count(*) into pExists
	from i2b2
	where c_fullname = '\' || RootNode || '\'|| TrialID || '\Biomarker Data\Protein\Proteomics\';
		  
	if pExists != 0 then
		--This deletes all i2b2, concept_dimension, and observation_fact records wher the path starts with the passed paramenter
		i2b2_delete_all_nodes('\' || RootNode || '\'|| TrialID || '\Biomarker Data\Protein\Proteomics\', jobID);
		stepCt := stepCt + 1;
		control.cz_write_audit(jobId,databaseName,procedureName,'Delete existing Proteomics data for trial in I2B2METADATA i2b2',0,stepCt,'Done');
	end if;
	
	--	Cleanup any existing data in de_subject_sample_mapping.  
	
	delete from deapp.DE_SUBJECT_SAMPLE_MAPPING 
	where trial_name = TrialID 
	  and platform = 'Protein'
	  and platform_cd = trialID || ':Protein'; --Making sure only protein data is deleted
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--	add \Biomarker\Protein\Proteomics\timepoint nodes
	
	FOR r_addNodes in addNodes Loop
		
		i2b2_add_node(TrialId, r_addNodes.path, r_addNodes.node_name, jobId);

	End loop;
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Added Biomarker\Protein\Proteomics\timepoint nodes',0,stepCt,'Done');
	commit;
	
  --Load the DE_SUBJECT_SAMPLE_MAPPING from deapp_wz.stg_subject_mrna_data

  --CONCEPT_CODE    = generated JNJ concept code 
  --PATIENT_ID      = PATIENT_ID (SAME AS ID ON THE PATIENT_DIMENSION)
  --TRIAL_NAME      = TRIAL_NAME
  --TIMEPOINT       = TIMEPOINT
  --ASSAY_ID        = ASSAY_ID
  --PLATFORM        = Protein - this is required by ui code
  --PLATFORM_CD     = trial_name || 'Protein' 
  --TISSUE_TYPE     = NULL
  --SITE_ID         = NULL
  --SUBJECT_ID      = NULL
  --SUBJECT_TYPE    = NULL
  --PATIENT_UID     = NULL
  --SAMPLE_TYPE     = NULL
  --ASSAY_UID       = NULL
  --TIMEPOINT_CD    = same as concept_cd
  --SAMPLE_TYPE_CD  = NULL
  --TISSUE_TYPE_CD  = NULL
  --GPL_ID			= NULL
    
	insert into de_subject_sample_mapping
	(data_uid
	,concept_code
	,patient_id
	,trial_name
	,timepoint
	,assay_id
	,platform
	,platform_cd
	,timepoint_cd
	,sample_type
	,sample_type_cd
	,gpl_id
    )
	select distinct replace(cd.concept_cd || '-' || a.patient_id,' ','') as data_uid
	      ,cd.concept_cd
		  ,a.patient_id
		  ,a.trial_name
		  ,a.timepoint
		  ,a.assay_id
		  ,'Protein'
		  ,a.trial_name || ':Protein'
		  ,cd.concept_cd as timepoint_cd
		  ,null
		  ,null as sample_type_cd
		  ,null
	from deapp.de_subject_protein_data a		
    --Joining to Pat_dim to ensure the ID's match. If not I2B2 won't work.
	join i2b2demodata.patient_dimension b
	  on a.patient_id = b.patient_num
	join i2b2demodata.concept_dimension cd
	  on cd.concept_path = '\' || rootNode || '\' || TrialId || '\Biomarker Data\Protein\Proteomics\' || a.timepoint || '\'
    where a.trial_name = TrialID; 
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_sample_mapping',SQL%ROWCOUNT,stepCt,'Done');
	commit;
         
--	Insert records for patients and timepoints into observation_fact

	insert into observation_fact
    (patient_num
	,concept_cd
	,modifier_cd
	,valtype_cd
	,tval_char
	,nval_num
	,sourcesystem_cd
	,import_date
	,valueflag_cd
	,provider_id
	,location_cd
	,units_cd
    )
    select m.patient_id
		  ,m.concept_code
		  ,m.trial_name
		  ,'T' -- Text data type
		  ,'E'  --Stands for Equals for Text Types
		  ,null	--	not numeric for Proteomics
		  ,m.trial_name
		  ,sysdate
		  ,'@'
		  ,'@'
		  ,'@'
		  ,'' -- no units available
    from  deapp.de_subject_sample_mapping m
    where trial_name = TrialID 
      and platform = 'Protein'
    group by patient_id
			,concept_code
			,trial_name;
    stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into I2B2DEMODATA observation_fact',SQL%ROWCOUNT,stepCt,'Done');

    commit;
    
--	Update visual attributes for leaf active (default is folder)

	update i2b2 a
    set c_visualattributes = 'LA'
    where 1 = (select count(*)
			   from i2b2 b
			   where b.c_fullname like (a.c_fullname || '%'))
      and a.c_fullname like '\' || RootNode || '\' || TrialID || '\Biomarker Data\%';
    stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Update leaf active attribute for trial in I2B2METADATA i2b2',SQL%ROWCOUNT,stepCt,'Done');
    commit;
	
--	fill in tree

	i2b2_fill_in_tree(TrialID,'\' || rootNode || '\' || TrialID || '\Biomarker Data\', jobID);
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Fill in tree for Biomarker Data for trial',SQL%ROWCOUNT,stepCt,'Done');
  
  --Build concept Counts
  --Also marks any i2B2 records with no underlying data as Hidden, need to do at Biomarker level because there may be multiple platforms and patient count can vary
  
    i2b2_create_concept_counts('\' || RootNode || '\' || TrialID || '\Biomarker Data\',jobID );
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Create concept counts',0,stepCt,'Done');

  --Reload Security: Inserts one record for every I2B2 record into the security table

    i2b2_load_security_data(jobId);
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Load security data',0,stepCt,'Done');

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_protein_data',0,stepCt,'Done');
		
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL'); 

END;


 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_PROCESS_RAW_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_PROCESS_RAW_DATA" 
(
  trialID varchar2
)
AS

BEGIN

  --Record counts to counts table
  INSERT
  INTO I2B2_LZ.TPM_COUNTS
  (
    STUDY_ID,
    CATEGORY_CD,
    RECORD_COUNT,
    LOAD_DATE
  )
  select 
    study_id,
    category_cd, 
    count(*),
    sysdate
    from i2b2_lz.time_point_measurement
    where study_id = trialID
    group by 
      study_id,
      category_cd;
  commit;
    
  --Delete data from Time Point Measurement raw table where Trial Number and Category Code match.
  delete from i2b2_lz.time_point_measurement_raw
    where study_id = trialID
      and category_cd IN(select distinct category_cd from i2b2_lz.time_point_measurement where study_id = trialID);
  COMMIT;
  
  --Insert new records into Raw tables
  insert into 
    i2b2_lz.time_point_measurement_raw
  select * 
    from i2b2_lz.time_point_measurement
    where study_id = trialID;
  commit;
  
  --Clear the Working zone table
  delete from  i2b2_wz.time_point_measurement;
  
  --Load the new records
  insert into i2b2_wz.time_point_measurement
  select distinct * 
    from i2b2_lz.time_point_measurement a
      where data_value is not null
        and study_id = trialID;
  commit;
  
  --CATEGORY DATA
  --DELETE DATA from category table.
  delete 
    from i2b2_lz.category 
      where study_id = trialID
        and category_cd IN (Select category_cd from i2b2_lz.stg_category where study_id = trialID);
  COMMIT;

  --insert new records into the category table
  INSERT INTO I2B2_LZ.CATEGORY
    (study_id, category_cd, category_path)
  SELECT trialID, category_cd, category_path
    FROM i2b2_lz.stg_category;
  COMMIT;

  --clear the category table in the working zone
  delete  
    from i2b2_wz.category;

  --Insert the Category data converting the path to proper case
  INSERT INTO I2B2_WZ.CATEGORY
  select
    category_Cd, 
    initcap(category_path) as category_path,
    study_id
  FROM
    i2b2_lz.category
    where study_id = trialID;
  commit;

  --Fix category records
  UPDATE i2b2_wz.CATEGORY
  SET CATEGORY_PATH = REPLACE(CATEGORY_PATH, 'Elisa', 'ELISA')
  where category_path like '%Elisa%';
  commit;
  
  --Clean up LZ tables
  delete  
    from i2b2_lz.stg_category;
  
  delete 
    from i2b2_lz.time_point_measurement
      where study_id = trialID;
  commit;
END;

 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_PROCESS_RAW_DATA_EXTRNL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_PROCESS_RAW_DATA_EXTRNL" 
(
  trialID varchar2
 ,reloadType IN VARCHAR2 := 'R'
 ,currentJobID NUMBER := null
)
AS

--	JEA@20091117	Added reloadType processing to only delete matching trial/category data if reloadType = I otherwise delete all existing data for trial
--	JEA@20091117	Added auditing
--	JEA@20091208	Remove leading and trailing "'s in time_point_measurement columns generated by excel

  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN
	
	stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
	
  --Record counts to counts table
 
  INSERT
  INTO I2B2_LZ.TPM_COUNTS
  (
    STUDY_ID,
    CATEGORY_CD,
    RECORD_COUNT,
    LOAD_DATE
  )
  select 
    study_id,
    category_cd, 
    count(*),
    sysdate
    from i2b2_lz.time_point_measurement_extrnl
    where study_id = trialID
    group by 
      study_id,
      category_cd;
  commit;
    
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Record counts for external tpm table',SQL%ROWCOUNT,stepCt,'Done');
	
--	if reloadType = 'I', the data is an incremental load and only the data where trial name and category code match will be deleted
--	any other code (or none which defaults to R) is a full refresh and all the data for the trial is deleted

  if reloadType = 'I' then
	--Delete data from Time Point Measurement raw table where Trial Number and Category Code match.
	delete from i2b2_lz.time_point_measurement_raw
    where study_id = trialID
      and category_cd IN(select distinct category_cd from i2b2_lz.time_point_measurement_extrnl where study_id = trialID);
	  
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete matching trial/category in LZ time_point_measurement_raw',SQL%ROWCOUNT,stepCt,'Done');
	
	COMMIT;
  else
     delete from i2b2_lz.time_point_measurement_raw
	 where study_id = trialID;
	 
	 stepCt := stepCt + 1;
	 control.cz_write_audit(jobId,databaseName,procedureName,'Delete all trial data in LZ time_point_measurement_raw',SQL%ROWCOUNT,stepCt,'Done');
	 
	 commit;
  end if;
  
  --Insert new records into Raw tables
  insert into 
    i2b2_lz.time_point_measurement_raw
   (STUDY_ID
   ,USUBJID
   ,SITE_ID
   ,SUBJECT_ID
   ,VISIT_NAME
   ,DATASET_NAME
   ,SAMPLE_TYPE
   ,DATA_LABEL
   ,DATA_VALUE
   ,CATEGORY_CD
   ,PERIOD
   )
  select STUDY_ID
        ,USUBJID
        ,SITE_ID
        ,SUBJECT_ID
        ,trim('"' from VISIT_NAME)
        ,trim('"' from DATASET_NAME)
        ,trim('"' from SAMPLE_TYPE)
        ,trim('"' from DATA_LABEL)
        ,trim('"' from DATA_VALUE)
        ,trim('"' from CATEGORY_CD)
        ,trim('"' from PERIOD)
    from i2b2_lz.time_point_measurement_extrnl
    where study_id = trialID;
		 
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial data into LZ time_point_measurement_raw',SQL%ROWCOUNT,stepCt,'Done');
	
  commit;
  
  --Clear the Working zone table
  execute immediate('truncate table i2b2_wz.time_point_measurement');
  
  --Load the new records into wz time_point_measurement
  insert into i2b2_wz.time_point_measurement
  (study_id
  ,site_id
  ,subject_id
  ,site_subj
  ,visit_date
  ,visit_name
  ,dataset_name
  ,endpoint_flag
  ,sample_type
  ,data_label
  ,data_value
  ,category_cd
  ,updated_value
  ,suppress_flag
  ,operator_flag
  ,valueflag_cd
  ,unit_cd
  ,etl_id
  ,data_type
  ,usubjid
  ,pd_marker
  ,period) 
  select study_id
        ,site_id
        ,subject_id
        ,null
        ,null
        ,trim('"' from visit_name)
        ,trim('"' from dataset_name)
        ,null
        ,trim('"' from sample_type)
        ,trim('"' from data_label)
        ,trim('"' from data_value)
        ,trim('"' from category_cd)
        ,null
        ,null
        ,null
        ,null
        ,null
        ,'JNJ@' || to_char(sysdate        ,'YYYYMMDD')
        ,null
        ,usubjid
        ,null
        ,trim('"' from period)
  from i2b2_lz.time_point_measurement_extrnl
  where data_value is not null
    and study_id = trialID;
	 
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial data in WZ time_point_measurement',SQL%ROWCOUNT,stepCt,'Done');
  
  commit;
  
  --CATEGORY DATA
  --DELETE DATA from category table.
  if reloadType = 'I' then
      delete from i2b2_lz.category 
      where study_id = trialID
        and category_cd IN (Select category_cd from i2b2_lz.category_extrnl where study_id = trialID);
			 
      stepCt := stepCt + 1;
	  control.cz_write_audit(jobId,databaseName,procedureName,'Delete all matching trial/category data in LZ category',SQL%ROWCOUNT,stepCt,'Done');
	  
	  COMMIT;
  else
     delete from i2b2_lz.category
	 where study_id = trialID;
	 	 
     stepCt := stepCt + 1;
	 control.cz_write_audit(jobId,databaseName,procedureName,'Delete all trial data in LZ category',SQL%ROWCOUNT,stepCt,'Done');
	 
	 commit;
  end if;

  --insert new records into the category table
  INSERT INTO I2B2_LZ.CATEGORY
    (study_id, category_cd, category_path)
  SELECT trialID, category_cd, category_path
    FROM i2b2_lz.category_extrnl;
		 
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial data into LZ category',SQL%ROWCOUNT,stepCt,'Done');
  
  COMMIT;

  --clear the category table in the working zone
   execute immediate('truncate table i2b2_wz.category');

  --Insert the Category data converting the path to proper case, use the jnj_init_cap function so that "reserved" words are not changed
  INSERT INTO I2B2_WZ.CATEGORY
  select
    category_Cd, 
    control.jnj_init_cap(category_path) as category_path,
    study_id
  FROM
    i2b2_lz.category
    where study_id = trialID;
		 
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial data into WZ category',SQL%ROWCOUNT,stepCt,'Done');
  
  commit;

  --Fix category records
  UPDATE i2b2_wz.CATEGORY
  SET CATEGORY_PATH = REPLACE(CATEGORY_PATH, 'Elisa', 'ELISA')
  where category_path like '%Elisa%';
  	 
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Fix ELISA category_path',SQL%ROWCOUNT,stepCt,'Done');
  commit;
  
   --	do alter table move to defrag i2b2_wz.time_point_measurement
 
   EXECUTE IMMEDIATE 'ALTER TABLE I2B2_WZ.TIME_POINT_MEASUREMENT MOVE';
   EXECUTE IMMEDIATE 'ALTER INDEX I2B2_WZ.IDX_TPM_USUBJID REBUILD';
   EXECUTE IMMEDIATE 'ALTER INDEX I2B2_WZ.IDX_TPM_CATEGORY_CD REBUILD';
   EXECUTE IMMEDIATE 'ALTER INDEX I2B2_WZ.IDX_TPM_DATA_LABEL REBUILD';
   EXECUTE IMMEDIATE 'ANALYZE TABLE I2B2_WZ.TIME_POINT_MEASUREMENT COMPUTE STATISTICS';
   
   stepCt := stepCt + 1;
   control.cz_write_audit(jobId,databaseName,procedureName,'After defrag/analyze',0,stepCt,'Done');
   
  --Clean up LZ tables
  
  delete 
    from i2b2_lz.time_point_measurement
      where study_id = trialID;
  commit;
  
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

END I2B2_PROCESS_RAW_DATA_EXTRNL;

 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_PROCESS_RBM_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_PROCESS_RBM_DATA" 
(
  trial_id VARCHAR2
 ,currentJobID NUMBER := null
)
AS
  
  --	JEA@20100115	New
  --	JEA@20100121	Removed IgA/IgE/IgM-specific code, moved entries to stg_rbm_antigen_gene table
  --	JEA@20100129	Removed delete of N/A, Not Requested, QNS value_text, will be dropped because not numeric
  --	JEA@20100201	Renamed to I2B2_PROCESS_RBM_DATA from I2B2_LOAD_RBM_DATA for consistency amoung mRNA, RBM, and protein load procedures

  TrialID varchar2(100);
  RootNode VARCHAR2(100);
  pExists number;
    
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);


BEGIN
  TrialID := upper(trial_id);  
  
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;
  stepCt := stepCt + 1;
  control.cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_process_rbm_data',0,stepCt,'Done');
	
  --Determine root value of I2B2: Could be Clinical or Experimental
  select parse_nth_value(c_fullname, 2, '\') into RootNode
  from i2b2
  where c_name = TrialID;

  --if Root Node is null, then add a root node as a clinical trial as a default.
  if RootNode is null then  
    i2b2_add_node(TrialID, '\Clinical Trials\' || TrialID || '\', TrialID, jobID);
    RootNode := 'Clinical Trials';
  end if;

	--Cleanup any existing data from raw table
  
	delete from deapp_wz.stg_subject_rbm_data_raw 
    where trial_name = TrialID; 

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from DEAPP_WZ stg_subject_rbm_data_raw',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	Insert into raw data table from staging
 
	insert into deapp_wz.stg_subject_rbm_data_raw
	(trial_name
	,antigen_name
	,value_text
	,timepoint
	,assay_id
	,sample_id
	,subject_id
	,site_id
	)
	select trial_name
		  ,antigen_name
		  ,value_text
		  ,timepoint
		  ,assay_id
		  ,sample_id
		  ,subject_id
		  ,site_id
	from deapp_wz.stg_subject_rbm_data
    where trial_name = TrialID; 

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert data for trial into DEAPP_WZ stg_subject_rbm_data_raw',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
	--Remove any unit values from antigen_name and trim antigen_name
	
	update deapp_wz.stg_subject_rbm_data
	set antigen_name = trim(case when instr(upper(antigen_name),'NMOL/L') > 0
								 then substr(antigen_name,1,instr(UPPER(antigen_name),'NMOL/L')-1)
								 when instr(upper(antigen_name),'MIU/ML') > 0
								 then substr(antigen_name,1,instr(UPPER(antigen_name),'MIU/ML')-1)
								 else antigen_name
							end
						   );

	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Removed units from antigen_name and trimmed in DEAPP_WZ stg_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	Perform node-curation on timepoint

	update deapp_wz.stg_subject_rbm_data a
    set a.timepoint = 
       (select replace(Upper(a.timepoint), b.node_name, b.display_name)
        from node_curation b
        where b.node_type = 'VISIT_NAME'
          and upper(a.timepoint) = b.node_name  
          and b.active_flag = 'Y'
          and (b.global_flag = 'Y' OR b.study_id = a.trial_name)
		  and b.global_flag =
			 (select min(x.global_flag) from node_curation x
			  where b.node_type = x.node_type
                and b.node_name = x.node_name
                and (x.global_flag = 'Y' or a.trial_name = x.study_id)
             )
      )
    where exists
    (select 1 
      from node_curation b 
      where b.node_type = 'VISIT_NAME'
        and upper(a.timepoint) = b.node_name  
        and b.active_flag = 'Y'
        and (b.global_flag = 'Y' OR b.study_id = a.trial_name)
		and b.global_flag =
			 (select min(x.global_flag) from node_curation x
			  where b.node_type = x.node_type
                and b.node_name = x.node_name
                and (x.global_flag = 'Y' or a.trial_name = x.study_id)
             )
    );
	
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated timepoints in DEAPP_WZ stg_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	Perform node-curation on antigen_name

	update deapp_wz.stg_subject_rbm_data a
    set a.antigen_name = 
       (select replace(Upper(a.antigen_name), b.node_name, b.display_name)
        from node_curation b
        where b.node_type = 'ANTIGEN'
          and upper(a.antigen_name) = b.node_name  
          and b.active_flag = 'Y'
          and (b.global_flag = 'Y' OR b.study_id = a.trial_name)
		  and b.global_flag =
			 (select min(x.global_flag) from node_curation x
			  where b.node_type = x.node_type
                and b.node_name = x.node_name
                and (x.global_flag = 'Y' or a.trial_name = x.study_id)
             )
      )
    where exists
    (select 1 
      from node_curation b 
      where b.node_type = 'ANTIGEN'
        and upper(a.antigen_name) = b.node_name  
        and b.active_flag = 'Y'
        and (b.global_flag = 'Y' OR b.study_id = a.trial_name)
		and b.global_flag =
			 (select min(x.global_flag) from node_curation x
			  where b.node_type = x.node_type
                and b.node_name = x.node_name
                and (x.global_flag = 'Y' or a.trial_name = x.study_id)
             )
    );
	
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated antigen_name in DEAPP_WZ stg_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	
	
	--	Update any values that contain < to value-.01 and that contain > to value+.01
	
	update deapp_wz.stg_subject_rbm_data t
	set value_text=decode(instr(value_text,'<'),0,to_char(to_number(replace(value_text,'>',''))+.01),to_char(to_number(replace(value_text,'<',''))-.01))
	where (value_text like '%<%' or value_text like '%>%')
	  and control.is_number(replace(replace(value_text,'<',''),'>','')) = 0;

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated values with < or > in DEAPP_WZ stg_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	--	Delete any data where antigen_name is null and value is null
	
	delete from deapp_wz.stg_subject_rbm_data
	where antigen_name is null
	  and value_text is null;
	  
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete records with null antigen_name and value_text in DEAPP_WZ stg_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	--	Delete any antigens that have more than 50% of the values as LOW
	
	delete from deapp_wz.stg_subject_rbm_data s
	where s.antigen_name in
	     (select x.antigen_name
		 from deapp_wz.stg_subject_rbm_data x
		 group by x.antigen_name
		 having sum(decode(instr(upper(x.value_text),'LOW'),0,0,1))/count(*) > .50);
	  
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete antigens with > 50% LOW values in DEAPP_WZ stg_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;	

	--	Update numeric values 
	
	update deapp_wz.stg_subject_rbm_data
	set value_number=to_number(value_text)
	where control.is_number(value_text) = 0;
	  
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Updated numeric values in DEAPP_WZ stg_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;		

	--	Update any remaining LOW values to 50% of minimum value for antigen
	
	update deapp_wz.stg_subject_rbm_data s
	set value_number=
	    (select min(x.value_number)*.5
		 from deapp_wz.stg_subject_rbm_data x
		 where s.antigen_name = x.antigen_name
		  and x.value_number is not null)
	where upper(s.value_text) like '%LOW%';

	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Updated LOW values in DEAPP_WZ stg_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--Cleanup any existing data from data file
  
	delete from deapp_wz.de_subject_rbm_data
    where trial_name = TrialID; 

	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete data for trial from DEAPP_WZ de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	create temporary indexes
	
	select count(*)
	into pExists
	from all_indexes
	where owner = 'DEAPP_WZ'
	  and index_name = 'STG_SUBJECT_RBM_DATA_I1';
	  
	if pExists > 0 then
		execute immediate('drop index deapp_wz.stg_subject_rbm_data_i1');
	end if;
	execute immediate('create index deapp_wz.stg_subject_rbm_data_i1 on deapp_wz.stg_subject_rbm_data (antigen_name, subject_id) tablespace deapp');
	
	select count(*)
	into pExists
	from all_indexes
	where owner = 'DEAPP'
	  and index_name = 'STG_RBM_ANTIGEN_GENE_I1';
	  
	if pExists > 0 then
		execute immediate('drop index deapp.stg_rbm_antigen_gene_i1');
	end if;

	execute immediate('create index deapp.stg_rbm_antigen_gene_i1 on deapp.stg_rbm_antigen_gene (antigen_name) tablespace deapp');
	
	select count(*)
	into pExists
	from all_indexes
	where owner = 'I2B2_LZ'
	  and index_name = 'RBM_PATIENT_INFO_I1';
	  
	if pExists > 0 then
		execute immediate('drop index i2b2_lz.rbm_patient_info_i1');
	end if;
	
	execute immediate('create index i2b2_lz.rbm_patient_info_i1 on i2b2_lz.patient_info (study_id, subject_id, usubjid) tablespace i2b2_data');
	
	select count(*)
	into pExists
	from all_indexes
	where owner = 'I2B2DEMODATA'
	  and index_name = 'RBM_PATIENT_DIMENSION_I1';
	  
	if pExists > 0 then
		execute immediate('drop index i2b2demodata.rbm_patient_dimension_i1');
	end if;	
			
	execute immediate('create index i2b2demodata.rbm_patient_dimension_i1 on i2b2demodata.patient_dimension (sourcesystem_cd) tablespace i2b2_data');
	
    insert into deapp_wz.de_subject_rbm_data
	(trial_name
	,antigen_name
	,value
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,normalized_value
	,concept_cd
	,timepoint
	,zscore
	)
	select rbm.trial_name
		  ,rbm.antigen_name
		  ,avg(rbm.value_number) as value
		  ,avg(rbm.value_number) as n_value
		  ,pd.patient_num
		  ,ag.gene_symbol
		  ,ag.gene_id
		  ,to_number(rbm.assay_id)
		  ,0 as normalized_value
		  ,rbm.trial_name || ':' || substr(rbm.antigen_name,1,20) as concept_cd
		  ,rbm.timepoint
		  ,0 as zscore
	from deapp_wz.stg_subject_rbm_data rbm
		,i2b2_lz.patient_info pi
		,i2b2demodata.patient_dimension pd
		,deapp.stg_rbm_antigen_gene ag
	where rbm.subject_id = pi.subject_id
	  and nvl(rbm.site_id,'**NULL**') = nvl(pi.site_id,'**NULL**')
	  and pi.study_id = TrialId
	  and pi.usubjid = pd.sourcesystem_cd
	  and rbm.trial_name = TrialId
	  and rbm.antigen_name = ag.antigen_name
	  and rbm.value_number is not null
	  and rbm.value_number > 0
	  group by rbm.trial_name
		  ,rbm.antigen_name
		  ,pd.patient_num
		  ,ag.gene_symbol
		  ,ag.gene_id
		  ,to_number(rbm.assay_id)
		  ,rbm.trial_name || ':' || substr(rbm.antigen_name,1,20) 
		  ,rbm.timepoint;
	  
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into DEAPP_WZ de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	execute immediate('drop index deapp_wz.stg_subject_rbm_data_i1');
	execute immediate('drop index deapp.stg_rbm_antigen_gene_i1');
	execute immediate('drop index i2b2_lz.rbm_patient_info_i1');
	execute immediate('drop index i2b2demodata.rbm_patient_dimension_i1');
	
	/*	the delete/insert will be done as part of i2b2_rbm_zscore_calc procedure'
	
	--	Delete existing data from deapp.de_subject_rbm_data

	delete from deapp.de_subject_rbm_data
	where trial_name = TrialId;
		  
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Deleted trial from DEAPP de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	--	Insert trial into deapp.de_subject_rbm_data
	
	insert into deapp.de_subject_rbm_data
	(trial_name
	,antigen_name
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,normalized_value
	,concept_cd
	,timepoint
	,value
	,zscore
	)
	select trial_name
		  ,antigen_name
		  ,n_value
		  ,patient_id
		  ,gene_symbol
		  ,gene_id
		  ,assay_id
		  ,normalized_value
		  ,concept_cd
		  ,timepoint
		  ,value
		  ,zscore 
	from deapp_wz.de_subject_rbm_data
	where trial_name = TrialID;
	  
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'Inserted trial into DEAPP de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
*/

	--	ZScore calculation
	
	i2b2_rbm_zscore_calc(Trialid, jobid);
	
	--	Add observed and zscore to i2b2
	
	i2b2_load_rbm_data(TrialID, 'O', jobId); 	-- Observed values
	i2b2_load_rbm_data(TrialID, 'Z', jobId);		-- Z-Scores
	
	stepCt := stepCt + 1;
    control.cz_write_audit(jobId,databaseName,procedureName,'End i2b2_process_rbm_data',0,stepCt,'Done');
	
    ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL'); 

END;


 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_PROTEIN_ZSCORE_CALC
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_PROTEIN_ZSCORE_CALC" 
(
  trial_id VARCHAR2
 ,currentJobID NUMBER := null
)
AS

--	JEA@20100129	Calculate ZScore for a single trial using deapp_wz.de_subject_protein_data, delete the trial if found from deapp.de_subject_protein_data,
--					and insert the data from deapp_wz.de_subject_protein_data to deapp.de_subject_protein_data

-- Copyright ? 2010 Recombinant Data Corp.

  TrialID varchar2(100);
  sql_txt varchar2(2000);
  tExists number;		--	used to check if tmp_ tables exists.  If yes, then drop table
    
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
BEGIN

  TrialID := upper(trial_id);
  
  stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_protein_zscore_calc',0,stepCt,'Done');

	--	truncate work tables
	
	execute immediate('truncate table deapp_wz.tmp_subject_protein_logs');
	execute immediate('truncate table deapp_wz.tmp_subject_protein_calcs');
	execute immediate('truncate table deapp_wz.tmp_subject_protein_med');
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Truncate DEAPP_WZ tmp_subject_protein work tables',0,stepCt,'Done');

--	insert trial with protein data and log2 of intensity

	insert into deapp_wz.tmp_subject_protein_logs 
	(trial_name
	,component
	,intensity
    ,n_value
    ,patient_id
    ,gene_symbol
    ,gene_id
    ,assay_id
    ,timepoint
    ,log_intensity
	)
     select trial_name
            ,component
			,intensity
            ,n_value
            ,patient_id
            ,gene_symbol
            ,gene_id
            ,assay_id
            ,timepoint
            ,log(2,intensity) as log_intensity
     from deapp_wz.de_subject_protein_data
     where trial_name =  TrialId 
	   and intensity > 0;
	 stepCt := stepCt + 1;
	 control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial data into DEAPP_WZ tmp_subject_protein_logs',SQL%ROWCOUNT,stepCt,'Done');
	commit;
    
--	calculate mean_intensity, median_intensity, and stddev_intensity for gene/antigen

	insert into deapp_wz.tmp_subject_protein_calcs
	(trial_name
	,gene_symbol
	,component
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
    select d.trial_name
            ,NVL(d.gene_symbol,'**NULL**') as gene_symbol
            ,d.component
            ,avg(d.log_intensity)    as mean_intensity
            ,median(d.log_intensity) as median_intensity
            ,stddev(d.log_intensity) as stddev_intensity
            from deapp_wz.tmp_subject_protein_logs d
            group by d.trial_name, d.component, NVL(d.gene_symbol,'**NULL**');
	 stepCt := stepCt + 1;
	 control.cz_write_audit(jobId,databaseName,procedureName,'Insert intensities into DEAPP_WZ tmp_subject_protein_calcs',SQL%ROWCOUNT,stepCt,'Done');
	commit;

-- calculate zscore

	insert into deapp_wz.tmp_subject_protein_med 
	(trial_name
	,component
	,intensity
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,timepoint
	,zscore
	)
	select d.trial_name
          ,d.component
		  ,d.intensity
	      ,d.n_value
	      ,d.patient_id
          ,case when d.gene_symbol='**null**' then null else d.gene_symbol end as gene_symbol
          ,d.gene_id
	      ,d.assay_id
	      ,d.timepoint
          ,case when c.stddev_intensity=0
          then 0 
          else (d.log_intensity - c.median_intensity ) / c.stddev_intensity 
          end as zscore
    from deapp_wz.tmp_subject_protein_logs d 
    inner join deapp_wz.tmp_subject_protein_calcs c
          on d.trial_name=c.trial_name 
          and nvl(d.component,'**null**') = nvl(c.component,'**null**') 
          and nvl(d.gene_symbol,'**null**') = nvl(c.gene_symbol,'**null**');
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert uncapped zscore data into DEAPP_WZ tmp_subject_protein_med',SQL%ROWCOUNT,stepCt,'Done');
    commit;
  
	--	delete existing data from deapp_wz.de_subject_protein_data
	
	delete from deapp_wz.de_subject_protein_data
	where trial_name = Trialid;
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP_WZ de_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
    commit;
	
	--	insert data into deapp_wz.de_subject_protein_data
	
	insert into deapp_wz.de_subject_protein_data
	(trial_name
	,component
	,intensity
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,timepoint
	,zscore
	)
	select trial_name
		  ,component
		  ,intensity
		  ,n_value
		  ,patient_id
		  ,gene_symbol
		  ,gene_id
		  ,assay_id
		  ,timepoint
		  ,case when zscore < -2.5 then -2.5
		        when zscore > 2.5 then 2.5
			    else round(zscore,5)
		   end
	from deapp_wz.tmp_subject_protein_med;
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP_WZ de_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
    commit;	
	
--	delete any data from deapp.de_subject_protein_data for trial

	delete deapp.de_subject_protein_data
	where trial_name = TrialID;
	
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

--	insert data for trial into deapp.de_subject_protein_data

	insert into deapp.de_subject_protein_data
	(trial_name
	,component
	,intensity
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,timepoint
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	)
	select r.trial_name
      ,r.component
	  ,r.intensity
	  ,r.n_value
	  ,r.patient_id
	  ,r.gene_symbol
	  ,r.gene_id
	  ,r.assay_id
	  ,r.timepoint
	  ,m.mean_intensity
	  ,m.stddev_intensity
	  ,m.median_intensity
	  ,r.zscore
	from deapp_wz.de_subject_protein_data r
		,deapp_wz.tmp_subject_protein_calcs m
	where r.trial_name = TrialId
	  and r.trial_name = m.trial_name
	  and nvl(r.component,'**NULL**') = nvl(m.component,'**NULL**')
	  and nvl(r.gene_symbol,'**NULL**') = nvl(m.gene_symbol,'**NULL**')
	;
	 stepCt := stepCt + 1;
	 control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_protein_data',SQL%ROWCOUNT,stepCt,'Done');
	 commit;

--	cleanup tmp_ files

	execute immediate('truncate table deapp_wz.tmp_subject_protein_logs');
	execute immediate('truncate table deapp_wz.tmp_subject_protein_calcs');
	execute immediate('truncate table deapp_wz.tmp_subject_protein_med');
   
       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
   
END;

/*	--	recreate work tables

create table deapp_wz.tmp_subject_protein_logs as 
select trial_name
	  ,component
	  ,intensity
	  ,n_value
	  ,patient_id
	  ,gene_symbol
	  ,gene_id
	  ,assay_id
	  ,timepoint
	  ,intensity as log_intensity
from deapp_wz.de_subject_protein_data
where 1=2;

create table deapp_wz.tmp_subject_protein_calcs as
select trial_name
	  ,gene_symbol
	  ,component
	  ,log_intensity as mean_intensity
	  ,log_intensity as median_intensity
	  ,log_intensity as stddev_intensity
from deapp_wz.tmp_subject_protein_logs 
where 1=2;

create table deapp_wz.tmp_subject_protein_med as
select trial_name
	  ,component
	  ,intensity
	  ,n_value
	  ,patient_id
	  ,gene_symbol
	  ,gene_id
	  ,assay_id
	  ,timepoint
	  ,log_intensity
	  ,log_intensity as zscore
from deapp_wz.tmp_subject_protein_logs
where 1=2;

*/

 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_RBM_ZSCORE_CALC
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_RBM_ZSCORE_CALC" 
(
  trial_id VARCHAR2
 ,currentJobID NUMBER := null
)
AS

--	JEA@20090902	Calculate ZScore for a single trial using deapp_wz.de_subject_rbm_data, delete the trial if found from deapp.de_subject_rbm_data,
--					and insert the data from deapp_wz.de_subject_rbm_data to deapp.de_subject_rbm_data
--	JEA@20100111	Added auditing
--	JEA@20100129	Changed update of deapp_wz.de_subject_rbm_data to delete/insert
--	JEA@20100304	Added assay_id to join on insert to de_subject_rbm_data 
--	Copyright ? 2009 Recombinant Data Corp.

  TrialID varchar2(100);
  sql_txt varchar2(2000);
  tExists number;		--	used to check if tmp_ tables exists.  If yes, then drop table
    
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
BEGIN

  TrialID := upper(trial_id);
  
  stepCt := 0;
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
  
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_rbm_zscore_calc',0,stepCt,'Done');

--	truncate work tables

	execute immediate('truncate table deapp_wz.tmp_subject_rbm_logs');
	execute immediate('truncate table deapp_wz.tmp_subject_rbm_calcs');
	execute immediate('truncate table deapp_wz.tmp_subject_rbm_med');
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Truncate DEAPP_WZ tmp_subject_rbm work tables',0,stepCt,'Done');
	commit;

--	insert trial with rbm data and log2 of value

	insert into deapp_wz.tmp_subject_rbm_logs 
	(trial_name
	,antigen_name
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,normalized_value
	,concept_cd
	,timepoint
	,value
	,log_intensity
	)
     select TRIAL_NAME
            ,ANTIGEN_NAME
            ,N_VALUE
            ,PATIENT_ID
            ,GENE_SYMBOL
            ,GENE_ID
            ,ASSAY_ID
            ,NORMALIZED_VALUE
            ,CONCEPT_CD
            ,TIMEPOINT
            ,VALUE
            ,log(2,VALUE) as log_intensity
     from deapp_wz.de_subject_rbm_data
     where trial_name =  TrialId 
	   and value > 0;
	 stepCt := stepCt + 1;
	 control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial data into DEAPP_WZ tmp_subject_rbm_logs',SQL%ROWCOUNT,stepCt,'Done');
	commit;
    
--	calculate mean_intensity, median_intensity, and stddev_intensity for gene/antigen

	insert into deapp_wz.tmp_subject_rbm_calcs
	(trial_name
	,gene_symbol
	,antigen_name
	,mean_intensity
	,median_intensity
	,stddev_intensity
	)
    select d.trial_name
            ,NVL(d.gene_symbol,'**NULL**') as gene_symbol
            ,d.antigen_name
            ,avg(d.log_intensity)    as mean_intensity
            ,median(d.log_intensity) as median_intensity
            ,stddev(d.log_intensity) as stddev_intensity
            from deapp_wz.tmp_subject_rbm_logs d
            group by d.trial_name, d.antigen_name, NVL(d.gene_symbol,'**NULL**');
	 stepCt := stepCt + 1;
	 control.cz_write_audit(jobId,databaseName,procedureName,'Insert intensities into DEAPP_WZ tmp_subject_rbm_calcs',SQL%ROWCOUNT,stepCt,'Done');
	commit;

	-- calculate zscore

	insert into deapp_wz.tmp_subject_rbm_med 
	(trial_name
	,antigen_name
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,normalized_value
	,concept_cd
	,timepoint
	,log_intensity
	,value
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	)
	select d.trial_name
          ,d.antigen_name
	      ,d.n_value
	      ,d.patient_id
          ,CASE WHEN d.gene_symbol='**NULL**' THEN NULL ELSE d.gene_symbol END as gene_symbol
          ,d.gene_id
	      ,d.assay_id
	      ,d.normalized_value
	      ,d.concept_cd
	      ,d.timepoint
          ,d.log_intensity
	      ,d.value
          ,c.mean_intensity
	      ,c.stddev_intensity
	      ,c.median_intensity
          ,CASE WHEN c.stddev_intensity=0
          THEN 0 
          ELSE (d.log_intensity - c.median_intensity ) / c.stddev_intensity 
          END as zscore
          from deapp_wz.tmp_subject_rbm_logs d 
          inner join deapp_wz.tmp_subject_rbm_calcs c
          on d.trial_name=c.trial_name 
          and d.antigen_name=c.antigen_name 
          and NVL(d.gene_symbol,'**NULL**')=c.gene_symbol;
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert uncapped zscore data into DEAPP_WZ tmp_subject_rbm_med',SQL%ROWCOUNT,stepCt,'Done');
    commit;
  
	--	delete trial from deapp_wz.de_subject_rbm_data
	
	delete from deapp_wz.de_subject_rbm_data
	where trial_name = TrialId;
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP_WZ de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
    commit;	
	
	--	insert trial into deapp_wz.de_subject_rbm_data
	
	insert into deapp_wz.de_subject_rbm_data
	(trial_name
	,antigen_name
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,normalized_value
	,concept_cd
	,timepoint
	,value
	,zscore
	)
	select trial_name
	,antigen_name
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,normalized_value
	,concept_cd
	,timepoint
	,value
	,case when zscore < -2.5 then -2.5
	      when zscore > 2.5 then 2.5
		  else round(zscore,5)
	 end
	from deapp_wz.tmp_subject_rbm_med;
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP_WZ de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;

--	delete any data from deapp.de_subject_rbm_data for trial

	delete deapp.de_subject_rbm_data
	where trial_name = TrialID;
	stepCt := stepCt + 1;
	control.cz_write_audit(jobId,databaseName,procedureName,'Delete trial from DEAPP de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
--	insert data for trial into deapp.de_subject_rbm_data, both concept_cd and data_uid will be recast and timepoints will be curated when i2b2_process_rbm_data is run 

	insert into deapp.de_subject_rbm_data
	(trial_name
	,antigen_name
	,n_value
	,patient_id
	,gene_symbol
	,gene_id
	,assay_id
	,normalized_value
	,concept_cd
	,timepoint
	,data_uid
	,value
	,log_intensity
	,mean_intensity
	,stddev_intensity
	,median_intensity
	,zscore
	)
	select r.trial_name
      ,r.antigen_name
	  ,r.n_value
	  ,r.patient_id
	  ,r.gene_symbol
	  ,r.gene_id
	  ,r.assay_id
	  ,r.normalized_value
	  ,r.concept_cd
	  ,r.timepoint
	  ,null
	  ,r.value
	  ,m.log_intensity
	  ,m.mean_intensity
	  ,m.stddev_intensity
	  ,m.median_intensity
	  ,r.zscore
	from deapp_wz.de_subject_rbm_data r
    ,deapp_wz.tmp_subject_rbm_med m
	where r.trial_name = TrialId
	  and r.trial_name = m.trial_name
	  and r.antigen_name = m.antigen_name
	  and r.patient_id = m.patient_id
	  and r.assay_id = m.assay_id
	  and nvl(r.gene_symbol,'**NULL**') = nvl(m.gene_symbol,'**NULL**')
	;
	 stepCt := stepCt + 1;
	 control.cz_write_audit(jobId,databaseName,procedureName,'Insert trial into DEAPP de_subject_rbm_data',SQL%ROWCOUNT,stepCt,'Done');
	 commit;


--	cleanup tmp_ files

   sql_txt := 'truncate table deapp_wz.tmp_subject_rbm_logs';
   execute immediate sql_txt;
   
   sql_txt := 'truncate table deapp_wz.tmp_subject_rbm_calcs';
   execute immediate sql_txt;
  
   sql_txt := 'truncate table deapp_wz.tmp_subject_rbm_med';
   execute immediate sql_txt;
   
       ---Cleanup OVERALL JOB if this proc is being run standalone
  IF newJobFlag = 1
  THEN
    cz_end_audit (jobID, 'SUCCESS');
  END IF;

  EXCEPTION
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
   
END;

/*	recreate work tables

create table deapp_wz.tmp_subject_rbm_logs as 
				  select trial_name
                  ,antigen_name
                  ,n_value
                  ,patient_id
                  ,gene_symbol
                  ,gene_id
                  ,assay_id
                  ,normalized_value
                  ,concept_cd
                  ,timepoint
                  ,value
                  ,n_value as log_intensity
                  from deapp_wz.de_subject_rbm_data
                  where 1=2;

create table deapp_wz.tmp_subject_rbm_calcs as
               select trial_name
				,gene_symbol
				,antigen_name
				,log_intensity as mean_intensity
				,log_intensity as median_intensity
				,log_intensity as stddev_intensity
				from deapp_wz.tmp_subject_rbm_logs 
				where 1=2;


create table deapp_wz.tmp_subject_rbm_med as
				select trial_name
                    ,antigen_name
	                ,n_value
	                ,patient_id
                    ,gene_symbol
                    ,gene_id
	                ,assay_id
	                ,normalized_value
	                ,concept_cd
	                ,timepoint
                    ,log_intensity
	                ,value
                    ,log_intensity as mean_intensity
	                ,log_intensity as stddev_intensity
	                ,log_intensity as median_intensity
                    ,log_intensity as zscore
                   from deapp_wz.tmp_subject_rbm_logs
				   where 1=2;
				   
*/
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_REMOVE_ANALYSIS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_REMOVE_ANALYSIS" 
(
    etlID NUMBER,
    currentJobID NUMBER := null
)
AS
 --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  analysis_id number(18,0);
  E_ID number(18,0);

  sqlText	varchar2(1000);

  BEGIN
    E_ID := etlID;
    --Set Audit Parameters
    newJobFlag := 0; -- False (Default)
    jobID := currentJobID;

    SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
    procedureName := $$PLSQL_UNIT;

    --Audit JOB Initialization
    --If Job ID does not exist, then this is a single procedure run and we need to create it
    IF(jobID IS NULL or jobID < 1)
    THEN
        newJobFlag := 1; -- True
        cz_start_audit (procedureName, databaseName, jobID);
    END IF;

    stepCt := 0;
    --get etl_id
    SELECT bio_assay_analysis_id into analysis_id from BIOMART.BIO_ASSAY_ANALYSIS where ETL_ID_SOURCE = E_ID;

    --delete data from bio_assay_analysis_data
    DELETE from biomart.bio_assay_analysis_data where bio_assay_analysis_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data in bio_assay_analysis_data',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete data from bio_assay_analysis_data_tea
    DELETE from biomart.bio_assay_analysis_data_tea where bio_assay_analysis_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data in bio_assay_analysis_data_tea',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete data from bio_asy_analysis_dataset
    DELETE from biomart.bio_asy_analysis_dataset where bio_assay_analysis_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data in bio_assay_analysis_dataset',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete from bio_assay_analysis_EQTL
    DELETE from biomart.bio_assay_analysis_eqtl where bio_assay_analysis_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data in bio_assay_analysis_eqtl',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete from bio_assay_analysis_EXT
    DELETE from biomart.bio_assay_analysis_ext where bio_assay_analysis_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data in bio_assay_analysis_ext',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete from bio_assay_analysis_GWAS
	--	changed to drop partition
    DELETE from biomart.bio_assay_analysis_gwas where bio_assay_analysis_id=analysis_id;
	--sqlText := 'alter table biomart.bio_assay_analysis_gwas drop partition "' || to_char(analysis_id) || '"';
	--execute immediate(sqlText);
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data in bio_assay_analysis_gwas',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete from bio_asy_analysis_EQTL_TOP50
    DELETE from biomart.bio_asy_analysis_eqtl_top50 where bio_assay_analysis_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data in bio_asy_analysis_eqtl_top50',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete from bio_asy_analysis_gwas_top50
    DELETE from biomart.bio_asy_analysis_gwas_top50 where bio_assay_analysis_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing data in bio_asy_analysis_gwas_top50',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete from bio_data_observation
    DELETE from biomart.bio_data_observation where bio_data_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing metadata in bio_data_observation',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete from bio_data_platform
    DELETE from biomart.bio_data_platform where bio_data_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing metadata in bio_data_platform',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete from bio_data_disease
    DELETE from biomart.bio_data_disease where bio_data_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing metadata in bio_data_disease',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete from bio_assay_analysis
    DELETE from biomart.bio_assay_analysis where bio_assay_analysis_id=analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing metadata in bio_assay_analysis',SQL%ROWCOUNT,stepCt,'Done');
    commit;
    --delete from tm_lz.lz_src_analysis_metadata
    delete from lz_src_analysis_metadata where ETL_ID=etlID ;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Delete existing metadata in lz_src_study_metadata',SQL%ROWCOUNT,stepCt,'Done');
    commit;

    cz_write_audit(jobId,databaseName,procedureName,'End i2b2_remove_analysis',0,stepCt,'Done');
    stepCt := stepCt + 1;

    cz_end_audit(jobId, 'Success');
    EXCEPTION
    WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');

END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_RENAME_GWAS_ANALYSIS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_RENAME_GWAS_ANALYSIS" 
(
  study_id varchar2,
  old_name VARCHAR2,
  new_name VARCHAR2,
  currentJobID number:=null
)
AS

   
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  b_analysis_id number(18,0);
  etlid number(18,0);
  pExists        int;
  data_type VARCHAR(50);
  
  MULTIPLE_ANALYSES exception;
  ANALYSES_NOTFOUND exception;
  
BEGIN
 -------------------------------------------------------------
  --Rename the analysis name for a GWAS analyses
  -- HZ@20140128 - First Rev
  -------------------------------------------------------------
    
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
        
  stepCt := 0;

  
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_rename_GWAS_analysis',0,stepCt,'Done'); 
    
  if old_name != ''  or old_name != '%' or new_name != ''  or new_name != '%'
  then

    -- get the analysis_id from biomart.bio_assay_analysis table
    select count(*) into pExists from  biomart.bio_assay_analysis WHERE analysis_name=old_name and ETL_ID=study_id;
    
    if pExists>1 then
      raise MULTIPLE_ANALYSES;
    elsif pExists =0 then
      raise ANALYSES_NOTFOUND;
    end if;
     
    select bio_assay_analysis_id, ETL_ID_SOURCE, bio_assay_data_type into b_analysis_id, etlid, data_type 
      from biomart.bio_assay_analysis WHERE analysis_name=old_name and ETL_ID=study_id;
   
    -- update bio_asy_analysis_gwas_top50 if GWAS
    if data_type='EQTL' then
        update biomart.bio_asy_analysis_eQTL_TOP50 set analysis=new_name where bio_assay_analysis_id=b_analysis_id;
    else 
        update biomart.bio_asy_analysis_GWAS_TOP50 set analysis=new_name where bio_assay_analysis_id=b_analysis_id;
    end if;   
    
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Update bio_asy_analysis_GWAS/eQTL_top50',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;
    
    --Update bio_assay_analysis table
    update biomart.bio_assay_analysis set analysis_name=new_name WHERE bio_assay_analysis_id=b_analysis_id;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Update bio_assay_analysis ',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;
    
   
    --Update tm_lz.lz_src_analsis_metadata table
    update TM_LZ.LZ_SRC_ANALYSIS_METADATA 
      set ANALYSIS_NAME = new_name
      where
        ETL_ID=etlid;
    stepCt := stepCt + 1;
    cz_write_audit(jobId,databaseName,procedureName,'Update lz_src_analysis_metadata ',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;
  END IF;
  cz_write_audit(jobId,databaseName,procedureName,'End i2b2_rename_GWAS_analysis',0,stepCt,'Done');
  stepCt := stepCt + 1;

  cz_end_audit(jobId, 'Success');
  EXCEPTION
  when MULTIPLE_ANALYSES then
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Error: There are multiple analyses corresponding to '|| study_id || ':' || old_name,0,stepCt,'Done');    
        cz_error_handler (jobID, procedureName);
        cz_end_audit (jobID, 'FAIL');
  WHEN ANALYSES_NOTFOUND then
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,'Error: There is no analyses corresponding to '|| study_id || ':' || old_name,0,stepCt,'Done');    
        cz_error_handler (jobID, procedureName);
        cz_end_audit (jobID, 'FAIL');  
  WHEN OTHERS THEN
    --Handle errors.
    cz_error_handler (jobID, procedureName);
    --End Proc
    cz_end_audit (jobID, 'FAIL');
END;

/
--------------------------------------------------------
--  DDL for Procedure I2B2_RENAME_NODE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_RENAME_NODE" 
(
  trial_id varchar2,
  old_node VARCHAR2,
  new_node VARCHAR2,
  currentJobID number:=null
)
AS

   
  --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);
  
BEGIN
  -------------------------------------------------------------
  -- Add a tree node in I2b2
  -- KCR@20090519 - First Rev
  -- JEA@20090910 - Added update of concept_path and parent_concept_path in concept_counts, moved update of i2b2 c_dimcode and c_tooltip to be done
  --				at the same time as c_fullname
  -- JEA@20091029 - Update i2b2_secure and i2b2_tags
  -- JEA@20111223	Revised because trial name not necessarily part of path
	-- JEA@20120228	Added auditing
	-- JEA@20120517	Add \ to all replace to make sure only string as node name gets updated and not update if string part of node
  -------------------------------------------------------------
	
  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := currentJobID;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    	
  stepCt := 0;

  
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start i2b2_rename_node',0,stepCt,'Done'); 
	
  if old_node != ''  or old_node != '%' or new_node != ''  or new_node != '%'
  then

	--	Update concept_counts paths

	update concept_counts cc
      set CONCEPT_PATH = replace(cc.concept_path, '\' || old_node || '\', '\' || new_node || '\'),
	      parent_concept_path = replace(cc.parent_concept_path, '\' || old_node || '\', '\' || new_node || '\')
      where cc.concept_path in
		   (select cd.concept_path from concept_dimension cd
		    where cd.sourcesystem_cd = trial_id
              and cd.concept_path like '%' || old_node || '%');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update concept_counts with new path',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;
	
    --Update path in i2b2_tags
    update i2b2_tags t
      set path = replace(t.path, '\' || old_node || '\', '\' || new_node || '\')
      where t.path in
		   (select cd.concept_path from concept_dimension cd
		    where cd.sourcesystem_cd = trial_id
              and cd.concept_path like '%\' || old_node || '\%');
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update i2b2_tags with new path',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;
	
    --Update specific name
    --update concept_dimension
    --  set name_char = new_node
    --  where name_char = old_node
    --    and sourcesystem_cd = trial_id;

    --Update all paths
    update concept_dimension
      set CONCEPT_PATH = replace(concept_path, '\' || old_node || '\', '\' || new_node || '\')
	     ,name_char=decode(name_char,old_node,new_node,name_char)
      where
		sourcesystem_cd = trial_id
        and concept_path like '%\' || old_node || '\%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update concept_dimension with new path',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;



    --I2B2
    --Update specific name
    --update i2b2
    --  set c_name = new_node
    --  where c_name = old_node
    --    and c_fullname like '%' || trial_id || '%';

    --Update all paths, added updates to c_dimcode and c_tooltip instead of separate pass
    update i2b2
      set c_fullname = replace(c_fullname, '\' || old_node || '\', '\' || new_node || '\')
	  	 ,c_dimcode = replace(c_dimcode, '\' || old_node || '\', '\' || new_node || '\')
		 ,c_tooltip = replace(c_tooltip, '\' || old_node || '\', '\' || new_node || '\')
		 ,c_name = decode(c_name,old_node,new_node,c_name)
      where sourcesystem_cd = trial_id
        and c_fullname like '%\' || old_node || '\%';
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Update i2b2 with new path',SQL%ROWCOUNT,stepCt,'Done'); 

    COMMIT;

	--Update i2b2_secure to match i2b2
    --update i2b2_secure
    --  set c_fullname = replace(c_fullname, old_node, new_node)
	--  	 ,c_dimcode = replace(c_dimcode, old_node, new_node)
	--	 ,c_tooltip = replace(c_tooltip, old_node, new_node)
    --  where
    --    c_fullname like '%' || trial_id || '%';
    --COMMIT;
	
	i2b2_load_security_data(jobID);


  END IF;
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_SECURE_STUDY
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_SECURE_STUDY" 
(trial_id	varchar
,currentJobID NUMBER := null
)
AS
/*************************************************************************
* Copyright 2008-2012 Janssen Research and Development, LLC.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
******************************************************************/

	--Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);
	
	v_bio_experiment_id	number(18,0);
	pExists				int;
	TrialId				varchar2(100);

BEGIN

	TrialId := trial_id;
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := currentJobID;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
  
	stepCt := 0;
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Start ' || procedureName,0,stepCt,'Done');
	
	--	create security records in observation_fact
	
	i2b2_create_security_for_trial(TrialId, 'Y', jobID);
	
	--	load i2b2_secure
	
	i2b2_load_security_data(jobID);
	
	--	check if entry exists for study in bio_experiment
	
	select count(*) into pExists
	from biomart.bio_experiment
	where accession = TrialId;
	
	if pExists = 0 then
		insert into biomart.bio_experiment
		(title, accession, etl_id)
		select 'Metadata not available'
			  ,TrialId
			  ,'METADATA:' || TrialId
		from dual;
	    stepCt := stepCt + 1;
		cz_write_audit(jobId,databaseName,procedureName,'Insert trial/study into biomart.bio_experiment',SQL%ROWCOUNT,stepCt,'Done');
		commit;
	end if;
	
	select bio_experiment_id into v_bio_experiment_id
	from biomart.bio_experiment
	where accession = TrialId;
	
	insert into searchapp.search_secure_object
	(bio_data_id
	,display_name
	,data_type
	,bio_data_unique_id
	)
	select v_bio_experiment_id
	      ,parse_nth_value(md.c_fullname,2,'\') || ' - ' || md.c_name as display_name
		  ,'BIO_CLINICAL_TRIAL' as data_type
		  ,'EXP:' || TrialId as bio_data_unique_id
	from i2b2metadata.i2b2 md
	where md.sourcesystem_cd = TrialId
	  and md.c_hlevel = 
		 (select min(x.c_hlevel) from i2b2metadata.i2b2 x
		  where x.sourcesystem_cd = TrialId)
	  and not exists
		 (select 1 from searchapp.search_secure_object so
		  where v_bio_experiment_id = so.bio_data_id);
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'Inserted trial/study into SEARCHAPP search_secure_object',SQL%ROWCOUNT,stepCt,'Done');
	commit;
		
	stepCt := stepCt + 1;
	cz_write_audit(jobId,databaseName,procedureName,'End ' || procedureName,SQL%ROWCOUNT,stepCt,'Done');
	commit;
	
    ---Cleanup OVERALL JOB if this proc is being run standalone
	IF newJobFlag = 1
	THEN
		cz_end_audit (jobID, 'SUCCESS');
	END IF;

	EXCEPTION
	WHEN OTHERS THEN
		--Handle errors.
		cz_error_handler (jobID, procedureName);
		
		--End Proc
		cz_end_audit (jobID, 'FAIL');
	
END;
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_SHOW_NODE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_SHOW_NODE" 
(
  path VARCHAR2
)
AS
BEGIN
  
  -------------------------------------------------------------
  -- Shows a tree node in I2b2
  -- KCR@20090519 - First Rev
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 

      --I2B2
    UPDATE i2b2
      SET c_visualattributes = 'FA'
    WHERE c_visualattributes LIKE 'F%'
      AND C_FULLNAME LIKE PATH || '%';

     UPDATE i2b2
      SET c_visualattributes = 'LA'
    WHERE c_visualattributes LIKE 'L%'
      AND C_FULLNAME LIKE PATH || '%';
    COMMIT;
  END IF;
  
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_TABLE_BKP
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_TABLE_BKP" 
AS
BEGIN
  
  -------------------------------------------------------------
  -- Backup the I2B2 tables.
  -- KCR@20090518 - First Rev
  -------------------------------------------------------------
  --Drop existing backups
  
  execute immediate('drop table i2b2metadata.i2b2_bkp');
  execute immediate('drop table i2b2demodata.concept_counts_bkp');
  execute immediate('drop table i2b2demodata.concept_dimension_bkp');
  execute immediate('drop table i2b2demodata.observation_fact_bkp');
  execute immediate('drop table i2b2demodata.patient_dimension_bkp');

  --Backup tables
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2METADATA.I2B2_BKP AS SELECT * FROM I2B2METADATA.I2B2';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.CONCEPT_COUNTS_BKP AS SELECT * FROM I2B2DEMODATA.CONCEPT_COUNTS';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.CONCEPT_DIMENSION_BKP AS SELECT * FROM I2B2DEMODATA.CONCEPT_DIMENSION';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.OBSERVATION_FACT_BKP AS SELECT * FROM I2B2DEMODATA.OBSERVATION_FACT';
  EXECUTE IMMEDIATE 'CREATE TABLE I2B2DEMODATA.PATIENT_DIMENSION_BKP AS SELECT * FROM I2B2DEMODATA.PATIENT_DIMENSION';
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_TABLE_DEFRAG
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_TABLE_DEFRAG" 
AS
BEGIN
  
  -------------------------------------------------------------
  -- Moves the I2B2 tables to reduce defragmentation
  -- KCR@20090527 - First Rev
  -- JEA@20090923 - Removed I2B2DEMODATA.IDX_OB_FACT_3, Oracle doesn't need to index every column like SQL Server (per Aaron A.)
  -------------------------------------------------------------
  EXECUTE IMMEDIATE 'ALTER TABLE I2B2METADATA.I2B2 MOVE';
  EXECUTE IMMEDIATE 'ALTER TABLE I2B2DEMODATA.CONCEPT_COUNTS MOVE';
  EXECUTE IMMEDIATE 'ALTER TABLE I2B2DEMODATA.CONCEPT_DIMENSION MOVE';
  EXECUTE IMMEDIATE 'ALTER TABLE I2B2DEMODATA.OBSERVATION_FACT MOVE';
  EXECUTE IMMEDIATE 'ALTER TABLE I2B2DEMODATA.PATIENT_DIMENSION MOVE';
  --Rebuild Indexes
  EXECUTE IMMEDIATE 'ALTER INDEX I2B2DEMODATA.OB_FACT_PK REBUILD';
  EXECUTE IMMEDIATE 'ALTER INDEX I2B2DEMODATA.IDX_OB_FACT_1 REBUILD';
  EXECUTE IMMEDIATE 'ALTER INDEX I2B2DEMODATA.IDX_OB_FACT_2 REBUILD';  
  
  EXECUTE IMMEDIATE 'ALTER INDEX I2B2DEMODATA.IDX_CONCEPT_DIM_1 REBUILD';
  EXECUTE IMMEDIATE 'ALTER INDEX I2B2DEMODATA.IDX_CONCEPT_DIM_2 REBUILD';
  
  EXECUTE IMMEDIATE 'ALTER INDEX I2B2METADATA.IDX_I2B2_A REBUILD';
  EXECUTE IMMEDIATE 'ALTER INDEX I2B2METADATA.IDX_I2B2_B REBUILD';

  EXECUTE IMMEDIATE 'ALTER INDEX I2B2DEMODATA.CONCEPT_COUNTS_INDEX1 REBUILD';

END;

 

 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_TRUNCATE_RELEASE_TABLES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_TRUNCATE_RELEASE_TABLES" 

AS
	--	Procedure to run one test in CZ_TEST
	
	--	JEA@20111019	New

	--	Define the abstract result set record
	
	TYPE r_type IS RECORD (
		rtn_text          VARCHAR2 (2000)
	);
	
	--	Define the abstract result set table
	TYPE tr_type IS TABLE OF r_type;

	--	Define the result set
	
	rtn_array tr_type;

	--	Variables

	tText 			varchar2(2000);
	
    --Audit variables
	newJobFlag INTEGER(1);
	databaseName VARCHAR(100);
	procedureName VARCHAR(100);
	jobID number(18,0);
	stepCt number(18,0);
	
	BEGIN	
	
	--Set Audit Parameters
	newJobFlag := 0; -- False (Default)
	jobID := -1;

	SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
	procedureName := $$PLSQL_UNIT;

	--Audit JOB Initialization
	--If Job ID does not exist, then this is a single procedure run and we need to create it
	IF(jobID IS NULL or jobID < 1)
	THEN
		newJobFlag := 1; -- True
		cz_start_audit (procedureName, databaseName, jobID);
	END IF;
    	
	stepCt := 0;	
	cz_write_audit(jobId,databaseName,procedureName,'Starting i2b2_truncate_release_tablese',0,stepCt,'Done');
	stepCt := stepCt + 1;
	
	tText := 'Select table_name from all_tables where owner = ' || '''' || 'TM_CZ' || '''' || 'and table_name like ' || '''' || '%_RELEASE' || '''';

	execute immediate(tText) BULK COLLECT INTO rtn_array;
      
	for i in rtn_array.first .. rtn_array.last
	loop
		dbms_output.put_line(rtn_array(i).rtn_text);
			
		if (rtn_array(i).rtn_text is not null) then
			tText := 'truncate table ' || rtn_array(i).rtn_text;
			
			execute immediate(tText);
			tText := 'Truncated ' || rtn_array(i).rtn_text;
			
			cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
		
		end if;
			
	end loop;
	
	cz_write_audit(jobId,databaseName,procedureName,'End i2b2_truncate_release_tablese',0,stepCt,'Done');
	stepCt := stepCt + 1;
	
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure I2B2_UNHIDE_NODE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."I2B2_UNHIDE_NODE" 
(
  path VARCHAR2
)
AS
BEGIN
  
  -------------------------------------------------------------
  -- hIDES a tree node in I2b2
  -- KCR@20090519 - First Rev
  -- JEA@20120404	Only update second character of c_visualattributes
  -------------------------------------------------------------
  if path != ''  or path != '%'
  then 
  
	update i2b2 b
	set c_visualattributes=substr(b.c_visualattributes,1,1) || 'A' || substr(b.c_visualattributes,3,1)
	where c_fullname like path || '%';
	commit;
	
	i2b2_create_concept_counts(path);
	
	
/*
      --I2B2
     UPDATE i2b2
      SET c_visualattributes = 'FH'
    WHERE c_visualattributes like 'F%'
      AND C_FULLNAME LIKE PATH || '%';

     UPDATE i2b2
      SET c_visualattributes = 'LH'
    WHERE c_visualattributes like 'L%'
      AND C_FULLNAME LIKE PATH || '%';
    COMMIT;
*/
  END IF;
  
END;
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure LOAD_CENTCLIN_CONTENT_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."LOAD_CENTCLIN_CONTENT_DATA" 
as
begin

begin

  delete from biomart_wz.bio_content_reference
    ;

  delete from biomart_wz.bio_content
    where repository_id = 
      (select bio_content_repo_id
      from biomart_wz.bio_content_repository
      where location = '\\JJHOST2\share\data\ClinicalTrials');
    
  delete from biomart_wz.bio_content_repository
    where lower(location) = '\\jjhost2\share\data\clinicaltrials';

commit;
end;

begin
-- populate bio_content_repository

  insert into biomart_wz.bio_content_repository(
    location
  , active_y_n
  , repository_type
  , location_type
  )
  values (
    '\\JJHOST2\share\data\ClinicalTrials'
  , 'Y'
  , 'Clinical Trials'
  , 'Data'
  );
  
commit;
end;

begin

  insert into biomart_wz.bio_content(
    file_name
  , repository_id
  , location
  --, title  , abstract
  , file_type
  --, etl_id
  )
  select distinct
    ec.file_name
  , bcr.bio_content_repo_id
  , ec.file_path
  , 'Data'
  from 
    centclinrd.externalcontent ec
  , biomart_wz.bio_content_repository bcr
  where bcr.location='\\JJHOST2\share\data\ClinicalTrials';
  
commit;
end;

begin

  insert into biomart_wz.bio_content_reference(
    bio_content_id
  , bio_data_id
  , content_reference_type
  )
  select distinct
    bc.bio_file_content_id
  , baa.bio_assay_analysis_id
  , bcr.location_type
  from
    biomart_wz.bio_content bc
  , biomart_wz.bio_assay_analysis baa
  , biomart_wz.bio_content_repository bcr
  , centclinrd.geneexpressionanalysiscontent geac
  , centclinrd.externalcontent ec
  where bc.repository_id = bcr.bio_content_repo_id
  and baa.etl_id = 'GEAC.'||to_char(geac.id)
  and geac.id = ec.id
  and ec.file_name = bc.file_name;
  
  --143 with GEAC in bio_assay_analysis

  
commit;
end;


end;
 

 
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure LOAD_DISEASE_UID
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."LOAD_DISEASE_UID" 
AS
  --initiate variables for Job run and step ID's
  jobRunID CONTROL.AZ_JOB_RUN.JOB_RUN_ID%TYPE;
  jobStepID CONTROL.CZ_JOB_STEP.JOB_STEP_ID%TYPE;
BEGIN
  -------------------------------------------------------------------------------
  -- Loads Disease UID Data
  -- KCR@20090331 - First rev
  -------------------------------------------------------------------------------
  --Start ETL Control: Create a Job Run
  jobRunID := control.insert_etl_job_run('DIS:UID', 0, 'KRUSSELL', 'Loads UID data for Concept Disease', 'ADHOC', 'DISEASE');
  
  BEGIN
    --Delete existing data
		DELETE 
			FROM BIO_DATA_UID 
			WHERE BIO_DATA_TYPE = 'BIO_DISEASE';

    COMMIT;  

  END;

  BEGIN --LOAD BIO_DATA_ANALYSIS TABLE
    --Insert Job Run Info
    jobStepID := control.insert_etl_job_step(jobRunID, 'LoadDiseaseUID', 'Loading Disease UID Data', 'BIO_DATA_UID', 'INSERT', 0); 
  
  
    -- Add UIDs for diseases
    insert into bio_data_uid (
      bio_data_id,
      unique_id,
      bio_data_type
    )
    select
      bio_disease_id,
      bio_disease_uid(MESH_CODE),
      'BIO_DISEASE'
    from
      bio_disease;
    --END step: Update Step Run with TIME/STATUS
    control.UPDATE_ETL_JOB_STEP_PASS(jobStepID, 'BIO_DATA_UID',SQL%ROWCOUNT);
    COMMIT;
  END; --LOAD BIO_DATA_ANALYSIS TABLE
  
  --END ETL CONTROL: Update Job Run with TIME/STATUS
  control.UPDATE_ETL_JOB_RUN_PASS(jobRunID);
EXCEPTION
  WHEN OTHERS THEN
    control.UPDATE_ETL_JOB_STEP_FAIL(jobStepID, SQLCODE, SQLERRM(), DBMS_UTILITY.FORMAT_ERROR_STACK, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
    control.UPDATE_ETL_JOB_RUN_FAIL(jobRunID);
    --RAISE;
END;
  

 
 

 

 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure LOAD_JUB_TARGET_SUM_FROM_DB
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."LOAD_JUB_TARGET_SUM_FROM_DB" 
AS
  --initiate variables for Job run and step ID's
  --jobRunID CONTROL.SYSTEM_JOB_RUN.JOB_RUN_ID%TYPE;
  --jobStepID CONTROL.SYSTEM_JOB_STEP.JOB_STEP_ID%TYPE;

BEGIN
  -------------------------------------------------------------------------------
  -- Loads Jubilant Summary Data from the Jubilant DB received on 3/2009
  -- KCR@20090324 - First rev.
  -------------------------------------------------------------------------------
  --Start ETL Control: Create a Job Run
  --jobRunID := control.insert_system_job_run('LoadCCJubilantTargetSummaryData','Load Jubilant Target Summary data from CentClinRD');

  BEGIN
    
    --Delete
--    DELETE 
--      FROM BIO_CURATED_DATA
--      WHERE BIO_CURATION_DATASET_ID IN
--        (SELECT BIO_CURATION_DATASET_ID
--          FROM BIO_CURATION_DATASET
--            BIO_CURATION_NAME = 'Jubilant DB from March 2009');

    DELETE 
      FROM BIO_DATA_UID
      WHERE BIO_DATA_TYPE = 'BIO_JUB_ONC_SUM_DATA'
        AND UNIQUE_ID LIKE '5-%';
    
    
    DELETE 
      FROM BIO_JUB_ONC_SUM_DATA
      WHERE UNIQUE_ID LIKE '5-%';    
    
    COMMIT;
  END;

  BEGIN
  	--Insert Job Run Info
    --jobStepID := control.insert_system_job_step(jobRunID, 'Insert to BIO_JUB_ONCOL_DATA', 'Inserting Jubilant Target Summary Data from CentClinRD', 915); 

    --Loading Target table
    INSERT INTO 
      BIO_JUB_ONC_SUM_DATA 
        (DATATYPE, 
        ALTERATION_TYPE, 
        TOTAL_FREQUENCY, 
        TOTAL_AFFECTED_CASES, 
        TARGET_NAME, 
        VARRIANT_NAME, 
        DISEASE_SITE_NAME, 
        TOTAL_NUMERATOR, 
        TOTAL_DENOMINATOR,
        UNIQUE_ID) 
    SELECT 
      DATA_TYPE, 
      ALTERATION_TYPE, 
      TOTAL_FREQUENCY, 
      TOTAL_AFFECTED_CASES, 
      TARGET_NAME, 
      VARRIANT_NAME, 
      DISEASE_SITE_NAME, 
      TOTAL_NUMERATOR, 
      TOTAL_DENOMINATOR,
      '5-' || rownum
    FROM jbl_jwb.TEMP_DISEASE_SUMMARY;

    --control.UPDATE_SYSTEM_JOB_STEP_PASS(jobStepID, SQL%ROWCOUNT);
    COMMIT;        

  END; 

  BEGIN
  	--Insert Job Run Info
    --jobStepID := control.insert_system_job_step(jobRunID, 'Insert to BIO_DATA_UID', 'Inserting UID data for Jubilant Target Summary Data', 915); 

    --INSERT THE UID FOR THIS TYPE.
    INSERT INTO 
      BIO_DATA_UID 
        (BIO_DATA_ID, 
        UNIQUE_ID, 
        BIO_DATA_TYPE) 
    SELECT
      BIO_DATA_ID,
      unique_id,
      'BIO_JUB_ONC_SUM_DATA'
    FROM BIO_JUB_ONC_SUM_DATA
    WHERE
      UNIQUE_ID LIKE '5-%';

    --control.UPDATE_SYSTEM_JOB_STEP_PASS(jobStepID, SQL%ROWCOUNT);
    COMMIT;        

  END; 

  BEGIN
  	--Insert Job Run Info
    --jobStepID := control.insert_system_job_step(jobRunID, 'Insert to BIO_CURATED_DATA', 'Inserting Jubilant Target Summary Data to the Curated Data table.', 915); 

    --BIO_CURATED DATA
    INSERT INTO 
      BIO_CURATED_DATA
        (BIO_DATA_ID, 
        BIO_CURATION_DATASET_ID,
        DATA_TYPE) 
      SELECT 
        a.bio_data_id,
        b.BIO_CURATION_DATASET_ID,
        'JUBILANT_ONCOLOGY_SUMMARY'
      FROM BIO_JUB_ONC_SUM_DATA a, 
        BIO_CURATION_DATASET b
      where 
        BIO_CURATION_NAME = 'Jubilant DB from March 2009'
        AND a.UNIQUE_ID LIKE '5-%';
        
    --control.UPDATE_SYSTEM_JOB_STEP_PASS(jobStepID, SQL%ROWCOUT);
    COMMIT;        

  END; 
  
  --END ETL CONTROL: Update Job Run with TIME/STATUS
--  control.UPDATE_SYSTEM_JOB_RUN_PASS(jobRunID);
--  EXCEPTION
--  WHEN OTHERS THEN
--    control.UPDATE_SYSTEM_JOB_STEP_FAIL(jobStepID, SQLCODE, SQLERRM(), DBMS_UTILITY.FORMAT_ERROR_STACK, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
--    control.UPDATE_SYSTEM_JOB_RUN_FAIL(jobRunID);
    --RAISE;
END;
 
 
 
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure LOAD_KEGG_COMP_PATH_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."LOAD_KEGG_COMP_PATH_DATA" 
as
  --jobRunID CONTROL.SYSTEM_JOB_RUN.JOB_RUN_ID%TYPE;
  --jobStepID CONTROL.SYSTEM_JOB_STEP.JOB_STEP_ID%TYPE;
--CREATE SYNONYM kegg_compound_name FOR PICTOR.kegg_compound_name;
--CREATE SYNONYM kegg_compound_xref FOR PICTOR.kegg_compound_xref;

BEGIN
--------------------------------------------------------------------------------
-- Loads data from PICTOR into biomart_LZ
--  emt@20090324
--------------------------------------------------------------------------------
  --jobrunid := control.insert_system_job_run('LoadPictorPathways', 'Load All Pathways from Pictor -- KEGG');
  
  begin
  --delete residual kegg records from the target tables
  -- NOTE: this delete statement deletes both pathways and genes
    delete from bio_marker
      where primary_source_code='KEGG';
    
    commit;
  end;
  
  begin

    --jobStepID := control.insert_system_job_step(jobRunID, 'Insert compound pathways into bio_marker for KEGG compound pathways'    
  --, 'Insert compound pathways into bio_marker for KEGG compound pathways', 22);
  
    insert into bio_marker(
      bio_marker_name
    , bio_marker_description
    , organism
    , primary_source_code
    , primary_external_id
    , bio_marker_type)
    select distinct
      kd.description
    , kd.description
    , upper(tax.taxonomy_name)
    , 'KEGG'
    , kd.map_id
    , 'PATHWAY'
    from 
      pictor.kmap_desc kd
    , pictor.taxonomy tax
    where kd.taxonomy_id = tax.taxonomy_id;
    --806
  --control.update_system_job_step_pass(jobStepID, SQL%ROWCOUNT);
  
  commit;
  end;
  
    begin

    --jobStepID := control.insert_system_job_step(jobRunID, 'Insert pathway genes  into bio_marker for KEGG compound pathways'    
  --, 'Insert pathway genes into bio_marker for KEGG compound pathways', 22);
 -- insert genes from kmap_gene that are not already in bio_marker

    insert into bio_marker(
      bio_marker_name
    , bio_marker_description
    , organism
    --, primary_source_code
    , primary_external_id
    , bio_marker_type)
    select distinct
      agi.gene_symbol
    , agi.description
    , upper(tn.name)
    , agi.gene_id
    , 'GENE'
    from 
      pictor.kmap_gene kg
    , pictor.kmap_desc kd
    , reference.ext_all_gene_info agi
    , reference.taxonomy_names tn
    , pictor.taxonomy tax
    where kg.map_id = kd.map_id
    and kd.taxonomy_id = tax.taxonomy_id
    and kg.gene_id = agi.gene_id
    and agi.tax_id = tn.tax_id
    and tn.tax_id = tax.taxonomy_id
    and to_char(kg.gene_id) not in 
      (select primary_external_id from bio_marker
      WHERE bio_marker.bio_marker_type='GENE');
      --14,413 new - this should be 0 subsequently
  --control.update_system_job_step_pass(jobStepID, SQL%ROWCOUNT);
  
  commit;
  end;
 
  begin                                                
    --jobStepID := control.insert_system_job_step(jobRunID, 'Insert disease pathways into bio_marker for KEGG compound pathways'    
  --, 'Insert disease pathways into bio_marker for KEGG compound pathways', 22);

    insert into bio_data_correlation(
      bio_data_id
    , asso_bio_data_id
    , bio_data_correl_descr_id
    )
    select distinct
      path.bio_marker_id
    , gene.bio_marker_id
    , bdcd.bio_data_correl_descr_id
    from 
      bio_marker path
    , bio_marker gene
    , pictor.kmap_gene kg
    , bio_data_correl_descr bdcd
    where path.bio_marker_type = 'PATHWAY'
    and gene.bio_marker_type = 'GENE' 
    and path.primary_external_id = to_char(kg.map_id)
    and gene.primary_external_id = to_char(kg.gene_id)
    and bdcd.correlation='PATHWAY GENE';
    -- 42,826
-- 43,075 distinct map, gene, tax 
-- 305 genes that are not in ext_gene_id
-- 4,794 genes are human
-- 1 that is not human: rat, geneid 5212, pancreatic cancer
-- 14,529 not in bio_marker and not human
        
    --control.update_system_job_step_pass(jobStepID, SQL%ROWCOUNT);
  commit;
  end;

end;
 
 
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure LOAD_KEGG_CONTENT_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."LOAD_KEGG_CONTENT_DATA" 
as
begin

begin

  delete from bio_content_reference
    where bio_content_id in 
      (select bio_file_content_id
      from bio_content
      where repository_id in 
        (select bio_content_repo_id
        from bio_content_repository
        where upper(repository_type)='KEGG')
      );
  --806
  delete from bio_content
    where repository_id = 
      (select bio_content_repo_id
      from bio_content_repository
      where upper(repository_type)='KEGG');
  --806  
  delete from bio_content_repository
    where upper(repository_type)='KEGG';
  --1
commit;
end;

begin
-- populate bio_content_repository
  insert into bio_content_repository(
    location
  , active_y_n
  , repository_type
  , location_type
  )
  values (
    'http://www.genome.jp/'
  , 'Y'
  , 'Kegg'
  , 'URL'
  );
commit;
end;

begin

  insert into bio_content(
  --  file_name
    repository_id
  , location
  --, title  , abstract
  , file_type
  --, etl_id
  )
  select distinct
    bcr.bio_content_repo_id
  , bcr.location||'dbget-bin/show_pathway?'|| bm.primary_external_id
  , 'Data'
  from 
    bio_content_repository bcr
  , bio_marker bm
  where upper(bcr.repository_type)='KEGG'
  and upper(bm.primary_source_code)='KEGG';
  --806 rows inserted
commit;
end;

begin

  insert into bio_content_reference(
    bio_content_id
  , bio_data_id
  , content_reference_type
  )
  select distinct
    bc.bio_file_content_id
  , path.bio_marker_id
  , bcr.location_type
  from
    bio_content bc
  , bio_marker path
  , bio_content_repository bcr
  where bc.repository_id = bcr.bio_content_repo_id
  and path.primary_external_id=substr(bc.location, length(bc.location)-7)
  and path.primary_source_code='KEGG';
  --806
commit;
end;


end;
 
 
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure PARSE_DESIGN_FIELD
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARSE_DESIGN_FIELD" 
as
  
  bcc_exp number;

  design_fields varchar_table;
  
  cursor c_design
  is
  select bio_experiment_id, design from bio_experiment
  where bio_experiment_type='Experiment'
  and design is not null;

begin

  begin
    delete from bio_data_attribute
      where bio_data_id in 
        (select bio_experiment_id 
        from bio_experiment
        where bio_experiment.bio_experiment_type='Experiment'
        and design is not null);
   end;

  begin
    insert into bio_concept_code(
      bio_concept_code
    , code_description
    , code_type_name
    )
    select 
      'Experiment Design'
    , 'Experiment Design'
    , 'Design'
    from dual
    where not exists
      (select 1 from bio_concept_code
      where bio_concept_code='Experiment Design');
  commit;
  end;
  
  begin
  
    select bio_concept_code_id 
    into bcc_exp
    from bio_concept_code
    where bio_concept_code = 'Experiment Design';
    
    design_fields := control.varchar_table();
    
    for r_design in c_design loop    
      design_fields := control.text_parser(r_design.design, ',');
      for i in design_fields.first..design_fields.last loop
        insert into bio_data_attribute(
          bio_data_id
        , property_code
        , property_value
        )
        select
          r_design.bio_experiment_id
        , bcc_exp
        , ltrim(upper(replace(design_fields(i), '_', ' ')))
        from dual
        where r_design.bio_experiment_id not in (
          select bio_data_id from bio_data_attribute
          where property_code=bcc_exp
          and property_value=ltrim(upper(replace(design_fields(i), '_', ' '))));
            
      end loop;
    
    end loop;
  
  commit;
  end;
end;
 
 
 
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure PARTITION_GWAS_DATA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."PARTITION_GWAS_DATA" 
AS

  sqlText                varchar2(1000);
  tText                        varchar2(1000);
  pExists                number;
  
    --Audit variables
  newJobFlag INTEGER(1);
  databaseName VARCHAR(100);
  procedureName VARCHAR(100);
  jobID number(18,0);
  stepCt number(18,0);

BEGIN

  --Set Audit Parameters
  newJobFlag := 0; -- False (Default)
  jobID := -1;

  SELECT sys_context('USERENV', 'CURRENT_SCHEMA') INTO databaseName FROM dual;
  procedureName := $$PLSQL_UNIT;

  --Audit JOB Initialization
  --If Job ID does not exist, then this is a single procedure run and we need to create it
  IF(jobID IS NULL or jobID < 1)
  THEN
    newJobFlag := 1; -- True
    cz_start_audit (procedureName, databaseName, jobID);
  END IF;
    
       -- for gwas_data in (select distinct bio_assay_analysis_id from biomart.bio_assay_analysis_gwas )
     for gwas_data in (select distinct bio_assay_analysis_id from tm_cz.temp )
     loop

                stepCt := 0;
                stepCt := stepCt + 1;
                tText := 'Starting load for ' || to_char(gwas_data.bio_assay_analysis_id);
                cz_write_audit(jobId,databaseName,procedureName,tText,0,stepCt,'Done');
                
                --        Create partition in gwas_partition if it doesn't exist else truncate partition
                
                select count(*)
                        into pExists
                        from all_tab_partitions
                        where table_name = 'GWAS_PARTITION'
                          and partition_name = to_char(gwas_data.bio_assay_analysis_id);
                
                if pExists = 0 then                                
                        --        needed to add partition to GWAS_PARTITION

                        sqlText := 'alter table biomart.GWAS_PARTITION add PARTITION "' || to_char(gwas_data.bio_assay_analysis_id) || '"  VALUES (' || 
                                           to_char(gwas_data.bio_assay_analysis_id) || ') ' ||
                                                   'NOLOGGING TABLESPACE "BIOMART" ';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Adding partition to GWAS_PARTITION',0,stepCt,'Done');
                        
                else
                        sqlText := 'alter table biomart.GWAS_PARTITION truncate partition "' || to_char(gwas_data.bio_assay_analysis_id) || '"';
                        execute immediate(sqlText);
                        stepCt := stepCt + 1;
                        cz_write_audit(jobId,databaseName,procedureName,'Truncating partition in GWAS_PARTITION',0,stepCt,'Done');
                end if;

                insert into biomart.GWAS_PARTITION
                (bio_asy_analysis_gwas_id
                ,bio_assay_analysis_id
                ,rs_id
                ,p_value_char
                ,p_value
                ,log_p_value
                ,etl_id
                ,ext_data
                )
                select g.bio_asy_analysis_gwas_id
                          ,g.bio_assay_analysis_id
                          ,g.rs_id
                          ,g.p_value_char
                          ,g.p_value
                          ,g.log_p_value
                          ,g.etl_id
                          ,g.ext_data
                from biomart.bio_assay_analysis_gwas g
                where g.bio_assay_analysis_id = gwas_data.bio_assay_analysis_id; 
                stepCt := stepCt + 1;
                cz_write_audit(jobId,databaseName,procedureName,'Insert data for analysis into GWAS_PARTITION',SQL%ROWCOUNT,stepCt,'Done');        
                commit;
                
        end loop;
        
           ---Cleanup OVERALL JOB if this proc is being run standalone
        
        stepCt := stepCt + 1;
        cz_write_audit(jobId,databaseName,procedureName,procedureName,0,stepCt,'Done');

        IF newJobFlag = 1
        THEN
                cz_end_audit (jobID, 'SUCCESS');
        END IF;

        EXCEPTION
        WHEN OTHERS THEN
                --Handle errors.
                cz_error_handler (jobID, procedureName);
                --End Proc
                cz_end_audit (jobID, 'FAIL');
                --select 16 into rtn_code from dual;
END;

/
--------------------------------------------------------
--  DDL for Procedure SET_BIO_DATA_UID_DIS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."SET_BIO_DATA_UID_DIS" 
as
  --jobRunID CONTROL.SYSTEM_JOB_RUN.JOB_RUN_ID%TYPE;
  --jobStepID CONTROL.SYSTEM_JOB_STEP.JOB_STEP_ID%TYPE;
--CREATE SYNONYM genego for pictor.genego;
BEGIN

-------------------------------------------------------------------------------
-- Loads data from PICTOR into biomart_LZ
--  emt@20090310
--------------------------------------------------------------------------------
--  jobrunid := control.insert_system_job_run('LoadGeneGOPathways', 'Load All Pathways from GENEGO in PICTOR');

begin

  --jobStepID := control.insert_system_job_step(jobRunID, 'Insert disease pathways into bio_marker for GENEGO disease pathways'    
  --, 'Insert disease pathways into bio_marker for GENEGO disease pathways', 22);
  execute immediate 'delete from bio_data_uid where unique_id in 
                    (select bio_disease_uid(mesh_code) from bio_disease)';
  execute immediate 'insert into bio_data_uid( 
                    bio_data_id, unique_id, bio_data_type)
                    select 
                    bio_disease_id, bio_disease_uid(mesh_code), ''BIO_DISEASE''
                    from bio_disease
                    where not exists 
                      (select 1 from bio_data_uid 
                      where bio_disease_uid(bio_disease.mesh_code) = bio_data_uid.unique_id)';

  --control.update_system_job_step_pass(jobStepID, SQL%ROWCOUNT);
  commit;

end;  
/*
control.update_system_job_run_pass(jobRunID);
exception
when others then
  control.update_system_job_step_fail(jobStepID, sqlcode, sqlerrm()
  , dbms_utility.format_error_stack, dbms_utility.format_error_backtrace);
  control.update_system_job_run_fail(jobRunID);
  */
end;
 
 
 
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure SET_BIO_DATA_UID_PATH
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."SET_BIO_DATA_UID_PATH" 
as
 -- jobRunID CONTROL.SYSTEM_JOB_RUN.JOB_RUN_ID%TYPE;
 -- jobStepID CONTROL.SYSTEM_JOB_STEP.JOB_STEP_ID%TYPE;
--CREATE SYNONYM genego for pictor.genego;
BEGIN

-------------------------------------------------------------------------------
-- Loads data from PICTOR into biomart_LZ
--  emt@20090310
--------------------------------------------------------------------------------
  --jobrunid := control.insert_system_job_run('LoadGeneGOPathways', 'Load All Pathways from GENEGO in PICTOR');



  --jobStepID := control.insert_system_job_step(jobRunID, 'Insert disease pathways into bio_marker for GENEGO disease pathways'    
  --, 'Insert disease pathways into bio_marker for GENEGO disease pathways', 22);
  execute immediate 'delete from bio_data_uid where unique_id in 
                    (select biomarker_pathway_uid(primary_source_code, primary_external_id)
                    from bio_marker)';
  execute immediate 'delete from bio_data_uid where unique_id in 
                    (select biomarker_gene_uid(primary_external_id)
                    from bio_marker)';
  execute immediate 'insert into bio_data_uid( 
                    bio_data_id, unique_id, bio_data_type)
                    select 
                    bio_marker_id
                    , biomarker_pathway_uid(primary_source_code, primary_external_id)
                    , ''BIO_MARKER.PATHWAY''
                    from bio_marker
                    where bio_marker_type=''PATHWAY''
                    and not exists 
                      (select 1 from bio_data_uid 
                      where biomarker_pathway_uid(bio_marker.primary_source_code, bio_marker.primary_external_id) = 
                      bio_data_uid.unique_id)';
  execute immediate 'insert into bio_data_uid(
                    bio_data_id, unique_id, bio_data_type)
                    select
                    bio_marker_id
                    , biomarker_gene_uid(primary_external_id)
                    , ''BIO_MARKER.GENE''
                    from bio_marker
                    where bio_marker_type=''GENE''
                    and not exists
                      (select 1 from bio_data_uid
                      where biomarker_gene_uid(bio_marker.primary_external_id) = bio_data_uid.unique_id)';


  --control.update_system_job_step_pass(jobStepID, SQL%ROWCOUNT);
  commit;


--control.update_system_job_run_pass(jobRunID);
--exception
--when others then
  --control.update_system_job_step_fail(jobStepID, sqlcode, sqlerrm()
  --, dbms_utility.format_error_stack, dbms_utility.format_error_backtrace);
  --control.update_system_job_run_fail(jobRunID);
end;
 
 
 
 
 
 
 
 
 

/
--------------------------------------------------------
--  DDL for Procedure TM_CZ.CZ_WRITE_AUDIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."TM_CZ.CZ_WRITE_AUDIT" 
(
	jobId IN NUMBER,
	databaseName IN VARCHAR2 , 
	procedureName IN VARCHAR2 , 
	stepDesc IN VARCHAR2 , 
	recordsManipulated IN NUMBER,
	stepNumber IN NUMBER,
	stepStatus IN VARCHAR2
)
AS
  lastTime timestamp;
BEGIN
  select max(job_date)
    into lastTime
    from cz_job_audit
    where job_id = jobID;

	insert 	into cz_job_audit(
		job_id, 
		database_name,
 		procedure_name, 
 		step_desc, 
		records_manipulated,
		step_number,
		step_status,
    job_date,
    time_elapsed_secs
	)
	select
 		jobId,
		databaseName,
		procedureName,
		stepDesc,
		recordsManipulated,
		stepNumber,
		stepStatus,
    SYSTIMESTAMP,
      COALESCE(
      EXTRACT (DAY    FROM (SYSTIMESTAMP - lastTime))*24*60*60 + 
      EXTRACT (HOUR   FROM (SYSTIMESTAMP - lastTime))*60*60 + 
      EXTRACT (MINUTE FROM (SYSTIMESTAMP - lastTime))*60 + 
      EXTRACT (SECOND FROM (SYSTIMESTAMP - lastTime))
      ,0)
  from dual;
  
  COMMIT;

END;

/
--------------------------------------------------------
--  DDL for Procedure UTIL_CREATE_SYNONYM_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_CREATE_SYNONYM_ALL" 
(
	V_FROMZONE IN VARCHAR2 DEFAULT NULL ,
	V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS'
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_CREATE_SYNONYM_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
	--The name of the table, proc, function or view.
	V_OBJNAME VARCHAR2(50);

	--Dynamic SQL line
	V_CMDLINE VARCHAR2(200);

	--Table list
	CURSOR L_TABLE IS
		SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = UPPER(V_FROMZONE);
	--View List
	CURSOR L_VIEW IS
		SELECT VIEW_NAME FROM ALL_VIEWS WHERE OWNER = UPPER(V_FROMZONE);
	--Procedure and function list (OBJTYPE are PROCEDURE, FUNCTION, TRIGGER)
	CURSOR L_PROCEDURE (OBJTYPE VARCHAR2) IS
		SELECT DISTINCT OBJECT_NAME FROM ALL_PROCEDURES
			WHERE OWNER = UPPER(V_FROMZONE) AND OBJECT_TYPE = OBJTYPE
      AND UPPER(OBJECT_NAME) NOT LIKE 'UTIL%';

BEGIN

	-- Create synonyms for Tables
	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN

		OPEN L_TABLE;
			FETCH L_TABLE INTO V_OBJNAME;
		WHILE L_TABLE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);
	
				FETCH L_TABLE  INTO V_OBJNAME;

			EXCEPTION 
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
       END LOOP;
       CLOSE L_TABLE;
   end if;

	--CREATE SYNONYMS FOR VIEWS
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN

		OPEN L_VIEW;
			FETCH L_VIEW INTO V_OBJNAME;
		WHILE L_VIEW%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_VIEW INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE L_VIEW;
   END IF;

-- CREATE SYNONYMS FOR PROCEDURES
	IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' THEN

		OPEN L_PROCEDURE('PROCEDURE');
			FETCH L_PROCEDURE INTO V_OBJNAME;
		WHILE L_PROCEDURE%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create or replace synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH l_procedure INTO V_OBJNAME;

			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE l_procedure;
   end if;

-- CREATE SYNONYMS FOR FUNCTIONS
	IF UPPER(V_WHATTYPE) LIKE '%FUNCTION%' THEN
		
		OPEN l_procedure('FUNCTION');
			FETCH l_procedure INTO V_OBJNAME;
		WHILE l_procedure%FOUND
			LOOP
			BEGIN

				V_CMDLINE := 'create synonym ' || V_OBJNAME || ' for ' || UPPER(V_FROMZONE) || '.' || V_OBJNAME ;

				EXECUTE IMMEDIATE V_CMDLINE;
				--DBMS_OUTPUT.PUT_LINE('SUCCESS ' || V_CMDLINE);

				FETCH L_PROCEDURE INTO V_OBJNAME;
		
			EXCEPTION
			WHEN OTHERS THEN
			BEGIN
				DBMS_OUTPUT.PUT_LINE('ERROR ' || V_CMDLINE);
				DBMS_OUTPUT.PUT_LINE(SQLERRM);
			END;
		END;
		END LOOP;
		CLOSE L_PROCEDURE;
   END IF;
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_DROP_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_DROP_ALL" 
(
  v_whattype IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,VIEWS,SYNONYMS' ,
  v_dropifempty IN VARCHAR2 DEFAULT 'Y'
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_DROP_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   v_procname VARCHAR2(50);
   v_objtype VARCHAR2(50);
   v_table_name VARCHAR2(50);
   v_view_name VARCHAR2(50);
   v_synonym_name VARCHAR2(50);
   v_constraint_name VARCHAR2(50);


   cursor l_table is
     select table_name from user_tables;

   cursor l_view is
     select view_name from user_views;

   cursor l_procedure is
     select distinct object_name, object_type from user_procedures;

   cursor l_synonym is
     select synonym_name from user_synonyms;

   cursor l_constraint is
     select distinct table_name, constraint_name from user_constraints;

BEGIN

   --util_make_object_list(v_whattype, v_things);

   -- drop procedure(s) or function(s)
   if upper(v_whattype) like 'PROCEDURE' or upper(v_whattype) like 'FUNCTION' then
      open l_procedure;
      fetch l_procedure into v_procname, v_objtype;
      while l_procedure%FOUND
      loop
         -- dbms_output.put_line( v_objtype || '  ' || v_procname);
         execute immediate 'drop '|| v_objtype || ' ' || v_procname;

         fetch l_procedure into v_procname, v_objtype;
      end loop;
      close l_procedure;
   end if;


   -- drop table(s)
   if upper(v_whattype) like 'TABLE' then
      open l_table;
      fetch l_table into v_table_name;
      while l_table%FOUND
      loop
         -- dbms_output.put_line( v_table_name);
         execute immediate 'drop table '|| v_table_name || ' cascade constraints ';

         fetch l_table into v_table_name;
      end loop;
      close l_table;
   end if;

   -- drop synonyms(s)
   if upper(v_whattype) like 'SYNONYM' then
      open l_synonym;
      fetch l_synonym into v_synonym_name;
      while l_synonym%FOUND
      loop
         -- dbms_output.put_line( v_synonym_name);
         execute immediate 'drop synonym ' || v_synonym_name ;

         fetch l_synonym into v_synonym_name;
      end loop;
      close l_synonym;
   end if;


   -- drop view(s)
   if upper(v_whattype) like 'VIEW' then
      open l_view;
      fetch l_view into v_view_name;
      while l_view%FOUND
      loop
         -- dbms_output.put_line( v_view_name);
         execute immediate 'drop view '|| v_table_name ;

         fetch l_view into v_view_name;
      end loop;
      close l_view;
   end if;


   -- drop constraint(s)
   if upper(v_whattype) like 'CONSTRAINT' then
      open l_constraint;
      fetch l_constraint into v_table_name, v_constraint_name;
      while l_constraint%FOUND
      loop
         -- dbms_output.put_line( v_constraint_name);
         execute immediate 'alter table '|| v_table_name || ' drop constraint '|| v_constraint_name ;

         fetch l_constraint into v_table_name, v_constraint_name;
      end loop;
      close l_constraint;
   end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_DROP_ANYTHING
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_DROP_ANYTHING" 
(
  v_objname IN VARCHAR2 DEFAULT NULL ,
  v_objtype IN VARCHAR2 DEFAULT NULL
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_DROP_ANYTHING
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   v_cmdline VARCHAR2(100);

BEGIN

   if upper(v_objtype) like 'TABLE%' then
       v_cmdline := 'drop '|| v_objtype || ' '|| v_objname || ' cascade constraint';
   else
       v_cmdline := 'drop '|| v_objtype || ' '|| v_objname;
   end if;

   BEGIN
      execute immediate v_cmdline;
      DBMS_OUTPUT.PUT_LINE('SUCCESS ' || v_cmdline);
   EXCEPTION
      WHEN OTHERS THEN
         DBMS_OUTPUT.PUT_LINE('ERROR ' || v_cmdline);
   END;
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_DROP_SYNONYM
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_DROP_SYNONYM" 
(
  v_objname IN VARCHAR2 DEFAULT NULL
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_DROP_SYNONYM
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   v_cmdline VARCHAR2(100);

   cursor ts is
     select 'drop synonym ' || synonym_name || ' ' from user_synonyms;


BEGIN

  OPEN ts;
   FETCH ts INTO v_cmdline;
   WHILE ts%FOUND
   LOOP

      BEGIN
         BEGIN

            BEGIN
               EXECUTE IMMEDIATE v_cmdline;
               DBMS_OUTPUT.PUT_LINE('SUCCESS ' || v_cmdline);
            END;
         EXCEPTION
            WHEN OTHERS THEN

               BEGIN
                  DBMS_OUTPUT.PUT_LINE('ERROR ' || v_cmdline);
               END;
         END;
         FETCH ts INTO v_cmdline;
      END;
   END LOOP;
   CLOSE ts;
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_DROP_SYNONYM_BY_OWNER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_DROP_SYNONYM_BY_OWNER" 
(
  v_owner in varchar2,
  v_dropifempty IN VARCHAR2 DEFAULT 'Y'
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_DROP_SYNONYM_BY_OWNER
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   v_procname VARCHAR2(50);
   v_objtype VARCHAR2(50);
   v_table_name VARCHAR2(50);
   v_view_name VARCHAR2(50);
   v_synonym_name VARCHAR2(50);
   v_constraint_name VARCHAR2(50);


   cursor l_synonym is
     select synonym_name from all_synonyms
	 where owner = v_owner;


BEGIN

   -- drop synonyms(s)

      open l_synonym;
      fetch l_synonym into v_synonym_name;
      while l_synonym%FOUND
      loop
         -- dbms_output.put_line( v_synonym_name);
         execute immediate( 'drop synonym ' || v_synonym_name) ;

         fetch l_synonym into v_synonym_name;
      end loop;
      close l_synonym;



END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_DROP_TABLE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_DROP_TABLE" 
(
  v_tabname IN VARCHAR2 DEFAULT NULL
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_DROP_TABLE
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
  v_exists INTEGER;
  v_cmdline VARCHAR2(200);

BEGIN

  --Check if table exists
  select count(*) 
  into v_exists
  from user_tables
  where table_name = v_tabname;

  if v_exists > 0 then
     v_cmdline := 'drop table ' || v_tabname; 
     EXECUTE IMMEDIATE v_cmdline;
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_GRANT_ALL" 
(username	varchar2 := 'DATATRUST'
,V_WHATTYPE IN VARCHAR2 DEFAULT 'PROCEDURES,FUNCTIONS,TABLES,VIEWS,PACKAGES')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS DATATRUST POSSIBLE PERMISSIONS
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110901	Added parameter to allow username other than DATATRUST, look for EXTRNL as external table names

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

	IF UPPER(V_WHATTYPE) LIKE '%TABLE%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables where table_name not like '%EXTRNL%') LOOP

       if L_TABLE.table_name like '%EXTRNL%' then
          --grant select only to External tables
          execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
       
       else
          --Grant full permissions on regular tables  
          execute immediate 'grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username;
          --DBMS_OUTPUT.put_line('grant select, insert, update, delete on ' || L_TABLE.table_name || ' to ' || username);
       end if;
       
     END LOOP; --TABLE LOOP
     end if;
     
	IF UPPER(V_WHATTYPE) LIKE '%VIEW%' THEN
    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Views');

     for L_VIEW in (select view_name from user_views ) LOOP
          execute immediate 'grant select on ' || L_VIEW.view_name || ' to ' || username;
       
     END LOOP; --TABLE LOOP
 end if;

 IF UPPER(V_WHATTYPE) LIKE '%PROCEDURE%' or UPPER(V_WHATTYPE) LIKE '%FUNCTION%' or UPPER(V_WHATTYPE) LIKE '%PACKAGE%' THEN
    dbms_output.put_line(chr(10) || 'Procedures, functions and packages');

    for L_PROCEDURE in (select object_name from user_objects where object_type in ('PROCEDURE', 'FUNCTION', 'PACKAGE') )
     LOOP

       execute immediate 'grant execute on ' || L_PROCEDURE.object_name || ' to ' || username;
      -- DBMS_OUTPUT.put_line('grant execute on ' || L_PROCEDURE.object_name || ' to ' || username);

     END LOOP; --PROCEDURE LOOP
  end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_EXECUTE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_GRANT_EXECUTE" 
(
  v_to_zone IN VARCHAR2 DEFAULT NULL ,
  v_type IN VARCHAR2 DEFAULT 'TABLES,VIEWS'
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_EXECUTE
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

   v_object_name VARCHAR2(50);
   v_cmdline VARCHAR2(200);

   cursor l_table is
        select table_name from all_tables where owner = v_to_zone;

   cursor l_view is
        select view_name from all_views where owner = v_to_zone;

BEGIN

   if upper(v_type) like '%TABLE%' then
       OPEN l_table;
       FETCH l_table INTO v_object_name;
       WHILE l_table%FOUND
       LOOP
          BEGIN
             v_cmdline := 'grant select on ' || v_object_name || ' to ' || v_to_zone;

             BEGIN

                BEGIN
                   EXECUTE IMMEDIATE v_cmdline;
                   DBMS_OUTPUT.PUT_LINE('SUCCESS ' || v_cmdline);
                END;
             EXCEPTION
                WHEN OTHERS THEN

                   BEGIN
                      DBMS_OUTPUT.PUT_LINE('ERROR ' || v_cmdline);
                   END;
             END;

             FETCH l_table INTO v_object_name;
          END;
       END LOOP;
       CLOSE l_table;
   end if;

   if upper(v_type) like '%VIEW%' then
       OPEN l_view;
       FETCH l_view INTO v_object_name;
       WHILE l_view%FOUND
       LOOP
          BEGIN

             v_cmdline := 'grant select on ' || v_object_name || ' to ' || v_to_zone;

             BEGIN

                BEGIN
                   EXECUTE IMMEDIATE v_cmdline;
                   DBMS_OUTPUT.PUT_LINE('SUCCESS ' || v_cmdline);
                END;
             EXCEPTION
                WHEN OTHERS THEN

                   BEGIN
                      DBMS_OUTPUT.PUT_LINE('ERROR ' || v_cmdline);
                   END;
             END;

             FETCH l_view INTO v_object_name;
          END;
       END LOOP;
       CLOSE l_view;
   end if;

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_GRANT_SELECT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_GRANT_SELECT" 
(username	varchar2 := 'DATATRUST')
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_GRANT_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

    --GRANTS SELECT PERMISSIONS to DATATRUST (default) or specified user
    --ON OBJECTS OWNED BY THE CURRENT USER
	
	--	JEA@20110927	New, cloned from UTIL_GRANT_ALL

    v_user      varchar2(2000) := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');

  begin

    dbms_output.put_line('Owner ' || v_user  || '   Grantee ' || username);
    dbms_output.put_line('Tables');

     for L_TABLE in (select table_name from user_tables) LOOP

	 execute immediate 'grant select on ' || L_TABLE.table_name || ' to ' || username;
          DBMS_OUTPUT.put_line('grant select on ' || L_TABLE.table_name || ' to ' || username);
       
     END LOOP; --TABLE LOOP

  --  dbms_output.put_line(chr(10) || 'Views');

 --   for L_VIEW in (select object_name from user_objects where object_type = 'VIEW' )
  --   LOOP

   --    execute immediate 'grant select on ' || L_VIEW.object_name || ' to ' || username;
   --    DBMS_OUTPUT.put_line('grant select on ' || L_VIEW.object_name || ' to ' || username);

   --  END LOOP; --VIEW LOOP

END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_IS_POPULATED
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_IS_POPULATED" 
(
  tabname IN varchar2,
  retval OUT integer
)
AUTHID CURRENT_USER
as
-------------------------------------------------------------------------------------
-- NAME: UTIL_IS_POPULATED
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
  sqltext varchar2(500);
  l_count pls_integer;

begin

   sqltext := 'select count(*) into :result from ' || tabname;

   execute immediate sqltext into l_count;


   if l_count > 0 then
   retval :=1;
   else
    retval := 0;
   end if;

   --dbms_output.put_line(l_count);

end;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_MAKE_OBJECT_LIST
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_MAKE_OBJECT_LIST" 
(
  -- comma-separated list of things,
  v_whattype IN VARCHAR2 DEFAULT NULL,

  -- resolved list of things formatted as a list of quoted strings
  -- but without the enclosing parentheses.
  v_things OUT VARCHAR2
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_MAKE_OBJECT_LIST
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------

BEGIN

   v_things := REPLACE(UPPER(v_whattype), 'PROCEDURES', 'P,PC') ;
   v_things := REPLACE(UPPER(v_things), 'PROCEDURE', 'P,PC') ;
   v_things := REPLACE(UPPER(v_things), 'CONSTRAINTS', 'PK,F') ;
   v_things := REPLACE(UPPER(v_things), 'CONSTRAINT', 'PK,F') ;
   v_things := REPLACE(UPPER(v_things), 'FUNCTIONS', 'FN') ;
   v_things := REPLACE(UPPER(v_things), 'FUNCTION', 'FN') ;
   v_things := REPLACE(UPPER(v_things), 'TABLES', 'U') ;
   v_things := REPLACE(UPPER(v_things), 'TABLE', 'U') ;
   v_things := REPLACE(UPPER(v_things), 'VIEWS', 'V') ;
   v_things := REPLACE(UPPER(v_things), 'VIEW', 'V') ;

   -- add more common names for things
   -- but now transform a,b into 'a','b'
   v_things := REPLACE(UPPER(v_things), ',', ''',''') ;
   v_things := '''' || v_things || '''' ;
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_RECOMPILE_ALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_RECOMPILE_ALL" 
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_RECOMPILE_ALL
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   CURSOR v_proclist IS
     SELECT distinct 'alter '|| object_type || ' ' || object_name || ' compile '
     FROM user_procedures;

   v_procname VARCHAR2(50);

BEGIN

   OPEN v_proclist;
   FETCH v_proclist INTO v_procname;
   WHILE v_proclist%FOUND
   LOOP

      BEGIN
         BEGIN

            BEGIN
               execute immediate v_procname;
               DBMS_OUTPUT.PUT_LINE('succesfully compiled ' || v_procname);
            END;
         EXCEPTION
            WHEN OTHERS THEN

               BEGIN
                  DBMS_OUTPUT.PUT_LINE('error compiling ' || v_procname);
               END;
         END;
         FETCH v_proclist INTO v_procname;
      END;
   END LOOP;
   -- while loop
   CLOSE v_proclist;-- procedure
END;
 
 

/
--------------------------------------------------------
--  DDL for Procedure UTIL_TRUNCATE_TABLE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "TM_CZ"."UTIL_TRUNCATE_TABLE" 
(
  v_tabname IN VARCHAR2 DEFAULT NULL ,
  v_dummyarg IN VARCHAR2 DEFAULT 'Y'
)
AUTHID CURRENT_USER
AS
-------------------------------------------------------------------------------------
-- NAME: UTIL_TRUNCATE_TABLE
--
-- Copyright c 2011 Recombinant Data Corp.
--

--------------------------------------------------------------------------------------
   CURSOR v_cmdlist IS
     /* disable all foreign key constraints on this table */
     SELECT 'alter table ' || t1.owner ||'.' || t1.table_name ||' disable constraint '|| t1.constraint_name || '' cmd
     FROM user_constraints t1, user_constraints t2
     WHERE T1.CONSTRAINT_TYPE='R' and T1.R_CONSTRAINT_NAME=T2.CONSTRAINT_NAME and
        T2.TABLE_NAME = v_tabname
     UNION ALL
     /* finally actually truncate the table */
     SELECT 'truncate table ' || v_tabname || '' cmd
     FROM dual
     UNION ALL
     /* do a delete just incase the truncate failed */
     SELECT 'delete from ' || v_tabname || '' cmd
     FROM dual;

   v_cmdline VARCHAR2(200);
   v_drop_if_populated INTEGER;

BEGIN

   /* done with the SQL select - now process each command we selected */
   OPEN v_cmdlist;
   FETCH v_cmdlist INTO v_cmdline;
   WHILE v_cmdlist%FOUND
   LOOP

      BEGIN
         BEGIN

            BEGIN
               EXECUTE IMMEDIATE v_cmdline;
               DBMS_OUTPUT.PUT_LINE('SUCCESS ' || v_cmdline);
            END;
         EXCEPTION
            WHEN OTHERS THEN

               BEGIN
                  DBMS_OUTPUT.PUT_LINE('ERROR ' || v_cmdline);
               END;
         END;
         FETCH v_cmdlist INTO v_cmdline;
      END;
   END LOOP;
   -- while loop
   CLOSE v_cmdlist;-- procedure
END;
 
 

/
--------------------------------------------------------
--  DDL for Synonymn ADD_ONTOLOGY_NODE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."ADD_ONTOLOGY_NODE" FOR "I2B2METADATA"."ADD_ONTOLOGY_NODE";
--------------------------------------------------------
--  DDL for Synonymn ANNOTATION_DEAPP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."ANNOTATION_DEAPP" FOR "TM_CZ"."ANNOTATION_DEAPP";
--------------------------------------------------------
--  DDL for Synonymn ANNOTATION_DEAPP_20120206
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."ANNOTATION_DEAPP_20120206" FOR "TM_CZ"."ANNOTATION_DEAPP_20120206";
--------------------------------------------------------
--  DDL for Synonymn ASYNC_JOB
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."ASYNC_JOB" FOR "I2B2DEMODATA"."ASYNC_JOB";
--------------------------------------------------------
--  DDL for Synonymn BIO_AD_HOC_PROPERTY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_AD_HOC_PROPERTY" FOR "BIOMART"."BIO_AD_HOC_PROPERTY";
--------------------------------------------------------
--  DDL for Synonymn BIO_ANALYSIS_ATTRIBUTE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ANALYSIS_ATTRIBUTE" FOR "BIOMART"."BIO_ANALYSIS_ATTRIBUTE";
--------------------------------------------------------
--  DDL for Synonymn BIO_ANALYSIS_ATTRIBUTE_LINEAGE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ANALYSIS_ATTRIBUTE_LINEAGE" FOR "BIOMART"."BIO_ANALYSIS_ATTRIBUTE_LINEAGE";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY" FOR "BIOMART"."BIO_ASSAY";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_ANALYSIS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_ANALYSIS" FOR "BIOMART"."BIO_ASSAY_ANALYSIS";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_ANALYSIS_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_ANALYSIS_DATA" FOR "BIOMART"."BIO_ASSAY_ANALYSIS_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_ANALYSIS_DATA_TEA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_ANALYSIS_DATA_TEA" FOR "BIOMART"."BIO_ASSAY_ANALYSIS_DATA_TEA";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_ANALYSIS_EQTL
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_ANALYSIS_EQTL" FOR "BIOMART"."BIO_ASSAY_ANALYSIS_EQTL";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_ANALYSIS_EXT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_ANALYSIS_EXT" FOR "BIOMART"."BIO_ASSAY_ANALYSIS_EXT";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_ANALYSIS_GWAS_OLD
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_ANALYSIS_GWAS_OLD" FOR "BIOMART"."BIO_ASSAY_ANALYSIS_GWAS";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_DATA" FOR "BIOMART"."BIO_ASSAY_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_DATASET
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_DATASET" FOR "BIOMART"."BIO_ASSAY_DATASET";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_DATA_ANNOTATION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_DATA_ANNOTATION" FOR "BIOMART"."BIO_ASSAY_DATA_ANNOTATION";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_DATA_STATS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_DATA_STATS" FOR "BIOMART"."BIO_ASSAY_DATA_STATS";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_DATA_STATS_SEQ
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_DATA_STATS_SEQ" FOR "BIOMART"."BIO_ASSAY_DATA_STATS_SEQ";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_FEATURE_GROUP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_FEATURE_GROUP" FOR "BIOMART"."BIO_ASSAY_FEATURE_GROUP";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_PLATFORM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_PLATFORM" FOR "BIOMART"."BIO_ASSAY_PLATFORM";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASSAY_SAMPLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASSAY_SAMPLE" FOR "BIOMART"."BIO_ASSAY_SAMPLE";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASY_ANALYSIS_DATASET
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASY_ANALYSIS_DATASET" FOR "BIOMART"."BIO_ASY_ANALYSIS_DATASET";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASY_ANALYSIS_DATA_IDX
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASY_ANALYSIS_DATA_IDX" FOR "BIOMART"."BIO_ASY_ANALYSIS_DATA_IDX";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASY_ANALYSIS_PLTFM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASY_ANALYSIS_PLTFM" FOR "BIOMART"."BIO_ASY_ANALYSIS_PLTFM";
--------------------------------------------------------
--  DDL for Synonymn BIO_ASY_DATA_STATS_ALL
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_ASY_DATA_STATS_ALL" FOR "BIOMART"."BIO_ASY_DATA_STATS_ALL";
--------------------------------------------------------
--  DDL for Synonymn BIO_CELL_LINE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CELL_LINE" FOR "BIOMART"."BIO_CELL_LINE";
--------------------------------------------------------
--  DDL for Synonymn BIO_CGDCP_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CGDCP_DATA" FOR "BIOMART"."BIO_CGDCP_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_CLINC_TRIAL_ATTR
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CLINC_TRIAL_ATTR" FOR "BIOMART"."BIO_CLINC_TRIAL_ATTR";
--------------------------------------------------------
--  DDL for Synonymn BIO_CLINC_TRIAL_PT_GROUP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CLINC_TRIAL_PT_GROUP" FOR "BIOMART"."BIO_CLINC_TRIAL_PT_GROUP";
--------------------------------------------------------
--  DDL for Synonymn BIO_CLINC_TRIAL_TIME_PT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CLINC_TRIAL_TIME_PT" FOR "BIOMART"."BIO_CLINC_TRIAL_TIME_PT";
--------------------------------------------------------
--  DDL for Synonymn BIO_CLINICAL_TRIAL
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CLINICAL_TRIAL" FOR "BIOMART"."BIO_CLINICAL_TRIAL";
--------------------------------------------------------
--  DDL for Synonymn BIO_CLINICAL_TRIAL_DESIGN
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CLINICAL_TRIAL_DESIGN" FOR "BIOMART"."BIO_CLINICAL_TRIAL_DESIGN";
--------------------------------------------------------
--  DDL for Synonymn BIO_CLINICAL_TRIAL_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CLINICAL_TRIAL_RELEASE" FOR "TM_CZ"."BIO_CLINICAL_TRIAL_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn BIO_COMPOUND
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_COMPOUND" FOR "BIOMART"."BIO_COMPOUND";
--------------------------------------------------------
--  DDL for Synonymn BIO_CONCEPT_CODE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CONCEPT_CODE" FOR "BIOMART"."BIO_CONCEPT_CODE";
--------------------------------------------------------
--  DDL for Synonymn BIO_CONTENT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CONTENT" FOR "BIOMART"."BIO_CONTENT";
--------------------------------------------------------
--  DDL for Synonymn BIO_CONTENT_REFERENCE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CONTENT_REFERENCE" FOR "BIOMART"."BIO_CONTENT_REFERENCE";
--------------------------------------------------------
--  DDL for Synonymn BIO_CONTENT_REPOSITORY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CONTENT_REPOSITORY" FOR "BIOMART"."BIO_CONTENT_REPOSITORY";
--------------------------------------------------------
--  DDL for Synonymn BIO_CURATED_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CURATED_DATA" FOR "BIOMART"."BIO_CURATED_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_CURATION_DATASET
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_CURATION_DATASET" FOR "BIOMART"."BIO_CURATION_DATASET";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_ATTRIBUTE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_ATTRIBUTE" FOR "BIOMART"."BIO_DATA_ATTRIBUTE";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_COMPOUND
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_COMPOUND" FOR "BIOMART"."BIO_DATA_COMPOUND";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_COMPOUND_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_COMPOUND_RELEASE" FOR "TM_CZ"."BIO_DATA_COMPOUND_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_CORRELATION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_CORRELATION" FOR "BIOMART"."BIO_DATA_CORRELATION";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_CORREL_DESCR
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_CORREL_DESCR" FOR "BIOMART"."BIO_DATA_CORREL_DESCR";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_DISEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_DISEASE" FOR "BIOMART"."BIO_DATA_DISEASE";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_EXT_CODE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_EXT_CODE" FOR "BIOMART"."BIO_DATA_EXT_CODE";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_LITERATURE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_LITERATURE" FOR "BIOMART"."BIO_DATA_LITERATURE";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_OBSERVATION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_OBSERVATION" FOR "BIOMART"."BIO_DATA_OBSERVATION";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_OMIC_MARKER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_OMIC_MARKER" FOR "BIOMART"."BIO_DATA_OMIC_MARKER";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_PLATFORM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_PLATFORM" FOR "BIOMART"."BIO_DATA_PLATFORM";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_TAXONOMY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_TAXONOMY" FOR "BIOMART"."BIO_DATA_TAXONOMY";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_UID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_UID" FOR "BIOMART"."BIO_DATA_UID";
--------------------------------------------------------
--  DDL for Synonymn BIO_DATA_UID_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DATA_UID_RELEASE" FOR "TM_CZ"."BIO_DATA_UID_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn BIO_DISEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_DISEASE" FOR "BIOMART"."BIO_DISEASE";
--------------------------------------------------------
--  DDL for Synonymn BIO_EXPERIMENT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_EXPERIMENT" FOR "BIOMART"."BIO_EXPERIMENT";
--------------------------------------------------------
--  DDL for Synonymn BIO_EXPERIMENT_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_EXPERIMENT_RELEASE" FOR "TM_CZ"."BIO_EXPERIMENT_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn BIO_LIT_ALT_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_LIT_ALT_DATA" FOR "BIOMART"."BIO_LIT_ALT_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_LIT_AMD_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_LIT_AMD_DATA" FOR "BIOMART"."BIO_LIT_AMD_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_LIT_INH_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_LIT_INH_DATA" FOR "BIOMART"."BIO_LIT_INH_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_LIT_INT_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_LIT_INT_DATA" FOR "BIOMART"."BIO_LIT_INT_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_LIT_INT_MODEL_MV
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_LIT_INT_MODEL_MV" FOR "BIOMART"."BIO_LIT_INT_MODEL_MV";
--------------------------------------------------------
--  DDL for Synonymn BIO_LIT_MODEL_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_LIT_MODEL_DATA" FOR "BIOMART"."BIO_LIT_MODEL_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_LIT_PE_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_LIT_PE_DATA" FOR "BIOMART"."BIO_LIT_PE_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_LIT_REF_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_LIT_REF_DATA" FOR "BIOMART"."BIO_LIT_REF_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_LIT_SUM_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_LIT_SUM_DATA" FOR "BIOMART"."BIO_LIT_SUM_DATA";
--------------------------------------------------------
--  DDL for Synonymn BIO_MARKER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_MARKER" FOR "BIOMART"."BIO_MARKER";
--------------------------------------------------------
--  DDL for Synonymn BIO_MARKER_CORREL_MV
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_MARKER_CORREL_MV" FOR "BIOMART"."BIO_MARKER_CORREL_MV";
--------------------------------------------------------
--  DDL for Synonymn BIO_OBSERVATION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_OBSERVATION" FOR "BIOMART"."BIO_OBSERVATION";
--------------------------------------------------------
--  DDL for Synonymn BIO_PATIENT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_PATIENT" FOR "BIOMART"."BIO_PATIENT";
--------------------------------------------------------
--  DDL for Synonymn BIO_PATIENT_EVENT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_PATIENT_EVENT" FOR "BIOMART"."BIO_PATIENT_EVENT";
--------------------------------------------------------
--  DDL for Synonymn BIO_PATIENT_EVENT_ATTR
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_PATIENT_EVENT_ATTR" FOR "BIOMART"."BIO_PATIENT_EVENT_ATTR";
--------------------------------------------------------
--  DDL for Synonymn BIO_SAMPLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_SAMPLE" FOR "BIOMART"."BIO_SAMPLE";
--------------------------------------------------------
--  DDL for Synonymn BIO_STATS_EXP_MARKER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_STATS_EXP_MARKER" FOR "BIOMART"."BIO_STATS_EXP_MARKER";
--------------------------------------------------------
--  DDL for Synonymn BIO_SUBJECT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_SUBJECT" FOR "BIOMART"."BIO_SUBJECT";
--------------------------------------------------------
--  DDL for Synonymn BIO_TAXONOMY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."BIO_TAXONOMY" FOR "BIOMART"."BIO_TAXONOMY";
--------------------------------------------------------
--  DDL for Synonymn CATEGORY_PATH_EXCLUDED_WORDS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CATEGORY_PATH_EXCLUDED_WORDS" FOR "TM_CZ"."CATEGORY_PATH_EXCLUDED_WORDS";
--------------------------------------------------------
--  DDL for Synonymn CODE_LOOKUP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CODE_LOOKUP" FOR "I2B2DEMODATA"."CODE_LOOKUP";
--------------------------------------------------------
--  DDL for Synonymn CONCEPT_COUNTS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CONCEPT_COUNTS" FOR "I2B2DEMODATA"."CONCEPT_COUNTS";
--------------------------------------------------------
--  DDL for Synonymn CONCEPT_DIMENSION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CONCEPT_DIMENSION" FOR "I2B2DEMODATA"."CONCEPT_DIMENSION";
--------------------------------------------------------
--  DDL for Synonymn CONCEPT_DIMENSION_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CONCEPT_DIMENSION_RELEASE" FOR "TM_CZ"."CONCEPT_DIMENSION_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn CONCEPT_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CONCEPT_ID" FOR "I2B2DEMODATA"."CONCEPT_ID";
--------------------------------------------------------
--  DDL for Synonymn COUNTER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."COUNTER" FOR "I2B2DEMODATA"."COUNTER";
--------------------------------------------------------
--  DDL for Synonymn CRC_ANALYSIS_JOB
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CRC_ANALYSIS_JOB" FOR "I2B2HIVE"."CRC_ANALYSIS_JOB";
--------------------------------------------------------
--  DDL for Synonymn CRC_DB_LOOKUP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CRC_DB_LOOKUP" FOR "I2B2HIVE"."CRC_DB_LOOKUP";
--------------------------------------------------------
--  DDL for Synonymn CREATE_TEMP_CONCEPT_TABLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CREATE_TEMP_CONCEPT_TABLE" FOR "I2B2DEMODATA"."CREATE_TEMP_CONCEPT_TABLE";
--------------------------------------------------------
--  DDL for Synonymn CREATE_TEMP_EID_TABLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CREATE_TEMP_EID_TABLE" FOR "I2B2DEMODATA"."CREATE_TEMP_EID_TABLE";
--------------------------------------------------------
--  DDL for Synonymn CREATE_TEMP_PATIENT_TABLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CREATE_TEMP_PATIENT_TABLE" FOR "I2B2DEMODATA"."CREATE_TEMP_PATIENT_TABLE";
--------------------------------------------------------
--  DDL for Synonymn CREATE_TEMP_PID_TABLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CREATE_TEMP_PID_TABLE" FOR "I2B2DEMODATA"."CREATE_TEMP_PID_TABLE";
--------------------------------------------------------
--  DDL for Synonymn CREATE_TEMP_PROVIDER_TABLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CREATE_TEMP_PROVIDER_TABLE" FOR "I2B2DEMODATA"."CREATE_TEMP_PROVIDER_TABLE";
--------------------------------------------------------
--  DDL for Synonymn CREATE_TEMP_TABLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CREATE_TEMP_TABLE" FOR "I2B2DEMODATA"."CREATE_TEMP_TABLE";
--------------------------------------------------------
--  DDL for Synonymn CREATE_TEMP_VISIT_TABLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CREATE_TEMP_VISIT_TABLE" FOR "I2B2DEMODATA"."CREATE_TEMP_VISIT_TABLE";
--------------------------------------------------------
--  DDL for Synonymn CTD2_CLIN_INHIB_EFFECT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD2_CLIN_INHIB_EFFECT" FOR "BIOMART"."CTD2_CLIN_INHIB_EFFECT";
--------------------------------------------------------
--  DDL for Synonymn CTD2_DISEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD2_DISEASE" FOR "BIOMART"."CTD2_DISEASE";
--------------------------------------------------------
--  DDL for Synonymn CTD2_INHIB_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD2_INHIB_DETAILS" FOR "BIOMART"."CTD2_INHIB_DETAILS";
--------------------------------------------------------
--  DDL for Synonymn CTD2_STUDY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD2_STUDY" FOR "BIOMART"."CTD2_STUDY";
--------------------------------------------------------
--  DDL for Synonymn CTD2_TRIAL_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD2_TRIAL_DETAILS" FOR "BIOMART"."CTD2_TRIAL_DETAILS";
--------------------------------------------------------
--  DDL for Synonymn CTD_ALLOWED_MEDS_TREATMENT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_ALLOWED_MEDS_TREATMENT" FOR "BIOMART"."CTD_ALLOWED_MEDS_TREATMENT";
--------------------------------------------------------
--  DDL for Synonymn CTD_ARM_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_ARM_VIEW" FOR "BIOMART"."CTD_ARM_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_BIOMARKER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_BIOMARKER" FOR "BIOMART"."CTD_BIOMARKER";
--------------------------------------------------------
--  DDL for Synonymn CTD_BIOMARKER_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_BIOMARKER_VIEW" FOR "BIOMART"."CTD_BIOMARKER_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_CELL_INFO_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_CELL_INFO_VIEW" FOR "BIOMART"."CTD_CELL_INFO_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_CLINICAL_CHARS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_CLINICAL_CHARS_VIEW" FOR "BIOMART"."CTD_CLINICAL_CHARS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_DISEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_DISEASE" FOR "BIOMART"."CTD_DISEASE";
--------------------------------------------------------
--  DDL for Synonymn CTD_DRUG_EFFECTS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_DRUG_EFFECTS_VIEW" FOR "BIOMART"."CTD_DRUG_EFFECTS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_DRUG_INHIB
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_DRUG_INHIB" FOR "BIOMART"."CTD_DRUG_INHIB";
--------------------------------------------------------
--  DDL for Synonymn CTD_DRUG_INHIBITOR_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_DRUG_INHIBITOR_VIEW" FOR "BIOMART"."CTD_DRUG_INHIBITOR_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_EVENTS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_EVENTS_VIEW" FOR "BIOMART"."CTD_EVENTS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_EXPERIMENTS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_EXPERIMENTS_VIEW" FOR "BIOMART"."CTD_EXPERIMENTS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_EXPR_AFTER_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_EXPR_AFTER_VIEW" FOR "BIOMART"."CTD_EXPR_AFTER_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_EXPR_BASELINE_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_EXPR_BASELINE_VIEW" FOR "BIOMART"."CTD_EXPR_BASELINE_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_EXPR_BIO_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_EXPR_BIO_VIEW" FOR "BIOMART"."CTD_EXPR_BIO_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_EXPR_SOURCE_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_EXPR_SOURCE_VIEW" FOR "BIOMART"."CTD_EXPR_SOURCE_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_FULL
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_FULL" FOR "BIOMART"."CTD_FULL";
--------------------------------------------------------
--  DDL for Synonymn CTD_FULL_CLINICAL_ENDPTS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_FULL_CLINICAL_ENDPTS_VIEW" FOR "BIOMART"."CTD_FULL_CLINICAL_ENDPTS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_FULL_SEARCH_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_FULL_SEARCH_VIEW" FOR "BIOMART"."CTD_FULL_SEARCH_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_INCLUSION_CRITERIA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_INCLUSION_CRITERIA" FOR "BIOMART"."CTD_INCLUSION_CRITERIA";
--------------------------------------------------------
--  DDL for Synonymn CTD_PRIMARY_ENDPTS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_PRIMARY_ENDPTS" FOR "BIOMART"."CTD_PRIMARY_ENDPTS";
--------------------------------------------------------
--  DDL for Synonymn CTD_PRIMARY_ENDPTS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_PRIMARY_ENDPTS_VIEW" FOR "BIOMART"."CTD_PRIMARY_ENDPTS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_PRIOR_MED_USE_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_PRIOR_MED_USE_VIEW" FOR "BIOMART"."CTD_PRIOR_MED_USE_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_PULMONARY_PATH_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_PULMONARY_PATH_VIEW" FOR "BIOMART"."CTD_PULMONARY_PATH_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_QUANT_PARAMS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_QUANT_PARAMS_VIEW" FOR "BIOMART"."CTD_QUANT_PARAMS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_REFERENCE_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_REFERENCE_VIEW" FOR "BIOMART"."CTD_REFERENCE_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_RUNIN_THERAPIES_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_RUNIN_THERAPIES_VIEW" FOR "BIOMART"."CTD_RUNIN_THERAPIES_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_SECONDARY_ENDPTS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_SECONDARY_ENDPTS_VIEW" FOR "BIOMART"."CTD_SECONDARY_ENDPTS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_SEC_ENDPTS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_SEC_ENDPTS" FOR "BIOMART"."CTD_SEC_ENDPTS";
--------------------------------------------------------
--  DDL for Synonymn CTD_STATS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_STATS_VIEW" FOR "BIOMART"."CTD_STATS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_STUDY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_STUDY" FOR "BIOMART"."CTD_STUDY";
--------------------------------------------------------
--  DDL for Synonymn CTD_STUDY_DETAILS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_STUDY_DETAILS_VIEW" FOR "BIOMART"."CTD_STUDY_DETAILS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_TD_DESIGN_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_TD_DESIGN_VIEW" FOR "BIOMART"."CTD_TD_DESIGN_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_TD_EXCL_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_TD_EXCL_VIEW" FOR "BIOMART"."CTD_TD_EXCL_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_TD_INCLUSION_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_TD_INCLUSION_VIEW" FOR "BIOMART"."CTD_TD_INCLUSION_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_TD_SMOKER_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_TD_SMOKER_VIEW" FOR "BIOMART"."CTD_TD_SMOKER_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_TD_SPONSOR_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_TD_SPONSOR_VIEW" FOR "BIOMART"."CTD_TD_SPONSOR_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_TD_STATUS_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_TD_STATUS_VIEW" FOR "BIOMART"."CTD_TD_STATUS_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CTD_TREATMENT_PHASES_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CTD_TREATMENT_PHASES_VIEW" FOR "BIOMART"."CTD_TREATMENT_PHASES_VIEW";
--------------------------------------------------------
--  DDL for Synonymn CUSTOM_META
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CUSTOM_META" FOR "I2B2METADATA"."CUSTOM_META";
--------------------------------------------------------
--  DDL for Synonymn CZ_DATA_PROFILE_COLUMN_EXCLUSI
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_DATA_PROFILE_COLUMN_EXCLUSI" FOR "TM_CZ"."CZ_DATA_PROFILE_COLUMN_EXCLUSI";
--------------------------------------------------------
--  DDL for Synonymn CZ_DATA_PROFILE_COLUMN_SAMPLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_DATA_PROFILE_COLUMN_SAMPLE" FOR "TM_CZ"."CZ_DATA_PROFILE_COLUMN_SAMPLE";
--------------------------------------------------------
--  DDL for Synonymn CZ_DATA_PROFILE_STATS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_DATA_PROFILE_STATS" FOR "TM_CZ"."CZ_DATA_PROFILE_STATS";
--------------------------------------------------------
--  DDL for Synonymn CZ_FORM_LAYOUT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_FORM_LAYOUT" FOR "TM_CZ"."CZ_FORM_LAYOUT";
--------------------------------------------------------
--  DDL for Synonymn CZ_JOB_AUDIT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_JOB_AUDIT" FOR "TM_CZ"."CZ_JOB_AUDIT";
--------------------------------------------------------
--  DDL for Synonymn CZ_JOB_ERROR
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_JOB_ERROR" FOR "TM_CZ"."CZ_JOB_ERROR";
--------------------------------------------------------
--  DDL for Synonymn CZ_JOB_MASTER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_JOB_MASTER" FOR "TM_CZ"."CZ_JOB_MASTER";
--------------------------------------------------------
--  DDL for Synonymn CZ_JOB_MESSAGE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_JOB_MESSAGE" FOR "TM_CZ"."CZ_JOB_MESSAGE";
--------------------------------------------------------
--  DDL for Synonymn CZ_PERSON
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_PERSON" FOR "TM_CZ"."CZ_PERSON";
--------------------------------------------------------
--  DDL for Synonymn CZ_REQUIRED_UPLOAD_FIELD
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_REQUIRED_UPLOAD_FIELD" FOR "TM_CZ"."CZ_REQUIRED_UPLOAD_FIELD";
--------------------------------------------------------
--  DDL for Synonymn CZ_TEST
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_TEST" FOR "TM_CZ"."CZ_TEST";
--------------------------------------------------------
--  DDL for Synonymn CZ_TEST_CATEGORY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_TEST_CATEGORY" FOR "TM_CZ"."CZ_TEST_CATEGORY";
--------------------------------------------------------
--  DDL for Synonymn CZ_TEST_RESULT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_TEST_RESULT" FOR "TM_CZ"."CZ_TEST_RESULT";
--------------------------------------------------------
--  DDL for Synonymn CZ_XTRIAL_CTRL_VOCAB
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_XTRIAL_CTRL_VOCAB" FOR "TM_CZ"."CZ_XTRIAL_CTRL_VOCAB";
--------------------------------------------------------
--  DDL for Synonymn CZ_XTRIAL_EXCLUSION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."CZ_XTRIAL_EXCLUSION" FOR "TM_CZ"."CZ_XTRIAL_EXCLUSION";
--------------------------------------------------------
--  DDL for Synonymn DATAMART_REPORT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DATAMART_REPORT" FOR "I2B2DEMODATA"."DATAMART_REPORT";
--------------------------------------------------------
--  DDL for Synonymn DEAPP_ANNOTATION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DEAPP_ANNOTATION" FOR "DEAPP"."DEAPP_ANNOTATION";
--------------------------------------------------------
--  DDL for Synonymn DE_CONCEPT_CONTEXT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_CONCEPT_CONTEXT" FOR "DEAPP"."DE_CONCEPT_CONTEXT";
--------------------------------------------------------
--  DDL for Synonymn DE_CONTEXT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_CONTEXT" FOR "DEAPP"."DE_CONTEXT";
--------------------------------------------------------
--  DDL for Synonymn DE_CONTEXT_SEQ
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_CONTEXT_SEQ" FOR "DEAPP"."DE_CONTEXT_SEQ";
--------------------------------------------------------
--  DDL for Synonymn DE_GPL_INFO
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_GPL_INFO" FOR "DEAPP"."DE_GPL_INFO";
--------------------------------------------------------
--  DDL for Synonymn DE_GPL_INFO_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_GPL_INFO_RELEASE" FOR "TM_CZ"."DE_GPL_INFO_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_MRNA_ANNOTATION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_MRNA_ANNOTATION" FOR "DEAPP"."DE_MRNA_ANNOTATION";
--------------------------------------------------------
--  DDL for Synonymn DE_MRNA_ANNOTATION_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_MRNA_ANNOTATION_RELEASE" FOR "TM_CZ"."DE_MRNA_ANNOTATION_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_PARENT_CD_SEQ
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_PARENT_CD_SEQ" FOR "DEAPP"."DE_PARENT_CD_SEQ";
--------------------------------------------------------
--  DDL for Synonymn DE_PATHWAY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_PATHWAY" FOR "DEAPP"."DE_PATHWAY";
--------------------------------------------------------
--  DDL for Synonymn DE_PATHWAY_GENE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_PATHWAY_GENE" FOR "DEAPP"."DE_PATHWAY_GENE";
--------------------------------------------------------
--  DDL for Synonymn DE_RC_SNP_INFO
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_RC_SNP_INFO" FOR "DEAPP"."DE_RC_SNP_INFO";
--------------------------------------------------------
--  DDL for Synonymn DE_SAVED_COMPARISON
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SAVED_COMPARISON" FOR "DEAPP"."DE_SAVED_COMPARISON";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_CALLS_BY_GSM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_CALLS_BY_GSM" FOR "DEAPP"."DE_SNP_CALLS_BY_GSM";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_COPY_NUMBER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_COPY_NUMBER" FOR "DEAPP"."DE_SNP_COPY_NUMBER";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_DATA_BY_PATIENT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_DATA_BY_PATIENT" FOR "DEAPP"."DE_SNP_DATA_BY_PATIENT";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_DATA_BY_PATIENT_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_DATA_BY_PATIENT_RELEASE" FOR "TM_CZ"."DE_SNP_DATA_BY_PATIENT_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_DATA_BY_PROBE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_DATA_BY_PROBE" FOR "DEAPP"."DE_SNP_DATA_BY_PROBE";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_DATA_BY_PROBE_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_DATA_BY_PROBE_RELEASE" FOR "TM_CZ"."DE_SNP_DATA_BY_PROBE_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_DATA_DATASET_LOC
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_DATA_DATASET_LOC" FOR "DEAPP"."DE_SNP_DATA_DATASET_LOC";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_DATA_DS_LOC_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_DATA_DS_LOC_RELEASE" FOR "TM_CZ"."DE_SNP_DATA_DS_LOC_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_GENE_MAP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_GENE_MAP" FOR "DEAPP"."DE_SNP_GENE_MAP";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_GENE_MAP_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_GENE_MAP_RELEASE" FOR "TM_CZ"."DE_SNP_GENE_MAP_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_INFO
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_INFO" FOR "DEAPP"."DE_SNP_INFO";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_INFO_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_INFO_RELEASE" FOR "TM_CZ"."DE_SNP_INFO_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_PROBE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_PROBE" FOR "DEAPP"."DE_SNP_PROBE";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_PROBE_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_PROBE_RELEASE" FOR "TM_CZ"."DE_SNP_PROBE_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_PROBE_SORTED_DEF
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_PROBE_SORTED_DEF" FOR "DEAPP"."DE_SNP_PROBE_SORTED_DEF";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_PROBE_SORT_DEF_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_PROBE_SORT_DEF_RELEASE" FOR "TM_CZ"."DE_SNP_PROBE_SORT_DEF_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_SNP_SUBJECT_SORTED_DEF
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SNP_SUBJECT_SORTED_DEF" FOR "DEAPP"."DE_SNP_SUBJECT_SORTED_DEF";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJECT_MICROARRAY_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJECT_MICROARRAY_DATA" FOR "DEAPP"."DE_SUBJECT_MICROARRAY_DATA";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJECT_MICROARRAY_DATA_OLD
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJECT_MICROARRAY_DATA_OLD" FOR "DEAPP"."DE_SUBJECT_MICROARRAY_DATA_OLD";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJECT_MICROARRAY_LOGS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJECT_MICROARRAY_LOGS" FOR "DEAPP"."DE_SUBJECT_MICROARRAY_LOGS";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJECT_MICROARRAY_MED
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJECT_MICROARRAY_MED" FOR "DEAPP"."DE_SUBJECT_MICROARRAY_MED";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJECT_MRNA_DATA_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJECT_MRNA_DATA_RELEASE" FOR "TM_CZ"."DE_SUBJECT_MRNA_DATA_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJECT_PROTEIN_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJECT_PROTEIN_DATA" FOR "DEAPP"."DE_SUBJECT_PROTEIN_DATA";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJECT_RBM_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJECT_RBM_DATA" FOR "DEAPP"."DE_SUBJECT_RBM_DATA";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJECT_RBM_DATA_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJECT_RBM_DATA_RELEASE" FOR "TM_CZ"."DE_SUBJECT_RBM_DATA_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJECT_SAMPLE_MAPPING
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJECT_SAMPLE_MAPPING" FOR "DEAPP"."DE_SUBJECT_SAMPLE_MAPPING";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJECT_SNP_DATASET
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJECT_SNP_DATASET" FOR "DEAPP"."DE_SUBJECT_SNP_DATASET";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJ_PROTEIN_DATA_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJ_PROTEIN_DATA_RELEASE" FOR "TM_CZ"."DE_SUBJ_PROTEIN_DATA_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_SUBJ_SAMPLE_MAP_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_SUBJ_SAMPLE_MAP_RELEASE" FOR "TM_CZ"."DE_SUBJ_SAMPLE_MAP_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn DE_XTRIAL_CHILD_MAP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_XTRIAL_CHILD_MAP" FOR "DEAPP"."DE_XTRIAL_CHILD_MAP";
--------------------------------------------------------
--  DDL for Synonymn DE_XTRIAL_PARENT_NAMES
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DE_XTRIAL_PARENT_NAMES" FOR "DEAPP"."DE_XTRIAL_PARENT_NAMES";
--------------------------------------------------------
--  DDL for Synonymn DIMLOADER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DIMLOADER" FOR "I2B2DEMODATA"."DIMLOADER";
--------------------------------------------------------
--  DDL for Synonymn DUMP_TABLE_TO_CSV
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DUMP_TABLE_TO_CSV" FOR "DEAPP"."DUMP_TABLE_TO_CSV";
--------------------------------------------------------
--  DDL for Synonymn DX
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."DX" FOR "I2B2DEMODATA"."DX";
--------------------------------------------------------
--  DDL for Synonymn ENCOUNTER_MAPPING
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."ENCOUNTER_MAPPING" FOR "I2B2DEMODATA"."ENCOUNTER_MAPPING";
--------------------------------------------------------
--  DDL for Synonymn FACETED_SEARCH
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."FACETED_SEARCH" FOR "BIOMART"."FACETED_SEARCH";
--------------------------------------------------------
--  DDL for Synonymn FM_DATA_UID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."FM_DATA_UID" FOR "FMAPP"."FM_DATA_UID";
--------------------------------------------------------
--  DDL for Synonymn FM_FILE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."FM_FILE" FOR "FMAPP"."FM_FILE";
--------------------------------------------------------
--  DDL for Synonymn FM_FOLDER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."FM_FOLDER" FOR "FMAPP"."FM_FOLDER";
--------------------------------------------------------
--  DDL for Synonymn FM_FOLDER_ASSOCIATION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."FM_FOLDER_ASSOCIATION" FOR "FMAPP"."FM_FOLDER_ASSOCIATION";
--------------------------------------------------------
--  DDL for Synonymn FM_FOLDER_FILE_ASSOCIATION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."FM_FOLDER_FILE_ASSOCIATION" FOR "FMAPP"."FM_FOLDER_FILE_ASSOCIATION";
--------------------------------------------------------
--  DDL for Synonymn GLOBAL_TEMP_FACT_PARAM_TABLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."GLOBAL_TEMP_FACT_PARAM_TABLE" FOR "I2B2DEMODATA"."GLOBAL_TEMP_FACT_PARAM_TABLE";
--------------------------------------------------------
--  DDL for Synonymn GLOBAL_TEMP_PARAM_TABLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."GLOBAL_TEMP_PARAM_TABLE" FOR "I2B2DEMODATA"."GLOBAL_TEMP_PARAM_TABLE";
--------------------------------------------------------
--  DDL for Synonymn HAPLOVIEW_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."HAPLOVIEW_DATA" FOR "DEAPP"."HAPLOVIEW_DATA";
--------------------------------------------------------
--  DDL for Synonymn HAPLOVIEW_DATA_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."HAPLOVIEW_DATA_RELEASE" FOR "TM_CZ"."HAPLOVIEW_DATA_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn HIBERNATE_SEQUENCE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."HIBERNATE_SEQUENCE" FOR "SEARCHAPP"."HIBERNATE_SEQUENCE";
--------------------------------------------------------
--  DDL for Synonymn HILOSEQUENCES
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."HILOSEQUENCES" FOR "I2B2HIVE"."HILOSEQUENCES";
--------------------------------------------------------
--  DDL for Synonymn I2B2
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."I2B2" FOR "I2B2METADATA"."I2B2";
--------------------------------------------------------
--  DDL for Synonymn I2B2_ID_SEQ
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."I2B2_ID_SEQ" FOR "I2B2METADATA"."I2B2_ID_SEQ";
--------------------------------------------------------
--  DDL for Synonymn I2B2_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."I2B2_RELEASE" FOR "TM_CZ"."I2B2_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn I2B2_SAMPLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."I2B2_SAMPLE" FOR "I2B2SAMPLEDATA"."I2B2_SAMPLE";
--------------------------------------------------------
--  DDL for Synonymn I2B2_SECURE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."I2B2_SECURE" FOR "I2B2METADATA"."I2B2_SECURE";
--------------------------------------------------------
--  DDL for Synonymn I2B2_TAGS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."I2B2_TAGS" FOR "I2B2METADATA"."I2B2_TAGS";
--------------------------------------------------------
--  DDL for Synonymn I2B2_TAGS_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."I2B2_TAGS_RELEASE" FOR "TM_CZ"."I2B2_TAGS_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn INSERT_CONCEPT_FROMTEMP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."INSERT_CONCEPT_FROMTEMP" FOR "I2B2DEMODATA"."INSERT_CONCEPT_FROMTEMP";
--------------------------------------------------------
--  DDL for Synonymn INSERT_EID_MAP_FROMTEMP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."INSERT_EID_MAP_FROMTEMP" FOR "I2B2DEMODATA"."INSERT_EID_MAP_FROMTEMP";
--------------------------------------------------------
--  DDL for Synonymn INSERT_ENCOUNTERVISIT_FROMTEMP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."INSERT_ENCOUNTERVISIT_FROMTEMP" FOR "I2B2DEMODATA"."INSERT_ENCOUNTERVISIT_FROMTEMP";
--------------------------------------------------------
--  DDL for Synonymn INSERT_PATIENT_MAP_FROMTEMP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."INSERT_PATIENT_MAP_FROMTEMP" FOR "I2B2DEMODATA"."INSERT_PATIENT_MAP_FROMTEMP";
--------------------------------------------------------
--  DDL for Synonymn INSERT_PID_MAP_FROMTEMP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."INSERT_PID_MAP_FROMTEMP" FOR "I2B2DEMODATA"."INSERT_PID_MAP_FROMTEMP";
--------------------------------------------------------
--  DDL for Synonymn INSERT_PROVIDER_FROMTEMP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."INSERT_PROVIDER_FROMTEMP" FOR "I2B2DEMODATA"."INSERT_PROVIDER_FROMTEMP";
--------------------------------------------------------
--  DDL for Synonymn JMS_MESSAGES
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."JMS_MESSAGES" FOR "I2B2HIVE"."JMS_MESSAGES";
--------------------------------------------------------
--  DDL for Synonymn JMS_ROLES
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."JMS_ROLES" FOR "I2B2HIVE"."JMS_ROLES";
--------------------------------------------------------
--  DDL for Synonymn JMS_SUBSCRIPTIONS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."JMS_SUBSCRIPTIONS" FOR "I2B2HIVE"."JMS_SUBSCRIPTIONS";
--------------------------------------------------------
--  DDL for Synonymn JMS_TRANSACTIONS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."JMS_TRANSACTIONS" FOR "I2B2HIVE"."JMS_TRANSACTIONS";
--------------------------------------------------------
--  DDL for Synonymn JMS_USERS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."JMS_USERS" FOR "I2B2HIVE"."JMS_USERS";
--------------------------------------------------------
--  DDL for Synonymn LZ_SRC_ANALYSIS_METADATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."LZ_SRC_ANALYSIS_METADATA" FOR "TM_LZ"."LZ_SRC_ANALYSIS_METADATA";
--------------------------------------------------------
--  DDL for Synonymn LZ_SRC_STUDY_METADATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."LZ_SRC_STUDY_METADATA" FOR "TM_LZ"."LZ_SRC_STUDY_METADATA";
--------------------------------------------------------
--  DDL for Synonymn MASTER_QUERY_GLOBAL_TEMP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."MASTER_QUERY_GLOBAL_TEMP" FOR "I2B2DEMODATA"."MASTER_QUERY_GLOBAL_TEMP";
--------------------------------------------------------
--  DDL for Synonymn MESH
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."MESH" FOR "BIOMART"."MESH";
--------------------------------------------------------
--  DDL for Synonymn MESH_ALL
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."MESH_ALL" FOR "BIOMART"."MESH_ALL";
--------------------------------------------------------
--  DDL for Synonymn MESH_ENTRY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."MESH_ENTRY" FOR "BIOMART"."MESH_ENTRY";
--------------------------------------------------------
--  DDL for Synonymn MESH_ENTRY_ALL
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."MESH_ENTRY_ALL" FOR "BIOMART"."MESH_ENTRY_ALL";
--------------------------------------------------------
--  DDL for Synonymn MLOG$_SEARCH_GENE_SIGNATUR
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."MLOG$_SEARCH_GENE_SIGNATUR" FOR "SEARCHAPP"."MLOG$_SEARCH_GENE_SIGNATUR";
--------------------------------------------------------
--  DDL for Synonymn NEWS_UPDATES
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."NEWS_UPDATES" FOR "I2B2DEMODATA"."NEWS_UPDATES";
--------------------------------------------------------
--  DDL for Synonymn NODE_CURATION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."NODE_CURATION" FOR "TM_CZ"."NODE_CURATION";
--------------------------------------------------------
--  DDL for Synonymn OBSERVATION_FACT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."OBSERVATION_FACT" FOR "I2B2DEMODATA"."OBSERVATION_FACT";
--------------------------------------------------------
--  DDL for Synonymn OBSERVATION_FACT_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."OBSERVATION_FACT_RELEASE" FOR "TM_CZ"."OBSERVATION_FACT_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn ONT_DB_LOOKUP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."ONT_DB_LOOKUP" FOR "I2B2METADATA"."ONT_DB_LOOKUP";
--------------------------------------------------------
--  DDL for Synonymn ONT_PROCESS_STATUS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."ONT_PROCESS_STATUS" FOR "I2B2METADATA"."ONT_PROCESS_STATUS";
--------------------------------------------------------
--  DDL for Synonymn ONT_SQ_PS_PRID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."ONT_SQ_PS_PRID" FOR "I2B2METADATA"."ONT_SQ_PS_PRID";
--------------------------------------------------------
--  DDL for Synonymn PATIENT_DIMENSION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PATIENT_DIMENSION" FOR "I2B2DEMODATA"."PATIENT_DIMENSION";
--------------------------------------------------------
--  DDL for Synonymn PATIENT_DIMENSION_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PATIENT_DIMENSION_RELEASE" FOR "TM_CZ"."PATIENT_DIMENSION_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn PATIENT_MAPPING
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PATIENT_MAPPING" FOR "I2B2DEMODATA"."PATIENT_MAPPING";
--------------------------------------------------------
--  DDL for Synonymn PATIENT_TRIAL
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PATIENT_TRIAL" FOR "I2B2DEMODATA"."PATIENT_TRIAL";
--------------------------------------------------------
--  DDL for Synonymn PLUGIN
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PLUGIN" FOR "SEARCHAPP"."PLUGIN";
--------------------------------------------------------
--  DDL for Synonymn PLUGIN_MODULE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PLUGIN_MODULE" FOR "SEARCHAPP"."PLUGIN_MODULE";
--------------------------------------------------------
--  DDL for Synonymn PLUGIN_MODULE_SEQ
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PLUGIN_MODULE_SEQ" FOR "SEARCHAPP"."PLUGIN_MODULE_SEQ";
--------------------------------------------------------
--  DDL for Synonymn PLUGIN_SEQ
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PLUGIN_SEQ" FOR "SEARCHAPP"."PLUGIN_SEQ";
--------------------------------------------------------
--  DDL for Synonymn PROBESET_DEAPP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PROBESET_DEAPP" FOR "TM_CZ"."PROBESET_DEAPP";
--------------------------------------------------------
--  DDL for Synonymn PROBESET_DEAPP_20120206
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PROBESET_DEAPP_20120206" FOR "TM_CZ"."PROBESET_DEAPP_20120206";
--------------------------------------------------------
--  DDL for Synonymn PROJECT_INFO
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PROJECT_INFO" FOR "BIOMART"."PROJECT_INFO";
--------------------------------------------------------
--  DDL for Synonymn PROTOCOL_ID_SEQ
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PROTOCOL_ID_SEQ" FOR "I2B2DEMODATA"."PROTOCOL_ID_SEQ";
--------------------------------------------------------
--  DDL for Synonymn PROVIDER_DIMENSION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."PROVIDER_DIMENSION" FOR "I2B2DEMODATA"."PROVIDER_DIMENSION";
--------------------------------------------------------
--  DDL for Synonymn QT_ANALYSIS_PLUGIN
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_ANALYSIS_PLUGIN" FOR "I2B2DEMODATA"."QT_ANALYSIS_PLUGIN";
--------------------------------------------------------
--  DDL for Synonymn QT_ANALYSIS_PLUGIN_RESULT_TYPE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_ANALYSIS_PLUGIN_RESULT_TYPE" FOR "I2B2DEMODATA"."QT_ANALYSIS_PLUGIN_RESULT_TYPE";
--------------------------------------------------------
--  DDL for Synonymn QT_BREAKDOWN_PATH
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_BREAKDOWN_PATH" FOR "I2B2DEMODATA"."QT_BREAKDOWN_PATH";
--------------------------------------------------------
--  DDL for Synonymn QT_PATIENT_ENC_COLLECTION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_PATIENT_ENC_COLLECTION" FOR "I2B2DEMODATA"."QT_PATIENT_ENC_COLLECTION";
--------------------------------------------------------
--  DDL for Synonymn QT_PATIENT_SET_COLLECTION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_PATIENT_SET_COLLECTION" FOR "I2B2DEMODATA"."QT_PATIENT_SET_COLLECTION";
--------------------------------------------------------
--  DDL for Synonymn QT_PDO_QUERY_MASTER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_PDO_QUERY_MASTER" FOR "I2B2DEMODATA"."QT_PDO_QUERY_MASTER";
--------------------------------------------------------
--  DDL for Synonymn QT_PRIVILEGE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_PRIVILEGE" FOR "I2B2DEMODATA"."QT_PRIVILEGE";
--------------------------------------------------------
--  DDL for Synonymn QT_QUERY_INSTANCE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_QUERY_INSTANCE" FOR "I2B2DEMODATA"."QT_QUERY_INSTANCE";
--------------------------------------------------------
--  DDL for Synonymn QT_QUERY_MASTER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_QUERY_MASTER" FOR "I2B2DEMODATA"."QT_QUERY_MASTER";
--------------------------------------------------------
--  DDL for Synonymn QT_QUERY_RESULT_INSTANCE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_QUERY_RESULT_INSTANCE" FOR "I2B2DEMODATA"."QT_QUERY_RESULT_INSTANCE";
--------------------------------------------------------
--  DDL for Synonymn QT_QUERY_RESULT_TYPE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_QUERY_RESULT_TYPE" FOR "I2B2DEMODATA"."QT_QUERY_RESULT_TYPE";
--------------------------------------------------------
--  DDL for Synonymn QT_QUERY_STATUS_TYPE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_QUERY_STATUS_TYPE" FOR "I2B2DEMODATA"."QT_QUERY_STATUS_TYPE";
--------------------------------------------------------
--  DDL for Synonymn QT_SQ_PQM_QMID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_SQ_PQM_QMID" FOR "I2B2DEMODATA"."QT_SQ_PQM_QMID";
--------------------------------------------------------
--  DDL for Synonymn QT_SQ_QI_QIID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_SQ_QI_QIID" FOR "I2B2DEMODATA"."QT_SQ_QI_QIID";
--------------------------------------------------------
--  DDL for Synonymn QT_SQ_QM_QMID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_SQ_QM_QMID" FOR "I2B2DEMODATA"."QT_SQ_QM_QMID";
--------------------------------------------------------
--  DDL for Synonymn QT_SQ_QPER_PECID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_SQ_QPER_PECID" FOR "I2B2DEMODATA"."QT_SQ_QPER_PECID";
--------------------------------------------------------
--  DDL for Synonymn QT_SQ_QPR_PCID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_SQ_QPR_PCID" FOR "I2B2DEMODATA"."QT_SQ_QPR_PCID";
--------------------------------------------------------
--  DDL for Synonymn QT_SQ_QRI_QRIID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_SQ_QRI_QRIID" FOR "I2B2DEMODATA"."QT_SQ_QRI_QRIID";
--------------------------------------------------------
--  DDL for Synonymn QT_SQ_QR_QRID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_SQ_QR_QRID" FOR "I2B2DEMODATA"."QT_SQ_QR_QRID";
--------------------------------------------------------
--  DDL for Synonymn QT_SQ_QS_QSID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_SQ_QS_QSID" FOR "I2B2DEMODATA"."QT_SQ_QS_QSID";
--------------------------------------------------------
--  DDL for Synonymn QT_SQ_QXR_XRID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_SQ_QXR_XRID" FOR "I2B2DEMODATA"."QT_SQ_QXR_XRID";
--------------------------------------------------------
--  DDL for Synonymn QT_XML_RESULT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QT_XML_RESULT" FOR "I2B2DEMODATA"."QT_XML_RESULT";
--------------------------------------------------------
--  DDL for Synonymn QUERY1
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QUERY1" FOR "I2B2METADATA"."QUERY1";
--------------------------------------------------------
--  DDL for Synonymn QUERY_GLOBAL_TEMP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."QUERY_GLOBAL_TEMP" FOR "I2B2DEMODATA"."QUERY_GLOBAL_TEMP";
--------------------------------------------------------
--  DDL for Synonymn REMOVE_TEMP_TABLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."REMOVE_TEMP_TABLE" FOR "I2B2DEMODATA"."REMOVE_TEMP_TABLE";
--------------------------------------------------------
--  DDL for Synonymn REPORT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."REPORT" FOR "SEARCHAPP"."REPORT";
--------------------------------------------------------
--  DDL for Synonymn REPORT_ITEM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."REPORT_ITEM" FOR "SEARCHAPP"."REPORT_ITEM";
--------------------------------------------------------
--  DDL for Synonymn SAMPLE_CATEGORIES
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SAMPLE_CATEGORIES" FOR "I2B2DEMODATA"."SAMPLE_CATEGORIES";
--------------------------------------------------------
--  DDL for Synonymn SAMPLE_CATEGORIES_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SAMPLE_CATEGORIES_RELEASE" FOR "TM_CZ"."SAMPLE_CATEGORIES_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn SCHEMES
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SCHEMES" FOR "I2B2METADATA"."SCHEMES";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_APP_ACCESS_LOG
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_APP_ACCESS_LOG" FOR "SEARCHAPP"."SEARCH_APP_ACCESS_LOG";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_AUTH_GROUP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_AUTH_GROUP" FOR "SEARCHAPP"."SEARCH_AUTH_GROUP";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_AUTH_GROUP_MEMBER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_AUTH_GROUP_MEMBER" FOR "SEARCHAPP"."SEARCH_AUTH_GROUP_MEMBER";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_AUTH_PRINCIPAL
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_AUTH_PRINCIPAL" FOR "SEARCHAPP"."SEARCH_AUTH_PRINCIPAL";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_AUTH_SEC_OBJECT_ACCESS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_AUTH_SEC_OBJECT_ACCESS" FOR "SEARCHAPP"."SEARCH_AUTH_SEC_OBJECT_ACCESS";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_AUTH_USER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_AUTH_USER" FOR "SEARCHAPP"."SEARCH_AUTH_USER";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_AUTH_USER_SEC_ACCESS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_AUTH_USER_SEC_ACCESS" FOR "SEARCHAPP"."SEARCH_AUTH_USER_SEC_ACCESS";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_AUTH_USER_SEC_ACCESS_V
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_AUTH_USER_SEC_ACCESS_V" FOR "SEARCHAPP"."SEARCH_AUTH_USER_SEC_ACCESS_V";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_BIO_MKR_CORREL_FAST_MV
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_BIO_MKR_CORREL_FAST_MV" FOR "SEARCHAPP"."SEARCH_BIO_MKR_CORREL_FAST_MV";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_BIO_MKR_CORREL_VIEW
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_BIO_MKR_CORREL_VIEW" FOR "SEARCHAPP"."SEARCH_BIO_MKR_CORREL_VIEW";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_CUSTOM_FILTER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_CUSTOM_FILTER" FOR "SEARCHAPP"."SEARCH_CUSTOM_FILTER";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_CUSTOM_FILTER_ITEM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_CUSTOM_FILTER_ITEM" FOR "SEARCHAPP"."SEARCH_CUSTOM_FILTER_ITEM";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_GENE_SIGNATURE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_GENE_SIGNATURE" FOR "SEARCHAPP"."SEARCH_GENE_SIGNATURE";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_GENE_SIGNATURE_ITEM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_GENE_SIGNATURE_ITEM" FOR "SEARCHAPP"."SEARCH_GENE_SIGNATURE_ITEM";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_GENE_SIG_FILE_SCHEMA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_GENE_SIG_FILE_SCHEMA" FOR "SEARCHAPP"."SEARCH_GENE_SIG_FILE_SCHEMA";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_KEYWORD
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_KEYWORD" FOR "SEARCHAPP"."SEARCH_KEYWORD";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_KEYWORD1
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_KEYWORD1" FOR "SEARCHAPP"."SEARCH_KEYWORD1";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_KEYWORD_TERM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_KEYWORD_TERM" FOR "SEARCHAPP"."SEARCH_KEYWORD_TERM";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_KEYWORD_TERM1
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_KEYWORD_TERM1" FOR "SEARCHAPP"."SEARCH_KEYWORD_TERM1";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_REQUEST_MAP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_REQUEST_MAP" FOR "SEARCHAPP"."SEARCH_REQUEST_MAP";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_ROLE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_ROLE" FOR "SEARCHAPP"."SEARCH_ROLE";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_ROLE_AUTH_USER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_ROLE_AUTH_USER" FOR "SEARCHAPP"."SEARCH_ROLE_AUTH_USER";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_SECURE_OBJECT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_SECURE_OBJECT" FOR "SEARCHAPP"."SEARCH_SECURE_OBJECT";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_SECURE_OBJECT_PATH
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_SECURE_OBJECT_PATH" FOR "SEARCHAPP"."SEARCH_SECURE_OBJECT_PATH";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_SECURE_OBJECT_RELEASE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_SECURE_OBJECT_RELEASE" FOR "TM_CZ"."SEARCH_SECURE_OBJECT_RELEASE";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_SEC_ACCESS_LEVEL
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_SEC_ACCESS_LEVEL" FOR "SEARCHAPP"."SEARCH_SEC_ACCESS_LEVEL";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_TAXONOMY
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_TAXONOMY" FOR "SEARCHAPP"."SEARCH_TAXONOMY";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_TAXONOMY_RELS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_TAXONOMY_RELS" FOR "SEARCHAPP"."SEARCH_TAXONOMY_RELS";
--------------------------------------------------------
--  DDL for Synonymn SEARCH_USER_FEEDBACK
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEARCH_USER_FEEDBACK" FOR "SEARCHAPP"."SEARCH_USER_FEEDBACK";
--------------------------------------------------------
--  DDL for Synonymn SEQ_ASSAY_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_ASSAY_ID" FOR "DEAPP"."SEQ_ASSAY_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_BIO_DATA_FACT_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_BIO_DATA_FACT_ID" FOR "BIOMART"."SEQ_BIO_DATA_FACT_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_BIO_DATA_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_BIO_DATA_ID" FOR "BIOMART"."SEQ_BIO_DATA_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_CLINICAL_TRIAL_DESIGN_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_CLINICAL_TRIAL_DESIGN_ID" FOR "BIOMART"."SEQ_CLINICAL_TRIAL_DESIGN_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_CONCEPT_CODE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_CONCEPT_CODE" FOR "I2B2METADATA"."SEQ_CONCEPT_CODE";
--------------------------------------------------------
--  DDL for Synonymn SEQ_DATA_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_DATA_ID" FOR "DEAPP"."SEQ_DATA_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_ETL_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_ETL_ID" FOR "TM_LZ"."SEQ_ETL_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_FM_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_FM_ID" FOR "FMAPP"."SEQ_FM_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_I2B2_DATA_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_I2B2_DATA_ID" FOR "I2B2METADATA"."SEQ_I2B2_DATA_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_PATIENT_NUM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_PATIENT_NUM" FOR "I2B2DEMODATA"."SEQ_PATIENT_NUM";
--------------------------------------------------------
--  DDL for Synonymn SEQ_SEARCH_DATA_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_SEARCH_DATA_ID" FOR "SEARCHAPP"."SEQ_SEARCH_DATA_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_SEARCH_TAXONOMY_RELS_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_SEARCH_TAXONOMY_RELS_ID" FOR "SEARCHAPP"."SEQ_SEARCH_TAXONOMY_RELS_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_SEARCH_TAXONOMY_TERM_ID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_SEARCH_TAXONOMY_TERM_ID" FOR "SEARCHAPP"."SEQ_SEARCH_TAXONOMY_TERM_ID";
--------------------------------------------------------
--  DDL for Synonymn SEQ_SUBJECT_REFERENCE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SEQ_SUBJECT_REFERENCE" FOR "I2B2DEMODATA"."SEQ_SUBJECT_REFERENCE";
--------------------------------------------------------
--  DDL for Synonymn SETONT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SETONT" FOR "I2B2DEMODATA"."SETONT";
--------------------------------------------------------
--  DDL for Synonymn SET_TYPE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SET_TYPE" FOR "I2B2DEMODATA"."SET_TYPE";
--------------------------------------------------------
--  DDL for Synonymn SET_UPLOAD_STATUS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SET_UPLOAD_STATUS" FOR "I2B2DEMODATA"."SET_UPLOAD_STATUS";
--------------------------------------------------------
--  DDL for Synonymn SOURCE_MASTER
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SOURCE_MASTER" FOR "I2B2DEMODATA"."SOURCE_MASTER";
--------------------------------------------------------
--  DDL for Synonymn SP_XTAB
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SP_XTAB" FOR "I2B2DEMODATA"."SP_XTAB";
--------------------------------------------------------
--  DDL for Synonymn SQ_UPLOADSTATUS_UPLOADID
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SQ_UPLOADSTATUS_UPLOADID" FOR "I2B2DEMODATA"."SQ_UPLOADSTATUS_UPLOADID";
--------------------------------------------------------
--  DDL for Synonymn SQ_UP_ENCDIM_ENCOUNTERNUM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SQ_UP_ENCDIM_ENCOUNTERNUM" FOR "I2B2DEMODATA"."SQ_UP_ENCDIM_ENCOUNTERNUM";
--------------------------------------------------------
--  DDL for Synonymn SQ_UP_PATDIM_PATIENTNUM
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SQ_UP_PATDIM_PATIENTNUM" FOR "I2B2DEMODATA"."SQ_UP_PATDIM_PATIENTNUM";
--------------------------------------------------------
--  DDL for Synonymn SUBSET
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."SUBSET" FOR "SEARCHAPP"."SUBSET";
--------------------------------------------------------
--  DDL for Synonymn T1
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."T1" FOR "BIOMART"."T1";
--------------------------------------------------------
--  DDL for Synonymn TABLE_ACCESS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."TABLE_ACCESS" FOR "I2B2METADATA"."TABLE_ACCESS";
--------------------------------------------------------
--  DDL for Synonymn TIMERS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."TIMERS" FOR "I2B2HIVE"."TIMERS";
--------------------------------------------------------
--  DDL for Synonymn TJEA_JUNK
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."TJEA_JUNK" FOR "TM_CZ"."TJEA_JUNK";
--------------------------------------------------------
--  DDL for Synonymn TMP_ANALYSIS_DATA_TEA_RANK
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."TMP_ANALYSIS_DATA_TEA_RANK" FOR "BIOMART"."TMP_ANALYSIS_DATA_TEA_RANK";
--------------------------------------------------------
--  DDL for Synonymn TMP_NUM_DATA_TYPES
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."TMP_NUM_DATA_TYPES" FOR "TM_CZ"."TMP_NUM_DATA_TYPES";
--------------------------------------------------------
--  DDL for Synonymn TMP_SUBJECT_INFO
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."TMP_SUBJECT_INFO" FOR "TM_CZ"."TMP_SUBJECT_INFO";
--------------------------------------------------------
--  DDL for Synonymn TMP_TRIAL_DATA
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."TMP_TRIAL_DATA" FOR "TM_CZ"."TMP_TRIAL_DATA";
--------------------------------------------------------
--  DDL for Synonymn TMP_TRIAL_NODES
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."TMP_TRIAL_NODES" FOR "TM_CZ"."TMP_TRIAL_NODES";
--------------------------------------------------------
--  DDL for Synonymn UPDATE_OBSERVATION_FACT
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."UPDATE_OBSERVATION_FACT" FOR "I2B2DEMODATA"."UPDATE_OBSERVATION_FACT";
--------------------------------------------------------
--  DDL for Synonymn UPLOAD_STATUS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."UPLOAD_STATUS" FOR "I2B2DEMODATA"."UPLOAD_STATUS";
--------------------------------------------------------
--  DDL for Synonymn UTIL_GRANT_ALL
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."UTIL_GRANT_ALL" FOR "DEAPP"."UTIL_GRANT_ALL";
--------------------------------------------------------
--  DDL for Synonymn VISIT_DIMENSION
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."VISIT_DIMENSION" FOR "I2B2DEMODATA"."VISIT_DIMENSION";
--------------------------------------------------------
--  DDL for Synonymn VW_FACETED_SEARCH
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."VW_FACETED_SEARCH" FOR "BIOMART"."VW_FACETED_SEARCH";
--------------------------------------------------------
--  DDL for Synonymn WORKPLACE
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."WORKPLACE" FOR "I2B2WORKDATA"."WORKPLACE";
--------------------------------------------------------
--  DDL for Synonymn WORKPLACE_ACCESS
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."WORKPLACE_ACCESS" FOR "I2B2WORKDATA"."WORKPLACE_ACCESS";
--------------------------------------------------------
--  DDL for Synonymn WORK_DB_LOOKUP
--------------------------------------------------------

  CREATE OR REPLACE SYNONYM "BIOMART_USER"."WORK_DB_LOOKUP" FOR "I2B2HIVE"."WORK_DB_LOOKUP";
